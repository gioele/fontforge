<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd) - fontforge/asmfpst.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">fontforge</a> - asmfpst.c<span style="font-size: 80%;"> (source / <a href="asmfpst.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd)</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">168</td>
            <td class="headerCovTableEntry">632</td>
            <td class="headerCovTableEntryLo">26.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-08-04</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntryLo">25.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright (C) 2003-2007 by George Williams */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       4 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :  * Redistributions of source code must retain the above copyright notice, this
<span class="lineNum">       7 </span>            :  * list of conditions and the following disclaimer.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :  * Redistributions in binary form must reproduce the above copyright notice,
<span class="lineNum">      10 </span>            :  * this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      11 </span>            :  * and/or other materials provided with the distribution.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :  * The name of the author may not be used to endorse or promote products
<span class="lineNum">      14 </span>            :  * derived from this software without specific prior written permission.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
<span class="lineNum">      17 </span>            :  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
<span class="lineNum">      18 </span>            :  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
<span class="lineNum">      19 </span>            :  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      20 </span>            :  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      21 </span>            :  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
<span class="lineNum">      22 </span>            :  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
<span class="lineNum">      23 </span>            :  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
<span class="lineNum">      24 </span>            :  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
<span class="lineNum">      25 </span>            :  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;asmfpst.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;fontforgevw.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;fvfonts.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;ttf.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;splineutil.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;tottfaat.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;tottfgpos.h&quot;
<span class="lineNum">      36 </span>            : #include &lt;chardata.h&gt;
<span class="lineNum">      37 </span>            : #include &lt;utype.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;ustring.h&gt;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : /* ************************************************************************** */
<span class="lineNum">      41 </span>            : /* *************** Routines to test conversion from OpenType **************** */
<a name="42"><span class="lineNum">      42 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span><span class="lineCov">         24 : int ClassesMatch(int cnt1,char **classes1,int cnt2,char **classes2) {</span>
<span class="lineNum">      45 </span>            :     int i;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span><span class="lineCov">         24 :     if ( cnt1!=cnt2 )</span>
<span class="lineNum">      48 </span><span class="lineCov">         12 : return( false );</span>
<span class="lineNum">      49 </span><span class="lineCov">         34 :     for ( i=1; i&lt;cnt2; ++i )</span>
<span class="lineNum">      50 </span><span class="lineCov">         26 :         if ( strcmp(classes1[i],classes2[i])!=0 )</span>
<span class="lineNum">      51 </span><span class="lineCov">          4 : return( false );</span>
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span><span class="lineCov">          8 : return( true );</span>
<a name="54"><span class="lineNum">      54 </span>            : }</a>
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span><span class="lineNoCov">          0 : static char **classcopy(char **names,int nextclass) {</span>
<span class="lineNum">      57 </span>            :     char **ret;
<span class="lineNum">      58 </span>            :     int i;
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span><span class="lineNoCov">          0 :     if ( nextclass &lt;= 1 )</span>
<span class="lineNum">      61 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span><span class="lineNoCov">          0 :     ret = malloc(nextclass*sizeof(char *));</span>
<span class="lineNum">      64 </span><span class="lineNoCov">          0 :     ret[0] = NULL;</span>
<span class="lineNum">      65 </span><span class="lineNoCov">          0 :     for ( i=1; i&lt;nextclass; ++i )</span>
<span class="lineNum">      66 </span><span class="lineNoCov">          0 :         ret[i] = copy(names[i]);</span>
<span class="lineNum">      67 </span><span class="lineNoCov">          0 : return( ret );</span>
<a name="68"><span class="lineNum">      68 </span>            : }</a>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineNoCov">          0 : FPST *FPSTGlyphToClass(FPST *fpst) {</span>
<span class="lineNum">      71 </span>            :     FPST *new;
<span class="lineNum">      72 </span><span class="lineNoCov">          0 :     int nextclass=0, i,j,k, max, cnt, ch;</span>
<span class="lineNum">      73 </span>            :     char *pt, *end;
<span class="lineNum">      74 </span>            :     char **names;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span><span class="lineNoCov">          0 :     if ( fpst-&gt;format!=pst_glyphs )</span>
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span><span class="lineNoCov">          0 :     new = chunkalloc(sizeof(FPST));</span>
<span class="lineNum">      80 </span><span class="lineNoCov">          0 :     new-&gt;type = fpst-&gt;type;</span>
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :     new-&gt;format = pst_class;</span>
<span class="lineNum">      82 </span><span class="lineNoCov">          0 :     new-&gt;subtable = fpst-&gt;subtable;</span>
<span class="lineNum">      83 </span><span class="lineNoCov">          0 :     new-&gt;rule_cnt = fpst-&gt;rule_cnt;</span>
<span class="lineNum">      84 </span><span class="lineNoCov">          0 :     new-&gt;rules = calloc(fpst-&gt;rule_cnt,sizeof(struct fpst_rule));</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     max = 100; nextclass=1;</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :     names = malloc(max*sizeof(char *));</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     names[0] = NULL;</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         for ( j=0; j&lt;3; ++j ) {</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :             cnt = 0;</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 :             if ( (&amp;fpst-&gt;rules[i].u.glyph.names)[j]!=NULL &amp;&amp; *(&amp;fpst-&gt;rules[i].u.glyph.names)[j]!='\0' ) {</span>
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :                 for ( pt=(&amp;fpst-&gt;rules[i].u.glyph.names)[j]; *pt; ) {</span>
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :                     while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :                     if ( *pt=='\0' )</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :                     while ( *pt!=' ' &amp;&amp; *pt!='\0' ) ++pt;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                     ++cnt;</span>
<span class="lineNum">      99 </span>            :                 }
<span class="lineNum">     100 </span>            :             }
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :             (&amp;new-&gt;rules[i].u.class.ncnt)[j] = cnt;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :             if ( cnt!=0 ) {</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :                 (&amp;new-&gt;rules[i].u.class.nclasses)[j] = malloc(cnt*sizeof(uint16));</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :                 cnt = 0;</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :                 for ( pt=(&amp;fpst-&gt;rules[i].u.glyph.names)[j]; *pt; pt=end ) {</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :                     while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :                     if ( *pt=='\0' )</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :                     for ( end=pt ; *end!=' ' &amp;&amp; *end!='\0'; ++end );</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :                     ch = *end; *end='\0';</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :                     for ( k=1; k&lt;nextclass; ++k )</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :                         if ( strcmp(pt,names[k])==0 )</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :                     if ( k==nextclass ) {</span>
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :                         if ( nextclass&gt;=max )</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :                             names = realloc(names,(max+=100)*sizeof(char *));</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :                         names[nextclass++] = copy(pt);</span>
<span class="lineNum">     118 </span>            :                     }
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :                     *end = ch;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :                     (&amp;new-&gt;rules[i].u.class.nclasses)[j][cnt++] = k;</span>
<span class="lineNum">     121 </span>            :                 }
<span class="lineNum">     122 </span>            :             }
<span class="lineNum">     123 </span>            :         }
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :         new-&gt;rules[i].lookup_cnt = fpst-&gt;rules[i].lookup_cnt;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :         new-&gt;rules[i].lookups = malloc(fpst-&gt;rules[i].lookup_cnt*sizeof(struct seqlookup));</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :         memcpy(new-&gt;rules[i].lookups,fpst-&gt;rules[i].lookups,</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :                 fpst-&gt;rules[i].lookup_cnt*sizeof(struct seqlookup));</span>
<span class="lineNum">     128 </span>            :     }
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     new-&gt;nccnt = nextclass;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     new-&gt;nclass = names;</span>
<span class="lineNum">     131 </span><span class="lineNoCov">          0 :     new-&gt;nclassnames = calloc(nextclass,sizeof(char *));     /* Leave as NULL */</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     if ( fpst-&gt;type==pst_chainpos || fpst-&gt;type==pst_chainsub ) {</span>
<span class="lineNum">     133 </span>            :         /* our class set has one &quot;class&quot; for each glyph used anywhere */
<span class="lineNum">     134 </span>            :         /*  all three class sets are the same */
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :         new-&gt;bccnt = new-&gt;fccnt = nextclass;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :         new-&gt;bclass = classcopy(names,nextclass);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         new-&gt;fclass = classcopy(names,nextclass);</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :         new-&gt;bclassnames = calloc(nextclass,sizeof(char *)); /* Leave as NULL */</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :         new-&gt;fclassnames = calloc(nextclass,sizeof(char *)); /* Leave as NULL */</span>
<span class="lineNum">     140 </span>            :     }
<span class="lineNum">     141 </span><span class="lineNoCov">          0 : return( new );</span>
<a name="142"><span class="lineNum">     142 </span>            : }</a>
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span><span class="lineCov">          1 : static int ValidSubs(OTLookup *otl ) {</span>
<span class="lineNum">     145 </span><span class="lineCov">          1 : return( otl-&gt;lookup_type == gsub_single );</span>
<a name="146"><span class="lineNum">     146 </span>            : }</a>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineNoCov">          0 : static void TreeFree(struct contexttree *tree) {</span>
<span class="lineNum">     149 </span>            :     int i;
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :     if ( tree==NULL )</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;tree-&gt;branch_cnt; ++i )</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :         TreeFree(tree-&gt;branches[i].branch);</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     free( tree-&gt;branches );</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :     free( tree-&gt;rules );</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :     chunkfree( tree,sizeof(*tree) );</span>
<a name="160"><span class="lineNum">     160 </span>            : }</a>
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span><span class="lineNoCov">          0 : static int TreeLabelState(struct contexttree *tree, int snum) {</span>
<span class="lineNum">     163 </span>            :     int i;
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :     if ( tree-&gt;branch_cnt==0 &amp;&amp; tree-&gt;ends_here!=NULL ) {</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :         tree-&gt;state = 0;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 : return( snum );</span>
<span class="lineNum">     168 </span>            :     }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :     tree-&gt;state = snum++;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;tree-&gt;branch_cnt; ++i )</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         snum = TreeLabelState(tree-&gt;branches[i].branch,snum);</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     tree-&gt;next_state = snum;</span>
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span><span class="lineNoCov">          0 : return( snum );</span>
<a name="176"><span class="lineNum">     176 </span>            : }</a>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineNoCov">          0 : static OTLookup *RuleHasSubsHere(struct fpst_rule *rule,int depth) {</span>
<span class="lineNum">     179 </span>            :     int i,j;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :     if ( depth&lt;rule-&gt;u.class.bcnt )</span>
<span class="lineNum">     182 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     depth -= rule-&gt;u.class.bcnt;</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     if ( depth&gt;=rule-&gt;u.class.ncnt )</span>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;rule-&gt;lookup_cnt; ++i ) {</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :         if ( rule-&gt;lookups[i].seq==depth ) {</span>
<span class="lineNum">     188 </span>            :             /* It is possible to have two substitutions applied at the same */
<span class="lineNum">     189 </span>            :             /*  location. I can't deal with that here */
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :             for ( j=i+1; j&lt;rule-&gt;lookup_cnt; ++j ) {</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :                 if ( rule-&gt;lookups[j].seq==depth )</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 : return( (OTLookup *) 0xffffffff );</span>
<span class="lineNum">     193 </span>            :             }
<span class="lineNum">     194 </span><span class="lineNoCov">          0 : return( rule-&gt;lookups[i].lookup );</span>
<span class="lineNum">     195 </span>            :         }
<span class="lineNum">     196 </span>            :     }
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="199"><span class="lineNum">     199 </span>            : }</a>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 : static OTLookup *RulesAllSameSubsAt(struct contexttree *me,int pos) {</span>
<span class="lineNum">     202 </span>            :     int i;
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     OTLookup *tag=(OTLookup *) 0x01, *newtag;   /* Can't use 0 as an &quot;unused&quot; flag because it is perfectly valid for there to be no substititution. But then all rules must have no subs */</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;me-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         newtag = RuleHasSubsHere(me-&gt;rules[i].rule,pos);</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :         if ( tag==(OTLookup *) 0x01 )</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :             tag=newtag;</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :         else if ( newtag!=tag )</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : return( (OTLookup *) 0xffffffff );</span>
<span class="lineNum">     211 </span>            :     }
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     if ( tag==(OTLookup *) 0x01 )</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 : return( NULL );         /* Should never happen */</span>
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span><span class="lineNoCov">          0 : return( tag );</span>
<a name="216"><span class="lineNum">     216 </span>            : }</a>
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span><span class="lineNoCov">          0 : static int TreeFollowBranches(SplineFont *sf,struct contexttree *me,int pending_pos) {</span>
<span class="lineNum">     219 </span>            :     int i, j;
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :     me-&gt;pending_pos = pending_pos;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :     if ( me-&gt;ends_here!=NULL ) {</span>
<span class="lineNum">     223 </span>            :         /* If any rule ends here then we have to be able to apply all current */
<span class="lineNum">     224 </span>            :         /*  and pending substitutions */
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :         if ( pending_pos!=-1 ) {</span>
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             me-&gt;applymarkedsubs = RulesAllSameSubsAt(me,pending_pos);</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :             if ( me-&gt;applymarkedsubs==(OTLookup *) 0xffffffff )</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :             if ( !ValidSubs(me-&gt;applymarkedsubs))</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     231 </span>            :         }
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         me-&gt;applycursubs = RulesAllSameSubsAt(me,me-&gt;depth);</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         if ( me-&gt;applycursubs==(OTLookup *) 0xffffffff )</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         if ( me-&gt;applycursubs!=NULL &amp;&amp; !ValidSubs(me-&gt;applycursubs))</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;me-&gt;branch_cnt; ++i ) {</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :             if ( !TreeFollowBranches(sf,me-&gt;branches[i].branch,-1))</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     240 </span>            :         }
<span class="lineNum">     241 </span>            :     } else {
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;me-&gt;branch_cnt; ++i ) {</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;me-&gt;rule_cnt; ++j )</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :                 if ( me-&gt;rules[j].branch==me-&gt;branches[i].branch &amp;&amp;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :                         RuleHasSubsHere(me-&gt;rules[j].rule,me-&gt;depth)!=NULL )</span>
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :             if ( j&lt;me-&gt;rule_cnt ) {</span>
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :                 if ( pending_pos==-1 ) {</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :                     pending_pos = me-&gt;pending_pos = me-&gt;depth;</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :                     me-&gt;markme = true;</span>
<span class="lineNum">     251 </span>            :                 } else
<span class="lineNum">     252 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     253 </span>            :             }
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :             if ( !TreeFollowBranches(sf,me-&gt;branches[i].branch,pending_pos))</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     256 </span>            :         }
<span class="lineNum">     257 </span>            :     }
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineNoCov">          0 : return( true );</span>
<a name="260"><span class="lineNum">     260 </span>            : }</a>
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span><span class="lineNoCov">          0 : static struct contexttree *_FPST2Tree(FPST *fpst,struct contexttree *parent,int class) {</span>
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :     struct contexttree *me = chunkalloc(sizeof(struct contexttree));</span>
<span class="lineNum">     264 </span>            :     int i, rcnt, ccnt, k, thisclass;
<span class="lineNum">     265 </span>            :     uint16 *classes;
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :     if ( fpst!=NULL ) {</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :         me-&gt;depth = -1;</span>
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :         me-&gt;rule_cnt = fpst-&gt;rule_cnt;</span>
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :         me-&gt;rules = calloc(me-&gt;rule_cnt,sizeof(struct ct_subs));</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;me-&gt;rule_cnt; ++i )</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :             me-&gt;rules[i].rule = &amp;fpst-&gt;rules[i];</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         me-&gt;parent = NULL;</span>
<span class="lineNum">     274 </span>            :     } else {
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :         me-&gt;depth = parent-&gt;depth+1;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :         for ( i=rcnt=0; i&lt;parent-&gt;rule_cnt; ++i )</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :             if ( parent-&gt;rules[i].rule-&gt;u.class.allclasses[me-&gt;depth] == class )</span>
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                 ++rcnt;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :         me-&gt;rule_cnt = rcnt;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :         me-&gt;rules = calloc(me-&gt;rule_cnt,sizeof(struct ct_subs));</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :         for ( i=rcnt=0; i&lt;parent-&gt;rule_cnt; ++i )</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :             if ( parent-&gt;rules[i].rule-&gt;u.class.allclasses[me-&gt;depth] == class )</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :                 me-&gt;rules[rcnt++].rule = parent-&gt;rules[i].rule;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         me-&gt;parent = parent;</span>
<span class="lineNum">     285 </span>            :     }
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :     classes = malloc(me-&gt;rule_cnt*sizeof(uint16));</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     for ( i=ccnt=0; i&lt;me-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :         thisclass = me-&gt;rules[i].thisclassnum = me-&gt;rules[i].rule-&gt;u.class.allclasses[me-&gt;depth+1];</span>
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :         if ( thisclass==0xffff ) {</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :             if ( me-&gt;ends_here==NULL )</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :                 me-&gt;ends_here = me-&gt;rules[i].rule;</span>
<span class="lineNum">     292 </span>            :         } else {
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :             for ( k=0; k&lt;ccnt; ++k )</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :                 if ( classes[k] == thisclass )</span>
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :             if ( k==ccnt )</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                 classes[ccnt++] = thisclass;</span>
<span class="lineNum">     298 </span>            :         }
<span class="lineNum">     299 </span>            :     }
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :     me-&gt;branch_cnt = ccnt;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :     me-&gt;branches = calloc(ccnt,sizeof(struct ct_branch));</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;ccnt; ++i )</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :         me-&gt;branches[i].classnum = classes[i];</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;ccnt; ++i ) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :         me-&gt;branches[i].branch = _FPST2Tree(NULL,me,classes[i]);</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         for ( k=0; k&lt;me-&gt;rule_cnt; ++k )</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :             if ( classes[i]==me-&gt;rules[k].thisclassnum )</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                 me-&gt;rules[k].branch = me-&gt;branches[i].branch;</span>
<span class="lineNum">     309 </span>            :     }
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :     free(classes );</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 : return( me );</span>
<a name="312"><span class="lineNum">     312 </span>            : }</a>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineNoCov">          0 : static void FPSTBuildAllClasses(FPST *fpst) {</span>
<span class="lineNum">     315 </span>            :     int i, off,j;
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :         fpst-&gt;rules[i].u.class.allclasses = malloc((fpst-&gt;rules[i].u.class.bcnt+</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                                                     fpst-&gt;rules[i].u.class.ncnt+</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                                                     fpst-&gt;rules[i].u.class.fcnt+</span>
<span class="lineNum">     321 </span>            :                                                     1)*sizeof(uint16));
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         off = fpst-&gt;rules[i].u.class.bcnt;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         for ( j=0; j&lt;off; ++j )</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :             fpst-&gt;rules[i].u.class.allclasses[j] = fpst-&gt;rules[i].u.class.bclasses[off-1-j];</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :         for ( j=0; j&lt;fpst-&gt;rules[i].u.class.ncnt; ++j )</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :             fpst-&gt;rules[i].u.class.allclasses[off+j] = fpst-&gt;rules[i].u.class.nclasses[j];</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :         off += j;</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         for ( j=0; j&lt;fpst-&gt;rules[i].u.class.fcnt; ++j )</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :             fpst-&gt;rules[i].u.class.allclasses[off+j] = fpst-&gt;rules[i].u.class.fclasses[j];</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         fpst-&gt;rules[i].u.class.allclasses[off+j] = 0xffff;   /* End of rule marker */</span>
<span class="lineNum">     331 </span>            :     }
<a name="332"><span class="lineNum">     332 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineNoCov">          0 : static void FPSTFreeAllClasses(FPST *fpst) {</span>
<span class="lineNum">     335 </span>            :     int i;
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :         free( fpst-&gt;rules[i].u.class.allclasses );</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :         fpst-&gt;rules[i].u.class.allclasses = NULL;</span>
<span class="lineNum">     340 </span>            :     }
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineNoCov">          0 : static struct contexttree *FPST2Tree(SplineFont *sf,FPST *fpst) {</span>
<span class="lineNum">     344 </span>            :     struct contexttree *ret;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :     if ( fpst-&gt;format != pst_class )</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span>            :     /* I could check for subclasses rather than ClassesMatch, but then I'd have */
<span class="lineNum">     350 </span>            :     /* to make sure that class 0 was used (if at all) consistently */
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :     if ( (fpst-&gt;bccnt!=0 &amp;&amp; !ClassesMatch(fpst-&gt;bccnt,fpst-&gt;bclass,fpst-&gt;nccnt,fpst-&gt;nclass)) ||</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :             (fpst-&gt;fccnt!=0 &amp;&amp; !ClassesMatch(fpst-&gt;fccnt,fpst-&gt;fclass,fpst-&gt;nccnt,fpst-&gt;nclass)))</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :     FPSTBuildAllClasses(fpst);</span>
<span class="lineNum">     356 </span>            :         
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :     ret = _FPST2Tree(fpst,NULL,0);</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :     if ( !TreeFollowBranches(sf,ret,-1) ) {</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :         TreeFree(ret);</span>
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         ret = NULL;</span>
<span class="lineNum">     362 </span>            :     }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :     FPSTFreeAllClasses(fpst);</span>
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     if ( ret!=NULL )</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         TreeLabelState(ret,1);  /* actually, it's states 0&amp;1, but this will do */</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span><span class="lineNoCov">          0 : return( ret );</span>
<a name="370"><span class="lineNum">     370 </span>            : }</a>
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : static struct contexttree *TreeNext(struct contexttree *cur) {</span>
<span class="lineNum">     373 </span>            :     struct contexttree *p;
<span class="lineNum">     374 </span>            :     int i;
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     if ( cur-&gt;branch_cnt!=0 )</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 : return( cur-&gt;branches[0].branch );</span>
<span class="lineNum">     378 </span>            :     else {
<span class="lineNum">     379 </span>            :         for (;;) {
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :             p = cur-&gt;parent;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             if ( p==NULL )</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;p-&gt;branch_cnt; ++i ) {</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :                 if ( p-&gt;branches[i].branch==cur ) {</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :                     ++i;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     387 </span>            :                 }
<span class="lineNum">     388 </span>            :             }
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :             if ( i&lt;p-&gt;branch_cnt )</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 : return( p-&gt;branches[i].branch );</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :             cur = p;</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">     393 </span>            :     }
<a name="394"><span class="lineNum">     394 </span>            : }</a>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">          1 : int FPSTisMacable(SplineFont *sf, FPST *fpst) {</span>
<span class="lineNum">     397 </span>            :     int i;
<span class="lineNum">     398 </span>            :     int featureType, featureSetting;
<span class="lineNum">     399 </span>            :     struct contexttree *ret;
<span class="lineNum">     400 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span><span class="lineCov">          1 :     if ( fpst-&gt;type!=pst_contextsub &amp;&amp; fpst-&gt;type!=pst_chainsub )</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     404 </span><span class="lineCov">          1 :     for ( fl = fpst-&gt;subtable-&gt;lookup-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">     405 </span><span class="lineCov">          2 :         if ( OTTagToMacFeature(fl-&gt;featuretag,&amp;featureType,&amp;featureSetting) &amp;&amp;</span>
<span class="lineNum">     406 </span><span class="lineCov">          1 :                 scriptsHaveDefault(fl-&gt;scripts) )</span>
<span class="lineNum">     407 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">     408 </span>            :     }
<span class="lineNum">     409 </span><span class="lineCov">          1 :     if ( fl==NULL )</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineCov">          1 :     if ( fpst-&gt;format == pst_glyphs ) {</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :         FPST *tempfpst = FPSTGlyphToClass(fpst);</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :         ret = FPST2Tree(sf, tempfpst);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :         FPSTFree(tempfpst);</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :         TreeFree(ret);</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 : return( ret!=NULL );</span>
<span class="lineNum">     418 </span><span class="lineCov">          1 :     } else if ( fpst-&gt;format == pst_class ) {</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :         ret = FPST2Tree(sf, fpst);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         TreeFree(ret);</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 : return( ret!=NULL );</span>
<span class="lineNum">     422 </span><span class="lineCov">          1 :     } else if ( fpst-&gt;format != pst_coverage )</span>
<span class="lineNum">     423 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineCov">          2 :     for ( i=0; i&lt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     426 </span><span class="lineCov">          3 :         if ( fpst-&gt;rules[i].u.coverage.ncnt+</span>
<span class="lineNum">     427 </span><span class="lineCov">          2 :                 fpst-&gt;rules[i].u.coverage.bcnt+</span>
<span class="lineNum">     428 </span><span class="lineCov">          1 :                 fpst-&gt;rules[i].u.coverage.fcnt&gt;=10 )</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 : return( false );                        /* Let's not make a state machine this complicated */</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineCov">          1 :         if ( fpst-&gt;rules[i].lookup_cnt==2 ) {</span>
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :             switch ( fpst-&gt;format ) {</span>
<span class="lineNum">     433 </span>            :               case pst_coverage:
<span class="lineNum">     434 </span>            :                 /* Second substitution must be on the final glyph */
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                 if ( fpst-&gt;rules[i].u.coverage.fcnt!=0 ||</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                         fpst-&gt;rules[i].lookups[0].seq==fpst-&gt;rules[i].lookups[1].seq ||</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                         (fpst-&gt;rules[i].lookups[0].seq!=fpst-&gt;rules[i].u.coverage.ncnt-1 &amp;&amp;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                          fpst-&gt;rules[i].lookups[1].seq!=fpst-&gt;rules[i].u.coverage.ncnt-1) )</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">     441 </span>            :               default:
<span class="lineNum">     442 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     443 </span>            :             }
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :             if ( !ValidSubs(fpst-&gt;rules[i].lookups[1].lookup) )</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     446 </span>            :                 
<span class="lineNum">     447 </span><span class="lineCov">          1 :         } else if ( fpst-&gt;rules[i].lookup_cnt!=1 )</span>
<span class="lineNum">     448 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     449 </span><span class="lineCov">          1 :         if ( !ValidSubs(fpst-&gt;rules[i].lookups[0].lookup) )</span>
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     451 </span>            :     }
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">          1 : return( fpst-&gt;rule_cnt&gt;0 );</span>
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : /* ************************************************************************** */
<span class="lineNum">     457 </span>            : /* *************** Conversion from OpenType Context/Chaining **************** */
<span class="lineNum">     458 </span>            : /* ************************************************************************** */
<a name="459"><span class="lineNum">     459 </span>            : </a>
<span class="lineNum">     460 </span>            :         /* ********************** From Forms ********************** */
<span class="lineNum">     461 </span><span class="lineNoCov">          0 : static int IsMarkChar( SplineChar *sc ) {</span>
<span class="lineNum">     462 </span>            :     AnchorPoint *ap;
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :     ap=sc-&gt;anchor;</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :     while ( ap!=NULL &amp;&amp; (ap-&gt;type==at_centry || ap-&gt;type==at_cexit) )</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :         ap = ap-&gt;next;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     if ( ap!=NULL &amp;&amp; (ap-&gt;type==at_mark || ap-&gt;type==at_basemark) )</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span><span class="lineNoCov">          0 : return( false );</span>
<a name="471"><span class="lineNum">     471 </span>            : }</a>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineNoCov">          0 : static char *GlyphListToNames(SplineChar **classglyphs) {</span>
<span class="lineNum">     474 </span>            :     int i, len;
<span class="lineNum">     475 </span>            :     char *ret, *pt;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     for ( i=len=0; classglyphs[i]!=NULL; ++i )</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :         len += strlen(classglyphs[i]-&gt;name)+1;</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     ret = pt = malloc(len+1);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     for ( i=0; classglyphs[i]!=NULL; ++i ) {</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :         strcpy(pt,classglyphs[i]-&gt;name);</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :         pt += strlen(pt);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :         *pt++ = ' ';</span>
<span class="lineNum">     484 </span>            :     }
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :     if ( pt&gt;ret )</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :         pt[-1] = '\0';</span>
<span class="lineNum">     487 </span>            :     else
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         *ret = '\0';</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 : return( ret );</span>
<a name="490"><span class="lineNum">     490 </span>            : }</a>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineNoCov">          0 : static char *BuildMarkClass(SplineFont *sf) {</span>
<span class="lineNum">     493 </span>            :     SplineChar *sc, **markglyphs;
<span class="lineNum">     494 </span>            :     int i, mg;
<span class="lineNum">     495 </span>            :     char *ret;
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :     mg = 0;</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :     markglyphs = malloc(sf-&gt;glyphcnt*sizeof(SplineChar *));</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( (sc=sf-&gt;glyphs[i])!=NULL ) {</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         if ( IsMarkChar(sc)) {</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :             markglyphs[mg++] = sc;</span>
<span class="lineNum">     502 </span>            :         }
<span class="lineNum">     503 </span>            :     }
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :     markglyphs[mg] = NULL;</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     ret = GlyphListToNames(markglyphs);</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     free(markglyphs);</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 : return(ret);</span>
<a name="508"><span class="lineNum">     508 </span>            : }</a>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineCov">          3 : static char *BuildClassNames(SplineChar **glyphs,uint16 *map, int classnum) {</span>
<span class="lineNum">     511 </span>            :     int i, len;
<span class="lineNum">     512 </span>            :     char *ret, *pt;
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span><span class="lineCov">         96 :     for ( i=len=0; glyphs[i]!=NULL; ++i ) {</span>
<span class="lineNum">     515 </span><span class="lineCov">         93 :         if ( map[i]==classnum )</span>
<span class="lineNum">     516 </span><span class="lineCov">         31 :             len += strlen(glyphs[i]-&gt;name)+1;</span>
<span class="lineNum">     517 </span>            :     }
<span class="lineNum">     518 </span><span class="lineCov">          3 :     ret = pt = malloc(len+1);</span>
<span class="lineNum">     519 </span><span class="lineCov">         96 :     for ( i=len=0; glyphs[i]!=NULL; ++i ) {</span>
<span class="lineNum">     520 </span><span class="lineCov">         93 :         if ( map[i]==classnum ) {</span>
<span class="lineNum">     521 </span><span class="lineCov">         31 :             strcpy(pt,glyphs[i]-&gt;name);</span>
<span class="lineNum">     522 </span><span class="lineCov">         31 :             pt += strlen(pt);</span>
<span class="lineNum">     523 </span><span class="lineCov">         31 :             *pt++ = ' ';</span>
<span class="lineNum">     524 </span>            :         }
<span class="lineNum">     525 </span>            :     }
<span class="lineNum">     526 </span><span class="lineCov">          3 :     if ( pt&gt;ret )</span>
<span class="lineNum">     527 </span><span class="lineCov">          3 :         pt[-1] = '\0';</span>
<span class="lineNum">     528 </span>            :     else
<span class="lineNum">     529 </span><span class="lineNoCov">          0 :         *ret = '\0';</span>
<span class="lineNum">     530 </span><span class="lineCov">          3 : return( ret );</span>
<a name="531"><span class="lineNum">     531 </span>            : }</a>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 : static int FindFormLookupsForScript(SplineFont *sf,uint32 script,OTLookup *lookups[4]) {</span>
<span class="lineNum">     534 </span>            :     OTLookup *otl;
<span class="lineNum">     535 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">     536 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     537 </span>            :     int which;
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     memset(lookups,0,4*sizeof(OTLookup *));</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :     for ( otl=sf-&gt;gsub_lookups; otl!=NULL; otl=otl-&gt;next ) if ( !otl-&gt;unused &amp;&amp; otl-&gt;lookup_type == gsub_single ) {</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :         for ( fl=otl-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :             if ( fl-&gt;featuretag== CHR('i','n','i','t') ) which = 0;</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :             else if ( fl-&gt;featuretag== CHR('m','e','d','i') ) which = 1;</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :             else if ( fl-&gt;featuretag== CHR('f','i','n','a') ) which = 2;</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :             else if ( fl-&gt;featuretag== CHR('i','s','o','l') ) which = 3;</span>
<span class="lineNum">     546 </span>            :             else
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :             if ( lookups[which]!=NULL )</span>
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :             for ( sl=fl-&gt;scripts; sl!=NULL &amp;&amp; sl-&gt;script!=script; sl=sl-&gt;next );</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :             if ( sl==NULL )</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :             lookups[which] = otl;</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     555 </span>            :         }
<span class="lineNum">     556 </span>            :     }
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :     if ( lookups[0]!=NULL || lookups[1]!=NULL || lookups[2]!=NULL || lookups[3]!=NULL )</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineNoCov">          0 : return( false );</span>
<a name="561"><span class="lineNum">     561 </span>            : }</a>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 : ASM *ASMFromOpenTypeForms(SplineFont *sf,uint32 script) {</span>
<span class="lineNum">     564 </span>            :     int i, which, cg, mg;
<span class="lineNum">     565 </span>            :     SplineChar *sc, *rsc, **classglyphs, **markglyphs;
<span class="lineNum">     566 </span>            :     PST *pst;
<span class="lineNum">     567 </span>            :     OTLookup *lookups[4];
<span class="lineNum">     568 </span>            :     ASM *sm;
<span class="lineNum">     569 </span>            :     int flags;
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     if ( !FindFormLookupsForScript(sf,script,lookups))</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :     flags = (lookups[0]!=NULL ? lookups[0]-&gt;lookup_flags</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :             :lookups[1]!=NULL ? lookups[1]-&gt;lookup_flags</span>
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :             :lookups[2]!=NULL ? lookups[2]-&gt;lookup_flags</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :             :                   lookups[3]-&gt;lookup_flags);</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :     classglyphs = calloc((sf-&gt;glyphcnt+1),sizeof(SplineChar *));</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :     markglyphs = malloc((sf-&gt;glyphcnt+1)*sizeof(SplineChar *));</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :     mg = 0;</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( (sc=sf-&gt;glyphs[i])!=NULL ) {</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :         if ( (flags&amp;pst_ignorecombiningmarks) &amp;&amp; IsMarkChar(sc)) {</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :             markglyphs[mg++] = sc;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :         } else if ( SCScriptFromUnicode(sc)==script ) {</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :             classglyphs[sc-&gt;orig_pos] = sc;</span>
<span class="lineNum">     586 </span><span class="lineNoCov">          0 :             for ( pst = sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) if ( pst-&gt;subtable!=NULL ) {</span>
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :                 OTLookup *otl = pst-&gt;subtable-&gt;lookup;</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :                 for ( which=3; which&gt;=0; --which ) {</span>
<span class="lineNum">     589 </span><span class="lineNoCov">          0 :                     if ( otl==lookups[which])</span>
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     591 </span>            :                 }
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 if ( which==-1 )</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     594 </span><span class="lineNoCov">          0 :                 rsc = SFGetChar(sf,-1,pst-&gt;u.subs.variant);</span>
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :                 if ( rsc!=NULL )</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :                     classglyphs[rsc-&gt;orig_pos] = rsc;</span>
<span class="lineNum">     597 </span>            :             }
<span class="lineNum">     598 </span>            :         }
<span class="lineNum">     599 </span>            :     }
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :     markglyphs[mg] = NULL;</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     cg = 0;</span>
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i )</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :         if ( classglyphs[i]!=NULL )</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :             classglyphs[cg++] = classglyphs[i];</span>
<span class="lineNum">     606 </span><span class="lineNoCov">          0 :     classglyphs[cg] = NULL;</span>
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :     sm = chunkalloc(sizeof(ASM));</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     sm-&gt;type = asm_context;</span>
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     sm-&gt;flags = (flags&amp;pst_r2l) ? asm_descending : 0;</span>
<span class="lineNum">     611 </span>            :         /* This is a temporary value. It should be replaced if we will retain */
<span class="lineNum">     612 </span>            :         /*  this state machine */
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :     sm-&gt;subtable = (lookups[3]!=NULL ? lookups[3] : lookups[0]!=NULL ? lookups[0] : lookups[1]!=NULL ? lookups[1] : lookups[2])-&gt;subtables;</span>
<span class="lineNum">     614 </span>            :     /* Only one (or two) classes of any importance: Letter in this script */
<span class="lineNum">     615 </span>            :     /* might already be formed. Might be a lig. Might be normal */
<span class="lineNum">     616 </span>            :     /* Oh, if ignoremarks is true, then combining marks merit a class of their own */
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     sm-&gt;class_cnt = (flags&amp;pst_ignorecombiningmarks) ? 6 : 5;</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :     sm-&gt;classes = calloc(sm-&gt;class_cnt,sizeof(char *));</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     sm-&gt;classes[4] = GlyphListToNames(classglyphs);</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     if ( flags&amp;pst_ignorecombiningmarks )</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         sm-&gt;classes[5] = GlyphListToNames(markglyphs);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :     free(classglyphs); free(markglyphs);</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :     /* State 0,1 are start states */
<span class="lineNum">     627 </span>            :     /* State 2 means we have found one interesting letter, transformed current to 'init' and marked it (in case we need to make it isolated) */
<span class="lineNum">     628 </span>            :     /* State 3 means we have found two interesting letters, transformed current to 'medi' and marked (in case we need to make it final) */
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     sm-&gt;state_cnt = 4;</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :     sm-&gt;state = calloc(sm-&gt;state_cnt*sm-&gt;class_cnt,sizeof(struct asm_state));</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :     /* State 0,1 (start), Class 4 (char in script) takes us to state 2 */
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     sm-&gt;state[4].next_state = 2;</span>
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     sm-&gt;state[4].flags = 0x8000;</span>
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :     sm-&gt;state[sm-&gt;class_cnt+4] = sm-&gt;state[4];</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;4; ++i ) {</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :         sm-&gt;state[2*sm-&gt;class_cnt+i].next_state = 0;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :         sm-&gt;state[2*sm-&gt;class_cnt+i].u.context.mark_lookup = lookups[3];/* Isolated */</span>
<span class="lineNum">     641 </span>            :     }
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :     sm-&gt;state[2*sm-&gt;class_cnt+4].next_state = 3;</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :     sm-&gt;state[2*sm-&gt;class_cnt+4].flags = 0x8000;</span>
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :     sm-&gt;state[2*sm-&gt;class_cnt+4].u.context.mark_lookup = lookups[0];      /* Initial */</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;4; ++i ) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :         sm-&gt;state[3*sm-&gt;class_cnt+i].next_state = 0;</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :         sm-&gt;state[3*sm-&gt;class_cnt+i].u.context.mark_lookup = lookups[2];/* Final */</span>
<span class="lineNum">     650 </span>            :     }
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :     sm-&gt;state[3*sm-&gt;class_cnt+4].next_state = 3;</span>
<span class="lineNum">     653 </span><span class="lineNoCov">          0 :     sm-&gt;state[3*sm-&gt;class_cnt+4].flags = 0x8000;</span>
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :     sm-&gt;state[3*sm-&gt;class_cnt+4].u.context.mark_lookup = lookups[1];      /* Medial */</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :     /* Deleted glyph retains same state, just eats the glyph */
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sm-&gt;state_cnt; ++i ) {</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :         int pos = i*sm-&gt;class_cnt+2, mpos = i*sm-&gt;class_cnt+5;</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :         sm-&gt;state[pos].next_state = i;</span>
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :         sm-&gt;state[pos].flags = 0;</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         sm-&gt;state[pos].u.context.cur_lookup = NULL;</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         sm-&gt;state[pos].u.context.mark_lookup = NULL;</span>
<span class="lineNum">     663 </span>            :         /* same for ignored marks */
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :         if ( flags&amp;pst_ignorecombiningmarks )</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :             sm-&gt;state[mpos].next_state = i;</span>
<span class="lineNum">     666 </span>            :     }
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineNoCov">          0 : return( sm );</span>
<span class="lineNum">     669 </span>            : }
<a name="670"><span class="lineNum">     670 </span>            : </a>
<span class="lineNum">     671 </span>            :         /* ********************** From Coverage FPST ********************** */
<span class="lineNum">     672 </span><span class="lineCov">          1 : static SplineChar **morx_cg_FigureClasses(SplineChar ***tables,int match_len,</span>
<span class="lineNum">     673 </span>            :         int ***classes, int *cc, uint16 **mp, int *gc,
<span class="lineNum">     674 </span>            :         FPST *fpst,SplineFont *sf,int ordered) {
<span class="lineNum">     675 </span>            :     int i,j,k, mask, max, class_cnt, gcnt, gtot;
<span class="lineNum">     676 </span>            :     SplineChar ***temp, *sc, **glyphs, **gall;
<span class="lineNum">     677 </span>            :     uint16 *map;
<span class="lineNum">     678 </span>            :     int *nc;
<span class="lineNum">     679 </span>            :     int *next;
<span class="lineNum">     680 </span>            :     /* For each glyph used, figure out what coverage tables it gets used in */
<span class="lineNum">     681 </span>            :     /*  then all the glyphs which get used in the same set of coverage tables */
<span class="lineNum">     682 </span>            :     /*  can form one class */
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span><span class="lineCov">          1 :     if ( match_len&gt;10 )              /* would need too much space to figure out */</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span><span class="lineCov">          1 :     gtot = 0;</span>
<span class="lineNum">     688 </span><span class="lineCov">        213 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( sf-&gt;glyphs[i]!=NULL ) {</span>
<span class="lineNum">     689 </span><span class="lineCov">        164 :         sf-&gt;glyphs[i]-&gt;lsidebearing = 1;</span>
<span class="lineNum">     690 </span><span class="lineCov">        164 :         if ( !ordered )</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :             sf-&gt;glyphs[i]-&gt;ttf_glyph = gtot++;</span>
<span class="lineNum">     692 </span><span class="lineCov">        164 :         else if ( sf-&gt;glyphs[i]-&gt;ttf_glyph+1&gt;gtot )</span>
<span class="lineNum">     693 </span><span class="lineCov">        106 :             gtot = sf-&gt;glyphs[i]-&gt;ttf_glyph+1;</span>
<span class="lineNum">     694 </span>            :     }
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span><span class="lineCov">          1 :     max=0;</span>
<span class="lineNum">     697 </span><span class="lineCov">          3 :     for ( i=0; i&lt;match_len; ++i ) {</span>
<span class="lineNum">     698 </span><span class="lineCov">          2 :         for ( k=0; tables[i][k]!=NULL; ++k );</span>
<span class="lineNum">     699 </span><span class="lineCov">          2 :         if ( k&gt;max ) max=k;</span>
<span class="lineNum">     700 </span>            :     }
<span class="lineNum">     701 </span><span class="lineCov">          1 :     next = calloc(1&lt;&lt;match_len,sizeof(int));</span>
<span class="lineNum">     702 </span><span class="lineCov">          1 :     temp = malloc((1&lt;&lt;match_len)*sizeof(SplineChar **));</span>
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineCov">        213 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( sf-&gt;glyphs[i]!=NULL ) {</span>
<span class="lineNum">     705 </span><span class="lineCov">        164 :         sf-&gt;glyphs[i]-&gt;lsidebearing = 0;</span>
<span class="lineNum">     706 </span><span class="lineCov">        164 :         sf-&gt;glyphs[i]-&gt;ticked = false;</span>
<span class="lineNum">     707 </span>            :     }
<span class="lineNum">     708 </span><span class="lineCov">          3 :     for ( i=0; i&lt;match_len; ++i ) {</span>
<span class="lineNum">     709 </span><span class="lineCov">         38 :         for ( j=0; tables[i][j]!=NULL ; ++j )</span>
<span class="lineNum">     710 </span><span class="lineCov">         36 :             tables[i][j]-&gt;lsidebearing |= 1&lt;&lt;i;</span>
<span class="lineNum">     711 </span>            :     }
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">          3 :     for ( i=0; i&lt;match_len; ++i ) {</span>
<span class="lineNum">     714 </span><span class="lineCov">         38 :         for ( j=0; (sc=tables[i][j])!=NULL ; ++j ) if ( !sc-&gt;ticked ) {</span>
<span class="lineNum">     715 </span><span class="lineCov">         31 :             mask = sc-&gt;lsidebearing;</span>
<span class="lineNum">     716 </span><span class="lineCov">         31 :             if ( next[mask]==0 )</span>
<span class="lineNum">     717 </span><span class="lineCov">          3 :                 temp[mask] = malloc(max*sizeof(SplineChar *));</span>
<span class="lineNum">     718 </span><span class="lineCov">         31 :             temp[mask][next[mask]++] = sc;</span>
<span class="lineNum">     719 </span><span class="lineCov">         31 :             sc-&gt;ticked = true;</span>
<span class="lineNum">     720 </span>            :         }
<span class="lineNum">     721 </span>            :     }
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineCov">          1 :     gall = calloc(gtot+1,sizeof(SplineChar *));</span>
<span class="lineNum">     724 </span><span class="lineCov">          1 :     class_cnt = gcnt = 0;</span>
<span class="lineNum">     725 </span><span class="lineCov">          5 :     for ( i=0; i&lt;(1&lt;&lt;match_len); ++i ) {</span>
<span class="lineNum">     726 </span><span class="lineCov">          4 :         if ( next[i]!=0 ) {</span>
<span class="lineNum">     727 </span><span class="lineCov">         34 :             for ( k=0; k&lt;next[i]; ++k ) {</span>
<span class="lineNum">     728 </span><span class="lineCov">         31 :                 gall[temp[i][k]-&gt;ttf_glyph] = temp[i][k];</span>
<span class="lineNum">     729 </span><span class="lineCov">         31 :                 temp[i][k]-&gt;lsidebearing = class_cnt;</span>
<span class="lineNum">     730 </span>            :             }
<span class="lineNum">     731 </span><span class="lineCov">          3 :             ++class_cnt;</span>
<span class="lineNum">     732 </span><span class="lineCov">          3 :             gcnt += next[i];</span>
<span class="lineNum">     733 </span><span class="lineCov">          3 :             free(temp[i]);</span>
<span class="lineNum">     734 </span>            :         }
<span class="lineNum">     735 </span>            :     }
<span class="lineNum">     736 </span><span class="lineCov">          1 :     if ( fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags &amp; pst_ignorecombiningmarks ) {</span>
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( sf-&gt;glyphs[i]!=NULL &amp;&amp; sf-&gt;glyphs[i]-&gt;ttf_glyph!=-1 ) {</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :             if ( sf-&gt;glyphs[i]-&gt;lsidebearing==0 &amp;&amp; IsMarkChar(sf-&gt;glyphs[i])) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                 sf-&gt;glyphs[i]-&gt;lsidebearing = class_cnt;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                 ++gcnt;</span>
<span class="lineNum">     741 </span>            :             }
<span class="lineNum">     742 </span>            :         }
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :         ++class_cnt;                    /* Add a class for the marks so we can ignore them */</span>
<span class="lineNum">     744 </span>            :     }
<span class="lineNum">     745 </span><span class="lineCov">          1 :     *cc = class_cnt+4;</span>
<span class="lineNum">     746 </span><span class="lineCov">          1 :     glyphs = malloc((gcnt+1)*sizeof(SplineChar *));</span>
<span class="lineNum">     747 </span><span class="lineCov">          1 :     map = malloc((gcnt+1)*sizeof(uint16));</span>
<span class="lineNum">     748 </span><span class="lineCov">          1 :     gcnt = 0;</span>
<span class="lineNum">     749 </span><span class="lineCov">        166 :     for ( i=0; i&lt;gtot; ++i ) if ( gall[i]!=NULL ) {</span>
<span class="lineNum">     750 </span><span class="lineCov">         31 :         glyphs[gcnt] = gall[i];</span>
<span class="lineNum">     751 </span><span class="lineCov">         31 :         map[gcnt++] = gall[i]-&gt;lsidebearing+4;       /* there are 4 standard classes, so our first class starts at 4 */</span>
<span class="lineNum">     752 </span>            :     }
<span class="lineNum">     753 </span><span class="lineCov">          1 :     glyphs[gcnt] = NULL;</span>
<span class="lineNum">     754 </span><span class="lineCov">          1 :     free(gall);</span>
<span class="lineNum">     755 </span><span class="lineCov">          1 :     free(temp);</span>
<span class="lineNum">     756 </span><span class="lineCov">          1 :     *gc = gcnt;</span>
<span class="lineNum">     757 </span><span class="lineCov">          1 :     *mp = map;</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineCov">          1 :     nc = calloc(match_len,sizeof(int));</span>
<span class="lineNum">     760 </span><span class="lineCov">          1 :     *classes = malloc((match_len+1)*sizeof(int *));</span>
<span class="lineNum">     761 </span><span class="lineCov">          3 :     for ( i=0; i&lt;match_len; ++i )</span>
<span class="lineNum">     762 </span><span class="lineCov">          2 :         (*classes)[i] = malloc((class_cnt+1)*sizeof(int));</span>
<span class="lineNum">     763 </span><span class="lineCov">          1 :     (*classes)[i] = NULL;</span>
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineCov">          1 :     class_cnt = 0;</span>
<span class="lineNum">     766 </span><span class="lineCov">          5 :     for ( i=0; i&lt;(1&lt;&lt;match_len); ++i ) {</span>
<span class="lineNum">     767 </span><span class="lineCov">          4 :         if ( next[i]!=0 ) {</span>
<span class="lineNum">     768 </span><span class="lineCov">          9 :             for ( j=0; j&lt;match_len; ++j ) if ( i&amp;(1&lt;&lt;j)) {</span>
<span class="lineNum">     769 </span><span class="lineCov">          4 :                 (*classes)[j][nc[j]++] = class_cnt+4;   /* there are 4 standard classes, so our first class starts at 4 */</span>
<span class="lineNum">     770 </span>            :             }
<span class="lineNum">     771 </span><span class="lineCov">          3 :             ++class_cnt;</span>
<span class="lineNum">     772 </span>            :         }
<span class="lineNum">     773 </span>            :     }
<span class="lineNum">     774 </span><span class="lineCov">          3 :     for ( j=0; j&lt;match_len; ++j )</span>
<span class="lineNum">     775 </span><span class="lineCov">          2 :         (*classes)[j][nc[j]] = 0xffff;          /* End marker */</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineCov">          1 :     free(next);</span>
<span class="lineNum">     778 </span><span class="lineCov">          1 :     free(nc);</span>
<span class="lineNum">     779 </span><span class="lineCov">          1 : return( glyphs );</span>
<a name="780"><span class="lineNum">     780 </span>            : }</a>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">          1 : static ASM *ASMFromCoverageFPST(SplineFont *sf,FPST *fpst,int ordered) {</span>
<span class="lineNum">     783 </span>            :     SplineChar ***tables, **glyphs;
<span class="lineNum">     784 </span>            :     int **classes, class_cnt, gcnt;
<span class="lineNum">     785 </span>            :     int i, j, k, match_len;
<span class="lineNum">     786 </span><span class="lineCov">          1 :     struct fpst_rule *r = &amp;fpst-&gt;rules[0];</span>
<span class="lineNum">     787 </span><span class="lineCov">          1 :     int subspos = r-&gt;u.coverage.bcnt+r-&gt;lookups[0].seq;</span>
<span class="lineNum">     788 </span><span class="lineCov">          1 :     OTLookup *substag = r-&gt;lookups[0].lookup, *finaltag=NULL;</span>
<span class="lineNum">     789 </span>            :     uint16 *map;
<span class="lineNum">     790 </span>            :     ASM *sm;
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :     /* In one very specific case we can support two substitutions */
<span class="lineNum">     793 </span><span class="lineCov">          1 :     if ( r-&gt;lookup_cnt==2 ) {</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         if ( r-&gt;lookups[0].seq==r-&gt;u.coverage.ncnt-1 ) {</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :             finaltag = substag;</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :             subspos = r-&gt;u.coverage.bcnt+r-&gt;lookups[1].seq;</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :             substag = r-&gt;lookups[1].lookup;</span>
<span class="lineNum">     798 </span>            :         } else
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :             finaltag = r-&gt;lookups[1].lookup;</span>
<span class="lineNum">     800 </span>            :     }
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">          1 :     tables = malloc((r-&gt;u.coverage.ncnt+r-&gt;u.coverage.bcnt+r-&gt;u.coverage.fcnt+1)*sizeof(SplineChar **));</span>
<span class="lineNum">     803 </span><span class="lineCov">          2 :     for ( j=0, i=r-&gt;u.coverage.bcnt-1; i&gt;=0; --i, ++j )</span>
<span class="lineNum">     804 </span><span class="lineCov">          1 :         tables[j] = SFGlyphsFromNames(sf,r-&gt;u.coverage.bcovers[i]);</span>
<span class="lineNum">     805 </span><span class="lineCov">          2 :     for ( i=0; i&lt;r-&gt;u.coverage.ncnt; ++i, ++j )</span>
<span class="lineNum">     806 </span><span class="lineCov">          1 :         tables[j] = SFGlyphsFromNames(sf,r-&gt;u.coverage.ncovers[i]);</span>
<span class="lineNum">     807 </span><span class="lineCov">          1 :     for ( i=0; i&lt;r-&gt;u.coverage.fcnt; ++i, ++j )</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :         tables[j] = SFGlyphsFromNames(sf,r-&gt;u.coverage.fcovers[i]);</span>
<span class="lineNum">     809 </span><span class="lineCov">          1 :     tables[j] = NULL;</span>
<span class="lineNum">     810 </span><span class="lineCov">          1 :     match_len = j;</span>
<span class="lineNum">     811 </span>            : 
<span class="lineNum">     812 </span><span class="lineCov">          3 :     for ( i=0; i&lt;match_len; ++i )</span>
<span class="lineNum">     813 </span><span class="lineCov">          2 :         if ( tables[i]==NULL || tables[i][0]==NULL )</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineCov">          1 :     glyphs = morx_cg_FigureClasses(tables,match_len,</span>
<span class="lineNum">     817 </span>            :             &amp;classes,&amp;class_cnt,&amp;map,&amp;gcnt,fpst,sf,ordered);
<span class="lineNum">     818 </span><span class="lineCov">          1 :     if ( glyphs==NULL )</span>
<span class="lineNum">     819 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span><span class="lineCov">          3 :     for ( i=0; i&lt;match_len; ++i )</span>
<span class="lineNum">     822 </span><span class="lineCov">          2 :         free(tables[i]);</span>
<span class="lineNum">     823 </span><span class="lineCov">          1 :     free(tables);</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineCov">          1 :     sm = chunkalloc(sizeof(ASM));</span>
<span class="lineNum">     826 </span><span class="lineCov">          1 :     sm-&gt;type = asm_context;</span>
<span class="lineNum">     827 </span><span class="lineCov">          1 :     sm-&gt;flags = (fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags&amp;pst_r2l) ? asm_descending : 0;</span>
<span class="lineNum">     828 </span><span class="lineCov">          1 :     sm-&gt;class_cnt = class_cnt;</span>
<span class="lineNum">     829 </span><span class="lineCov">          1 :     sm-&gt;classes = malloc(class_cnt*sizeof(char *));</span>
<span class="lineNum">     830 </span><span class="lineCov">          1 :     sm-&gt;classes[0] = sm-&gt;classes[1] = sm-&gt;classes[2] = sm-&gt;classes[3] = NULL;</span>
<span class="lineNum">     831 </span><span class="lineCov">          4 :     for ( i=4; i&lt;class_cnt; ++i )</span>
<span class="lineNum">     832 </span><span class="lineCov">          3 :         sm-&gt;classes[i] = BuildClassNames(glyphs,map,i);</span>
<span class="lineNum">     833 </span><span class="lineCov">          1 :     free(glyphs); free(map);</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :     /* Now build the state machine */
<span class="lineNum">     836 </span>            :     /* we have match_len+1 states (there are 2 initial states) */
<span class="lineNum">     837 </span>            :     /*  we transition from the initial state to our first state when we get */
<span class="lineNum">     838 </span>            :     /*  any class which makes up the first coverage table. From the first */
<span class="lineNum">     839 </span>            :     /*  to the second on any class which makes up the second ... */
<span class="lineNum">     840 </span><span class="lineCov">          1 :     sm-&gt;state_cnt = match_len+1;</span>
<span class="lineNum">     841 </span><span class="lineCov">          1 :     sm-&gt;state = calloc(sm-&gt;state_cnt*sm-&gt;class_cnt,sizeof(struct asm_state));</span>
<span class="lineNum">     842 </span><span class="lineCov">          3 :     for ( j=0; j&lt;match_len; ++j ) {</span>
<span class="lineNum">     843 </span><span class="lineCov">          2 :         int off = (j+1)*sm-&gt;class_cnt;</span>
<span class="lineNum">     844 </span><span class="lineCov">         16 :         for ( i=0; i&lt;class_cnt; ++i ) {</span>
<span class="lineNum">     845 </span><span class="lineCov">         14 :             for ( k=0; classes[j][k]!=0xffff &amp;&amp; classes[j][k]!=i; ++k );</span>
<span class="lineNum">     846 </span><span class="lineCov">         14 :             if ( classes[j][k]==i ) {</span>
<span class="lineNum">     847 </span><span class="lineCov">          4 :                 sm-&gt;state[off+i].next_state = j+2;</span>
<span class="lineNum">     848 </span><span class="lineCov">          4 :                 if ( j==match_len-1 ) {</span>
<span class="lineNum">     849 </span><span class="lineCov">          2 :                     sm-&gt;state[off+i].next_state = 0;</span>
<span class="lineNum">     850 </span><span class="lineCov">          2 :                     sm-&gt;state[off+i].flags = 0x4000;</span>
<span class="lineNum">     851 </span><span class="lineCov">          2 :                     if ( subspos==j )</span>
<span class="lineNum">     852 </span><span class="lineCov">          2 :                         sm-&gt;state[off+i].u.context.cur_lookup = substag;</span>
<span class="lineNum">     853 </span>            :                     else {
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :                         sm-&gt;state[off+i].u.context.mark_lookup = substag;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                         sm-&gt;state[off+i].u.context.cur_lookup = finaltag;</span>
<span class="lineNum">     856 </span>            :                     }
<span class="lineNum">     857 </span><span class="lineCov">          2 :                 } else if ( subspos==j )</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                     sm-&gt;state[off+i].flags = 0x8000;</span>
<span class="lineNum">     859 </span><span class="lineCov">         10 :             } else if ( i==2 || ((fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags&amp;pst_ignorecombiningmarks) &amp;&amp; i==class_cnt-1 ) )</span>
<span class="lineNum">     860 </span><span class="lineCov">          2 :                 sm-&gt;state[off+i].next_state = j+1;   /* Deleted glyph is a noop */</span>
<span class="lineNum">     861 </span><span class="lineCov">          8 :             else if ( j!=0 )</span>
<span class="lineNum">     862 </span><span class="lineCov">          4 :                 sm-&gt;state[off+i].flags = 0x4000;     /* Don't eat the current glyph, go back to state 0 and see if it will start the sequence over again */</span>
<span class="lineNum">     863 </span>            :         }
<span class="lineNum">     864 </span>            :     }
<span class="lineNum">     865 </span>            :     /* Class 0 and class 1 should be the same. We only filled in class 1 above*/
<span class="lineNum">     866 </span><span class="lineCov">          1 :     memcpy(sm-&gt;state,sm-&gt;state+sm-&gt;class_cnt,sm-&gt;class_cnt*sizeof(struct asm_state));</span>
<span class="lineNum">     867 </span><span class="lineCov">          3 :     for ( j=0; j&lt;match_len; ++j )</span>
<span class="lineNum">     868 </span><span class="lineCov">          2 :         free(classes[j]);</span>
<span class="lineNum">     869 </span><span class="lineCov">          1 :     free(classes);</span>
<span class="lineNum">     870 </span><span class="lineCov">          1 : return( sm );</span>
<span class="lineNum">     871 </span>            : }
<a name="872"><span class="lineNum">     872 </span>            : </a>
<span class="lineNum">     873 </span>            :         /* ********************** From Class FPST ********************** */
<span class="lineNum">     874 </span><span class="lineNoCov">          0 : static void SMSetState(struct asm_state *trans,struct contexttree *cur,int class) {</span>
<span class="lineNum">     875 </span>            :     int i;
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;cur-&gt;branch_cnt; ++i ) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         if ( cur-&gt;branches[i].classnum==class ) {</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :             trans-&gt;next_state = cur-&gt;branches[i].branch-&gt;state;</span>
<span class="lineNum">     880 </span>            :             /* If we go back to state 0, it means we want to start from */
<span class="lineNum">     881 </span>            :             /*  the begining again, and we should check against the */
<span class="lineNum">     882 </span>            :             /*  current glyph (which failed for us, but might be useful */
<span class="lineNum">     883 </span>            :             /*  to start a new operation).  Even if we did not fail we */
<span class="lineNum">     884 </span>            :             /*  should still do this (so don't advance the glyph) */
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :             trans-&gt;flags = cur-&gt;branches[i].branch-&gt;state!=0</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :                     ? cur-&gt;branches[i].branch-&gt;markme?0x8000:0x0000</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :                     : cur-&gt;branches[i].branch-&gt;markme?0xc000:0x4000;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :             trans-&gt;u.context.mark_lookup = cur-&gt;branches[i].branch-&gt;applymarkedsubs;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :             trans-&gt;u.context.cur_lookup = cur-&gt;branches[i].branch-&gt;applycursubs;</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">     891 </span>            :         }
<span class="lineNum">     892 </span>            :     }
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :     if ( cur-&gt;ends_here!=NULL ) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         trans-&gt;next_state = 0;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :         trans-&gt;flags = 0x4000;</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         trans-&gt;u.context.mark_lookup = cur-&gt;applymarkedsubs;</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         trans-&gt;u.context.cur_lookup = cur-&gt;applycursubs;</span>
<span class="lineNum">     899 </span>            :     } else
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         trans-&gt;next_state = 0;</span>
<a name="901"><span class="lineNum">     901 </span>            : }</a>
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span><span class="lineNoCov">          0 : static struct asm_state *AnyActiveSubstrings(struct contexttree *tree,</span>
<span class="lineNum">     904 </span>            :         struct contexttree *cur,int class, struct asm_state *trans, int classcnt) {
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     struct fpc *any = &amp;cur-&gt;rules[0].rule-&gt;u.class;</span>
<span class="lineNum">     906 </span>            :     int i,rc,j, b;
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     for ( i=1; i&lt;=cur-&gt;depth; ++i ) {</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :         for ( rc=0; rc&lt;tree-&gt;rule_cnt; ++rc ) {</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :             struct fpc *r = &amp;tree-&gt;rules[rc].rule-&gt;u.class;</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :             int ok = true;</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;=cur-&gt;depth-i; ++j ) {</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :                 if ( any-&gt;allclasses[j+i]!=r-&gt;allclasses[j] ) {</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                     ok = false;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     916 </span>            :                 }
<span class="lineNum">     917 </span>            :             }
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :             if ( ok &amp;&amp; r-&gt;allclasses[j]==class ) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 struct contexttree *sub = tree;</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :                 for ( j=0; j&lt;=cur-&gt;depth-i; ++j ) {</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :                     for ( b=0; b&lt;sub-&gt;branch_cnt; ++b ) {</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :                         if ( sub-&gt;branches[b].classnum==r-&gt;allclasses[j] ) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :                             sub = sub-&gt;branches[b].branch;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     925 </span>            :                         }
<span class="lineNum">     926 </span>            :                     }
<span class="lineNum">     927 </span>            :                 }
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :                 if ( trans[sub-&gt;state*classcnt+class+3].next_state!=0 &amp;&amp;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :                         (sub-&gt;pending_pos+i == cur-&gt;pending_pos ||</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :                          sub-&gt;pending_pos == -1 ))</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 : return( &amp;trans[sub-&gt;state*classcnt+class+3] );</span>
<span class="lineNum">     932 </span>            :             }
<span class="lineNum">     933 </span>            :         }
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span><span class="lineNoCov">          0 : return( NULL );</span>
<a name="936"><span class="lineNum">     936 </span>            : }</a>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 : static int FailureTrans( struct asm_state *trans ) {</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 : return( trans-&gt;next_state==0 &amp;&amp;</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :             trans-&gt;u.context.mark_lookup==NULL &amp;&amp;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :             trans-&gt;u.context.cur_lookup==NULL );</span>
<a name="942"><span class="lineNum">     942 </span>            : }</a>
<span class="lineNum">     943 </span>            : 
<span class="lineNum">     944 </span><span class="lineNoCov">          0 : static ASM *ASMFromClassFPST(SplineFont *sf,FPST *fpst, struct contexttree *tree) {</span>
<span class="lineNum">     945 </span>            :     ASM *sm;
<span class="lineNum">     946 </span>            :     struct contexttree *cur;
<span class="lineNum">     947 </span>            :     int i;
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :     sm = chunkalloc(sizeof(ASM));</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     sm-&gt;type = asm_context;</span>
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :     sm-&gt;flags = (fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags&amp;pst_r2l) ? asm_descending : 0;</span>
<span class="lineNum">     952 </span>            :     /* mac class sets have four magic classes, opentype sets only have one */
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     sm-&gt;class_cnt = (fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags&amp;pst_ignorecombiningmarks) ? fpst-&gt;nccnt+4 : fpst-&gt;nccnt+3;</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     sm-&gt;classes = malloc(sm-&gt;class_cnt*sizeof(char *));</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     sm-&gt;classes[0] = sm-&gt;classes[1] = sm-&gt;classes[2] = sm-&gt;classes[3] = NULL;</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :     for ( i=1; i&lt;fpst-&gt;nccnt; ++i )</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :         sm-&gt;classes[i+3] = copy(fpst-&gt;nclass[i]);</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     if ( fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags&amp;pst_ignorecombiningmarks )</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :         sm-&gt;classes[sm-&gt;class_cnt-1] = BuildMarkClass(sf);</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :     /* Now build the state machine */
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :     sm-&gt;state_cnt = tree-&gt;next_state;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     sm-&gt;state = calloc(sm-&gt;state_cnt*sm-&gt;class_cnt,sizeof(struct asm_state));</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     for ( cur=tree; cur!=NULL; cur = TreeNext(cur)) if ( cur-&gt;state!=0 ) {</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :         int off = cur-&gt;state*sm-&gt;class_cnt;</span>
<span class="lineNum">     966 </span>            : 
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :         SMSetState(&amp;sm-&gt;state[off+1],cur,0);             /* Out of bounds state */</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :         sm-&gt;state[off+2].next_state = cur-&gt;state; /* Deleted glyph gets eaten and ignored */</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;subtable-&gt;lookup-&gt;lookup_flags&amp;pst_ignorecombiningmarks )</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :             sm-&gt;state[off+sm-&gt;class_cnt-1].next_state = cur-&gt;state;    /* As do ignored marks */</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :         for ( i=1; i&lt;fpst-&gt;nccnt; ++i )</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :             SMSetState(&amp;sm-&gt;state[off+i+3],cur,i);</span>
<span class="lineNum">     973 </span>            :     }
<span class="lineNum">     974 </span>            :     /* Class 0 and class 1 should be the same. We only filled in class 1 above*/
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :     memcpy(sm-&gt;state,sm-&gt;state+sm-&gt;class_cnt,sm-&gt;class_cnt*sizeof(struct asm_state));</span>
<span class="lineNum">     976 </span>            :     /* Do a sort of transitive closure on states, so if we are looking for */
<span class="lineNum">     977 </span>            :     /*  either &quot;abcd&quot; or &quot;bce&quot;, don't lose the &quot;bce&quot; inside &quot;abce&quot; */
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :     FPSTBuildAllClasses(fpst);</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :     for ( cur = tree; cur!=NULL; cur = TreeNext(cur)) if ( cur-&gt;state&gt;1 ) {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :         int off = cur-&gt;state*sm-&gt;class_cnt;</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :         for ( i=1; i&lt;fpst-&gt;nccnt; ++i ) if ( FailureTrans(&amp;sm-&gt;state[off+3+i]) ) {</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :             struct asm_state *trans =</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :                     AnyActiveSubstrings(tree,cur,i, sm-&gt;state,sm-&gt;class_cnt);</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :             if ( trans!=NULL )</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :                 sm-&gt;state[off+3+i] = *trans;</span>
<span class="lineNum">     986 </span>            :         }
<span class="lineNum">     987 </span>            :     }
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :     FPSTFreeAllClasses(fpst);</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 : return( sm );</span>
<a name="990"><span class="lineNum">     990 </span>            : }</a>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span><span class="lineCov">          1 : ASM *ASMFromFPST(SplineFont *sf,FPST *fpst,int ordered) {</span>
<span class="lineNum">     993 </span><span class="lineCov">          1 :     FPST *tempfpst=fpst;</span>
<span class="lineNum">     994 </span><span class="lineCov">          1 :     struct contexttree *tree=NULL;</span>
<span class="lineNum">     995 </span>            :     ASM *sm;
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineCov">          1 :     if ( fpst-&gt;format==pst_glyphs )</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :         tempfpst = FPSTGlyphToClass( fpst );</span>
<span class="lineNum">     999 </span><span class="lineCov">          1 :     if ( tempfpst-&gt;format==pst_coverage )</span>
<span class="lineNum">    1000 </span><span class="lineCov">          1 :         sm = ASMFromCoverageFPST(sf,fpst,ordered);</span>
<span class="lineNum">    1001 </span>            :     else {
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :         tree = FPST2Tree(sf, tempfpst);</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :         if ( tree!=NULL ) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :             sm = ASMFromClassFPST(sf,tempfpst,tree);</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :             TreeFree(tree);</span>
<span class="lineNum">    1006 </span>            :         } else
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :             sm = NULL;</span>
<span class="lineNum">    1008 </span>            :     }
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span><span class="lineCov">          1 :     if ( tempfpst!=fpst )</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         FPSTFree(tempfpst);</span>
<span class="lineNum">    1012 </span>            :         /* This is a temporary value. It should be replaced if we plan to */
<span class="lineNum">    1013 </span>            :         /*  retain this state machine */
<span class="lineNum">    1014 </span><span class="lineCov">          1 :     if ( sm!=NULL )</span>
<span class="lineNum">    1015 </span><span class="lineCov">          1 :         sm-&gt;subtable = fpst-&gt;subtable;</span>
<span class="lineNum">    1016 </span><span class="lineCov">          1 : return( sm );</span>
<span class="lineNum">    1017 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
