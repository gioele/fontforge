<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd) - fontforge/stemdb.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">fontforge</a> - stemdb.c<span style="font-size: 80%;"> (source / <a href="stemdb.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd)</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3530</td>
            <td class="headerCovTableEntry">3753</td>
            <td class="headerCovTableEntryHi">94.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-08-04</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">106</td>
            <td class="headerCovTableEntry">108</td>
            <td class="headerCovTableEntryHi">98.1 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright (C) 2005-2012 by George Williams and Alexey Kryukov */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       4 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :  * Redistributions of source code must retain the above copyright notice, this
<span class="lineNum">       7 </span>            :  * list of conditions and the following disclaimer.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :  * Redistributions in binary form must reproduce the above copyright notice,
<span class="lineNum">      10 </span>            :  * this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      11 </span>            :  * and/or other materials provided with the distribution.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :  * The name of the author may not be used to endorse or promote products
<span class="lineNum">      14 </span>            :  * derived from this software without specific prior written permission.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
<span class="lineNum">      17 </span>            :  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
<span class="lineNum">      18 </span>            :  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
<span class="lineNum">      19 </span>            :  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      20 </span>            :  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      21 </span>            :  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
<span class="lineNum">      22 </span>            :  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
<span class="lineNum">      23 </span>            :  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
<span class="lineNum">      24 </span>            :  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
<span class="lineNum">      25 </span>            :  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #include &quot;stemdb.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &quot;autohint.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;dumppfa.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;fontforge.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;edgelist2.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;splineoverlap.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;splineutil.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;splineutil2.h&quot;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;utype.h&gt;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #define GLYPH_DATA_DEBUG 0
<span class="lineNum">      42 </span>            : #define PI 3.14159265358979323846264338327
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : /* A diagonal end is like the top or bottom of a slash. Should we add a vertical stem at the end? */
<span class="lineNum">      45 </span>            : /* A diagonal corner is like the bottom of circumflex. Should we add a horizontal stem? */
<span class="lineNum">      46 </span>            : int     hint_diagonal_ends = 0,
<span class="lineNum">      47 </span>            :         hint_diagonal_intersections = 0,
<span class="lineNum">      48 </span>            :         hint_bounding_boxes = 1,
<span class="lineNum">      49 </span>            :         detect_diagonal_stems = 0;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : float   stem_slope_error = .05061454830783555773, /*  2.9 degrees */
<span class="lineNum">      52 </span>            :         stub_slope_error = .317649923862967983;   /* 18.2 degrees */
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : static double dist_error_hv = 3.5;
<span class="lineNum">      55 </span>            : static double dist_error_diag = 5.5;
<span class="lineNum">      56 </span>            : /* It's easy to get horizontal/vertical lines aligned properly */
<span class="lineNum">      57 </span>            : /* it is more difficult to get diagonal ones done */
<span class="lineNum">      58 </span>            : /* The &quot;A&quot; glyph in Apple's Times.dfont(Roman) is off by 6 in one spot */
<span class="lineNum">      59 </span>            : static double dist_error_curve = 22;
<span class="lineNum">      60 </span>            : /* The maximum possible distance between the edge of an active zone for */
<span class="lineNum">      61 </span>            : /* a curved spline segment and the spline itself */
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : struct st {
<span class="lineNum">      64 </span>            :     Spline *s;
<span class="lineNum">      65 </span>            :     double st, lt;
<a name="66"><span class="lineNum">      66 </span>            : };</a>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span><span class="lineCov">       1963 : static int GetBlueFuzz(SplineFont *sf) {</span>
<span class="lineNum">      69 </span>            :     char *str, *end;
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span><span class="lineCov">       2698 :     if ( sf == NULL || sf-&gt;private == NULL || </span>
<span class="lineNum">      72 </span><span class="lineCov">        735 :         (str=PSDictHasEntry( sf-&gt;private,&quot;BlueFuzz&quot; )) == NULL || !isdigit( str[0] ))</span>
<span class="lineNum">      73 </span><span class="lineCov">       1963 : return 1;</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 : return strtod( str, &amp;end );</span>
<a name="75"><span class="lineNum">      75 </span>            : }</a>
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineCov">    1450338 : static int IsUnitHV( BasePoint *unit,int strict ) {</span>
<span class="lineNum">      78 </span><span class="lineCov">    1450338 :     double angle = atan2( unit-&gt;y,unit-&gt;x );</span>
<span class="lineNum">      79 </span><span class="lineCov">    1450338 :     double deviation = ( strict ) ? stem_slope_error : stub_slope_error;</span>
<span class="lineNum">      80 </span>            :     
<span class="lineNum">      81 </span><span class="lineCov">    1450338 :     if ( fabs( angle ) &gt;= PI/2 - deviation &amp;&amp; fabs( angle ) &lt;= PI/2 + deviation )</span>
<span class="lineNum">      82 </span><span class="lineCov">     478391 : return( 2 );</span>
<span class="lineNum">      83 </span><span class="lineCov">     971947 :     else if ( fabs( angle ) &lt;= deviation || fabs( angle ) &gt;= PI - deviation )</span>
<span class="lineNum">      84 </span><span class="lineCov">     616112 : return( 1 );</span>
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span><span class="lineCov">     355835 : return( 0 );</span>
<a name="87"><span class="lineNum">      87 </span>            : }</a>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span><span class="lineCov">       3597 : static int UnitCloserToHV( BasePoint *u1,BasePoint *u2 ) {</span>
<span class="lineNum">      90 </span>            :     double adiff1, adiff2;
<span class="lineNum">      91 </span>            :     
<span class="lineNum">      92 </span><span class="lineCov">       3597 :     adiff1 = fabs( atan2( u1-&gt;y,u1-&gt;x ));</span>
<span class="lineNum">      93 </span><span class="lineCov">       3597 :     adiff2 = fabs( atan2( u2-&gt;y,u2-&gt;x ));</span>
<span class="lineNum">      94 </span>            :     
<span class="lineNum">      95 </span><span class="lineCov">       3597 :     if ( adiff1 &gt; PI*.25 &amp;&amp; adiff1 &lt; PI*.75 )</span>
<span class="lineNum">      96 </span><span class="lineCov">       1876 :         adiff1 = fabs( adiff1 - PI*.5 );</span>
<span class="lineNum">      97 </span><span class="lineCov">       1721 :     else if ( adiff1 &gt;= PI*.75 )</span>
<span class="lineNum">      98 </span><span class="lineCov">        545 :         adiff1 = PI - adiff1;</span>
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span><span class="lineCov">       3597 :     if ( adiff2 &gt; PI*.25 &amp;&amp; adiff2 &lt; PI*.75 )</span>
<span class="lineNum">     101 </span><span class="lineCov">       1814 :         adiff2 = fabs( adiff2 - PI*.5 );</span>
<span class="lineNum">     102 </span><span class="lineCov">       1783 :     else if ( adiff2 &gt;= PI*.75 )</span>
<span class="lineNum">     103 </span><span class="lineCov">        660 :         adiff2 = PI - adiff2;</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineCov">       3597 :     if ( adiff1 &lt; adiff2 )</span>
<span class="lineNum">     106 </span><span class="lineCov">       1671 : return( 1 );</span>
<span class="lineNum">     107 </span><span class="lineCov">       1926 :     else if ( adiff1 &gt; adiff2 )</span>
<span class="lineNum">     108 </span><span class="lineCov">       1486 : return( -1 );</span>
<span class="lineNum">     109 </span>            :     else
<span class="lineNum">     110 </span><span class="lineCov">        440 : return( 0 );</span>
<a name="111"><span class="lineNum">     111 </span>            : }</a>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">    1300147 : static double GetUnitAngle( BasePoint *u1,BasePoint *u2 ) {</span>
<span class="lineNum">     114 </span>            :     double dx, dy;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span><span class="lineCov">    1300147 :     dy = u1-&gt;x*u2-&gt;y - u1-&gt;y*u2-&gt;x;</span>
<span class="lineNum">     117 </span><span class="lineCov">    1300147 :     dx = u1-&gt;x*u2-&gt;x + u1-&gt;y*u2-&gt;y;</span>
<span class="lineNum">     118 </span><span class="lineCov">    1300147 : return( atan2( dy,dx ));</span>
<a name="119"><span class="lineNum">     119 </span>            : }</a>
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">      12529 : static int UnitsOrthogonal( BasePoint *u1,BasePoint *u2,int strict ) {</span>
<span class="lineNum">     122 </span><span class="lineCov">      12529 :     double angle, deviation = ( strict ) ? stem_slope_error : stub_slope_error;</span>
<span class="lineNum">     123 </span>            :     
<span class="lineNum">     124 </span><span class="lineCov">      12529 :     angle = GetUnitAngle( u1,u2 );</span>
<span class="lineNum">     125 </span>            :     
<span class="lineNum">     126 </span><span class="lineCov">      12529 : return( fabs( angle ) &gt;= PI/2 - deviation &amp;&amp; fabs( angle ) &lt;= PI/2 + deviation );</span>
<a name="127"><span class="lineNum">     127 </span>            : }</a>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineCov">     930958 : int UnitsParallel( BasePoint *u1,BasePoint *u2,int strict ) {</span>
<span class="lineNum">     130 </span><span class="lineCov">     930958 :     double angle, deviation = ( strict ) ? stem_slope_error : stub_slope_error;</span>
<span class="lineNum">     131 </span>            :     
<span class="lineNum">     132 </span><span class="lineCov">     930958 :     angle = GetUnitAngle( u1,u2 );</span>
<span class="lineNum">     133 </span>            :     
<span class="lineNum">     134 </span><span class="lineCov">     930958 : return( fabs( angle ) &lt;= deviation || fabs( angle ) &gt;= PI - deviation );</span>
<a name="135"><span class="lineNum">     135 </span>            : }</a>
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span><span class="lineCov">       2134 : static int IsInflectionPoint( struct glyphdata *gd,struct pointdata *pd ) {</span>
<span class="lineNum">     138 </span><span class="lineCov">       2134 :     SplinePoint *sp = pd-&gt;sp;</span>
<span class="lineNum">     139 </span><span class="lineCov">       2134 :     double CURVATURE_THRESHOLD = 1e-9;</span>
<span class="lineNum">     140 </span>            :     struct spline *prev, *next;
<span class="lineNum">     141 </span>            :     double in, out;
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">       2134 :     if ( sp-&gt;prev == NULL || sp-&gt;next == NULL || !pd-&gt;colinear )</span>
<span class="lineNum">     144 </span><span class="lineCov">        604 : return( false );</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :     /* point of a single-point contour can't be an inflection point. */
<span class="lineNum">     147 </span><span class="lineCov">       1530 :     if ( sp-&gt;prev-&gt;from == sp )</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineCov">       1530 :     prev = sp-&gt;prev;</span>
<span class="lineNum">     151 </span><span class="lineCov">       1530 :     in = 0;</span>
<span class="lineNum">     152 </span><span class="lineCov">       3060 :     while ( prev != NULL &amp;&amp; fabs(in) &lt; CURVATURE_THRESHOLD ) {</span>
<span class="lineNum">     153 </span><span class="lineCov">       1530 :         in = SplineCurvature( prev,1 );</span>
<span class="lineNum">     154 </span><span class="lineCov">       1530 :         if ( fabs( in ) &lt; CURVATURE_THRESHOLD ) in = SplineCurvature( prev, 0 );</span>
<span class="lineNum">     155 </span><span class="lineCov">       1530 :         if ( fabs( in ) &lt; CURVATURE_THRESHOLD ) prev = prev-&gt;from-&gt;prev;</span>
<span class="lineNum">     156 </span><span class="lineCov">       1530 :         if ( gd-&gt;points[prev-&gt;to-&gt;ptindex].colinear )</span>
<span class="lineNum">     157 </span><span class="lineCov">       1530 :     break;</span>
<span class="lineNum">     158 </span>            :     }
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span><span class="lineCov">       1530 :     next = sp-&gt;next;</span>
<span class="lineNum">     161 </span><span class="lineCov">       1530 :     out = 0;</span>
<span class="lineNum">     162 </span><span class="lineCov">       3062 :     while ( next != NULL &amp;&amp; fabs( out ) &lt; CURVATURE_THRESHOLD ) {</span>
<span class="lineNum">     163 </span><span class="lineCov">       1532 :         out = SplineCurvature( next,0 );</span>
<span class="lineNum">     164 </span><span class="lineCov">       1532 :         if ( fabs( out ) &lt; CURVATURE_THRESHOLD ) out = SplineCurvature( next, 1 );</span>
<span class="lineNum">     165 </span><span class="lineCov">       1532 :         if ( fabs( out ) &lt; CURVATURE_THRESHOLD ) next = next-&gt;to-&gt;next;</span>
<span class="lineNum">     166 </span><span class="lineCov">       1532 :         if ( gd-&gt;points[next-&gt;from-&gt;ptindex].colinear )</span>
<span class="lineNum">     167 </span><span class="lineCov">       1530 :     break;</span>
<span class="lineNum">     168 </span>            :     }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">       1530 :     if ( in==0 || out==0 || ( prev != sp-&gt;prev &amp;&amp; next != sp-&gt;next ))</span>
<span class="lineNum">     171 </span><span class="lineCov">          6 : return( false );</span>
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span><span class="lineCov">       1524 :     in/=fabs(in);</span>
<span class="lineNum">     174 </span><span class="lineCov">       1524 :     out/=fabs(out);</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">       1524 : return ( in*out &lt; 0 );</span>
<a name="177"><span class="lineNum">     177 </span>            : }</a>
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">      49908 : static int SplineFigureOpticalSlope(Spline *s,int start_at_from,BasePoint *dir) {</span>
<span class="lineNum">     180 </span>            :     /* Sometimes splines have tiny control points, and to the eye the slope */
<span class="lineNum">     181 </span>            :     /*  of the spline has nothing to do with that specified by the cps. */
<span class="lineNum">     182 </span>            :     /* So see if the spline is straightish and figure the slope based on */
<span class="lineNum">     183 </span>            :     /*  some average direction */
<span class="lineNum">     184 </span>            :     /* dir is a input output parameter. */
<span class="lineNum">     185 </span>            :     /*  it should be initialized to the unit vector determined by the appropriate cp */
<span class="lineNum">     186 </span>            :     /*  if the function returns true, it will be set to a unit vector in the average direction */
<span class="lineNum">     187 </span>            :     BasePoint pos, *base, average_dir, normal;
<span class="lineNum">     188 </span>            :     double t, len, incr, off;
<span class="lineNum">     189 </span>            :     double dx, dy, ax, ay, d, a;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :     /* The vector is already nearly vertical/horizontal, no need to modify*/
<span class="lineNum">     192 </span><span class="lineCov">      49908 :     if ( IsUnitHV( dir,true ))</span>
<span class="lineNum">     193 </span><span class="lineCov">      19420 : return( false );</span>
<span class="lineNum">     194 </span>            :     
<span class="lineNum">     195 </span><span class="lineCov">      30488 :     if ( start_at_from ) {</span>
<span class="lineNum">     196 </span><span class="lineCov">      15144 :         incr = -.1;</span>
<span class="lineNum">     197 </span><span class="lineCov">      15144 :         base = &amp;s-&gt;from-&gt;me;</span>
<span class="lineNum">     198 </span>            :     } else {
<span class="lineNum">     199 </span><span class="lineCov">      15344 :         incr = .1;</span>
<span class="lineNum">     200 </span><span class="lineCov">      15344 :         base = &amp;s-&gt;to-&gt;me;</span>
<span class="lineNum">     201 </span>            :     }
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineCov">      30488 :     t = .5-incr;</span>
<span class="lineNum">     204 </span><span class="lineCov">      30488 :     memset(&amp;average_dir,0,sizeof(average_dir));</span>
<span class="lineNum">     205 </span><span class="lineCov">     274392 :     while ( t&gt;0 &amp;&amp; t&lt;1.0 ) {</span>
<span class="lineNum">     206 </span><span class="lineCov">     213416 :         pos.x = ((s-&gt;splines[0].a*t+s-&gt;splines[0].b)*t+s-&gt;splines[0].c)*t+s-&gt;splines[0].d;</span>
<span class="lineNum">     207 </span><span class="lineCov">     213416 :         pos.y = ((s-&gt;splines[1].a*t+s-&gt;splines[1].b)*t+s-&gt;splines[1].c)*t+s-&gt;splines[1].d;</span>
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span><span class="lineCov">     213416 :         average_dir.x += (pos.x-base-&gt;x); average_dir.y += (pos.y-base-&gt;y);</span>
<span class="lineNum">     210 </span><span class="lineCov">     213416 :         t += incr;</span>
<span class="lineNum">     211 </span>            :     }
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineCov">      30488 :     len = sqrt( pow( average_dir.x,2 ) + pow( average_dir.y,2 ));</span>
<span class="lineNum">     214 </span><span class="lineCov">      30488 :     if ( len==0 )</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     216 </span><span class="lineCov">      30488 :     average_dir.x /= len; average_dir.y /= len;</span>
<span class="lineNum">     217 </span><span class="lineCov">      30488 :     normal.x = average_dir.y; normal.y = - average_dir.x;</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineCov">      30488 :     t = .5-incr;</span>
<span class="lineNum">     220 </span><span class="lineCov">     215313 :     while ( t&gt;0 &amp;&amp; t&lt;1.0 ) {</span>
<span class="lineNum">     221 </span><span class="lineCov">     162777 :         pos.x = ((s-&gt;splines[0].a*t+s-&gt;splines[0].b)*t+s-&gt;splines[0].c)*t+s-&gt;splines[0].d;</span>
<span class="lineNum">     222 </span><span class="lineCov">     162777 :         pos.y = ((s-&gt;splines[1].a*t+s-&gt;splines[1].b)*t+s-&gt;splines[1].c)*t+s-&gt;splines[1].d;</span>
<span class="lineNum">     223 </span><span class="lineCov">     162777 :         off = (pos.x-base-&gt;x)*normal.x + (pos.y-base-&gt;y)*normal.y;</span>
<span class="lineNum">     224 </span><span class="lineCov">     162777 :         if ( off&lt;-dist_error_hv || off&gt;dist_error_hv )</span>
<span class="lineNum">     225 </span><span class="lineCov">       8440 : return( false );</span>
<span class="lineNum">     226 </span><span class="lineCov">     154337 :         t += incr;</span>
<span class="lineNum">     227 </span>            :     }
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineCov">      22048 :     if ( UnitsParallel( dir,&amp;normal,true )) {</span>
<span class="lineNum">     230 </span>            :         /* prefer the direction which is closer to horizontal/vertical */
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         if ( (dx=dir-&gt;x)&lt;0 ) dx = -dx;</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         if ( (dy=dir-&gt;y)&lt;0 ) dy = -dy;</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         d = (dx&lt;dy) ? dx : dy;</span>
<span class="lineNum">     234 </span><span class="lineNoCov">          0 :         if ( (ax=average_dir.x)&lt;0 ) ax = -ax;</span>
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :         if ( (ay=average_dir.y)&lt;0 ) ay = -ay;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         a = (ax&lt;ay) ? ax : ay;</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :         if ( d&lt;a )</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">     239 </span>            :     }
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineCov">      22048 :     *dir = average_dir;</span>
<span class="lineNum">     242 </span><span class="lineCov">      22048 : return( true );</span>
<span class="lineNum">     243 </span>            : }
<span class="lineNum">     244 </span>            : 
<a name="245"><span class="lineNum">     245 </span>            : static int IsSplinePeak( struct glyphdata *gd,struct pointdata *pd,int outer,int is_x,int flags );</a>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">      39497 : static void PointInit( struct glyphdata *gd,SplinePoint *sp, SplineSet *ss ) {</span>
<span class="lineNum">     248 </span><span class="lineCov">      39497 :     struct pointdata *pd, *prevpd=NULL, *nextpd=NULL;</span>
<span class="lineNum">     249 </span>            :     double len, same;
<span class="lineNum">     250 </span>            :     int hv;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineCov">      39497 :     if ( sp-&gt;ptindex &gt;= gd-&gt;pcnt )</span>
<span class="lineNum">     253 </span><span class="lineCov">      39497 : return;</span>
<span class="lineNum">     254 </span><span class="lineCov">      39497 :     pd = &amp;gd-&gt;points[sp-&gt;ptindex];</span>
<span class="lineNum">     255 </span><span class="lineCov">      39497 :     pd-&gt;sp = sp;</span>
<span class="lineNum">     256 </span><span class="lineCov">      39497 :     pd-&gt;ss = ss;</span>
<span class="lineNum">     257 </span><span class="lineCov">      39497 :     pd-&gt;x_extr = pd-&gt;y_extr = 0;</span>
<span class="lineNum">     258 </span><span class="lineCov">      39497 :     pd-&gt;base = sp-&gt;me;</span>
<span class="lineNum">     259 </span><span class="lineCov">      39497 :     pd-&gt;ttfindex = sp-&gt;ttfindex;</span>
<span class="lineNum">     260 </span><span class="lineCov">      39497 :     pd-&gt;nextcnt = pd-&gt;prevcnt = 0;</span>
<span class="lineNum">     261 </span><span class="lineCov">      39497 :     pd-&gt;nextstems = pd-&gt;prevstems = NULL;</span>
<span class="lineNum">     262 </span><span class="lineCov">      39497 :     pd-&gt;next_is_l = pd-&gt;prev_is_l = NULL;</span>
<span class="lineNum">     263 </span>            :     
<span class="lineNum">     264 </span><span class="lineCov">      39497 :     if ( !sp-&gt;nonextcp &amp;&amp; gd-&gt;order2 &amp;&amp; sp-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">     265 </span>            :     
<span class="lineNum">     266 </span><span class="lineCov">      12263 :         nextpd = &amp;gd-&gt;points[sp-&gt;nextcpindex];</span>
<span class="lineNum">     267 </span><span class="lineCov">      12263 :         nextpd-&gt;ss = ss;</span>
<span class="lineNum">     268 </span><span class="lineCov">      12263 :         nextpd-&gt;x_extr = nextpd-&gt;y_extr = 0;</span>
<span class="lineNum">     269 </span><span class="lineCov">      12263 :         nextpd-&gt;base = sp-&gt;nextcp;</span>
<span class="lineNum">     270 </span><span class="lineCov">      12263 :         nextpd-&gt;ttfindex = sp-&gt;nextcpindex;</span>
<span class="lineNum">     271 </span>            :     }
<span class="lineNum">     272 </span><span class="lineCov">      51800 :     if ( !sp-&gt;noprevcp &amp;&amp; gd-&gt;order2 &amp;&amp; sp-&gt;prev != NULL &amp;&amp;</span>
<span class="lineNum">     273 </span><span class="lineCov">      12303 :         sp-&gt;prev-&gt;from-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">     274 </span>            :         
<span class="lineNum">     275 </span><span class="lineCov">      12263 :         nextpd = &amp;gd-&gt;points[sp-&gt;prev-&gt;from-&gt;nextcpindex];</span>
<span class="lineNum">     276 </span><span class="lineCov">      12263 :         nextpd-&gt;ss = ss;</span>
<span class="lineNum">     277 </span><span class="lineCov">      12263 :         nextpd-&gt;x_extr = nextpd-&gt;y_extr = 0;</span>
<span class="lineNum">     278 </span><span class="lineCov">      12263 :         nextpd-&gt;base = sp-&gt;prevcp;</span>
<span class="lineNum">     279 </span><span class="lineCov">      12263 :         nextpd-&gt;ttfindex = sp-&gt;prev-&gt;from-&gt;nextcpindex;</span>
<span class="lineNum">     280 </span>            :     }
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">      39497 :     if ( sp-&gt;next==NULL ) {</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :         pd-&gt;nextunit.x = ss-&gt;first-&gt;me.x - sp-&gt;me.x;</span>
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :         pd-&gt;nextunit.y = ss-&gt;first-&gt;me.y - sp-&gt;me.y;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :         pd-&gt;nextlinear = true;</span>
<span class="lineNum">     286 </span><span class="lineCov">      39497 :     } else if ( sp-&gt;next-&gt;knownlinear ) {</span>
<span class="lineNum">     287 </span><span class="lineCov">      14385 :         pd-&gt;nextunit.x = sp-&gt;next-&gt;to-&gt;me.x - sp-&gt;me.x;</span>
<span class="lineNum">     288 </span><span class="lineCov">      14385 :         pd-&gt;nextunit.y = sp-&gt;next-&gt;to-&gt;me.y - sp-&gt;me.y;</span>
<span class="lineNum">     289 </span><span class="lineCov">      14385 :         pd-&gt;nextlinear = true;</span>
<span class="lineNum">     290 </span><span class="lineCov">      25112 :     } else if ( sp-&gt;nonextcp ) {</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :         pd-&gt;nextunit.x = sp-&gt;next-&gt;to-&gt;prevcp.x - sp-&gt;me.x;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :         pd-&gt;nextunit.y = sp-&gt;next-&gt;to-&gt;prevcp.y - sp-&gt;me.y;</span>
<span class="lineNum">     293 </span>            :     } else {
<span class="lineNum">     294 </span><span class="lineCov">      25112 :         pd-&gt;nextunit.x = sp-&gt;nextcp.x - sp-&gt;me.x;</span>
<span class="lineNum">     295 </span><span class="lineCov">      25112 :         pd-&gt;nextunit.y = sp-&gt;nextcp.y - sp-&gt;me.y;</span>
<span class="lineNum">     296 </span>            :     }
<span class="lineNum">     297 </span><span class="lineCov">      39497 :     len = sqrt( pow( pd-&gt;nextunit.x,2 ) + pow( pd-&gt;nextunit.y,2 ));</span>
<span class="lineNum">     298 </span><span class="lineCov">      39497 :     if ( len==0 )</span>
<span class="lineNum">     299 </span><span class="lineCov">        169 :         pd-&gt;nextzero = true;</span>
<span class="lineNum">     300 </span>            :     else {
<span class="lineNum">     301 </span><span class="lineCov">      39328 :         pd-&gt;nextlen = len;</span>
<span class="lineNum">     302 </span><span class="lineCov">      39328 :         pd-&gt;nextunit.x /= len;</span>
<span class="lineNum">     303 </span><span class="lineCov">      39328 :         pd-&gt;nextunit.y /= len;</span>
<span class="lineNum">     304 </span><span class="lineCov">      39328 :         if ( sp-&gt;next!=NULL &amp;&amp; !sp-&gt;next-&gt;knownlinear )</span>
<span class="lineNum">     305 </span><span class="lineCov">      24943 :             SplineFigureOpticalSlope(sp-&gt;next,true,&amp;pd-&gt;nextunit);</span>
<span class="lineNum">     306 </span><span class="lineCov">      39328 :         hv = IsUnitHV( &amp;pd-&gt;nextunit,true );</span>
<span class="lineNum">     307 </span><span class="lineCov">      39328 :         if ( hv == 2 ) {</span>
<span class="lineNum">     308 </span><span class="lineCov">       9458 :             pd-&gt;nextunit.x = 0; pd-&gt;nextunit.y = pd-&gt;nextunit.y&gt;0 ? 1 : -1;</span>
<span class="lineNum">     309 </span><span class="lineCov">      29870 :         } else if ( hv == 1 ) {</span>
<span class="lineNum">     310 </span><span class="lineCov">      10783 :             pd-&gt;nextunit.y = 0; pd-&gt;nextunit.x = pd-&gt;nextunit.x&gt;0 ? 1 : -1;</span>
<span class="lineNum">     311 </span>            :         }
<span class="lineNum">     312 </span><span class="lineCov">      39328 :         if ( pd-&gt;nextunit.y==0 ) pd-&gt;next_hor = true;</span>
<span class="lineNum">     313 </span><span class="lineCov">      28545 :         else if ( pd-&gt;nextunit.x==0 ) pd-&gt;next_ver = true;</span>
<span class="lineNum">     314 </span>            :         
<span class="lineNum">     315 </span><span class="lineCov">      39328 :         if ( nextpd != NULL ) {</span>
<span class="lineNum">     316 </span><span class="lineCov">      13814 :             nextpd-&gt;prevunit.x = -pd-&gt;nextunit.x;</span>
<span class="lineNum">     317 </span><span class="lineCov">      13814 :             nextpd-&gt;prevunit.y = -pd-&gt;nextunit.y;</span>
<span class="lineNum">     318 </span>            :         }
<span class="lineNum">     319 </span>            :     }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineCov">      39497 :     if ( sp-&gt;prev==NULL ) {</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         pd-&gt;prevunit.x = ss-&gt;last-&gt;me.x - sp-&gt;me.x;</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :         pd-&gt;prevunit.y = ss-&gt;last-&gt;me.y - sp-&gt;me.y;</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         pd-&gt;prevlinear = true;</span>
<span class="lineNum">     325 </span><span class="lineCov">      39497 :     } else if ( sp-&gt;prev-&gt;knownlinear ) {</span>
<span class="lineNum">     326 </span><span class="lineCov">      14385 :         pd-&gt;prevunit.x = sp-&gt;prev-&gt;from-&gt;me.x - sp-&gt;me.x;</span>
<span class="lineNum">     327 </span><span class="lineCov">      14385 :         pd-&gt;prevunit.y = sp-&gt;prev-&gt;from-&gt;me.y - sp-&gt;me.y;</span>
<span class="lineNum">     328 </span><span class="lineCov">      14385 :         pd-&gt;prevlinear = true;</span>
<span class="lineNum">     329 </span><span class="lineCov">      25112 :     } else if ( sp-&gt;noprevcp ) {</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :         pd-&gt;prevunit.x = sp-&gt;prev-&gt;from-&gt;nextcp.x - sp-&gt;me.x;</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :         pd-&gt;prevunit.y = sp-&gt;prev-&gt;from-&gt;nextcp.y - sp-&gt;me.y;</span>
<span class="lineNum">     332 </span>            :     } else {
<span class="lineNum">     333 </span><span class="lineCov">      25112 :         pd-&gt;prevunit.x = sp-&gt;prevcp.x - sp-&gt;me.x;</span>
<span class="lineNum">     334 </span><span class="lineCov">      25112 :         pd-&gt;prevunit.y = sp-&gt;prevcp.y - sp-&gt;me.y;</span>
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span><span class="lineCov">      39497 :     len = sqrt( pow( pd-&gt;prevunit.x,2 ) + pow( pd-&gt;prevunit.y,2 ));</span>
<span class="lineNum">     337 </span><span class="lineCov">      39497 :     if ( len==0 )</span>
<span class="lineNum">     338 </span><span class="lineCov">        147 :         pd-&gt;prevzero = true;</span>
<span class="lineNum">     339 </span>            :     else {
<span class="lineNum">     340 </span><span class="lineCov">      39350 :         pd-&gt;prevlen = len;</span>
<span class="lineNum">     341 </span><span class="lineCov">      39350 :         pd-&gt;prevunit.x /= len;</span>
<span class="lineNum">     342 </span><span class="lineCov">      39350 :         pd-&gt;prevunit.y /= len;</span>
<span class="lineNum">     343 </span><span class="lineCov">      39350 :         if ( sp-&gt;prev!=NULL &amp;&amp; !sp-&gt;prev-&gt;knownlinear )</span>
<span class="lineNum">     344 </span><span class="lineCov">      24965 :             SplineFigureOpticalSlope(sp-&gt;prev,false,&amp;pd-&gt;prevunit);</span>
<span class="lineNum">     345 </span><span class="lineCov">      39350 :         hv = IsUnitHV( &amp;pd-&gt;prevunit,true );</span>
<span class="lineNum">     346 </span><span class="lineCov">      39350 :         if ( hv == 2 ) {</span>
<span class="lineNum">     347 </span><span class="lineCov">       9416 :             pd-&gt;prevunit.x = 0; pd-&gt;prevunit.y = pd-&gt;prevunit.y&gt;0 ? 1 : -1;</span>
<span class="lineNum">     348 </span><span class="lineCov">      29934 :         } else if ( hv == 1 ) {</span>
<span class="lineNum">     349 </span><span class="lineCov">      10656 :             pd-&gt;prevunit.y = 0; pd-&gt;prevunit.x = pd-&gt;prevunit.x&gt;0 ? 1 : -1;</span>
<span class="lineNum">     350 </span>            :         }
<span class="lineNum">     351 </span><span class="lineCov">      39350 :         if ( pd-&gt;prevunit.y==0 ) pd-&gt;prev_hor = true;</span>
<span class="lineNum">     352 </span><span class="lineCov">      28694 :         else if ( pd-&gt;prevunit.x==0 ) pd-&gt;prev_ver = true;</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineCov">      39350 :         if ( prevpd != NULL ) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :             prevpd-&gt;nextunit.x = -pd-&gt;prevunit.x;</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :             prevpd-&gt;nextunit.y = -pd-&gt;prevunit.y;</span>
<span class="lineNum">     357 </span>            :         }
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span>            :     {
<span class="lineNum">     360 </span><span class="lineCov">      39497 :         same = pd-&gt;prevunit.x*pd-&gt;nextunit.x + pd-&gt;prevunit.y*pd-&gt;nextunit.y;</span>
<span class="lineNum">     361 </span><span class="lineCov">      39497 :         if ( same&lt;-.95 )</span>
<span class="lineNum">     362 </span><span class="lineCov">      22974 :             pd-&gt;colinear = true;</span>
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span><span class="lineCov">      39497 :     if (( pd-&gt;prev_hor || pd-&gt;next_hor ) &amp;&amp; pd-&gt;colinear ) {</span>
<span class="lineNum">     365 </span><span class="lineCov">      12206 :         if ( IsSplinePeak( gd,pd,false,false,1 )) pd-&gt;y_extr = 1;</span>
<span class="lineNum">     366 </span><span class="lineCov">       4501 :         else if ( IsSplinePeak( gd,pd,true,false,1 )) pd-&gt;y_extr = 2;</span>
<span class="lineNum">     367 </span><span class="lineCov">      33394 :     } else if (( pd-&gt;prev_ver || pd-&gt;next_ver ) &amp;&amp; pd-&gt;colinear ) {</span>
<span class="lineNum">     368 </span><span class="lineCov">      11284 :         if ( IsSplinePeak( gd,pd,true,true,1 )) pd-&gt;x_extr = 1;</span>
<span class="lineNum">     369 </span><span class="lineCov">       3871 :         else if ( IsSplinePeak( gd,pd,false,true,1 )) pd-&gt;x_extr = 2;</span>
<span class="lineNum">     370 </span>            :     } else {
<span class="lineNum">     371 </span><span class="lineCov">      27752 :         if (( pd-&gt;nextunit.y &lt; 0 &amp;&amp; pd-&gt;prevunit.y &lt; 0 ) || ( pd-&gt;nextunit.y &gt; 0 &amp;&amp; pd-&gt;prevunit.y &gt; 0 )) {</span>
<span class="lineNum">     372 </span><span class="lineCov">       2928 :             if ( IsSplinePeak( gd,pd,false,false,2 )) pd-&gt;y_corner = 1;</span>
<span class="lineNum">     373 </span><span class="lineCov">       1743 :             else if ( IsSplinePeak( gd,pd,true,false,2 )) pd-&gt;y_corner = 2;</span>
<span class="lineNum">     374 </span>            :         }
<span class="lineNum">     375 </span><span class="lineCov">      27752 :         if (( pd-&gt;nextunit.x &lt; 0 &amp;&amp; pd-&gt;prevunit.x &lt; 0 ) || ( pd-&gt;nextunit.x &gt; 0 &amp;&amp; pd-&gt;prevunit.x &gt; 0 )) {</span>
<span class="lineNum">     376 </span><span class="lineCov">       3329 :             if ( IsSplinePeak( gd,pd,true,true,2 )) pd-&gt;x_corner = 1;</span>
<span class="lineNum">     377 </span><span class="lineCov">       1716 :             else if ( IsSplinePeak( gd,pd,false,true,2 )) pd-&gt;x_corner = 2;</span>
<span class="lineNum">     378 </span>            :         }
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span><span class="lineCov">      39497 :     if ( hint_diagonal_intersections ) {</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :         if (( pd-&gt;y_corner || pd-&gt;y_extr ) &amp;&amp; </span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :             RealNear( pd-&gt;nextunit.x,-pd-&gt;prevunit.x ) &amp;&amp;</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :             RealNear( pd-&gt;nextunit.y,pd-&gt;prevunit.y ) &amp;&amp; !pd-&gt;nextzero)</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :             pd-&gt;symetrical_h = true;</span>
<span class="lineNum">     385 </span><span class="lineNoCov">          0 :         else if (( pd-&gt;x_corner || pd-&gt;x_extr ) &amp;&amp;</span>
<span class="lineNum">     386 </span><span class="lineNoCov">          0 :             RealNear( pd-&gt;nextunit.y,-pd-&gt;prevunit.y ) &amp;&amp;</span>
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :             RealNear( pd-&gt;nextunit.x,pd-&gt;prevunit.x ) &amp;&amp; !pd-&gt;nextzero)</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :             pd-&gt;symetrical_v = true;</span>
<span class="lineNum">     389 </span>            :     }
<a name="390"><span class="lineNum">     390 </span>            : }</a>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineCov">    7996380 : static int BBoxIntersectsLine(Spline *s,Spline *line) {</span>
<span class="lineNum">     393 </span>            :     double t,x,y;
<span class="lineNum">     394 </span>            :     DBounds b;
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span><span class="lineCov">    7996380 :     b.minx = b.maxx = s-&gt;from-&gt;me.x;</span>
<span class="lineNum">     397 </span><span class="lineCov">    7996380 :     b.miny = b.maxy = s-&gt;from-&gt;me.y;</span>
<span class="lineNum">     398 </span><span class="lineCov">    7996380 :     if ( s-&gt;to-&gt;me.x&lt;b.minx ) b.minx = s-&gt;to-&gt;me.x;</span>
<span class="lineNum">     399 </span><span class="lineCov">    4218794 :     else if ( s-&gt;to-&gt;me.x&gt;b.maxx ) b.maxx = s-&gt;to-&gt;me.x;</span>
<span class="lineNum">     400 </span><span class="lineCov">    7996380 :     if ( s-&gt;to-&gt;me.y&lt;b.miny ) b.miny = s-&gt;to-&gt;me.y;</span>
<span class="lineNum">     401 </span><span class="lineCov">    4366549 :     else if ( s-&gt;to-&gt;me.y&gt;b.maxy ) b.maxy = s-&gt;to-&gt;me.y;</span>
<span class="lineNum">     402 </span><span class="lineCov">    7996380 :     if ( s-&gt;to-&gt;prevcp.x&lt;b.minx ) b.minx = s-&gt;to-&gt;prevcp.x;</span>
<span class="lineNum">     403 </span><span class="lineCov">    7779339 :     else if ( s-&gt;to-&gt;prevcp.x&gt;b.maxx ) b.maxx = s-&gt;to-&gt;prevcp.x;</span>
<span class="lineNum">     404 </span><span class="lineCov">    7996380 :     if ( s-&gt;to-&gt;prevcp.y&lt;b.miny ) b.miny = s-&gt;to-&gt;prevcp.y;</span>
<span class="lineNum">     405 </span><span class="lineCov">    7756286 :     else if ( s-&gt;to-&gt;prevcp.y&gt;b.maxy ) b.maxy = s-&gt;to-&gt;prevcp.y;</span>
<span class="lineNum">     406 </span><span class="lineCov">    7996380 :     if ( s-&gt;from-&gt;nextcp.x&lt;b.minx ) b.minx = s-&gt;from-&gt;nextcp.x;</span>
<span class="lineNum">     407 </span><span class="lineCov">    7935790 :     else if ( s-&gt;from-&gt;nextcp.x&gt;b.maxx ) b.maxx = s-&gt;from-&gt;nextcp.x;</span>
<span class="lineNum">     408 </span><span class="lineCov">    7996380 :     if ( s-&gt;from-&gt;nextcp.y&lt;b.miny ) b.miny = s-&gt;from-&gt;nextcp.y;</span>
<span class="lineNum">     409 </span><span class="lineCov">    7918919 :     else if ( s-&gt;from-&gt;nextcp.y&gt;b.maxy ) b.maxy = s-&gt;from-&gt;nextcp.y;</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineCov">    7996380 :     if ( line-&gt;splines[0].c!=0 ) {</span>
<span class="lineNum">     412 </span><span class="lineCov">    5807927 :         t = (b.minx-line-&gt;splines[0].d)/line-&gt;splines[0].c;</span>
<span class="lineNum">     413 </span><span class="lineCov">    5807927 :         y = line-&gt;splines[1].c*t+line-&gt;splines[1].d;</span>
<span class="lineNum">     414 </span><span class="lineCov">    5807927 :         if ( y&gt;=b.miny &amp;&amp; y&lt;=b.maxy )</span>
<span class="lineNum">     415 </span><span class="lineCov">     468977 : return( true );</span>
<span class="lineNum">     416 </span><span class="lineCov">    5338950 :         t = (b.maxx-line-&gt;splines[0].d)/line-&gt;splines[0].c;</span>
<span class="lineNum">     417 </span><span class="lineCov">    5338950 :         y = line-&gt;splines[1].c*t+line-&gt;splines[1].d;</span>
<span class="lineNum">     418 </span><span class="lineCov">    5338950 :         if ( y&gt;=b.miny &amp;&amp; y&lt;=b.maxy )</span>
<span class="lineNum">     419 </span><span class="lineCov">     121647 : return( true );</span>
<span class="lineNum">     420 </span>            :     }
<span class="lineNum">     421 </span><span class="lineCov">    7405756 :     if ( line-&gt;splines[1].c!=0 ) {</span>
<span class="lineNum">     422 </span><span class="lineCov">    5863485 :         t = (b.miny-line-&gt;splines[1].d)/line-&gt;splines[1].c;</span>
<span class="lineNum">     423 </span><span class="lineCov">    5863485 :         x = line-&gt;splines[0].c*t+line-&gt;splines[0].d;</span>
<span class="lineNum">     424 </span><span class="lineCov">    5863485 :         if ( x&gt;=b.minx &amp;&amp; x&lt;=b.maxx )</span>
<span class="lineNum">     425 </span><span class="lineCov">     397331 : return( true );</span>
<span class="lineNum">     426 </span><span class="lineCov">    5466154 :         t = (b.maxy-line-&gt;splines[1].d)/line-&gt;splines[1].c;</span>
<span class="lineNum">     427 </span><span class="lineCov">    5466154 :         x = line-&gt;splines[0].c*t+line-&gt;splines[0].d;</span>
<span class="lineNum">     428 </span><span class="lineCov">    5466154 :         if ( x&gt;=b.minx &amp;&amp; x&lt;=b.maxx )</span>
<span class="lineNum">     429 </span><span class="lineCov">          8 : return( true );</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span><span class="lineCov">    7008417 : return( false );</span>
<a name="432"><span class="lineNum">     432 </span>            : }</a>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">    1242823 : static int stcmp(const void *_p1, const void *_p2) {</span>
<span class="lineNum">     435 </span><span class="lineCov">    1242823 :     const struct st *stpt1 = _p1, *stpt2 = _p2;</span>
<span class="lineNum">     436 </span><span class="lineCov">    1242823 :     if ( stpt1-&gt;lt&gt;stpt2-&gt;lt )</span>
<span class="lineNum">     437 </span><span class="lineCov">     638665 : return( 1 );</span>
<span class="lineNum">     438 </span><span class="lineCov">     604158 :     else if ( stpt1-&gt;lt&lt;stpt2-&gt;lt )</span>
<span class="lineNum">     439 </span><span class="lineCov">     603382 : return( -1 );</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">        776 : return( 0 );</span>
<a name="442"><span class="lineNum">     442 </span>            : }</a>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">      17911 : static int line_pt_cmp( const void *_p1, const void *_p2 ) {</span>
<span class="lineNum">     445 </span><span class="lineCov">      17911 :     struct pointdata * const *pd1 = _p1, * const *pd2 = _p2;</span>
<span class="lineNum">     446 </span>            :     struct linedata *line;
<span class="lineNum">     447 </span><span class="lineCov">      17911 :     double ppos1=0,ppos2=0;</span>
<span class="lineNum">     448 </span>            :     
<span class="lineNum">     449 </span><span class="lineCov">      31265 :     if ( (*pd1)-&gt;prevline != NULL &amp;&amp; </span>
<span class="lineNum">     450 </span><span class="lineCov">      21629 :         ( (*pd1)-&gt;prevline == (*pd2)-&gt;prevline || (*pd1)-&gt;prevline == (*pd2)-&gt;nextline ))</span>
<span class="lineNum">     451 </span><span class="lineCov">       8015 :         line = (*pd1)-&gt;prevline;</span>
<span class="lineNum">     452 </span><span class="lineCov">      19792 :     else if ( (*pd1)-&gt;nextline != NULL &amp;&amp; </span>
<span class="lineNum">     453 </span><span class="lineCov">      10750 :         ( (*pd1)-&gt;nextline == (*pd2)-&gt;prevline || (*pd1)-&gt;nextline == (*pd2)-&gt;nextline ))</span>
<span class="lineNum">     454 </span><span class="lineCov">       9896 :         line = (*pd1)-&gt;nextline;</span>
<span class="lineNum">     455 </span>            :     else
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span><span class="lineCov">      35822 :     ppos1 = ( (*pd1)-&gt;sp-&gt;me.x - line-&gt;online.x ) * line-&gt;unit.x +</span>
<span class="lineNum">     459 </span><span class="lineCov">      17911 :             ( (*pd1)-&gt;sp-&gt;me.y - line-&gt;online.y ) * line-&gt;unit.y;</span>
<span class="lineNum">     460 </span><span class="lineCov">      35822 :     ppos2 = ( (*pd2)-&gt;sp-&gt;me.x - line-&gt;online.x ) * line-&gt;unit.x +</span>
<span class="lineNum">     461 </span><span class="lineCov">      17911 :             ( (*pd2)-&gt;sp-&gt;me.y - line-&gt;online.y ) * line-&gt;unit.y;</span>
<span class="lineNum">     462 </span>            :         
<span class="lineNum">     463 </span><span class="lineCov">      17911 :     if ( ppos1&gt;ppos2 )</span>
<span class="lineNum">     464 </span><span class="lineCov">       9580 : return( 1 );</span>
<span class="lineNum">     465 </span><span class="lineCov">       8331 :     else if ( ppos1&lt;ppos2 )</span>
<span class="lineNum">     466 </span><span class="lineCov">       8324 : return( -1 );</span>
<span class="lineNum">     467 </span>            :     else
<span class="lineNum">     468 </span><span class="lineCov">          7 : return( 0 );</span>
<a name="469"><span class="lineNum">     469 </span>            : }</a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">      22087 : static int segment_cmp(const void *_s1, const void *_s2) {</span>
<span class="lineNum">     472 </span><span class="lineCov">      22087 :     const struct segment *s1 = _s1, *s2 = _s2;</span>
<span class="lineNum">     473 </span><span class="lineCov">      22087 :     if ( s1-&gt;start&lt;s2-&gt;start )</span>
<span class="lineNum">     474 </span><span class="lineCov">      11463 : return( -1 );</span>
<span class="lineNum">     475 </span><span class="lineCov">      10624 :     else if ( s1-&gt;start&gt;s2-&gt;start )</span>
<span class="lineNum">     476 </span><span class="lineCov">        583 : return( 1 );</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">      10041 : return( 0 );</span>
<a name="479"><span class="lineNum">     479 </span>            : }</a>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">      48041 : static int proj_cmp(const void *_p1, const void *_p2) {</span>
<span class="lineNum">     482 </span><span class="lineCov">      48041 :     struct pointdata * const *p1 = _p1, * const *p2 = _p2;</span>
<span class="lineNum">     483 </span><span class="lineCov">      48041 :     if ( (*p1)-&gt;projection&lt;(*p2)-&gt;projection )</span>
<span class="lineNum">     484 </span><span class="lineCov">      15647 : return( -1 );</span>
<span class="lineNum">     485 </span><span class="lineCov">      32394 :     else if ( (*p1)-&gt;projection&gt;(*p2)-&gt;projection )</span>
<span class="lineNum">     486 </span><span class="lineCov">      21502 : return( 1 );</span>
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span><span class="lineCov">      10892 : return( 0 );</span>
<a name="489"><span class="lineNum">     489 </span>            : }</a>
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span><span class="lineCov">     180695 : static void AssignStemToPoint( struct pointdata *pd,struct stemdata *stem,int is_next, int left ) {</span>
<span class="lineNum">     492 </span>            :     struct stemdata ***stems;
<span class="lineNum">     493 </span>            :     int i, *stemcnt, **is_l;
<span class="lineNum">     494 </span>            :     
<span class="lineNum">     495 </span><span class="lineCov">     180695 :     stems = ( is_next ) ? &amp;pd-&gt;nextstems : &amp;pd-&gt;prevstems;</span>
<span class="lineNum">     496 </span><span class="lineCov">     180695 :     stemcnt = ( is_next ) ? &amp;pd-&gt;nextcnt : &amp;pd-&gt;prevcnt;</span>
<span class="lineNum">     497 </span><span class="lineCov">     180695 :     is_l = ( is_next ) ? &amp;pd-&gt;next_is_l : &amp;pd-&gt;prev_is_l;</span>
<span class="lineNum">     498 </span><span class="lineCov">     203448 :     for ( i=0; i&lt;*stemcnt; i++ ) {</span>
<span class="lineNum">     499 </span><span class="lineCov">     126158 :         if ((*stems)[i] == stem )</span>
<span class="lineNum">     500 </span><span class="lineCov">     284100 : return;</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span>            :     
<span class="lineNum">     503 </span><span class="lineCov">      77290 :     *stems = realloc( *stems,( *stemcnt+1 )*sizeof( struct stemdata *));</span>
<span class="lineNum">     504 </span><span class="lineCov">      77290 :     *is_l  = realloc( *is_l, ( *stemcnt+1 )*sizeof( int ));</span>
<span class="lineNum">     505 </span><span class="lineCov">      77290 :     (*stems)[*stemcnt] = stem;</span>
<span class="lineNum">     506 </span><span class="lineCov">      77290 :     (*is_l )[*stemcnt] = left;</span>
<span class="lineNum">     507 </span><span class="lineCov">      77290 :     (*stemcnt)++;</span>
<a name="508"><span class="lineNum">     508 </span>            : }</a>
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span><span class="lineCov">     194328 : int IsStemAssignedToPoint( struct pointdata *pd,struct stemdata *stem,int is_next ) {</span>
<span class="lineNum">     511 </span>            :     struct stemdata **stems;
<span class="lineNum">     512 </span>            :     int i, stemcnt;
<span class="lineNum">     513 </span>            :     
<span class="lineNum">     514 </span><span class="lineCov">     194328 :     stems = ( is_next ) ? pd-&gt;nextstems : pd-&gt;prevstems;</span>
<span class="lineNum">     515 </span><span class="lineCov">     194328 :     stemcnt = ( is_next ) ? pd-&gt;nextcnt : pd-&gt;prevcnt;</span>
<span class="lineNum">     516 </span>            :     
<span class="lineNum">     517 </span><span class="lineCov">     292117 :     for ( i=0; i&lt;stemcnt; i++ ) {</span>
<span class="lineNum">     518 </span><span class="lineCov">     206401 :         if ( stems[i] == stem )</span>
<span class="lineNum">     519 </span><span class="lineCov">     108612 : return( i );</span>
<span class="lineNum">     520 </span>            :     }
<span class="lineNum">     521 </span><span class="lineCov">      85716 : return( -1 );</span>
<a name="522"><span class="lineNum">     522 </span>            : }</a>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">      51853 : static int GetValidPointDataIndex( struct glyphdata *gd,SplinePoint *sp,</span>
<span class="lineNum">     525 </span>            :     struct stemdata *stem ) {
<span class="lineNum">     526 </span>            :     
<span class="lineNum">     527 </span>            :     struct pointdata *tpd;
<span class="lineNum">     528 </span>            :     
<span class="lineNum">     529 </span><span class="lineCov">      51853 :     if ( sp == NULL )</span>
<span class="lineNum">     530 </span><span class="lineNoCov">          0 : return( -1 );</span>
<span class="lineNum">     531 </span><span class="lineCov">      51853 :     if ( sp-&gt;ttfindex &lt; gd-&gt;realcnt )</span>
<span class="lineNum">     532 </span><span class="lineCov">      50129 : return( sp-&gt;ttfindex );</span>
<span class="lineNum">     533 </span><span class="lineCov">       1724 :     if ( !sp-&gt;nonextcp &amp;&amp; sp-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">     534 </span><span class="lineCov">       1419 :         tpd = &amp;gd-&gt;points[sp-&gt;nextcpindex];</span>
<span class="lineNum">     535 </span><span class="lineCov">       1419 :         if ( IsStemAssignedToPoint( tpd,stem,false ) != -1 )</span>
<span class="lineNum">     536 </span><span class="lineCov">       1317 : return( sp-&gt;nextcpindex );</span>
<span class="lineNum">     537 </span>            :     }
<span class="lineNum">     538 </span><span class="lineCov">        559 :     if ( !sp-&gt;noprevcp &amp;&amp; sp-&gt;prev != NULL &amp;&amp; </span>
<span class="lineNum">     539 </span><span class="lineCov">        152 :         sp-&gt;prev-&gt;from-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">     540 </span><span class="lineCov">        102 :         tpd = &amp;gd-&gt;points[sp-&gt;prev-&gt;from-&gt;nextcpindex];</span>
<span class="lineNum">     541 </span><span class="lineCov">        102 :         if ( IsStemAssignedToPoint( tpd,stem,true ) != -1 )</span>
<span class="lineNum">     542 </span><span class="lineCov">         23 : return( sp-&gt;prev-&gt;from-&gt;nextcpindex );</span>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span><span class="lineCov">        384 : return( -1 );</span>
<a name="545"><span class="lineNum">     545 </span>            : }</a>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span><span class="lineCov">     385001 : static int LineType(struct st *st,int i, int cnt,Spline *line) {</span>
<span class="lineNum">     548 </span>            :     SplinePoint *sp;
<span class="lineNum">     549 </span>            :     BasePoint nextcp, prevcp, here;
<span class="lineNum">     550 </span>            :     double dn, dp;
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineCov">     385001 :     if ( st[i].st&gt;.01 &amp;&amp; st[i].st&lt;.99 )</span>
<span class="lineNum">     553 </span><span class="lineCov">     372418 : return( 0 );            /* Not near an end-point, just a normal line */</span>
<span class="lineNum">     554 </span><span class="lineCov">      12583 :     if ( i+1&gt;=cnt )</span>
<span class="lineNum">     555 </span><span class="lineCov">       2409 : return( 0 );            /* No following spline */</span>
<span class="lineNum">     556 </span><span class="lineCov">      10174 :     if ( st[i+1].st&gt;.01 &amp;&amp; st[i+1].st&lt;.99 )</span>
<span class="lineNum">     557 </span><span class="lineCov">       7061 : return( 0 );            /* Following spline not near an end-point, can't */</span>
<span class="lineNum">     558 </span>            :                         /*  match to this one, just a normal line */
<span class="lineNum">     559 </span><span class="lineCov">       3113 :     if ( st[i].st&lt;.5 &amp;&amp; st[i+1].st&gt;.5 ) {</span>
<span class="lineNum">     560 </span><span class="lineCov">       1412 :         if ( st[i+1].s-&gt;to-&gt;next!=st[i].s )</span>
<span class="lineNum">     561 </span><span class="lineCov">       1058 : return( 0 );</span>
<span class="lineNum">     562 </span><span class="lineCov">        354 :         sp = st[i].s-&gt;from;</span>
<span class="lineNum">     563 </span><span class="lineCov">       1701 :     } else if ( st[i].st&gt;.5 &amp;&amp; st[i+1].st&lt;.5 ) {</span>
<span class="lineNum">     564 </span><span class="lineCov">       1556 :         if ( st[i].s-&gt;to-&gt;next!=st[i+1].s )</span>
<span class="lineNum">     565 </span><span class="lineCov">       1054 : return( 0 );</span>
<span class="lineNum">     566 </span><span class="lineCov">        502 :         sp = st[i].s-&gt;to;</span>
<span class="lineNum">     567 </span>            :     } else
<span class="lineNum">     568 </span><span class="lineCov">        145 : return( 0 );</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">        856 :     if ( !sp-&gt;nonextcp )</span>
<span class="lineNum">     571 </span><span class="lineCov">        476 :         nextcp = sp-&gt;nextcp;</span>
<span class="lineNum">     572 </span>            :     else
<span class="lineNum">     573 </span><span class="lineCov">        380 :         nextcp = sp-&gt;next-&gt;to-&gt;me;</span>
<span class="lineNum">     574 </span><span class="lineCov">        856 :     if ( !sp-&gt;noprevcp )</span>
<span class="lineNum">     575 </span><span class="lineCov">        487 :         prevcp = sp-&gt;prevcp;</span>
<span class="lineNum">     576 </span>            :     else
<span class="lineNum">     577 </span><span class="lineCov">        369 :         prevcp = sp-&gt;prev-&gt;from-&gt;me;</span>
<span class="lineNum">     578 </span><span class="lineCov">        856 :     here.x = line-&gt;splines[0].c*(st[i].st+st[i+1].st)/2 + line-&gt;splines[0].d;</span>
<span class="lineNum">     579 </span><span class="lineCov">        856 :     here.y = line-&gt;splines[1].c*(st[i].st+st[i+1].st)/2 + line-&gt;splines[1].d;</span>
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span><span class="lineCov">        856 :     nextcp.x -= here.x; nextcp.y -= here.y;</span>
<span class="lineNum">     582 </span><span class="lineCov">        856 :     prevcp.x -= here.x; prevcp.y -= here.y;</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov">        856 :     dn = nextcp.x*line-&gt;splines[1].c - nextcp.y*line-&gt;splines[0].c;</span>
<span class="lineNum">     585 </span><span class="lineCov">        856 :     dp = prevcp.x*line-&gt;splines[1].c - prevcp.y*line-&gt;splines[0].c;</span>
<span class="lineNum">     586 </span><span class="lineCov">        856 :     if ( dn*dp&lt;0 )   /* splines away move on opposite sides of the line */</span>
<span class="lineNum">     587 </span><span class="lineCov">        117 : return( 1 );            /* Treat this line and the next as one */</span>
<span class="lineNum">     588 </span>            :                         /* We assume that a rounding error gave us one erroneous intersection (or we went directly through the endpoint) */
<span class="lineNum">     589 </span>            :     else
<span class="lineNum">     590 </span><span class="lineCov">        739 : return( 2 );            /* Ignore both this line and the next */</span>
<span class="lineNum">     591 </span>            :                         /* Intersects both in a normal fashion */
<a name="592"><span class="lineNum">     592 </span>            : }</a>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">     209066 : static int MonotonicOrder(Spline **sspace,Spline *line,struct st *stspace) {</span>
<span class="lineNum">     595 </span>            :     Spline *s;
<span class="lineNum">     596 </span>            :     int i,j,k,cnt;
<span class="lineNum">     597 </span>            :     BasePoint pts[9];
<span class="lineNum">     598 </span>            :     extended lts[10], sts[10];
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineCov">    8205446 :     for ( i=j=0; (s=sspace[j])!=NULL; ++j ) {</span>
<span class="lineNum">     601 </span><span class="lineCov">    7996380 :         if ( BBoxIntersectsLine(s,line) ) {</span>
<span class="lineNum">     602 </span>            :             /* Lines parallel to the direction we are testing just get in the */
<span class="lineNum">     603 </span>            :             /*  way and don't add any useful info */
<span class="lineNum">     604 </span><span class="lineCov">    1164712 :             if ( s-&gt;islinear &amp;&amp;</span>
<span class="lineNum">     605 </span><span class="lineCov">     176749 :                     RealNear(line-&gt;splines[0].c*s-&gt;splines[1].c,</span>
<span class="lineNum">     606 </span><span class="lineCov">     176749 :                             line-&gt;splines[1].c*s-&gt;splines[0].c))</span>
<span class="lineNum">     607 </span><span class="lineCov">       2444 :     continue;</span>
<span class="lineNum">     608 </span><span class="lineCov">     985519 :             if ( SplinesIntersect(line,s,pts,lts,sts)&lt;=0 )</span>
<span class="lineNum">     609 </span><span class="lineCov">      81623 :     continue;</span>
<span class="lineNum">     610 </span><span class="lineCov">    1814917 :             for ( k=0; sts[k]!=-1; ++k ) {</span>
<span class="lineNum">     611 </span><span class="lineCov">     911021 :                 if ( sts[k]&gt;=0 &amp;&amp; sts[k]&lt;=1 ) {</span>
<span class="lineNum">     612 </span><span class="lineCov">     911021 :                     stspace[i].s    = s;</span>
<span class="lineNum">     613 </span><span class="lineCov">     911021 :                     stspace[i].lt   = lts[k];</span>
<span class="lineNum">     614 </span><span class="lineCov">     911021 :                     stspace[i++].st = sts[k];</span>
<span class="lineNum">     615 </span>            :                 }
<span class="lineNum">     616 </span>            :             }
<span class="lineNum">     617 </span>            :         }
<span class="lineNum">     618 </span>            :     }
<span class="lineNum">     619 </span><span class="lineCov">     209066 :     stspace[i].s = NULL;</span>
<span class="lineNum">     620 </span><span class="lineCov">     209066 :     cnt = i;</span>
<span class="lineNum">     621 </span><span class="lineCov">     209066 :     qsort(stspace,cnt,sizeof(struct st),stcmp);</span>
<span class="lineNum">     622 </span><span class="lineCov">     209066 : return( cnt );</span>
<a name="623"><span class="lineNum">     623 </span>            : }</a>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineCov">      27798 : static Spline *MonotonicFindAlong(Spline *line,struct st *stspace,int cnt,</span>
<span class="lineNum">     626 </span>            :         Spline *findme, double *other_t) {
<span class="lineNum">     627 </span>            :     Spline *s;
<span class="lineNum">     628 </span>            :     int i;
<span class="lineNum">     629 </span>            :     int eo;             /* I do horizontal/vertical by winding number */
<span class="lineNum">     630 </span>            :                         /* But figuring winding number with respect to a */
<span class="lineNum">     631 </span>            :                         /* diagonal line is hard. So I use even-odd */
<span class="lineNum">     632 </span>            :                         /* instead. */
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineCov">      27798 :     eo = 0;</span>
<span class="lineNum">     635 </span><span class="lineCov">      75202 :     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     636 </span><span class="lineCov">      75202 :         s = stspace[i].s;</span>
<span class="lineNum">     637 </span><span class="lineCov">      75202 :         if ( s==findme ) {</span>
<span class="lineNum">     638 </span><span class="lineCov">      27798 :             if ( (eo&amp;1) &amp;&amp; i&gt;0 ) {</span>
<span class="lineNum">     639 </span><span class="lineCov">      14008 :                 *other_t = stspace[i-1].st;</span>
<span class="lineNum">     640 </span><span class="lineCov">      14008 : return( stspace[i-1].s );</span>
<span class="lineNum">     641 </span><span class="lineCov">      13790 :             } else if ( !(eo&amp;1) &amp;&amp; i+1&lt;cnt ) {</span>
<span class="lineNum">     642 </span><span class="lineCov">      13790 :                 *other_t = stspace[i+1].st;</span>
<span class="lineNum">     643 </span><span class="lineCov">      13790 : return( stspace[i+1].s );</span>
<span class="lineNum">     644 </span>            :             }
<span class="lineNum">     645 </span><span class="lineNoCov">          0 :             fprintf( stderr, &quot;MonotonicFindAlong: Ran out of intersections.\n&quot; );</span>
<span class="lineNum">     646 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     647 </span>            :         }
<span class="lineNum">     648 </span><span class="lineCov">      47404 :         if ( i+1&lt;cnt &amp;&amp; stspace[i+1].s==findme )</span>
<span class="lineNum">     649 </span><span class="lineCov">      20045 :             ++eo;</span>
<span class="lineNum">     650 </span><span class="lineCov">      27359 :         else switch ( LineType(stspace,i,cnt,line) ) {</span>
<span class="lineNum">     651 </span>            :           case 0:       /* Normal spline */
<span class="lineNum">     652 </span><span class="lineCov">      27329 :             ++eo;</span>
<span class="lineNum">     653 </span><span class="lineCov">      27329 :           break;</span>
<span class="lineNum">     654 </span>            :           case 1:       /* Intersects at end-point &amp; next entry is other side */
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :             ++eo;       /*  And the two sides continue in approximately the   */</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :             ++i;        /*  same direction */</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     658 </span>            :           case 2:       /* Intersects at end-point &amp; next entry is other side */
<span class="lineNum">     659 </span><span class="lineCov">         30 :             ++i;        /*  And the two sides go in opposite directions */</span>
<span class="lineNum">     660 </span><span class="lineCov">         30 :           break;</span>
<span class="lineNum">     661 </span>            :           default:
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     663 </span>            : }
<span class="lineNum">     664 </span>            :     }
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :     fprintf( stderr, &quot;MonotonicFindAlong: Never found our spline.\n&quot; );</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 : return( NULL );</span>
<a name="667"><span class="lineNum">     667 </span>            : }</a>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineCov">     157981 : static int MonotonicFindStemBounds(Spline *line,struct st *stspace,int cnt,</span>
<span class="lineNum">     670 </span>            :         double fudge,struct stemdata *stem ) {
<span class="lineNum">     671 </span>            :     int i,j;
<span class="lineNum">     672 </span>            :     int eo;             /* I do horizontal/vertical by winding number */
<span class="lineNum">     673 </span>            :                         /* But figuring winding number with respect to a */
<span class="lineNum">     674 </span>            :                         /* diagonal line is hard. So I use even-odd */
<span class="lineNum">     675 </span>            :                         /* instead. */
<span class="lineNum">     676 </span>            :     double pos, npos;
<span class="lineNum">     677 </span><span class="lineCov">     157981 :     double lmin = ( stem-&gt;lmin &lt; -fudge ) ? stem-&gt;lmin : -fudge;</span>
<span class="lineNum">     678 </span><span class="lineCov">     157981 :     double lmax = ( stem-&gt;lmax &gt; fudge ) ? stem-&gt;lmax : fudge;</span>
<span class="lineNum">     679 </span><span class="lineCov">     157981 :     double rmin = ( stem-&gt;rmin &lt; -fudge ) ? stem-&gt;rmin : -fudge;</span>
<span class="lineNum">     680 </span><span class="lineCov">     157981 :     double rmax = ( stem-&gt;rmax &gt; fudge ) ? stem-&gt;rmax : fudge;</span>
<span class="lineNum">     681 </span><span class="lineCov">     157981 :     lmin -= .0001; lmax += .0001; rmin -= .0001; rmax += .0001;</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineCov">     157981 :     eo = 0;</span>
<span class="lineNum">     684 </span><span class="lineCov">     614787 :     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     685 </span><span class="lineCov">    1093564 :         pos =   (line-&gt;splines[0].c*stspace[i].lt + line-&gt;splines[0].d - stem-&gt;left.x)*stem-&gt;l_to_r.x +</span>
<span class="lineNum">     686 </span><span class="lineCov">     546782 :                 (line-&gt;splines[1].c*stspace[i].lt + line-&gt;splines[1].d - stem-&gt;left.y)*stem-&gt;l_to_r.y;</span>
<span class="lineNum">     687 </span><span class="lineCov">     546782 :         npos = 1e4;</span>
<span class="lineNum">     688 </span><span class="lineCov">     546782 :         if ( i+1&lt;cnt )</span>
<span class="lineNum">     689 </span><span class="lineCov">     902132 :             npos = (line-&gt;splines[0].c*stspace[i+1].lt + line-&gt;splines[0].d - stem-&gt;left.x)*stem-&gt;l_to_r.x +</span>
<span class="lineNum">     690 </span><span class="lineCov">     451066 :                    (line-&gt;splines[1].c*stspace[i+1].lt + line-&gt;splines[1].d - stem-&gt;left.y)*stem-&gt;l_to_r.y;</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">     546782 :         if ( pos&gt;=lmin &amp;&amp; pos&lt;=lmax ) {</span>
<span class="lineNum">     693 </span><span class="lineCov">     132339 :             if ( (eo&amp;1) &amp;&amp; i&gt;0 )</span>
<span class="lineNum">     694 </span><span class="lineCov">      77403 :                 j = i-1;</span>
<span class="lineNum">     695 </span><span class="lineCov">      54936 :             else if ( !(eo&amp;1) &amp;&amp; i+1&lt;cnt )</span>
<span class="lineNum">     696 </span><span class="lineCov">      54804 :                 j = i+1;</span>
<span class="lineNum">     697 </span>            :             else
<span class="lineNum">     698 </span><span class="lineCov">        132 : return( false );</span>
<span class="lineNum">     699 </span><span class="lineCov">     264414 :             pos = (line-&gt;splines[0].c*stspace[j].lt + line-&gt;splines[0].d - stem-&gt;right.x)*stem-&gt;l_to_r.x +</span>
<span class="lineNum">     700 </span><span class="lineCov">     132207 :                   (line-&gt;splines[1].c*stspace[j].lt + line-&gt;splines[1].d - stem-&gt;right.y)*stem-&gt;l_to_r.y;</span>
<span class="lineNum">     701 </span><span class="lineCov">     132207 :             if ( pos &gt;= rmin &amp;&amp; pos &lt;= rmax )</span>
<span class="lineNum">     702 </span><span class="lineCov">      89844 : return( true );</span>
<span class="lineNum">     703 </span>            :         }
<span class="lineNum">     704 </span><span class="lineCov">     456806 :         if ( i+1 &lt; cnt &amp;&amp; npos &gt;= lmin &amp;&amp; npos &lt;= lmax )</span>
<span class="lineNum">     705 </span><span class="lineCov">      99164 :             ++eo;</span>
<span class="lineNum">     706 </span><span class="lineCov">     357642 :         else switch ( LineType(stspace,i,cnt,line) ) {</span>
<span class="lineNum">     707 </span>            :           case 0:       /* Normal spline */
<span class="lineNum">     708 </span><span class="lineCov">     356816 :             ++eo;</span>
<span class="lineNum">     709 </span><span class="lineCov">     356816 :           break;</span>
<span class="lineNum">     710 </span>            :           case 1:       /* Intersects at end-point &amp; next entry is other side */
<span class="lineNum">     711 </span><span class="lineCov">        117 :             ++eo;       /*  And the two sides continue in approximately the   */</span>
<span class="lineNum">     712 </span><span class="lineCov">        117 :             ++i;        /*  same direction */</span>
<span class="lineNum">     713 </span><span class="lineCov">        117 :           break;</span>
<span class="lineNum">     714 </span>            :           case 2:       /* Intersects at end-point &amp; next entry is other side */
<span class="lineNum">     715 </span><span class="lineCov">        709 :             ++i;        /*  And the two sides go in opposite directions */</span>
<span class="lineNum">     716 </span><span class="lineCov">        709 :           break;</span>
<span class="lineNum">     717 </span>            :           default:
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">     719 </span>            :         }
<span class="lineNum">     720 </span>            :     }
<span class="lineNum">     721 </span><span class="lineCov">      68005 : return( false );</span>
<a name="722"><span class="lineNum">     722 </span>            : }</a>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">      64479 : static int MatchWinding(struct monotonic ** space,int i,int nw,int winding,int which,int idx) {</span>
<span class="lineNum">     725 </span>            :     struct monotonic *m;
<span class="lineNum">     726 </span><span class="lineCov">      64479 :     int j,cnt=0;</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineCov">      65869 :     if (( nw&lt;0 &amp;&amp; winding&gt;0 ) || (nw&gt;0 &amp;&amp; winding&lt;0)) {</span>
<span class="lineNum">     729 </span><span class="lineCov">      32379 :         winding = nw;</span>
<span class="lineNum">     730 </span><span class="lineCov">      38169 :         for ( j=i-1; j&gt;=0; --j ) {</span>
<span class="lineNum">     731 </span><span class="lineCov">      36779 :             m = space[j];</span>
<span class="lineNum">     732 </span><span class="lineCov">      36779 :             winding += ((&amp;m-&gt;xup)[which] ? 1 : -1 );</span>
<span class="lineNum">     733 </span><span class="lineCov">      36779 :             if ( winding==0 ) {</span>
<span class="lineNum">     734 </span><span class="lineCov">      34340 :                 if ( cnt == idx )</span>
<span class="lineNum">     735 </span><span class="lineCov">      30989 : return( j );</span>
<span class="lineNum">     736 </span><span class="lineCov">       3351 :                 cnt++;</span>
<span class="lineNum">     737 </span>            :             }
<span class="lineNum">     738 </span>            :         }
<span class="lineNum">     739 </span>            :     } else {
<span class="lineNum">     740 </span><span class="lineCov">      32100 :         winding = nw;</span>
<span class="lineNum">     741 </span><span class="lineCov">      39564 :         for ( j=i+1; space[j]!=NULL; ++j ) {</span>
<span class="lineNum">     742 </span><span class="lineCov">      37419 :             m = space[j];</span>
<span class="lineNum">     743 </span><span class="lineCov">      37419 :             winding += ((&amp;m-&gt;xup)[which] ? 1 : -1 );</span>
<span class="lineNum">     744 </span><span class="lineCov">      37419 :             if ( winding==0 ) {</span>
<span class="lineNum">     745 </span><span class="lineCov">      33284 :                 if ( cnt == idx )</span>
<span class="lineNum">     746 </span><span class="lineCov">      29955 : return( j );</span>
<span class="lineNum">     747 </span><span class="lineCov">       3329 :                 cnt++;</span>
<span class="lineNum">     748 </span>            :             }
<span class="lineNum">     749 </span>            :         }
<span class="lineNum">     750 </span>            :     }
<span class="lineNum">     751 </span><span class="lineCov">       3535 : return( -1 );</span>
<a name="752"><span class="lineNum">     752 </span>            : }</a>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineCov">      40313 : static int FindMatchingHVEdge( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">     755 </span>            :     int is_next,Spline **edges,double *other_t,double *dist ) {
<span class="lineNum">     756 </span>            :     
<span class="lineNum">     757 </span>            :     double test, t, start, end;
<span class="lineNum">     758 </span>            :     int which;
<span class="lineNum">     759 </span>            :     Spline *s;
<span class="lineNum">     760 </span>            :     Monotonic *m;
<span class="lineNum">     761 </span><span class="lineCov">      40313 :     int winding, nw, i, j, ret=0;</span>
<span class="lineNum">     762 </span>            :     struct monotonic **space;
<span class="lineNum">     763 </span>            :     BasePoint *dir, d, hv;
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            :     /* Things are difficult if we go exactly through the point. Move off */
<span class="lineNum">     766 </span>            :     /*  to the side a tiny bit and hope that doesn't matter */
<span class="lineNum">     767 </span><span class="lineCov">      40313 :     if ( is_next==2 ) {</span>
<span class="lineNum">     768 </span>            :         /* Consider the case of the bottom of the circumflex (or a chevron) */
<span class="lineNum">     769 </span>            :         /*  Think of it as a flattend breve. It is symetrical and we want to */
<span class="lineNum">     770 </span>            :         /*  note the vertical distance between the two points that define */
<span class="lineNum">     771 </span>            :         /*  the bottom, so treat them as a funky stem */
<span class="lineNum">     772 </span>            :         /*                 \ \     / /              */
<span class="lineNum">     773 </span>            :         /*                  \ \   / /               */
<span class="lineNum">     774 </span>            :         /*                   \ \ / /                */
<span class="lineNum">     775 </span>            :         /*                    \ + /                 */
<span class="lineNum">     776 </span>            :         /*                     \ /                  */
<span class="lineNum">     777 </span>            :         /*                      +                   */
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :         hv.x = pd-&gt;symetrical_h ? 1.0 : 0.0;</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :         hv.y = pd-&gt;symetrical_v ? 1.0 : 0.0;</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :         dir = &amp;hv;</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :         t = .001;</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :         s = pd-&gt;sp-&gt;next;         /* Could just as easily be prev */</span>
<span class="lineNum">     783 </span><span class="lineCov">      40313 :     } else if ( is_next ) {</span>
<span class="lineNum">     784 </span><span class="lineCov">      20241 :         s = pd-&gt;sp-&gt;next;</span>
<span class="lineNum">     785 </span><span class="lineCov">      20241 :         t = .001;</span>
<span class="lineNum">     786 </span><span class="lineCov">      20241 :         dir = &amp;pd-&gt;nextunit;</span>
<span class="lineNum">     787 </span>            :     } else {
<span class="lineNum">     788 </span><span class="lineCov">      20072 :         s = pd-&gt;sp-&gt;prev;</span>
<span class="lineNum">     789 </span><span class="lineCov">      20072 :         t = .999;</span>
<span class="lineNum">     790 </span><span class="lineCov">      20072 :         dir = &amp;pd-&gt;prevunit;</span>
<span class="lineNum">     791 </span>            :     }
<span class="lineNum">     792 </span><span class="lineCov">      40313 :     if (( d.x = dir-&gt;x )&lt;0 ) d.x = -d.x;</span>
<span class="lineNum">     793 </span><span class="lineCov">      40313 :     if (( d.y = dir-&gt;y )&lt;0 ) d.y = -d.y;</span>
<span class="lineNum">     794 </span><span class="lineCov">      40313 :     which = d.x&lt;d.y;         /* closer to vertical */</span>
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineCov">      40313 :     if ( s==NULL )              /* Somehow we got an open contour? */</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineCov">      40313 :     test = ((s-&gt;splines[which].a*t+s-&gt;splines[which].b)*t+s-&gt;splines[which].c)*t+s-&gt;splines[which].d;</span>
<span class="lineNum">     800 </span><span class="lineCov">      40313 :     MonotonicFindAt(gd-&gt;ms,which,test,space = gd-&gt;space);</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">      40313 :     winding = 0;</span>
<span class="lineNum">     803 </span><span class="lineCov">     100162 :     for ( i=0; space[i]!=NULL; ++i ) {</span>
<span class="lineNum">     804 </span><span class="lineCov">     100162 :         m = space[i];</span>
<span class="lineNum">     805 </span><span class="lineCov">     100162 :         nw = ((&amp;m-&gt;xup)[which] ? 1 : -1 );</span>
<span class="lineNum">     806 </span><span class="lineCov">     100162 :         if ( m-&gt;s == s &amp;&amp; t&gt;=m-&gt;tstart &amp;&amp; t&lt;=m-&gt;tend ) {</span>
<span class="lineNum">     807 </span><span class="lineCov">      40313 :             start = m-&gt;other;</span>
<span class="lineNum">     808 </span><span class="lineCov">      40313 :     break;</span>
<span class="lineNum">     809 </span>            :         }
<span class="lineNum">     810 </span><span class="lineCov">      59849 :         winding += nw;</span>
<span class="lineNum">     811 </span>            :     }
<span class="lineNum">     812 </span><span class="lineCov">      40313 :     if ( space[i]==NULL ) {</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         fprintf( stderr, &quot;FindMatchinHVEdge didn't\n&quot; );</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">     815 </span>            :     }
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span><span class="lineCov">      40313 :     j = MatchWinding(space,i,nw,winding,which,0);</span>
<span class="lineNum">     818 </span><span class="lineCov">      40313 :     if ( j!=-1 ) {</span>
<span class="lineNum">     819 </span><span class="lineCov">      40313 :         other_t[0] = space[j]-&gt;t;</span>
<span class="lineNum">     820 </span><span class="lineCov">      40313 :         end = space[j]-&gt;other;</span>
<span class="lineNum">     821 </span><span class="lineCov">      40313 :         dist[0] = end - start;</span>
<span class="lineNum">     822 </span><span class="lineCov">      40313 :         if ( dist[0] &lt; 0 ) dist[0] = -dist[0];</span>
<span class="lineNum">     823 </span><span class="lineCov">      40313 :         edges[0] = space[j]-&gt;s;</span>
<span class="lineNum">     824 </span><span class="lineCov">      40313 :         ret++;</span>
<span class="lineNum">     825 </span>            :     }
<span class="lineNum">     826 </span><span class="lineCov">      40313 :     if ( ret &gt; 0 &amp;&amp; is_next != 2 &amp;&amp; ( pd-&gt;x_extr == 1 || pd-&gt;y_extr == 1 )) {</span>
<span class="lineNum">     827 </span><span class="lineCov">       6680 :         j = MatchWinding(space,i,nw,winding,which,1);</span>
<span class="lineNum">     828 </span><span class="lineCov">       6680 :         if ( j!=-1 ) {</span>
<span class="lineNum">     829 </span><span class="lineCov">       3794 :             other_t[ret] = space[j]-&gt;t;</span>
<span class="lineNum">     830 </span><span class="lineCov">       3794 :             end = space[j]-&gt;other;</span>
<span class="lineNum">     831 </span><span class="lineCov">       3794 :             dist[ret] = end - start;</span>
<span class="lineNum">     832 </span><span class="lineCov">       3794 :             if ( dist[ret] &lt; 0 ) dist[ret] = -dist[ret];</span>
<span class="lineNum">     833 </span><span class="lineCov">       3794 :             edges[ret] = space[j]-&gt;s;</span>
<span class="lineNum">     834 </span><span class="lineCov">       3794 :             ret++;</span>
<span class="lineNum">     835 </span>            :         }
<span class="lineNum">     836 </span>            :     }
<span class="lineNum">     837 </span><span class="lineCov">      40313 : return( ret );</span>
<a name="838"><span class="lineNum">     838 </span>            : }</a>
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span><span class="lineCov">      99298 : static BasePoint PerturbAlongSpline( Spline *s,BasePoint *bp,double t ) {</span>
<span class="lineNum">     841 </span>            :     BasePoint perturbed;
<span class="lineNum">     842 </span>            :     
<span class="lineNum">     843 </span>            :     for (;;) {
<span class="lineNum">     844 </span><span class="lineCov">      99298 :         perturbed.x = ((s-&gt;splines[0].a*t+s-&gt;splines[0].b)*t+s-&gt;splines[0].c)*t+s-&gt;splines[0].d;</span>
<span class="lineNum">     845 </span><span class="lineCov">      99298 :         perturbed.y = ((s-&gt;splines[1].a*t+s-&gt;splines[1].b)*t+s-&gt;splines[1].c)*t+s-&gt;splines[1].d;</span>
<span class="lineNum">     846 </span><span class="lineCov">      99298 :         if ( !RealWithin( perturbed.x,bp-&gt;x,.01 ) || !RealWithin( perturbed.y,bp-&gt;y,.01 ))</span>
<span class="lineNum">     847 </span>            :     break;
<span class="lineNum">     848 </span><span class="lineCov">      10295 :         if ( t&lt;.5 ) {</span>
<span class="lineNum">     849 </span><span class="lineCov">       5451 :             t *= 2;</span>
<span class="lineNum">     850 </span><span class="lineCov">       5451 :             if ( t&gt;.5 )</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     852 </span>            :         } else {
<span class="lineNum">     853 </span><span class="lineCov">       4844 :             t = 1- 2*(1-t);</span>
<span class="lineNum">     854 </span><span class="lineCov">       4844 :             if ( t&lt;.5 )</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">     856 </span>            :         }
<span class="lineNum">     857 </span><span class="lineCov">      10295 :     }</span>
<span class="lineNum">     858 </span><span class="lineCov">      89003 : return( perturbed );</span>
<a name="859"><span class="lineNum">     859 </span>            : }</a>
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span><span class="lineCov">     209066 : static void MakeVirtualLine(struct glyphdata *gd,BasePoint *perturbed,</span>
<span class="lineNum">     862 </span>            :     BasePoint *dir,Spline *myline,SplinePoint *end1, SplinePoint *end2) {
<span class="lineNum">     863 </span>            :     
<span class="lineNum">     864 </span>            :     BasePoint norm, absnorm;
<span class="lineNum">     865 </span>            :     SplineSet *spl;
<span class="lineNum">     866 </span>            :     Spline *s, *first;
<span class="lineNum">     867 </span>            :     double t1, t2;
<span class="lineNum">     868 </span>            :     int i, cnt;
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">     209066 :     if ( gd-&gt;stspace==NULL ) {</span>
<span class="lineNum">     871 </span><span class="lineCov">       4707 :         for ( i=0; i&lt;2; ++i ) {</span>
<span class="lineNum">     872 </span><span class="lineCov">       3138 :             cnt = 0;</span>
<span class="lineNum">     873 </span><span class="lineCov">       8180 :             for ( spl=gd-&gt;sc-&gt;layers[gd-&gt;layer].splines; spl!=NULL; spl=spl-&gt;next ) {</span>
<span class="lineNum">     874 </span><span class="lineCov">       5042 :                 first = NULL;</span>
<span class="lineNum">     875 </span><span class="lineCov">       5042 :                 if ( spl-&gt;first-&gt;prev!=NULL ) {</span>
<span class="lineNum">     876 </span><span class="lineCov">      77674 :                     for ( s=spl-&gt;first-&gt;next; s!=first; s=s-&gt;to-&gt;next ) {</span>
<span class="lineNum">     877 </span><span class="lineCov">      72632 :                         if ( first==NULL ) first = s;</span>
<span class="lineNum">     878 </span><span class="lineCov">      72632 :                         if ( i )</span>
<span class="lineNum">     879 </span><span class="lineCov">      36316 :                             gd-&gt;sspace[cnt] = s;</span>
<span class="lineNum">     880 </span><span class="lineCov">      72632 :                         ++cnt;</span>
<span class="lineNum">     881 </span>            :                     }
<span class="lineNum">     882 </span>            :                 }
<span class="lineNum">     883 </span>            :             }
<span class="lineNum">     884 </span><span class="lineCov">       3138 :             if ( !i ) {</span>
<span class="lineNum">     885 </span><span class="lineCov">       1569 :                 gd-&gt;scnt = cnt;</span>
<span class="lineNum">     886 </span><span class="lineCov">       1569 :                 gd-&gt;sspace = malloc((cnt+1)*sizeof(Spline *));</span>
<span class="lineNum">     887 </span>            :             } else
<span class="lineNum">     888 </span><span class="lineCov">       1569 :                 gd-&gt;sspace[cnt] = NULL;</span>
<span class="lineNum">     889 </span>            :         }
<span class="lineNum">     890 </span><span class="lineCov">       1569 :         gd-&gt;stspace = malloc((3*cnt+2)*sizeof(struct st));</span>
<span class="lineNum">     891 </span><span class="lineCov">       1569 :         SplineCharFindBounds(gd-&gt;sc,&amp;gd-&gt;size);</span>
<span class="lineNum">     892 </span><span class="lineCov">       1569 :         gd-&gt;size.minx -= 10; gd-&gt;size.miny -= 10;</span>
<span class="lineNum">     893 </span><span class="lineCov">       1569 :         gd-&gt;size.maxx += 10; gd-&gt;size.maxy += 10;</span>
<span class="lineNum">     894 </span>            :     }
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineCov">     209066 :     norm.x = -dir-&gt;y;</span>
<span class="lineNum">     897 </span><span class="lineCov">     209066 :     norm.y = dir-&gt;x;</span>
<span class="lineNum">     898 </span><span class="lineCov">     209066 :     absnorm = norm;</span>
<span class="lineNum">     899 </span><span class="lineCov">     209066 :     if ( absnorm.x&lt;0 ) absnorm.x = -absnorm.x;</span>
<span class="lineNum">     900 </span><span class="lineCov">     209066 :     if ( absnorm.y&lt;0 ) absnorm.y = -absnorm.y;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineCov">     209066 :     memset(myline,0,sizeof(*myline));</span>
<span class="lineNum">     903 </span><span class="lineCov">     209066 :     memset(end1,0,sizeof(*end1));</span>
<span class="lineNum">     904 </span><span class="lineCov">     209066 :     memset(end2,0,sizeof(*end2));</span>
<span class="lineNum">     905 </span><span class="lineCov">     209066 :     myline-&gt;knownlinear = myline-&gt;islinear = true;</span>
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span><span class="lineCov">     209066 :     if ( absnorm.x &gt; absnorm.y ) {</span>
<span class="lineNum">     908 </span>            :         /* Greater change in x than in y */
<span class="lineNum">     909 </span><span class="lineCov">     103877 :         t1 = (gd-&gt;size.minx-perturbed-&gt;x)/norm.x;</span>
<span class="lineNum">     910 </span><span class="lineCov">     103877 :         t2 = (gd-&gt;size.maxx-perturbed-&gt;x)/norm.x;</span>
<span class="lineNum">     911 </span><span class="lineCov">     103877 :         myline-&gt;splines[0].d = gd-&gt;size.minx;</span>
<span class="lineNum">     912 </span><span class="lineCov">     103877 :         myline-&gt;splines[0].c = gd-&gt;size.maxx-gd-&gt;size.minx;</span>
<span class="lineNum">     913 </span><span class="lineCov">     103877 :         myline-&gt;splines[1].d = perturbed-&gt;y+t1*norm.y;</span>
<span class="lineNum">     914 </span><span class="lineCov">     103877 :         myline-&gt;splines[1].c = (t2-t1)*norm.y;</span>
<span class="lineNum">     915 </span>            :     } else {
<span class="lineNum">     916 </span><span class="lineCov">     105189 :         t1 = (gd-&gt;size.miny-perturbed-&gt;y)/norm.y;</span>
<span class="lineNum">     917 </span><span class="lineCov">     105189 :         t2 = (gd-&gt;size.maxy-perturbed-&gt;y)/norm.y;</span>
<span class="lineNum">     918 </span><span class="lineCov">     105189 :         myline-&gt;splines[1].d = gd-&gt;size.miny;</span>
<span class="lineNum">     919 </span><span class="lineCov">     105189 :         myline-&gt;splines[1].c = gd-&gt;size.maxy-gd-&gt;size.miny;</span>
<span class="lineNum">     920 </span><span class="lineCov">     105189 :         myline-&gt;splines[0].d = perturbed-&gt;x+t1*norm.x;</span>
<span class="lineNum">     921 </span><span class="lineCov">     105189 :         myline-&gt;splines[0].c = (t2-t1)*norm.x;</span>
<span class="lineNum">     922 </span>            :     }
<span class="lineNum">     923 </span><span class="lineCov">     209066 :     end1-&gt;me.x = myline-&gt;splines[0].d;</span>
<span class="lineNum">     924 </span><span class="lineCov">     209066 :     end2-&gt;me.x = myline-&gt;splines[0].d + myline-&gt;splines[0].c;</span>
<span class="lineNum">     925 </span><span class="lineCov">     209066 :     end1-&gt;me.y = myline-&gt;splines[1].d;</span>
<span class="lineNum">     926 </span><span class="lineCov">     209066 :     end2-&gt;me.y = myline-&gt;splines[1].d + myline-&gt;splines[1].c;</span>
<span class="lineNum">     927 </span><span class="lineCov">     209066 :     end1-&gt;nextcp = end1-&gt;prevcp = end1-&gt;me;</span>
<span class="lineNum">     928 </span><span class="lineCov">     209066 :     end2-&gt;nextcp = end2-&gt;prevcp = end2-&gt;me;</span>
<span class="lineNum">     929 </span><span class="lineCov">     209066 :     end1-&gt;nonextcp = end1-&gt;noprevcp = end2-&gt;nonextcp = end2-&gt;noprevcp = true;</span>
<span class="lineNum">     930 </span><span class="lineCov">     209066 :     end1-&gt;next = myline; end2-&gt;prev = myline;</span>
<span class="lineNum">     931 </span><span class="lineCov">     209066 :     myline-&gt;from = end1; myline-&gt;to = end2;</span>
<a name="932"><span class="lineNum">     932 </span><span class="lineCov">     209066 : }</span></a>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineCov">      78678 : static int FindMatchingEdge( struct glyphdata *gd, struct pointdata *pd,</span>
<span class="lineNum">     935 </span>            :     int is_next,Spline **edges ) {
<span class="lineNum">     936 </span>            :     
<span class="lineNum">     937 </span>            :     BasePoint *dir, vert, perturbed, diff;
<span class="lineNum">     938 </span>            :     Spline myline;
<span class="lineNum">     939 </span>            :     SplinePoint end1, end2;
<span class="lineNum">     940 </span><span class="lineCov">      78678 :     double *other_t = is_next==2 ? &amp;pd-&gt;both_e_t : is_next ? pd-&gt;next_e_t : pd-&gt;prev_e_t;</span>
<span class="lineNum">     941 </span><span class="lineCov">      78678 :     double *dist = is_next ? pd-&gt;next_dist : pd-&gt;prev_dist;</span>
<span class="lineNum">     942 </span>            :     double t ;
<span class="lineNum">     943 </span>            :     Spline *s;
<span class="lineNum">     944 </span>            :     int cnt;
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span><span class="lineCov">      78678 :     dist[0] = 0; dist[1] = 0;</span>
<span class="lineNum">     947 </span><span class="lineCov">      78678 :     if (( is_next &amp;&amp; ( pd-&gt;next_hor || pd-&gt;next_ver )) ||</span>
<span class="lineNum">     948 </span><span class="lineCov">      39350 :         ( !is_next &amp;&amp; ( pd-&gt;prev_hor || pd-&gt;prev_ver )) ||</span>
<span class="lineNum">     949 </span>            :         is_next == 2 )
<span class="lineNum">     950 </span><span class="lineCov">      40313 : return( FindMatchingHVEdge(gd,pd,is_next,edges,other_t,dist));</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineCov">      38365 :     if ( is_next ) {</span>
<span class="lineNum">     953 </span><span class="lineCov">      19087 :         dir = &amp;pd-&gt;nextunit;</span>
<span class="lineNum">     954 </span><span class="lineCov">      19087 :         t = .001;</span>
<span class="lineNum">     955 </span><span class="lineCov">      19087 :         s = pd-&gt;sp-&gt;next;</span>
<span class="lineNum">     956 </span>            :     } else {
<span class="lineNum">     957 </span><span class="lineCov">      19278 :         dir = &amp;pd-&gt;prevunit;</span>
<span class="lineNum">     958 </span><span class="lineCov">      19278 :         t = .999;</span>
<span class="lineNum">     959 </span><span class="lineCov">      19278 :         s = pd-&gt;sp-&gt;prev;</span>
<span class="lineNum">     960 </span>            :     }
<span class="lineNum">     961 </span>            :     /* For spline segments which have slope close enough to the font's italic */
<span class="lineNum">     962 </span>            :     /* slant look for an opposite edge along the horizontal direction, rather */
<span class="lineNum">     963 </span>            :     /* than along the normal for the point's next/previous unit. This allows  */
<span class="lineNum">     964 </span>            :     /* us e. g. to detect serifs in italic fonts */
<span class="lineNum">     965 </span><span class="lineCov">      38365 :     if ( gd-&gt;has_slant ) {</span>
<span class="lineNum">     966 </span><span class="lineCov">       9053 :         if ( UnitsParallel( dir,&amp;gd-&gt;slant_unit,true )) {</span>
<span class="lineNum">     967 </span><span class="lineCov">       1613 :             vert.x = 0; vert.y = 1;</span>
<span class="lineNum">     968 </span><span class="lineCov">       1613 :             dir = &amp;vert;</span>
<span class="lineNum">     969 </span>            :         }
<span class="lineNum">     970 </span>            :     }
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span><span class="lineCov">      38365 :     if ( s==NULL || ( gd-&gt;only_hv &amp;&amp; !IsUnitHV( dir,false )))</span>
<span class="lineNum">     973 </span><span class="lineCov">      10566 : return( 0 );</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span><span class="lineCov">      27799 :     diff.x = s-&gt;to-&gt;me.x-s-&gt;from-&gt;me.x; diff.y = s-&gt;to-&gt;me.y-s-&gt;from-&gt;me.y;</span>
<span class="lineNum">     976 </span><span class="lineCov">      27799 :     if ( diff.x&lt;.03 &amp;&amp; diff.x&gt;-.03 &amp;&amp; diff.y&lt;.03 &amp;&amp; diff.y&gt;-.03 )</span>
<span class="lineNum">     977 </span><span class="lineCov">          1 : return( 0 );</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :     /* Don't base the line on the current point, we run into rounding errors */
<span class="lineNum">     980 </span>            :     /*  where lines that should intersect it don't. Instead perturb it a tiny*/
<span class="lineNum">     981 </span>            :     /*  bit in the direction along the spline */
<span class="lineNum">     982 </span><span class="lineCov">      27798 :     perturbed = PerturbAlongSpline( s,&amp;pd-&gt;sp-&gt;me,t );</span>
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineCov">      27798 :     MakeVirtualLine(gd,&amp;perturbed,dir,&amp;myline,&amp;end1,&amp;end2);</span>
<span class="lineNum">     985 </span>            :     /* prev_e_t = next_e_t = both_e_t =. This is where these guys are set */
<span class="lineNum">     986 </span><span class="lineCov">      27798 :     cnt = MonotonicOrder(gd-&gt;sspace,&amp;myline,gd-&gt;stspace);</span>
<span class="lineNum">     987 </span><span class="lineCov">      27798 :     edges[0] = MonotonicFindAlong(&amp;myline,gd-&gt;stspace,cnt,s,other_t);</span>
<span class="lineNum">     988 </span><span class="lineCov">      27798 : return( edges[0] != NULL );</span>
<a name="989"><span class="lineNum">     989 </span>            : }</a>
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span><span class="lineCov">     157981 : static int StillStem(struct glyphdata *gd,double fudge,BasePoint *pos,struct stemdata *stem ) {</span>
<span class="lineNum">     992 </span>            :     Spline myline;
<span class="lineNum">     993 </span>            :     SplinePoint end1, end2;
<span class="lineNum">     994 </span>            :     int cnt, ret;
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">     157981 :     MakeVirtualLine( gd,pos,&amp;stem-&gt;unit,&amp;myline,&amp;end1,&amp;end2 );</span>
<span class="lineNum">     997 </span><span class="lineCov">     157981 :     cnt = MonotonicOrder( gd-&gt;sspace,&amp;myline,gd-&gt;stspace );</span>
<span class="lineNum">     998 </span><span class="lineCov">     157981 :     ret = MonotonicFindStemBounds( &amp;myline,gd-&gt;stspace,cnt,fudge,stem );</span>
<span class="lineNum">     999 </span><span class="lineCov">     157981 : return( ret );</span>
<a name="1000"><span class="lineNum">    1000 </span>            : }</a>
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span><span class="lineCov">       1069 : static int CornerCorrectSide( struct pointdata *pd,int x_dir,int is_l ) {</span>
<span class="lineNum">    1003 </span><span class="lineCov">       1069 :     int corner = ( x_dir ) ? pd-&gt;x_corner : pd-&gt;y_corner;</span>
<span class="lineNum">    1004 </span><span class="lineCov">       1069 :     int start = (( x_dir &amp;&amp; is_l ) || ( !x_dir &amp;&amp; !is_l ));</span>
<span class="lineNum">    1005 </span>            :     double unit_p, unit_n;
<span class="lineNum">    1006 </span>            :     
<span class="lineNum">    1007 </span><span class="lineCov">       1069 :     unit_p = (&amp;pd-&gt;prevunit.x)[!x_dir];</span>
<span class="lineNum">    1008 </span><span class="lineCov">       1069 :     unit_n = (&amp;pd-&gt;nextunit.x)[!x_dir];</span>
<span class="lineNum">    1009 </span><span class="lineCov">       1610 : return( ( start &amp;&amp; (</span>
<span class="lineNum">    1010 </span><span class="lineCov">        329 :         ( corner == 1 &amp;&amp; unit_p &gt; 0 &amp;&amp; unit_n &gt; 0 ) ||</span>
<span class="lineNum">    1011 </span><span class="lineCov">       2082 :         ( corner == 2 &amp;&amp; unit_p &lt; 0 &amp;&amp; unit_n &lt; 0 ))) ||</span>
<span class="lineNum">    1012 </span><span class="lineCov">        528 :         ( !start &amp;&amp; (</span>
<span class="lineNum">    1013 </span><span class="lineCov">        324 :         ( corner == 1 &amp;&amp; unit_p &lt; 0 &amp;&amp; unit_n &lt; 0 ) ||</span>
<span class="lineNum">    1014 </span><span class="lineCov">        204 :         ( corner == 2 &amp;&amp; unit_p &gt; 0 &amp;&amp; unit_n &gt; 0 ))));</span>
<a name="1015"><span class="lineNum">    1015 </span>            : }</a>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineCov">      62274 : static int IsCorrectSide( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    1018 </span>            :     int is_next,int is_l,BasePoint *dir ) {
<span class="lineNum">    1019 </span>            :     
<span class="lineNum">    1020 </span>            :     Spline *sbase, myline;
<span class="lineNum">    1021 </span><span class="lineCov">      62274 :     SplinePoint *sp = pd-&gt;sp, end1, end2;</span>
<span class="lineNum">    1022 </span>            :     BasePoint perturbed;
<span class="lineNum">    1023 </span><span class="lineCov">      62274 :     int i, hv, is_x, ret = false, winding = 0, cnt, eo;</span>
<span class="lineNum">    1024 </span>            :     double t, test;
<span class="lineNum">    1025 </span>            :     struct monotonic **space, *m;
<span class="lineNum">    1026 </span>            :     
<span class="lineNum">    1027 </span><span class="lineCov">      62274 :     hv = IsUnitHV( dir,true );</span>
<span class="lineNum">    1028 </span><span class="lineCov">      62274 :     if (( hv == 2 &amp;&amp; pd-&gt;x_corner ) || ( hv == 1 &amp;&amp; pd-&gt;y_corner ))</span>
<span class="lineNum">    1029 </span><span class="lineCov">       1069 : return( CornerCorrectSide( pd,( hv == 2 ),is_l ));</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span><span class="lineCov">      61205 :     sbase = ( is_next ) ? sp-&gt;next : sp-&gt;prev;</span>
<span class="lineNum">    1032 </span><span class="lineCov">      61205 :     t = ( is_next ) ? 0.001 : 0.999;</span>
<span class="lineNum">    1033 </span><span class="lineCov">      61205 :     perturbed = PerturbAlongSpline( sbase,&amp;sp-&gt;me,t );</span>
<span class="lineNum">    1034 </span>            :     
<span class="lineNum">    1035 </span><span class="lineCov">      61205 :     if ( hv ) {</span>
<span class="lineNum">    1036 </span><span class="lineCov">      37918 :         is_x = ( hv == 2 );</span>
<span class="lineNum">    1037 </span><span class="lineCov">      37918 :         test = ( is_x ) ? perturbed.y : perturbed.x;</span>
<span class="lineNum">    1038 </span><span class="lineCov">      37918 :         MonotonicFindAt( gd-&gt;ms,is_x,test,space = gd-&gt;space );</span>
<span class="lineNum">    1039 </span><span class="lineCov">      91261 :         for ( i=0; space[i]!=NULL; ++i ) {</span>
<span class="lineNum">    1040 </span><span class="lineCov">      90395 :             m = space[i];</span>
<span class="lineNum">    1041 </span><span class="lineCov">      90395 :             winding = ((&amp;m-&gt;xup)[is_x] ? 1 : -1 );</span>
<span class="lineNum">    1042 </span><span class="lineCov">      90395 :             if ( m-&gt;s == sbase )</span>
<span class="lineNum">    1043 </span><span class="lineCov">      37052 :         break;</span>
<span class="lineNum">    1044 </span>            :         }
<span class="lineNum">    1045 </span><span class="lineCov">      37918 :         if ( space[i]!=NULL )</span>
<span class="lineNum">    1046 </span><span class="lineCov">      37052 :             ret = (( is_l &amp;&amp; winding == 1 ) || ( !is_l &amp;&amp; winding == -1 ));</span>
<span class="lineNum">    1047 </span>            :     } else {
<span class="lineNum">    1048 </span><span class="lineCov">      23287 :         MakeVirtualLine( gd,&amp;perturbed,dir,&amp;myline,&amp;end1,&amp;end2 );</span>
<span class="lineNum">    1049 </span><span class="lineCov">      23287 :         cnt = MonotonicOrder( gd-&gt;sspace,&amp;myline,gd-&gt;stspace );</span>
<span class="lineNum">    1050 </span><span class="lineCov">      23287 :         eo = -1;</span>
<span class="lineNum">    1051 </span><span class="lineCov">      23287 :         is_x = fabs( dir-&gt;y ) &gt; fabs( dir-&gt;x );</span>
<span class="lineNum">    1052 </span>            :         /* If a diagonal stem is more vertical than horizontal, then our     */
<span class="lineNum">    1053 </span>            :         /* virtual line will go from left to right. It will first intersect  */
<span class="lineNum">    1054 </span>            :         /* the left side of the stem, if the stem also points north-east.    */
<span class="lineNum">    1055 </span>            :         /* In any other case the virtual line will first intersect the right */
<span class="lineNum">    1056 </span>            :         /* side. */
<span class="lineNum">    1057 </span><span class="lineCov">      23287 :         i = ( is_x &amp;&amp; dir-&gt;y &gt; 0 ) ? 0 : cnt-1; </span>
<span class="lineNum">    1058 </span><span class="lineCov">      84288 :         while ( i &gt;= 0 &amp;&amp; i &lt;= cnt-1 ) {</span>
<span class="lineNum">    1059 </span><span class="lineCov">      61001 :             eo = ( eo != 1 ) ? 1 : 0;</span>
<span class="lineNum">    1060 </span><span class="lineCov">      61001 :             if ( gd-&gt;stspace[i].s == sbase )</span>
<span class="lineNum">    1061 </span><span class="lineCov">      23287 :         break;</span>
<span class="lineNum">    1062 </span><span class="lineCov">      37714 :             if ( is_x &amp;&amp; dir-&gt;y &gt; 0 ) i++;</span>
<span class="lineNum">    1063 </span><span class="lineCov">      28104 :             else i--;</span>
<span class="lineNum">    1064 </span>            :         }
<span class="lineNum">    1065 </span><span class="lineCov">      23287 :         ret = ( is_l == eo );</span>
<span class="lineNum">    1066 </span>            :     }
<span class="lineNum">    1067 </span><span class="lineCov">      61205 : return( ret );</span>
<span class="lineNum">    1068 </span>            : }
<span class="lineNum">    1069 </span>            : 
<span class="lineNum">    1070 </span>            : /* In TrueType I want to make sure that everything on a diagonal line remains */
<a name="1071"><span class="lineNum">    1071 </span>            : /*  on the same line. Hence we compute the line. Also we are interested in */</a>
<span class="lineNum">    1072 </span>            : /*  points that are on the intersection of two lines */
<span class="lineNum">    1073 </span><span class="lineCov">      37468 : static struct linedata *BuildLine(struct glyphdata *gd,struct pointdata *pd,int is_next ) {</span>
<span class="lineNum">    1074 </span>            :     int i;
<span class="lineNum">    1075 </span>            :     BasePoint *dir, *base, *start, *end;
<span class="lineNum">    1076 </span><span class="lineCov">      37468 :     struct pointdata **pspace = gd-&gt;pspace, *pd2;</span>
<span class="lineNum">    1077 </span><span class="lineCov">      37468 :     int pcnt=0, is_l, hv;</span>
<span class="lineNum">    1078 </span>            :     double dist_error;
<span class="lineNum">    1079 </span>            :     struct linedata *line;
<span class="lineNum">    1080 </span><span class="lineCov">      37468 :     double off, firstoff, lastoff, lmin=0, lmax=0;</span>
<span class="lineNum">    1081 </span>            :     
<span class="lineNum">    1082 </span><span class="lineCov">      37468 :     dir = is_next ? &amp;pd-&gt;nextunit : &amp;pd-&gt;prevunit;</span>
<span class="lineNum">    1083 </span><span class="lineCov">      37468 :     is_l = IsCorrectSide( gd,pd,is_next,true,dir );</span>
<span class="lineNum">    1084 </span><span class="lineCov">      37468 :     dist_error = ( IsUnitHV( dir,true )) ? dist_error_hv : dist_error_diag ;    /* Diagonals are harder to align */</span>
<span class="lineNum">    1085 </span><span class="lineCov">      37468 :     if ( dir-&gt;x==0 &amp;&amp; dir-&gt;y==0 )</span>
<span class="lineNum">    1086 </span><span class="lineCov">         48 : return( NULL );</span>
<span class="lineNum">    1087 </span><span class="lineCov">      37420 :     base = &amp;pd-&gt;sp-&gt;me;</span>
<span class="lineNum">    1088 </span>            :     
<span class="lineNum">    1089 </span><span class="lineCov">    1093548 :     for ( i= (pd - gd-&gt;points)+1; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    1090 </span><span class="lineCov">     614183 :         pd2 = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    1091 </span><span class="lineCov">    1228366 :         off =  ( pd2-&gt;sp-&gt;me.x - base-&gt;x )*dir-&gt;y - </span>
<span class="lineNum">    1092 </span><span class="lineCov">     614183 :                ( pd2-&gt;sp-&gt;me.y - base-&gt;y )*dir-&gt;x;</span>
<span class="lineNum">    1093 </span><span class="lineCov">     614183 :         if ( off &lt;= lmax - 2*dist_error || off &gt;= lmin + 2*dist_error )</span>
<span class="lineNum">    1094 </span><span class="lineCov">     574034 :     continue;</span>
<span class="lineNum">    1095 </span><span class="lineCov">      40149 :         if ( off &lt; 0 &amp;&amp; off &lt; lmin ) lmin = off;</span>
<span class="lineNum">    1096 </span><span class="lineCov">      29875 :         else if ( off &gt; 0 &amp;&amp; off &gt; lmax ) lmax = off;</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineCov">      47778 :         if ((( UnitsParallel( dir,&amp;pd2-&gt;nextunit,true ) &amp;&amp; pd2-&gt;nextline==NULL ) &amp;&amp;</span>
<span class="lineNum">    1099 </span><span class="lineCov">      40729 :             IsCorrectSide( gd,pd2,true,is_l,dir )) ||</span>
<span class="lineNum">    1100 </span><span class="lineCov">      52340 :             (( UnitsParallel( dir,&amp;pd2-&gt;prevunit,true ) &amp;&amp; pd2-&gt;prevline==NULL ) &amp;&amp;</span>
<span class="lineNum">    1101 </span><span class="lineCov">       9533 :             IsCorrectSide( gd,pd2,false,is_l,dir )))</span>
<span class="lineNum">    1102 </span><span class="lineCov">      16057 :             pspace[pcnt++] = pd2;</span>
<span class="lineNum">    1103 </span>            :     }
<span class="lineNum">    1104 </span>            :     
<span class="lineNum">    1105 </span><span class="lineCov">      37420 :     if ( pcnt==0 )</span>
<span class="lineNum">    1106 </span><span class="lineCov">      26647 : return( NULL );</span>
<span class="lineNum">    1107 </span><span class="lineCov">      10773 :     if ( pcnt==1 ) {</span>
<span class="lineNum">    1108 </span>            :         /* if the line consists of just these two points, only count it as */
<span class="lineNum">    1109 </span>            :         /*  a true line if the two immediately follow each other */
<span class="lineNum">    1110 </span><span class="lineCov">      11156 :         if (( pd-&gt;sp-&gt;next-&gt;to != pspace[0]-&gt;sp || !pd-&gt;sp-&gt;next-&gt;knownlinear ) &amp;&amp;</span>
<span class="lineNum">    1111 </span><span class="lineCov">       3696 :             ( pd-&gt;sp-&gt;prev-&gt;from != pspace[0]-&gt;sp || !pd-&gt;sp-&gt;prev-&gt;knownlinear ))</span>
<span class="lineNum">    1112 </span><span class="lineCov">       1964 : return( NULL );</span>
<span class="lineNum">    1113 </span>            :     }
<span class="lineNum">    1114 </span>            :     
<span class="lineNum">    1115 </span><span class="lineCov">       8809 :     line = &amp;gd-&gt;lines[gd-&gt;linecnt++];</span>
<span class="lineNum">    1116 </span><span class="lineCov">       8809 :     line-&gt;pcnt = pcnt+1;</span>
<span class="lineNum">    1117 </span><span class="lineCov">       8809 :     line-&gt;points = malloc((pcnt+1)*sizeof(struct pointdata *));</span>
<span class="lineNum">    1118 </span><span class="lineCov">       8809 :     line-&gt;points[0] = pd;</span>
<span class="lineNum">    1119 </span><span class="lineCov">       8809 :     line-&gt;unit = *dir;</span>
<span class="lineNum">    1120 </span><span class="lineCov">       8809 :     line-&gt;is_left = is_l;</span>
<span class="lineNum">    1121 </span><span class="lineCov">       8809 :     if ( dir-&gt;x &lt; 0 || dir-&gt;y == -1 ) {</span>
<span class="lineNum">    1122 </span><span class="lineCov">       4478 :         line-&gt;unit.x = -line-&gt;unit.x;</span>
<span class="lineNum">    1123 </span><span class="lineCov">       4478 :         line-&gt;unit.y = -line-&gt;unit.y;</span>
<span class="lineNum">    1124 </span>            :     }
<span class="lineNum">    1125 </span><span class="lineCov">       8809 :     line-&gt;online = *base;</span>
<span class="lineNum">    1126 </span><span class="lineCov">       8809 :     if ( is_next ) {</span>
<span class="lineNum">    1127 </span><span class="lineCov">       7707 :         pd-&gt;nextline = line;</span>
<span class="lineNum">    1128 </span><span class="lineCov">       7707 :         if ( pd-&gt;colinear ) pd-&gt;prevline = line;</span>
<span class="lineNum">    1129 </span>            :     } else {
<span class="lineNum">    1130 </span><span class="lineCov">       1102 :         pd-&gt;prevline = line;</span>
<span class="lineNum">    1131 </span><span class="lineCov">       1102 :         if ( pd-&gt;colinear ) pd-&gt;nextline = line;</span>
<span class="lineNum">    1132 </span>            :     }
<span class="lineNum">    1133 </span><span class="lineCov">      22902 :     for ( i=0; i&lt;pcnt; ++i ) {</span>
<span class="lineNum">    1134 </span><span class="lineCov">      14093 :         if ( UnitsParallel( dir,&amp;pspace[i]-&gt;nextunit,true ) &amp;&amp; pspace[i]-&gt;nextline==NULL ) {</span>
<span class="lineNum">    1135 </span><span class="lineCov">       5771 :             pspace[i]-&gt;nextline = line;</span>
<span class="lineNum">    1136 </span><span class="lineCov">       5771 :             if ( pspace[i]-&gt;colinear )</span>
<span class="lineNum">    1137 </span><span class="lineCov">       2819 :                 pspace[i]-&gt;prevline = line;</span>
<span class="lineNum">    1138 </span>            :         }
<span class="lineNum">    1139 </span><span class="lineCov">      14093 :         if ( UnitsParallel( dir,&amp;pspace[i]-&gt;prevunit,true ) &amp;&amp; pspace[i]-&gt;prevline==NULL ) {</span>
<span class="lineNum">    1140 </span><span class="lineCov">       8369 :             pspace[i]-&gt;prevline = line;</span>
<span class="lineNum">    1141 </span><span class="lineCov">       8369 :             if ( pspace[i]-&gt;colinear )</span>
<span class="lineNum">    1142 </span><span class="lineCov">        252 :                 pspace[i]-&gt;nextline = line;</span>
<span class="lineNum">    1143 </span>            :         }
<span class="lineNum">    1144 </span><span class="lineCov">      14093 :         line-&gt;points[i+1] = pspace[i];</span>
<span class="lineNum">    1145 </span>            :     }
<span class="lineNum">    1146 </span><span class="lineCov">       8809 :     qsort( line-&gt;points,line-&gt;pcnt,sizeof( struct pointdata * ),line_pt_cmp );</span>
<span class="lineNum">    1147 </span><span class="lineCov">       8809 :     start = &amp;line-&gt;points[0]-&gt;sp-&gt;me;</span>
<span class="lineNum">    1148 </span><span class="lineCov">       8809 :     end = &amp;line-&gt;points[pcnt]-&gt;sp-&gt;me;</span>
<span class="lineNum">    1149 </span>            :     /* Now recalculate the line unit vector basing on its starting and */
<span class="lineNum">    1150 </span>            :     /* terminal points */
<span class="lineNum">    1151 </span><span class="lineCov">       8809 :     line-&gt;unit.x = ( end-&gt;x - start-&gt;x );</span>
<span class="lineNum">    1152 </span><span class="lineCov">       8809 :     line-&gt;unit.y = ( end-&gt;y - start-&gt;y );</span>
<span class="lineNum">    1153 </span><span class="lineCov">       8809 :     line-&gt;length = sqrt( pow( line-&gt;unit.x,2 ) + pow( line-&gt;unit.y,2 ));</span>
<span class="lineNum">    1154 </span><span class="lineCov">       8809 :     line-&gt;unit.x /= line-&gt;length;</span>
<span class="lineNum">    1155 </span><span class="lineCov">       8809 :     line-&gt;unit.y /= line-&gt;length;</span>
<span class="lineNum">    1156 </span><span class="lineCov">       8809 :     hv = IsUnitHV( &amp;line-&gt;unit,true );</span>
<span class="lineNum">    1157 </span><span class="lineCov">       8809 :     if ( hv == 2 ) {</span>
<span class="lineNum">    1158 </span><span class="lineCov">       3531 :         line-&gt;unit.x = 0; line-&gt;unit.y = 1;</span>
<span class="lineNum">    1159 </span><span class="lineCov">       5278 :     } else if ( hv == 1 ) {</span>
<span class="lineNum">    1160 </span><span class="lineCov">       3814 :         line-&gt;unit.x = 1; line-&gt;unit.y = 0;</span>
<span class="lineNum">    1161 </span><span class="lineCov">       1464 :     } else if ( gd-&gt;has_slant &amp;&amp; UnitsParallel( &amp;line-&gt;unit,&amp;gd-&gt;slant_unit,true )) {</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :         firstoff =  ( start-&gt;x - base-&gt;x )*gd-&gt;slant_unit.y - </span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :                     ( start-&gt;y - base-&gt;y )*gd-&gt;slant_unit.x;</span>
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 :         lastoff =   ( end-&gt;x - base-&gt;x )*gd-&gt;slant_unit.y - </span>
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :                     ( end-&gt;y - base-&gt;y )*gd-&gt;slant_unit.x;</span>
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :         if ( fabs( firstoff ) &lt; 2*dist_error &amp;&amp; fabs( lastoff ) &lt; 2*dist_error )</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :             line-&gt;unit = gd-&gt;slant_unit;</span>
<span class="lineNum">    1168 </span>            :     }
<span class="lineNum">    1169 </span><span class="lineCov">       8809 : return( line );</span>
<a name="1170"><span class="lineNum">    1170 </span>            : }</a>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineCov">       1288 : static BasePoint MiddleUnit( BasePoint *unit1, BasePoint *unit2 ) {</span>
<span class="lineNum">    1173 </span>            :     BasePoint u1, u2, ret;
<span class="lineNum">    1174 </span>            :     double hyp;
<span class="lineNum">    1175 </span>            :     int hv;
<span class="lineNum">    1176 </span>            :     
<span class="lineNum">    1177 </span><span class="lineCov">       1288 :     u1 = *unit1; u2 = *unit2;</span>
<span class="lineNum">    1178 </span><span class="lineCov">       1288 :     if ( u1.x*u2.x + u1.y*u2.y &lt; 0 ) {</span>
<span class="lineNum">    1179 </span><span class="lineCov">        395 :         u2.x = -u2.x; u2.y = -u2.y;</span>
<span class="lineNum">    1180 </span>            :     }
<span class="lineNum">    1181 </span><span class="lineCov">       1288 :     ret.x = ( u1.x + u2.x )/2;</span>
<span class="lineNum">    1182 </span><span class="lineCov">       1288 :     ret.y = ( u1.y + u2.y )/2;</span>
<span class="lineNum">    1183 </span><span class="lineCov">       1288 :     hyp = sqrt( pow( ret.x,2 ) + pow( ret.y,2 ));</span>
<span class="lineNum">    1184 </span><span class="lineCov">       1288 :     ret.x /= hyp;</span>
<span class="lineNum">    1185 </span><span class="lineCov">       1288 :     ret.y /= hyp;</span>
<span class="lineNum">    1186 </span>            :     
<span class="lineNum">    1187 </span><span class="lineCov">       1288 :     hv = IsUnitHV( &amp;ret,true );</span>
<span class="lineNum">    1188 </span><span class="lineCov">       1288 :     if ( hv ) {</span>
<span class="lineNum">    1189 </span><span class="lineCov">        146 :         ret.x = ( hv == 1 ) ? 1 : 0;</span>
<span class="lineNum">    1190 </span><span class="lineCov">        146 :         ret.y = ( hv == 1 ) ? 0 : 1;</span>
<span class="lineNum">    1191 </span>            :     }
<span class="lineNum">    1192 </span><span class="lineCov">       1288 : return( ret );</span>
<a name="1193"><span class="lineNum">    1193 </span>            : }</a>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineCov">     142070 : static uint8 IsStubOrIntersection( struct glyphdata *gd, BasePoint *dir1, </span>
<span class="lineNum">    1196 </span>            :     struct pointdata *pd1, struct pointdata *pd2, int is_next1, int is_next2 ) {
<span class="lineNum">    1197 </span>            :     int i;
<span class="lineNum">    1198 </span><span class="lineCov">     142070 :     int exc=0;</span>
<span class="lineNum">    1199 </span>            :     double dist, off, ext, norm1, norm2, opp, angle;
<span class="lineNum">    1200 </span><span class="lineCov">     142070 :     double mid_err = ( stem_slope_error + stub_slope_error )/2;</span>
<span class="lineNum">    1201 </span>            :     SplinePoint *sp1, *sp2, *nsp;
<span class="lineNum">    1202 </span>            :     BasePoint hvdir, *dir2, *odir1, *odir2;
<span class="lineNum">    1203 </span>            :     struct pointdata *npd;
<span class="lineNum">    1204 </span>            :     struct linedata *line;
<span class="lineNum">    1205 </span>            :     
<span class="lineNum">    1206 </span><span class="lineCov">     142070 :     sp1 = pd1-&gt;sp; sp2 = pd2-&gt;sp;</span>
<span class="lineNum">    1207 </span><span class="lineCov">     142070 :     dir2 = ( is_next2 ) ? &amp;pd2-&gt;nextunit : &amp;pd2-&gt;prevunit;</span>
<span class="lineNum">    1208 </span><span class="lineCov">     142070 :     hvdir.x = ( int ) rint( dir1-&gt;x );</span>
<span class="lineNum">    1209 </span><span class="lineCov">     142070 :     hvdir.y = ( int ) rint( dir1-&gt;y );</span>
<span class="lineNum">    1210 </span>            :     
<span class="lineNum">    1211 </span><span class="lineCov">     142070 :     line = is_next2 ? pd2-&gt;nextline : pd2-&gt;prevline;</span>
<span class="lineNum">    1212 </span><span class="lineCov">     142070 :     if ( !IsUnitHV( dir2,true ) &amp;&amp; line != NULL )</span>
<span class="lineNum">    1213 </span><span class="lineCov">       9058 :         dir2 = &amp;line-&gt;unit;</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineCov">     142070 :     odir1 = ( is_next1 ) ? &amp;pd1-&gt;prevunit : &amp;pd1-&gt;nextunit;</span>
<span class="lineNum">    1216 </span><span class="lineCov">     142070 :     odir2 = ( is_next2 ) ? &amp;pd2-&gt;prevunit : &amp;pd2-&gt;nextunit;</span>
<span class="lineNum">    1217 </span>            :     
<span class="lineNum">    1218 </span><span class="lineCov">     142070 :     angle = fabs( GetUnitAngle( dir1,dir2 ));</span>
<span class="lineNum">    1219 </span><span class="lineCov">     142070 :     if ( angle &gt; (double)stub_slope_error*1.5 &amp;&amp; angle &lt; PI - (double)stub_slope_error*1.5 )</span>
<span class="lineNum">    1220 </span><span class="lineCov">      51645 : return( 0 );</span>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            :     /* First check if it is a slightly slanted line or a curve which joins */
<span class="lineNum">    1223 </span>            :     /* a straight line under an angle close to 90 degrees. There are many */
<span class="lineNum">    1224 </span>            :     /* glyphs where circles or curved features are intersected by or */
<span class="lineNum">    1225 </span>            :     /* connected to vertical or horizontal straight stems (the most obvious */
<span class="lineNum">    1226 </span>            :     /* cases are Greek Psi and Cyrillic Yu), and usually it is highly desired to */
<span class="lineNum">    1227 </span>            :     /* mark such an intersection with a hint */
<span class="lineNum">    1228 </span><span class="lineCov">     180850 :     norm1 = ( sp1-&gt;me.x - sp2-&gt;me.x ) * odir2-&gt;x +</span>
<span class="lineNum">    1229 </span><span class="lineCov">      90425 :             ( sp1-&gt;me.y - sp2-&gt;me.y ) * odir2-&gt;y;</span>
<span class="lineNum">    1230 </span><span class="lineCov">     180850 :     norm2 = ( sp2-&gt;me.x - sp1-&gt;me.x ) * odir1-&gt;x +</span>
<span class="lineNum">    1231 </span><span class="lineCov">      90425 :             ( sp2-&gt;me.y - sp1-&gt;me.y ) * odir1-&gt;y;</span>
<span class="lineNum">    1232 </span>            :     /* if this is a real stub or intersection, then vectors on both sides */
<span class="lineNum">    1233 </span>            :     /* of out going-to-be stem should point in the same direction. So */
<span class="lineNum">    1234 </span>            :     /* the following value should be positive */
<span class="lineNum">    1235 </span><span class="lineCov">      90425 :     opp = dir1-&gt;x * dir2-&gt;x + dir1-&gt;y * dir2-&gt;y;</span>
<span class="lineNum">    1236 </span><span class="lineCov">      90425 :     if (( angle &lt;= mid_err || angle &gt;= PI - mid_err ) &amp;&amp; </span>
<span class="lineNum">    1237 </span><span class="lineCov">      43385 :         opp &gt; 0 &amp;&amp; norm1 &lt; 0 &amp;&amp; norm2 &lt; 0 &amp;&amp; UnitsParallel( odir1,odir2,true ) &amp;&amp; </span>
<span class="lineNum">    1238 </span><span class="lineCov">       2978 :         ( UnitsOrthogonal( dir1,odir1,false ) || UnitsOrthogonal( dir2,odir1,false )))</span>
<span class="lineNum">    1239 </span><span class="lineCov">       1498 : return( 2 );</span>
<span class="lineNum">    1240 </span><span class="lineCov">      88927 :     if (( angle &lt;= mid_err || angle &gt;= PI - mid_err ) &amp;&amp;</span>
<span class="lineNum">    1241 </span><span class="lineCov">      54976 :         opp &gt; 0 &amp;&amp; (( norm1 &lt; 0 &amp;&amp; pd1-&gt;colinear &amp;&amp;</span>
<span class="lineNum">    1242 </span><span class="lineCov">      24374 :         IsUnitHV( dir1,true ) &amp;&amp; UnitsOrthogonal( dir1,odir2,false )) ||</span>
<span class="lineNum">    1243 </span><span class="lineCov">       7693 :         ( norm2 &lt; 0 &amp;&amp; pd2-&gt;colinear &amp;&amp;</span>
<span class="lineNum">    1244 </span><span class="lineCov">       2424 :         IsUnitHV( dir2,true ) &amp;&amp; UnitsOrthogonal( dir2,odir1,false ))))</span>
<span class="lineNum">    1245 </span><span class="lineCov">        542 : return( 4 );</span>
<span class="lineNum">    1246 </span>            :     
<span class="lineNum">    1247 </span>            :     /* Now check if our 2 points form a serif termination or a feature stub */
<span class="lineNum">    1248 </span>            :     /* The check is pretty dumb: it returns 'true' if all the following */
<span class="lineNum">    1249 </span>            :     /* conditions are met: */
<span class="lineNum">    1250 </span>            :     /* - both the points belong to the same contour; */
<span class="lineNum">    1251 </span>            :     /* - there are no more than 3 other points between them; */
<span class="lineNum">    1252 </span>            :     /* - anyone of those intermediate points is positioned by such a way */
<span class="lineNum">    1253 </span>            :     /*   that it falls inside the stem formed by our 2 base point and */
<span class="lineNum">    1254 </span>            :     /*   the vector we are checking and its distance from the first point */
<span class="lineNum">    1255 </span>            :     /*   along that vector is not larger than the stem width; */
<span class="lineNum">    1256 </span>            :     /* - none of the intermediate points is parallel to the vector direction */
<span class="lineNum">    1257 </span>            :     /*   (otherwise we should have checked against that point instead) */
<span class="lineNum">    1258 </span><span class="lineCov">      88385 :     if ( !UnitsParallel( dir1,&amp;hvdir,false ))</span>
<span class="lineNum">    1259 </span><span class="lineCov">       8968 : return( 0 );</span>
<span class="lineNum">    1260 </span>            :     
<span class="lineNum">    1261 </span><span class="lineCov">     158834 :     dist = ( sp1-&gt;me.x - sp2-&gt;me.x ) * dir1-&gt;y -</span>
<span class="lineNum">    1262 </span><span class="lineCov">      79417 :            ( sp1-&gt;me.y - sp2-&gt;me.y ) * dir1-&gt;x;</span>
<span class="lineNum">    1263 </span><span class="lineCov">      79417 :     nsp = sp1;</span>
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span><span class="lineCov">     141334 :     for ( i=0; i&lt;4; i++ ) {</span>
<span class="lineNum">    1266 </span><span class="lineCov">     135563 :         if (( is_next1 &amp;&amp; nsp-&gt;prev == NULL ) || ( !is_next1 &amp;&amp; nsp-&gt;next == NULL ))</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span><span class="lineCov">     135563 :         nsp = ( is_next1 ) ? nsp-&gt;prev-&gt;from : nsp-&gt;next-&gt;to; </span>
<span class="lineNum">    1270 </span><span class="lineCov">     135563 :         if ( ( i&gt;0 &amp;&amp; nsp == sp1 ) || nsp == sp2 )</span>
<span class="lineNum">    1271 </span>            :     break;
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineCov">     122936 :         npd = &amp;gd-&gt;points[nsp-&gt;ptindex];</span>
<span class="lineNum">    1274 </span><span class="lineCov">     211128 :         if (UnitsParallel( &amp;npd-&gt;nextunit,&amp;hvdir,false ) || </span>
<span class="lineNum">    1275 </span><span class="lineCov">      88192 :             UnitsParallel( &amp;npd-&gt;prevunit,&amp;hvdir,false ))</span>
<span class="lineNum">    1276 </span>            :     break;
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineCov">     148014 :         ext = ( sp1-&gt;me.x - nsp-&gt;me.x ) * hvdir.x +</span>
<span class="lineNum">    1279 </span><span class="lineCov">      74007 :               ( sp1-&gt;me.y - nsp-&gt;me.y ) * hvdir.y;</span>
<span class="lineNum">    1280 </span><span class="lineCov">      74007 :         if ( ext &lt; 0 ) ext = -ext;</span>
<span class="lineNum">    1281 </span><span class="lineCov">      74007 :         if (( dist &gt; 0 &amp;&amp; ext &gt; dist ) || ( dist &lt; 0 &amp;&amp; ext &lt; dist ))</span>
<span class="lineNum">    1282 </span>            :     break;
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineCov">     123834 :         off = ( sp1-&gt;me.x - nsp-&gt;me.x ) * hvdir.y -</span>
<span class="lineNum">    1285 </span><span class="lineCov">      61917 :               ( sp1-&gt;me.y - nsp-&gt;me.y ) * hvdir.x;</span>
<span class="lineNum">    1286 </span><span class="lineCov">      61917 :         if (( dist &gt; 0 &amp;&amp; ( off &lt;= 0 || off &gt;= dist )) ||</span>
<span class="lineNum">    1287 </span><span class="lineCov">      45990 :             ( dist &lt; 0 &amp;&amp; ( off &gt;= 0 || off &lt;= dist )))</span>
<span class="lineNum">    1288 </span><span class="lineCov">      44087 :             exc++;</span>
<span class="lineNum">    1289 </span>            :     }
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span><span class="lineCov">      79417 :     if ( nsp == sp2 &amp;&amp; exc == 0 )</span>
<span class="lineNum">    1292 </span><span class="lineCov">      11756 : return( 1 );</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">      67661 : return( 0 );</span>
<span class="lineNum">    1295 </span>            : }
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span>            : /* We normalize all stem unit vectors so that they point between 90 and 270    */
<span class="lineNum">    1298 </span>            : /* degrees, as this range is optimal for sorting diagonal stems. This means    */
<span class="lineNum">    1299 </span>            : /* that vertical stems will normally point top to bottom, but for diagonal     */
<span class="lineNum">    1300 </span>            : /* stems (even if their angle is actually very close to vertical) the opposite */
<a name="1301"><span class="lineNum">    1301 </span>            : /* direction is also possible. Sometimes we &quot;normalize&quot; such stems converting  */</a>
<span class="lineNum">    1302 </span>            : /* them to vertical. In such a case we have to swap their edges too.  */
<span class="lineNum">    1303 </span><span class="lineCov">         29 : static void SwapEdges( struct glyphdata *gd,struct stemdata *stem ) {</span>
<span class="lineNum">    1304 </span>            :     BasePoint tpos;
<span class="lineNum">    1305 </span>            :     struct pointdata *tpd;
<span class="lineNum">    1306 </span>            :     struct linedata *tl;
<span class="lineNum">    1307 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    1308 </span>            :     double toff;
<span class="lineNum">    1309 </span>            :     int i, j, temp;
<span class="lineNum">    1310 </span>            :     
<span class="lineNum">    1311 </span><span class="lineCov">         29 :     tpos = stem-&gt;left; stem-&gt;left = stem-&gt;right; stem-&gt;right = tpos;</span>
<span class="lineNum">    1312 </span><span class="lineCov">         29 :     toff = stem-&gt;lmin; stem-&gt;lmin = stem-&gt;rmax; stem-&gt;rmax = toff;</span>
<span class="lineNum">    1313 </span><span class="lineCov">         29 :     toff = stem-&gt;rmin; stem-&gt;rmin = stem-&gt;lmax; stem-&gt;lmax = toff;</span>
<span class="lineNum">    1314 </span><span class="lineCov">         29 :     tl = stem-&gt;leftline; stem-&gt;leftline = stem-&gt;rightline; stem-&gt;rightline = tl;</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineCov">         59 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    1317 </span><span class="lineCov">         30 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    1318 </span><span class="lineCov">         30 :         tpd = chunk-&gt;l; chunk-&gt;l = chunk-&gt;r; chunk-&gt;r = tpd;</span>
<span class="lineNum">    1319 </span><span class="lineCov">         30 :         temp = chunk-&gt;lpotential; chunk-&gt;lpotential = chunk-&gt;rpotential; chunk-&gt;rpotential = temp;</span>
<span class="lineNum">    1320 </span><span class="lineCov">         30 :         temp = chunk-&gt;lnext; chunk-&gt;lnext = chunk-&gt;rnext; chunk-&gt;rnext = temp;</span>
<span class="lineNum">    1321 </span><span class="lineCov">         30 :         temp = chunk-&gt;ltick; chunk-&gt;ltick = chunk-&gt;rtick; chunk-&gt;rtick = temp;</span>
<span class="lineNum">    1322 </span>            :         
<span class="lineNum">    1323 </span><span class="lineCov">         30 :         tpd = chunk-&gt;l;</span>
<span class="lineNum">    1324 </span><span class="lineCov">         30 :         if ( tpd != NULL ) {</span>
<span class="lineNum">    1325 </span><span class="lineCov">         62 :             for ( j=0; j&lt;tpd-&gt;nextcnt; j++ )</span>
<span class="lineNum">    1326 </span><span class="lineCov">         32 :                 if ( tpd-&gt;nextstems[j] == stem )</span>
<span class="lineNum">    1327 </span><span class="lineCov">         21 :                     tpd-&gt;next_is_l[j] = true;</span>
<span class="lineNum">    1328 </span><span class="lineCov">         55 :             for ( j=0; j&lt;tpd-&gt;prevcnt; j++ )</span>
<span class="lineNum">    1329 </span><span class="lineCov">         25 :                 if ( tpd-&gt;prevstems[j] == stem )</span>
<span class="lineNum">    1330 </span><span class="lineCov">         17 :                     tpd-&gt;prev_is_l[j] = true;</span>
<span class="lineNum">    1331 </span>            :         }
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span><span class="lineCov">         30 :         tpd = chunk-&gt;r;</span>
<span class="lineNum">    1334 </span><span class="lineCov">         30 :         if ( tpd != NULL ) {</span>
<span class="lineNum">    1335 </span><span class="lineCov">         61 :             for ( j=0; j&lt;tpd-&gt;nextcnt; j++ )</span>
<span class="lineNum">    1336 </span><span class="lineCov">         31 :                 if ( tpd-&gt;nextstems[j] == stem )</span>
<span class="lineNum">    1337 </span><span class="lineCov">         20 :                     tpd-&gt;next_is_l[j] = false;</span>
<span class="lineNum">    1338 </span><span class="lineCov">         60 :             for ( j=0; j&lt;tpd-&gt;prevcnt; j++ )</span>
<span class="lineNum">    1339 </span><span class="lineCov">         30 :                 if ( tpd-&gt;prevstems[j] == stem )</span>
<span class="lineNum">    1340 </span><span class="lineCov">         20 :                     tpd-&gt;prev_is_l[j] = false;</span>
<span class="lineNum">    1341 </span>            :         }
<span class="lineNum">    1342 </span>            :     }
<span class="lineNum">    1343 </span>            :     
<span class="lineNum">    1344 </span>            :     /* In case of a quadratic contour invert assignments to stem sides */
<span class="lineNum">    1345 </span>            :     /* also for off-curve points */
<span class="lineNum">    1346 </span><span class="lineCov">         29 :     if ( gd-&gt;order2 ) {</span>
<span class="lineNum">    1347 </span><span class="lineCov">        556 :         for ( i=0; i&lt;gd-&gt;realcnt; i++ ) if ( gd-&gt;points[i].sp == NULL ) {</span>
<span class="lineNum">    1348 </span><span class="lineCov">        329 :             tpd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    1349 </span><span class="lineCov">        495 :             for ( j=0; j&lt;tpd-&gt;nextcnt; j++ )</span>
<span class="lineNum">    1350 </span><span class="lineCov">        166 :                 if ( tpd-&gt;nextstems[j] == stem )</span>
<span class="lineNum">    1351 </span><span class="lineCov">         14 :                     tpd-&gt;next_is_l[j] = !tpd-&gt;next_is_l[j];</span>
<span class="lineNum">    1352 </span><span class="lineCov">        516 :             for ( j=0; j&lt;tpd-&gt;prevcnt; j++ )</span>
<span class="lineNum">    1353 </span><span class="lineCov">        187 :                 if ( tpd-&gt;prevstems[j] == stem )</span>
<span class="lineNum">    1354 </span><span class="lineCov">         14 :                     tpd-&gt;prev_is_l[j] = !tpd-&gt;prev_is_l[j];</span>
<span class="lineNum">    1355 </span>            :         }
<span class="lineNum">    1356 </span>            :     }
<a name="1357"><span class="lineNum">    1357 </span><span class="lineCov">         29 : }</span></a>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineCov">       1805 : static int StemFitsHV( struct stemdata *stem,int is_x,uint8 mask ) {</span>
<span class="lineNum">    1360 </span>            :     int i,cnt;
<span class="lineNum">    1361 </span>            :     double loff,roff;
<span class="lineNum">    1362 </span><span class="lineCov">       1805 :     double lmin=0,lmax=0,rmin=0,rmax=0;</span>
<span class="lineNum">    1363 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    1364 </span>            :     
<span class="lineNum">    1365 </span><span class="lineCov">       1805 :     cnt = stem-&gt;chunk_cnt;</span>
<span class="lineNum">    1366 </span>            :     
<span class="lineNum">    1367 </span><span class="lineCov">       3357 :     for ( i=0 ; i&lt;stem-&gt;chunk_cnt; i++ ) {</span>
<span class="lineNum">    1368 </span><span class="lineCov">       2154 :         if( stem-&gt;chunks[i].stub &amp; mask )</span>
<span class="lineNum">    1369 </span><span class="lineCov">        602 :     break;</span>
<span class="lineNum">    1370 </span>            :     }
<span class="lineNum">    1371 </span><span class="lineCov">       1805 :     if ( i == stem-&gt;chunk_cnt )</span>
<span class="lineNum">    1372 </span><span class="lineCov">       1203 : return( false );    </span>
<span class="lineNum">    1373 </span><span class="lineCov">        602 :     if ( stem-&gt;chunk_cnt == 1 )</span>
<span class="lineNum">    1374 </span><span class="lineCov">        461 : return( true );</span>
<span class="lineNum">    1375 </span>            :     
<span class="lineNum">    1376 </span><span class="lineCov">        497 :     for ( i=0;i&lt;cnt;i++ ) {</span>
<span class="lineNum">    1377 </span><span class="lineCov">        356 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    1378 </span>            :         
<span class="lineNum">    1379 </span><span class="lineCov">        356 :         if ( chunk-&gt;l != NULL ) {</span>
<span class="lineNum">    1380 </span><span class="lineCov">        700 :             loff = ( chunk-&gt;l-&gt;sp-&gt;me.x - stem-&gt;left.x ) * !is_x -</span>
<span class="lineNum">    1381 </span><span class="lineCov">        350 :                    ( chunk-&gt;l-&gt;sp-&gt;me.y - stem-&gt;left.y ) * is_x;</span>
<span class="lineNum">    1382 </span><span class="lineCov">        350 :             if ( loff &lt; lmin ) lmin = loff;</span>
<span class="lineNum">    1383 </span><span class="lineCov">        289 :             else if ( loff &gt; lmax ) lmax = loff;</span>
<span class="lineNum">    1384 </span>            :         }
<span class="lineNum">    1385 </span><span class="lineCov">        356 :         if ( chunk-&gt;r != NULL ) {</span>
<span class="lineNum">    1386 </span><span class="lineCov">        698 :             roff = ( chunk-&gt;r-&gt;sp-&gt;me.x - stem-&gt;right.x ) * !is_x -</span>
<span class="lineNum">    1387 </span><span class="lineCov">        349 :                    ( chunk-&gt;r-&gt;sp-&gt;me.y - stem-&gt;right.y ) * is_x;</span>
<span class="lineNum">    1388 </span><span class="lineCov">        349 :             if ( roff &lt; rmin ) rmin = roff;</span>
<span class="lineNum">    1389 </span><span class="lineCov">        276 :             else if ( roff &gt; rmax ) rmax = roff;</span>
<span class="lineNum">    1390 </span>            :         }
<span class="lineNum">    1391 </span>            :     }
<span class="lineNum">    1392 </span><span class="lineCov">        141 :     if ((( lmax - lmin ) &lt; 2*dist_error_hv ) &amp;&amp; (( rmax - rmin ) &lt; 2*dist_error_hv ))</span>
<span class="lineNum">    1393 </span><span class="lineCov">          6 : return( true );</span>
<span class="lineNum">    1394 </span><span class="lineCov">        135 : return( false );</span>
<a name="1395"><span class="lineNum">    1395 </span>            : }</a>
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span><span class="lineCov">       8251 : static int LineFitsHV( struct linedata *line ) {</span>
<span class="lineNum">    1398 </span>            :     int i,cnt,is_x,hv;
<span class="lineNum">    1399 </span><span class="lineCov">       8251 :     double off,min=0,max=0;</span>
<span class="lineNum">    1400 </span>            :     struct pointdata *pd;
<span class="lineNum">    1401 </span>            :     
<span class="lineNum">    1402 </span><span class="lineCov">       8251 :     cnt = line-&gt;pcnt;</span>
<span class="lineNum">    1403 </span><span class="lineCov">       8251 :     hv = IsUnitHV( &amp;line-&gt;unit,true );</span>
<span class="lineNum">    1404 </span><span class="lineCov">       8251 :     if ( hv )</span>
<span class="lineNum">    1405 </span><span class="lineCov">       8245 : return( true );</span>
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span><span class="lineCov">          6 :     hv = IsUnitHV( &amp;line-&gt;unit,false );</span>
<span class="lineNum">    1408 </span><span class="lineCov">          6 :     if ( !hv )</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    1410 </span>            :     
<span class="lineNum">    1411 </span><span class="lineCov">          6 :     is_x = ( hv == 1 ) ? 1 : 0;</span>
<span class="lineNum">    1412 </span><span class="lineCov">         25 :     for ( i=0;i&lt;cnt;i++ ) {</span>
<span class="lineNum">    1413 </span><span class="lineCov">         19 :         pd = line-&gt;points[i];</span>
<span class="lineNum">    1414 </span>            :         
<span class="lineNum">    1415 </span><span class="lineCov">         38 :         off =   ( pd-&gt;base.x - line-&gt;online.x ) * !is_x -</span>
<span class="lineNum">    1416 </span><span class="lineCov">         19 :                 ( pd-&gt;base.y - line-&gt;online.y ) * is_x;</span>
<span class="lineNum">    1417 </span><span class="lineCov">         19 :         if ( off &lt; min ) min = off;</span>
<span class="lineNum">    1418 </span><span class="lineCov">         15 :         else if ( off &gt; max ) max = off;</span>
<span class="lineNum">    1419 </span>            :     }
<span class="lineNum">    1420 </span><span class="lineCov">          6 :     if (( max - min ) &lt; 2*dist_error_hv )</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    1422 </span><span class="lineCov">          6 : return( false );</span>
<a name="1423"><span class="lineNum">    1423 </span>            : }</a>
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span><span class="lineCov">     204770 : static int OnStem( struct stemdata *stem,BasePoint *test,int left ) {</span>
<span class="lineNum">    1426 </span>            :     double dist_error, off;
<span class="lineNum">    1427 </span><span class="lineCov">     204770 :     BasePoint *dir = &amp;stem-&gt;unit;</span>
<span class="lineNum">    1428 </span><span class="lineCov">     204770 :     double max=0, min=0;</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :     /* Diagonals are harder to align */
<span class="lineNum">    1431 </span><span class="lineCov">     204770 :     dist_error = IsUnitHV( dir,true ) ? dist_error_hv : dist_error_diag;</span>
<span class="lineNum">    1432 </span><span class="lineCov">     204770 :     if ( !stem-&gt;positioned ) dist_error = dist_error * 2;</span>
<span class="lineNum">    1433 </span><span class="lineCov">     204770 :     if ( dist_error &gt; stem-&gt;width/2 ) dist_error = stem-&gt;width/2;</span>
<span class="lineNum">    1434 </span><span class="lineCov">     204770 :     if ( left ) {</span>
<span class="lineNum">    1435 </span><span class="lineCov">     103648 :         off = (test-&gt;x - stem-&gt;left.x)*dir-&gt;y - (test-&gt;y - stem-&gt;left.y)*dir-&gt;x;</span>
<span class="lineNum">    1436 </span><span class="lineCov">     103648 :         max = stem-&gt;lmax; min = stem-&gt;lmin;</span>
<span class="lineNum">    1437 </span>            :     } else {
<span class="lineNum">    1438 </span><span class="lineCov">     101122 :         off = (test-&gt;x - stem-&gt;right.x)*dir-&gt;y - (test-&gt;y - stem-&gt;right.y)*dir-&gt;x;</span>
<span class="lineNum">    1439 </span><span class="lineCov">     101122 :         max = stem-&gt;rmax; min = stem-&gt;rmin;</span>
<span class="lineNum">    1440 </span>            :     }
<span class="lineNum">    1441 </span>            :     
<span class="lineNum">    1442 </span><span class="lineCov">     204770 :     if ( off &gt; ( max - dist_error ) &amp;&amp; off &lt; ( min + dist_error ) )</span>
<span class="lineNum">    1443 </span><span class="lineCov">     103074 : return( true );</span>
<span class="lineNum">    1444 </span>            : 
<span class="lineNum">    1445 </span><span class="lineCov">     101696 : return( false );</span>
<a name="1446"><span class="lineNum">    1446 </span>            : }</a>
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineCov">      74474 : static int BothOnStem( struct stemdata *stem,BasePoint *test1,BasePoint *test2,</span>
<span class="lineNum">    1449 </span>            :     int force_hv,int strict,int cove ) {
<span class="lineNum">    1450 </span>            :     double dist_error, off1, off2;
<span class="lineNum">    1451 </span><span class="lineCov">      74474 :     BasePoint dir = stem-&gt;unit;</span>
<span class="lineNum">    1452 </span>            :     int hv, hv_strict;
<span class="lineNum">    1453 </span><span class="lineCov">      74474 :     double lmax=0, lmin=0, rmax=0, rmin=0;</span>
<span class="lineNum">    1454 </span>            :     
<span class="lineNum">    1455 </span><span class="lineCov">      74474 :     hv = ( force_hv ) ? IsUnitHV( &amp;dir,false ) : IsUnitHV( &amp;dir,true );</span>
<span class="lineNum">    1456 </span><span class="lineCov">      74474 :     hv_strict = ( force_hv ) ? IsUnitHV( &amp;dir,true ) : hv;</span>
<span class="lineNum">    1457 </span><span class="lineCov">      74474 :     if ( force_hv ) {</span>
<span class="lineNum">    1458 </span><span class="lineCov">      36623 :         if ( force_hv != hv )</span>
<span class="lineNum">    1459 </span><span class="lineCov">      21812 : return( false );</span>
<span class="lineNum">    1460 </span><span class="lineCov">      14811 :         if ( !hv_strict &amp;&amp; !StemFitsHV( stem,( hv == 1 ),7 ))</span>
<span class="lineNum">    1461 </span><span class="lineCov">        810 : return( false );</span>
<span class="lineNum">    1462 </span><span class="lineCov">      14001 :         if ( !hv_strict ) {</span>
<span class="lineNum">    1463 </span><span class="lineCov">        315 :             dir.x = ( force_hv == 2 ) ? 0 : 1;</span>
<span class="lineNum">    1464 </span><span class="lineCov">        315 :             dir.y = ( force_hv == 2 ) ? 1 : 0;</span>
<span class="lineNum">    1465 </span>            :         }
<span class="lineNum">    1466 </span>            :     }
<span class="lineNum">    1467 </span>            :     /* Diagonals are harder to align */
<span class="lineNum">    1468 </span><span class="lineCov">      51852 :     dist_error = ( hv ) ? dist_error_hv : dist_error_diag;</span>
<span class="lineNum">    1469 </span><span class="lineCov">      51852 :     if ( !strict ) {</span>
<span class="lineNum">    1470 </span><span class="lineCov">      27257 :         dist_error = dist_error * 2;</span>
<span class="lineNum">    1471 </span><span class="lineCov">      27257 :         lmax = stem-&gt;lmax; lmin = stem-&gt;lmin;</span>
<span class="lineNum">    1472 </span><span class="lineCov">      27257 :         rmax = stem-&gt;rmax; rmin = stem-&gt;rmin;</span>
<span class="lineNum">    1473 </span>            :     }
<span class="lineNum">    1474 </span><span class="lineCov">      51852 :     if ( dist_error &gt; stem-&gt;width/2 ) dist_error = stem-&gt;width/2;</span>
<span class="lineNum">    1475 </span>            : 
<span class="lineNum">    1476 </span><span class="lineCov">      51852 :     off1 = (test1-&gt;x-stem-&gt;left.x)*dir.y - (test1-&gt;y-stem-&gt;left.y)*dir.x;</span>
<span class="lineNum">    1477 </span><span class="lineCov">      51852 :     off2 = (test2-&gt;x-stem-&gt;right.x)*dir.y - (test2-&gt;y-stem-&gt;right.y)*dir.x;</span>
<span class="lineNum">    1478 </span><span class="lineCov">      58174 :     if (off1 &gt; ( lmax - dist_error ) &amp;&amp; off1 &lt; ( lmin + dist_error ) &amp;&amp;</span>
<span class="lineNum">    1479 </span><span class="lineCov">      11607 :         off2 &gt; ( rmax - dist_error ) &amp;&amp; off2 &lt; ( rmin + dist_error )) {</span>
<span class="lineNum">    1480 </span>            :         /* For some reasons in my patch from Feb 24 2008 I prohibited snapping */
<span class="lineNum">    1481 </span>            :         /* to stems point pairs which together form a bend, if at least */
<span class="lineNum">    1482 </span>            :         /* one point from the pair doesn't have exactly the same position as */
<span class="lineNum">    1483 </span>            :         /* the stem edge. Unfortunately I don't remember why I did this, but */
<span class="lineNum">    1484 </span>            :         /* this behavior has at least one obviously negative effect: it */
<span class="lineNum">    1485 </span>            :         /* prevents building a stem from chunks which describe an ark   */
<span class="lineNum">    1486 </span>            :         /* intersected by some straight lines, even if the intersections lie */
<span class="lineNum">    1487 </span>            :         /* closely enough to the ark extremum. So don't apply this test */
<span class="lineNum">    1488 </span>            :         /* at least if the force_hv flag is on (which means either the  */
<span class="lineNum">    1489 </span>            :         /* chunk or the stem itself is not exactly horizontal/vertical) */
<span class="lineNum">    1490 </span><span class="lineCov">       3866 :         if ( !cove || force_hv || off1 == 0 || off2 == 0 )</span>
<span class="lineNum">    1491 </span><span class="lineCov">       3856 : return( true );</span>
<span class="lineNum">    1492 </span>            :     }
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineCov">      47996 :     off2 = (test2-&gt;x-stem-&gt;left.x)*dir.y - (test2-&gt;y-stem-&gt;left.y)*dir.x;</span>
<span class="lineNum">    1495 </span><span class="lineCov">      47996 :     off1 = (test1-&gt;x-stem-&gt;right.x)*dir.y - (test1-&gt;y-stem-&gt;right.y)*dir.x;</span>
<span class="lineNum">    1496 </span><span class="lineCov">      55776 :     if (off2 &gt; ( lmax - dist_error ) &amp;&amp; off2 &lt; ( lmin + dist_error ) &amp;&amp;</span>
<span class="lineNum">    1497 </span><span class="lineCov">      14121 :         off1 &gt; ( rmax - dist_error ) &amp;&amp; off1 &lt; ( rmin + dist_error )) {</span>
<span class="lineNum">    1498 </span><span class="lineCov">       4017 :         if ( !cove || force_hv || off1 == 0 || off2 == 0 )</span>
<span class="lineNum">    1499 </span><span class="lineCov">       4011 : return( true );</span>
<span class="lineNum">    1500 </span>            :     }
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span><span class="lineCov">      43985 : return( false );</span>
<a name="1503"><span class="lineNum">    1503 </span>            : }</a>
<span class="lineNum">    1504 </span>            : 
<span class="lineNum">    1505 </span><span class="lineCov">       7315 : static int RecalcStemOffsets( struct stemdata *stem,BasePoint *dir,int left,int right ) {</span>
<span class="lineNum">    1506 </span>            :     double off, err;
<span class="lineNum">    1507 </span><span class="lineCov">       7315 :     double lmin=0, lmax=0, rmin=0, rmax=0;</span>
<span class="lineNum">    1508 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    1509 </span>            :     int i;
<span class="lineNum">    1510 </span>            :     
<span class="lineNum">    1511 </span><span class="lineCov">       7315 :     if ( !left &amp;&amp; !right )</span>
<span class="lineNum">    1512 </span><span class="lineCov">       2449 : return( false );</span>
<span class="lineNum">    1513 </span><span class="lineCov">       4866 :     err = ( IsUnitHV( dir,true )) ? dist_error_hv : dist_error_diag;</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span><span class="lineCov">      14706 :     if ( stem-&gt;chunk_cnt &gt; 1 ) for ( i=0; i&lt;stem-&gt;chunk_cnt; i++ ) {</span>
<span class="lineNum">    1516 </span><span class="lineCov">       9840 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    1517 </span><span class="lineCov">       9840 :         if ( left &amp;&amp; chunk-&gt;l != NULL ) {</span>
<span class="lineNum">    1518 </span><span class="lineCov">      18590 :             off =  ( chunk-&gt;l-&gt;sp-&gt;me.x - stem-&gt;left.x )*dir-&gt;y -</span>
<span class="lineNum">    1519 </span><span class="lineCov">       9295 :                    ( chunk-&gt;l-&gt;sp-&gt;me.y - stem-&gt;left.y )*dir-&gt;x;</span>
<span class="lineNum">    1520 </span><span class="lineCov">       9295 :             if ( off &lt; lmin ) lmin = off;</span>
<span class="lineNum">    1521 </span><span class="lineCov">       7555 :             else if ( off &gt; lmax ) lmax = off;</span>
<span class="lineNum">    1522 </span>            :         }
<span class="lineNum">    1523 </span><span class="lineCov">       9840 :         if ( right &amp;&amp; chunk-&gt;r != NULL ) {</span>
<span class="lineNum">    1524 </span><span class="lineCov">      18588 :             off =  ( chunk-&gt;r-&gt;sp-&gt;me.x - stem-&gt;right.x )*dir-&gt;y +</span>
<span class="lineNum">    1525 </span><span class="lineCov">       9294 :                    ( chunk-&gt;r-&gt;sp-&gt;me.y - stem-&gt;right.y )*dir-&gt;x;</span>
<span class="lineNum">    1526 </span><span class="lineCov">       9294 :             if ( off &lt; rmin ) rmin = off;</span>
<span class="lineNum">    1527 </span><span class="lineCov">       7598 :             else if ( off &gt; rmax ) rmax = off;</span>
<span class="lineNum">    1528 </span>            :         }
<span class="lineNum">    1529 </span>            :     }
<span class="lineNum">    1530 </span><span class="lineCov">       4866 :     if ( lmax - lmin &lt; 2*err &amp;&amp; rmax - rmin &lt; 2*err ) {</span>
<span class="lineNum">    1531 </span><span class="lineCov">       2151 :         stem-&gt;lmin = lmin; stem-&gt;lmax = lmax;</span>
<span class="lineNum">    1532 </span><span class="lineCov">       2151 :         stem-&gt;rmin = rmin; stem-&gt;rmax = rmax;</span>
<span class="lineNum">    1533 </span><span class="lineCov">       2151 : return( true );</span>
<span class="lineNum">    1534 </span>            :     }
<span class="lineNum">    1535 </span><span class="lineCov">       2715 : return( false );</span>
<a name="1536"><span class="lineNum">    1536 </span>            : }</a>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span><span class="lineCov">        764 : static void SetStemUnit( struct stemdata *stem,BasePoint dir ) {</span>
<span class="lineNum">    1539 </span>            :     double width;
<span class="lineNum">    1540 </span>            :     
<span class="lineNum">    1541 </span><span class="lineCov">       1528 :     width = ( stem-&gt;right.x - stem-&gt;left.x ) * dir.y -</span>
<span class="lineNum">    1542 </span><span class="lineCov">        764 :             ( stem-&gt;right.y - stem-&gt;left.y ) * dir.x;</span>
<span class="lineNum">    1543 </span><span class="lineCov">        764 :     if ( width &lt; 0 ) {</span>
<span class="lineNum">    1544 </span><span class="lineCov">          3 :         width = -width;</span>
<span class="lineNum">    1545 </span><span class="lineCov">          3 :         dir.x = -dir.x;</span>
<span class="lineNum">    1546 </span><span class="lineCov">          3 :         dir.y = -dir.y;</span>
<span class="lineNum">    1547 </span>            :     }
<span class="lineNum">    1548 </span><span class="lineCov">        764 :     stem-&gt;unit = dir;</span>
<span class="lineNum">    1549 </span><span class="lineCov">        764 :     stem-&gt;width = width;</span>
<span class="lineNum">    1550 </span>            :     
<span class="lineNum">    1551 </span>            :     /* Guess at which normal we want */
<span class="lineNum">    1552 </span><span class="lineCov">        764 :     stem-&gt;l_to_r.x = dir.y; stem-&gt;l_to_r.y = -dir.x;</span>
<span class="lineNum">    1553 </span>            :     /* If we guessed wrong, use the other */
<span class="lineNum">    1554 </span><span class="lineCov">       1528 :     if (( stem-&gt;right.x-stem-&gt;left.x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    1555 </span><span class="lineCov">        764 :         ( stem-&gt;right.y-stem-&gt;left.y )*stem-&gt;l_to_r.y &lt; 0 ) {</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :         stem-&gt;l_to_r.x = -stem-&gt;l_to_r.x;</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :         stem-&gt;l_to_r.y = -stem-&gt;l_to_r.y;</span>
<span class="lineNum">    1558 </span>            :     }
<span class="lineNum">    1559 </span>            :     
<span class="lineNum">    1560 </span>            :     /* Recalculate left/right offsets relatively to new vectors */
<span class="lineNum">    1561 </span><span class="lineCov">        764 :     RecalcStemOffsets( stem,&amp;dir,true,true );</span>
<a name="1562"><span class="lineNum">    1562 </span><span class="lineCov">        764 : }</span></a>
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineCov">      48253 : static struct stem_chunk *AddToStem( struct glyphdata *gd,struct stemdata *stem,</span>
<span class="lineNum">    1565 </span>            :     struct pointdata *pd1,struct pointdata *pd2,int is_next1, int is_next2, int cheat ) {
<span class="lineNum">    1566 </span>            :     
<span class="lineNum">    1567 </span><span class="lineCov">      48253 :     int is_potential1 = false, is_potential2 = true;</span>
<span class="lineNum">    1568 </span><span class="lineCov">      48253 :     struct stem_chunk *chunk=NULL;</span>
<span class="lineNum">    1569 </span><span class="lineCov">      48253 :     BasePoint *dir = &amp;stem-&gt;unit;</span>
<span class="lineNum">    1570 </span>            :     BasePoint *test;
<span class="lineNum">    1571 </span><span class="lineCov">      48253 :     int lincr = 1, rincr = 1;</span>
<span class="lineNum">    1572 </span>            :     double off, dist_error;
<span class="lineNum">    1573 </span><span class="lineCov">      48253 :     double loff = 0, roff = 0;</span>
<span class="lineNum">    1574 </span><span class="lineCov">      48253 :     double min = 0, max = 0;</span>
<span class="lineNum">    1575 </span>            :     int i, in, ip, cpidx;
<span class="lineNum">    1576 </span>            :     struct pointdata *pd, *npd, *ppd;
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineCov">      48253 :     if ( cheat || stem-&gt;positioned ) is_potential2 = false;</span>
<span class="lineNum">    1579 </span>            :     /* Diagonals are harder to align */
<span class="lineNum">    1580 </span><span class="lineCov">      48253 :     dist_error = IsUnitHV( dir,true ) ? 2*dist_error_hv : 2*dist_error_diag;</span>
<span class="lineNum">    1581 </span><span class="lineCov">      48253 :     if ( dist_error &gt; stem-&gt;width/2 ) dist_error = stem-&gt;width/2;</span>
<span class="lineNum">    1582 </span><span class="lineCov">      48253 :     max = stem-&gt;lmax;</span>
<span class="lineNum">    1583 </span><span class="lineCov">      48253 :     min = stem-&gt;lmin;</span>
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :     /* The following swaps &quot;left&quot; and &quot;right&quot; points in case we have */
<span class="lineNum">    1586 </span>            :     /* started checking relatively to a wrong edge */
<span class="lineNum">    1587 </span><span class="lineCov">      48253 :     if ( pd1 != NULL ) {</span>
<span class="lineNum">    1588 </span><span class="lineCov">      43508 :         test = &amp;pd1-&gt;base;</span>
<span class="lineNum">    1589 </span><span class="lineCov">      87016 :         off =   ( test-&gt;x - stem-&gt;left.x )*dir-&gt;y - </span>
<span class="lineNum">    1590 </span><span class="lineCov">      43508 :                 ( test-&gt;y - stem-&gt;left.y )*dir-&gt;x;</span>
<span class="lineNum">    1591 </span><span class="lineCov">      85816 :         if (( !stem-&gt;ghost &amp;&amp;</span>
<span class="lineNum">    1592 </span><span class="lineCov">     108634 :             ( off &lt; ( max - dist_error ) || off &gt; ( min + dist_error ))) ||</span>
<span class="lineNum">    1593 </span><span class="lineCov">      59636 :             ( RealNear( stem-&gt;unit.x, 1) &amp;&amp; stem-&gt;ghost &amp;&amp; stem-&gt;width == 21 ) ||</span>
<span class="lineNum">    1594 </span><span class="lineCov">      33019 :             ( RealNear( stem-&gt;unit.x,0 ) &amp;&amp; stem-&gt;ghost &amp;&amp; stem-&gt;width == 20 )) {</span>
<span class="lineNum">    1595 </span><span class="lineCov">      19513 :             pd = pd1; pd1 = pd2; pd2 = pd;</span>
<span class="lineNum">    1596 </span><span class="lineCov">      19513 :             in = is_next1; is_next1 = is_next2; is_next2 = in;</span>
<span class="lineNum">    1597 </span><span class="lineCov">      19513 :             ip = is_potential1; is_potential1 = is_potential2; is_potential2 = ip;</span>
<span class="lineNum">    1598 </span>            :         }
<span class="lineNum">    1599 </span>            :     }
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineCov">      48253 :     if ( pd1 == NULL ) lincr = 0;</span>
<span class="lineNum">    1602 </span><span class="lineCov">      48253 :     if ( pd2 == NULL ) rincr = 0;</span>
<span class="lineNum">    1603 </span>            :     /* Now run through existing stem chunks and see if the chunk we are */
<span class="lineNum">    1604 </span>            :     /* going to add doesn't duplicate an existing one.*/
<span class="lineNum">    1605 </span><span class="lineCov">      83677 :     for ( i=stem-&gt;chunk_cnt-1; i&gt;=0; --i ) {</span>
<span class="lineNum">    1606 </span><span class="lineCov">      57801 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    1607 </span><span class="lineCov">      57801 :         if ( chunk-&gt;l == pd1 ) lincr = 0;</span>
<span class="lineNum">    1608 </span><span class="lineCov">      57801 :         if ( chunk-&gt;r == pd2 ) rincr = 0;</span>
<span class="lineNum">    1609 </span>            :         
<span class="lineNum">    1610 </span><span class="lineCov">      57801 :         if (( chunk-&gt;l == pd1 || pd1 == NULL ) &amp;&amp; ( chunk-&gt;r == pd2 || pd2 == NULL )) {</span>
<span class="lineNum">    1611 </span><span class="lineCov">      21826 :             if ( !is_potential1 ) chunk-&gt;lpotential = false;</span>
<span class="lineNum">    1612 </span><span class="lineCov">      21826 :             if ( !is_potential2 ) chunk-&gt;rpotential = false;</span>
<span class="lineNum">    1613 </span><span class="lineCov">      21826 :     break;</span>
<span class="lineNum">    1614 </span><span class="lineCov">      35975 :         } else if (( chunk-&gt;l == pd1 &amp;&amp; chunk-&gt;r == NULL ) || ( chunk-&gt;r == pd2 &amp;&amp; chunk-&gt;l == NULL )) {</span>
<span class="lineNum">    1615 </span><span class="lineCov">        551 :             if ( chunk-&gt;l == NULL ) {</span>
<span class="lineNum">    1616 </span><span class="lineCov">        273 :                 chunk-&gt;l = pd1;</span>
<span class="lineNum">    1617 </span><span class="lineCov">        273 :                 chunk-&gt;lpotential = is_potential1;</span>
<span class="lineNum">    1618 </span><span class="lineCov">        273 :                 chunk-&gt;lnext = is_next1;</span>
<span class="lineNum">    1619 </span><span class="lineCov">        273 :                 chunk-&gt;ltick = lincr;</span>
<span class="lineNum">    1620 </span><span class="lineCov">        278 :             } else if ( chunk-&gt;r == NULL ) {</span>
<span class="lineNum">    1621 </span><span class="lineCov">        278 :                 chunk-&gt;r = pd2;</span>
<span class="lineNum">    1622 </span><span class="lineCov">        278 :                 chunk-&gt;rpotential = is_potential2;</span>
<span class="lineNum">    1623 </span><span class="lineCov">        278 :                 chunk-&gt;rnext = is_next2;</span>
<span class="lineNum">    1624 </span><span class="lineCov">        278 :                 chunk-&gt;rtick = rincr;</span>
<span class="lineNum">    1625 </span>            :             }
<span class="lineNum">    1626 </span><span class="lineCov">        551 :     break;</span>
<span class="lineNum">    1627 </span>            :         }
<span class="lineNum">    1628 </span>            :     }
<span class="lineNum">    1629 </span>            : 
<span class="lineNum">    1630 </span><span class="lineCov">      48253 :     if ( i&lt;0 ) {</span>
<span class="lineNum">    1631 </span><span class="lineCov">      25876 :         stem-&gt;chunks = realloc(stem-&gt;chunks,(stem-&gt;chunk_cnt+1)*sizeof(struct stem_chunk));</span>
<span class="lineNum">    1632 </span><span class="lineCov">      25876 :         chunk = &amp;stem-&gt;chunks[stem-&gt;chunk_cnt++];</span>
<span class="lineNum">    1633 </span><span class="lineCov">      25876 :         chunk-&gt;parent = stem;</span>
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineCov">      25876 :         chunk-&gt;l = pd1; chunk-&gt;lpotential = is_potential1;</span>
<span class="lineNum">    1636 </span><span class="lineCov">      25876 :         chunk-&gt;r = pd2; chunk-&gt;rpotential = is_potential2;</span>
<span class="lineNum">    1637 </span><span class="lineCov">      25876 :         chunk-&gt;ltick = lincr; chunk-&gt;rtick = rincr;</span>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineCov">      25876 :         chunk-&gt;lnext = is_next1;</span>
<span class="lineNum">    1640 </span><span class="lineCov">      25876 :         chunk-&gt;rnext = is_next2;</span>
<span class="lineNum">    1641 </span><span class="lineCov">      25876 :         chunk-&gt;stemcheat = cheat;</span>
<span class="lineNum">    1642 </span><span class="lineCov">      25876 :         chunk-&gt;stub = chunk-&gt;is_ball = false;</span>
<span class="lineNum">    1643 </span><span class="lineCov">      25876 :         chunk-&gt;l_e_idx = chunk-&gt;r_e_idx = 0;</span>
<span class="lineNum">    1644 </span>            :     }
<span class="lineNum">    1645 </span>            :         
<span class="lineNum">    1646 </span><span class="lineCov">      48253 :     if ( pd1!=NULL ) {</span>
<span class="lineNum">    1647 </span><span class="lineCov">      86696 :         loff =  ( pd1-&gt;base.x - stem-&gt;left.x ) * stem-&gt;l_to_r.x +</span>
<span class="lineNum">    1648 </span><span class="lineCov">      43348 :                 ( pd1-&gt;base.y - stem-&gt;left.y ) * stem-&gt;l_to_r.y;</span>
<span class="lineNum">    1649 </span><span class="lineCov">      43348 :         if ( is_next1==1 || is_next1==2 || pd1-&gt;colinear ) {</span>
<span class="lineNum">    1650 </span><span class="lineCov">      33979 :             AssignStemToPoint( pd1,stem,true,true );</span>
<span class="lineNum">    1651 </span>            :             /* For quadratic layers assign the stem not only to   */
<span class="lineNum">    1652 </span>            :             /* spline points, but to their control points as well */
<span class="lineNum">    1653 </span>            :             /* (this may be important for TTF instructions */
<span class="lineNum">    1654 </span><span class="lineCov">      33979 :             if ( gd-&gt;order2 &amp;&amp; !pd1-&gt;sp-&gt;nonextcp &amp;&amp; pd1-&gt;sp-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">    1655 </span><span class="lineCov">      12360 :                 cpidx = pd1-&gt;sp-&gt;nextcpindex;</span>
<span class="lineNum">    1656 </span><span class="lineCov">      12360 :                 npd = &amp;gd-&gt;points[cpidx];</span>
<span class="lineNum">    1657 </span><span class="lineCov">      12360 :                 if ( OnStem( stem,&amp;npd-&gt;base,true ))</span>
<span class="lineNum">    1658 </span><span class="lineCov">      11914 :                     AssignStemToPoint( npd,stem,false,true );</span>
<span class="lineNum">    1659 </span>            :             }
<span class="lineNum">    1660 </span>            :         }
<span class="lineNum">    1661 </span><span class="lineCov">      43348 :         if ( is_next1==0 || is_next1==2 || pd1-&gt;colinear  ) {</span>
<span class="lineNum">    1662 </span><span class="lineCov">      33660 :             AssignStemToPoint( pd1,stem,false,true );</span>
<span class="lineNum">    1663 </span><span class="lineCov">      45652 :             if ( gd-&gt;order2 &amp;&amp; !pd1-&gt;sp-&gt;noprevcp &amp;&amp; pd1-&gt;sp-&gt;prev != NULL &amp;&amp;</span>
<span class="lineNum">    1664 </span><span class="lineCov">      11992 :                 pd1-&gt;sp-&gt;prev-&gt;from-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">    1665 </span><span class="lineCov">      11953 :                 cpidx = pd1-&gt;sp-&gt;prev-&gt;from-&gt;nextcpindex;</span>
<span class="lineNum">    1666 </span><span class="lineCov">      11953 :                 ppd = &amp;gd-&gt;points[cpidx];</span>
<span class="lineNum">    1667 </span><span class="lineCov">      11953 :                 if ( OnStem( stem,&amp;ppd-&gt;base,true ))</span>
<span class="lineNum">    1668 </span><span class="lineCov">      11487 :                     AssignStemToPoint( ppd,stem,true,true );</span>
<span class="lineNum">    1669 </span>            :             }
<span class="lineNum">    1670 </span>            :         }
<span class="lineNum">    1671 </span>            :     }
<span class="lineNum">    1672 </span><span class="lineCov">      48253 :     if ( pd2!=NULL ) {</span>
<span class="lineNum">    1673 </span><span class="lineCov">      86454 :         roff =  ( pd2-&gt;base.x - stem-&gt;right.x ) * stem-&gt;l_to_r.x +</span>
<span class="lineNum">    1674 </span><span class="lineCov">      43227 :                 ( pd2-&gt;base.y - stem-&gt;right.y ) * stem-&gt;l_to_r.y;</span>
<span class="lineNum">    1675 </span><span class="lineCov">      43227 :         if ( is_next2==1 || is_next2==2 || pd2-&gt;colinear ) {</span>
<span class="lineNum">    1676 </span><span class="lineCov">      33046 :             AssignStemToPoint( pd2,stem,true,false );</span>
<span class="lineNum">    1677 </span><span class="lineCov">      33046 :             if ( gd-&gt;order2 &amp;&amp; !pd2-&gt;sp-&gt;nonextcp &amp;&amp; pd2-&gt;sp-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">    1678 </span><span class="lineCov">      11805 :                 cpidx = pd2-&gt;sp-&gt;nextcpindex;</span>
<span class="lineNum">    1679 </span><span class="lineCov">      11805 :                 npd = &amp;gd-&gt;points[cpidx];</span>
<span class="lineNum">    1680 </span><span class="lineCov">      11805 :                 if ( OnStem( stem,&amp;npd-&gt;base,false ))</span>
<span class="lineNum">    1681 </span><span class="lineCov">      11355 :                     AssignStemToPoint( npd,stem,false,false );</span>
<span class="lineNum">    1682 </span>            :             }
<span class="lineNum">    1683 </span>            :         }
<span class="lineNum">    1684 </span><span class="lineCov">      43227 :         if ( is_next2==0 || is_next2==2 || pd2-&gt;colinear ) {</span>
<span class="lineNum">    1685 </span><span class="lineCov">      33622 :             AssignStemToPoint( pd2,stem,false,false );</span>
<span class="lineNum">    1686 </span><span class="lineCov">      45756 :             if ( gd-&gt;order2 &amp;&amp; !pd2-&gt;sp-&gt;noprevcp &amp;&amp; pd2-&gt;sp-&gt;prev != NULL &amp;&amp;</span>
<span class="lineNum">    1687 </span><span class="lineCov">      12134 :                 pd2-&gt;sp-&gt;prev-&gt;from-&gt;nextcpindex &lt; gd-&gt;realcnt ) {</span>
<span class="lineNum">    1688 </span><span class="lineCov">      12089 :                 cpidx = pd2-&gt;sp-&gt;prev-&gt;from-&gt;nextcpindex;</span>
<span class="lineNum">    1689 </span><span class="lineCov">      12089 :                 ppd = &amp;gd-&gt;points[cpidx];</span>
<span class="lineNum">    1690 </span><span class="lineCov">      12089 :                 if ( OnStem( stem,&amp;ppd-&gt;base,false ))</span>
<span class="lineNum">    1691 </span><span class="lineCov">      11632 :                     AssignStemToPoint( ppd,stem,true,false );</span>
<span class="lineNum">    1692 </span>            :             }
<span class="lineNum">    1693 </span>            :         }
<span class="lineNum">    1694 </span>            :     }
<span class="lineNum">    1695 </span><span class="lineCov">      48253 :     if ( loff &lt; stem-&gt;lmin ) stem-&gt;lmin = loff;</span>
<span class="lineNum">    1696 </span><span class="lineCov">      47564 :     else if ( loff &gt; stem-&gt;lmax ) stem-&gt;lmax = loff;</span>
<span class="lineNum">    1697 </span><span class="lineCov">      48253 :     if ( roff &lt; stem-&gt;rmin ) stem-&gt;rmin = roff;</span>
<span class="lineNum">    1698 </span><span class="lineCov">      47493 :     else if ( roff &gt; stem-&gt;rmax ) stem-&gt;rmax = roff;</span>
<span class="lineNum">    1699 </span><span class="lineCov">      48253 :     stem-&gt;lpcnt += lincr; stem-&gt;rpcnt += rincr;</span>
<span class="lineNum">    1700 </span><span class="lineCov">      48253 : return( chunk );</span>
<a name="1701"><span class="lineNum">    1701 </span>            : }</a>
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span><span class="lineCov">      43519 : static struct stemdata *FindStem( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    1704 </span>            :     struct pointdata *pd2,BasePoint *dir,int is_next2,int de ) {
<span class="lineNum">    1705 </span>            :     
<span class="lineNum">    1706 </span>            :     int i, cove, test_left, hv, stemcnt;
<span class="lineNum">    1707 </span>            :     struct stemdata *stem;
<span class="lineNum">    1708 </span>            :     SplinePoint *match;
<span class="lineNum">    1709 </span>            :     BasePoint newdir;
<span class="lineNum">    1710 </span>            : 
<span class="lineNum">    1711 </span><span class="lineCov">      43519 :     match = pd2-&gt;sp;</span>
<span class="lineNum">    1712 </span><span class="lineCov">      43519 :     stemcnt = ( is_next2 ) ? pd2-&gt;nextcnt : pd2-&gt;prevcnt;</span>
<span class="lineNum">    1713 </span>            :     
<span class="lineNum">    1714 </span><span class="lineCov">      47865 :     for ( i=0; i&lt;stemcnt; i++ ) {</span>
<span class="lineNum">    1715 </span><span class="lineCov">      26171 :         stem = ( is_next2 ) ? pd2-&gt;nextstems[i] : pd2-&gt;prevstems[i];</span>
<span class="lineNum">    1716 </span><span class="lineCov">      26171 :         test_left = ( is_next2 ) ? !pd2-&gt;next_is_l[i] : !pd2-&gt;prev_is_l[i];</span>
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span><span class="lineCov">      51598 :         if (UnitsParallel( &amp;stem-&gt;unit,dir,true ) &amp;&amp; </span>
<span class="lineNum">    1719 </span><span class="lineCov">      25427 :             OnStem( stem,&amp;pd-&gt;sp-&gt;me,test_left ))</span>
<span class="lineNum">    1720 </span><span class="lineCov">      21825 : return( stem );</span>
<span class="lineNum">    1721 </span>            :     }
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span><span class="lineCov">      44477 :     cove =  ( dir-&gt;x == 0 &amp;&amp; pd-&gt;x_extr + pd2-&gt;x_extr == 3 ) || </span>
<span class="lineNum">    1724 </span><span class="lineCov">      28519 :             ( dir-&gt;y == 0 &amp;&amp; pd-&gt;y_extr + pd2-&gt;y_extr == 3 );</span>
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :     /* First pass to check for strict matches */
<span class="lineNum">    1727 </span><span class="lineCov">      95184 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    1728 </span><span class="lineCov">      80329 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    1729 </span>            :         /* Ghost hints and BBox hits are usually generated after all other   */
<span class="lineNum">    1730 </span>            :         /* hint types, but we can get them here in case we are generating    */
<span class="lineNum">    1731 </span>            :         /* glyph data for a predefined hint layout. In this case they should */
<span class="lineNum">    1732 </span>            :         /* be excluded from the following tests */
<span class="lineNum">    1733 </span><span class="lineCov">      80329 :         if ( stem-&gt;ghost || stem-&gt;bbox )</span>
<span class="lineNum">    1734 </span><span class="lineCov">       2117 :     continue;</span>
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span><span class="lineCov">     102807 :         if ( UnitsParallel( &amp;stem-&gt;unit,dir,true ) &amp;&amp;</span>
<span class="lineNum">    1737 </span><span class="lineCov">      24595 :             BothOnStem( stem,&amp;pd-&gt;sp-&gt;me,&amp;pd2-&gt;sp-&gt;me,false,true,cove )) {</span>
<span class="lineNum">    1738 </span><span class="lineCov">       6839 :  return( stem );</span>
<span class="lineNum">    1739 </span>            :         }
<span class="lineNum">    1740 </span>            :     }
<span class="lineNum">    1741 </span>            :     /* One more pass. At this stage larger deviations are allowed */
<span class="lineNum">    1742 </span><span class="lineCov">      71725 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    1743 </span><span class="lineCov">      57343 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    1744 </span><span class="lineCov">      57343 :         if ( stem-&gt;ghost || stem-&gt;bbox )</span>
<span class="lineNum">    1745 </span><span class="lineCov">       1137 :     continue;</span>
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span><span class="lineCov">      68712 :         if ( UnitsParallel( &amp;stem-&gt;unit,dir,true ) &amp;&amp;</span>
<span class="lineNum">    1748 </span><span class="lineCov">      12506 :             BothOnStem( stem,&amp;pd-&gt;sp-&gt;me,&amp;pd2-&gt;sp-&gt;me,false,false,cove )) {</span>
<span class="lineNum">    1749 </span><span class="lineCov">        473 : return( stem );</span>
<span class="lineNum">    1750 </span>            :         }
<span class="lineNum">    1751 </span>            :     }
<span class="lineNum">    1752 </span><span class="lineCov">      14382 :     if ( de )</span>
<span class="lineNum">    1753 </span><span class="lineCov">          8 : return( NULL );</span>
<span class="lineNum">    1754 </span>            :     
<span class="lineNum">    1755 </span><span class="lineCov">      14374 :     hv = IsUnitHV( dir,false );</span>
<span class="lineNum">    1756 </span><span class="lineCov">      14374 :     if ( !hv )</span>
<span class="lineNum">    1757 </span><span class="lineCov">       2469 : return( NULL );</span>
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span><span class="lineCov">      49047 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    1760 </span><span class="lineCov">      37437 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    1761 </span><span class="lineCov">      37437 :         if ( stem-&gt;ghost || stem-&gt;bbox )</span>
<span class="lineNum">    1762 </span><span class="lineCov">        814 :     continue;</span>
<span class="lineNum">    1763 </span><span class="lineCov">      36623 :         if ( hv &amp;&amp; BothOnStem( stem,&amp;pd-&gt;base,&amp;pd2-&gt;base,hv,false,cove )) {</span>
<span class="lineNum">    1764 </span><span class="lineCov">        295 :             newdir.x = ( hv == 2 ) ? 0 : 1;</span>
<span class="lineNum">    1765 </span><span class="lineCov">        295 :             newdir.y = ( hv == 2 ) ? 1 : 0;</span>
<span class="lineNum">    1766 </span><span class="lineCov">        295 :             if ( hv == 2 &amp;&amp; stem-&gt;unit.y &lt; 0 )</span>
<span class="lineNum">    1767 </span><span class="lineCov">          8 :                 SwapEdges( gd,stem );</span>
<span class="lineNum">    1768 </span><span class="lineCov">        295 :             if ( stem-&gt;unit.x != newdir.x )</span>
<span class="lineNum">    1769 </span><span class="lineCov">         37 :                 SetStemUnit( stem,newdir );</span>
<span class="lineNum">    1770 </span><span class="lineCov">        295 : return( stem );</span>
<span class="lineNum">    1771 </span>            :         }
<span class="lineNum">    1772 </span>            :     }
<span class="lineNum">    1773 </span><span class="lineCov">      11610 : return( NULL );</span>
<a name="1774"><span class="lineNum">    1774 </span>            : }</a>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span><span class="lineCov">      12003 : static struct stemdata *NewStem( struct glyphdata *gd,BasePoint *dir,</span>
<span class="lineNum">    1777 </span>            :     BasePoint *pos1, BasePoint *pos2 ) {
<span class="lineNum">    1778 </span>            :     
<span class="lineNum">    1779 </span><span class="lineCov">      12003 :     struct stemdata * stem = &amp;gd-&gt;stems[gd-&gt;stemcnt++];</span>
<span class="lineNum">    1780 </span>            :     double width;
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span><span class="lineCov">      12003 :     stem-&gt;unit = *dir;</span>
<span class="lineNum">    1783 </span><span class="lineCov">      12003 :     if ( dir-&gt;x &lt; 0 || dir-&gt;y == -1 ) {</span>
<span class="lineNum">    1784 </span><span class="lineCov">       3908 :         stem-&gt;unit.x = -stem-&gt;unit.x;</span>
<span class="lineNum">    1785 </span><span class="lineCov">       3908 :         stem-&gt;unit.y = -stem-&gt;unit.y;</span>
<span class="lineNum">    1786 </span>            :     }
<span class="lineNum">    1787 </span><span class="lineCov">      24006 :     width = ( pos2-&gt;x - pos1-&gt;x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    1788 </span><span class="lineCov">      12003 :             ( pos2-&gt;y - pos1-&gt;y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    1789 </span><span class="lineCov">      12003 :     if ( width &gt; 0 ) {</span>
<span class="lineNum">    1790 </span><span class="lineCov">       7752 :         stem-&gt;left = *pos1;</span>
<span class="lineNum">    1791 </span><span class="lineCov">       7752 :         stem-&gt;right = *pos2;</span>
<span class="lineNum">    1792 </span><span class="lineCov">       7752 :         stem-&gt;width = width;</span>
<span class="lineNum">    1793 </span>            :     } else {
<span class="lineNum">    1794 </span><span class="lineCov">       4251 :         stem-&gt;left = *pos2;</span>
<span class="lineNum">    1795 </span><span class="lineCov">       4251 :         stem-&gt;right = *pos1;</span>
<span class="lineNum">    1796 </span><span class="lineCov">       4251 :         stem-&gt;width = -width;</span>
<span class="lineNum">    1797 </span>            :     }
<span class="lineNum">    1798 </span>            :     /* Guess at which normal we want */
<span class="lineNum">    1799 </span><span class="lineCov">      12003 :     stem-&gt;l_to_r.x = dir-&gt;y; stem-&gt;l_to_r.y = -dir-&gt;x;</span>
<span class="lineNum">    1800 </span>            :     /* If we guessed wrong, use the other */
<span class="lineNum">    1801 </span><span class="lineCov">      24006 :     if (( stem-&gt;right.x-stem-&gt;left.x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    1802 </span><span class="lineCov">      12003 :         ( stem-&gt;right.y-stem-&gt;left.y )*stem-&gt;l_to_r.y &lt; 0 ) {</span>
<span class="lineNum">    1803 </span><span class="lineCov">       3907 :         stem-&gt;l_to_r.x = -stem-&gt;l_to_r.x;</span>
<span class="lineNum">    1804 </span><span class="lineCov">       3907 :         stem-&gt;l_to_r.y = -stem-&gt;l_to_r.y;</span>
<span class="lineNum">    1805 </span>            :     }
<span class="lineNum">    1806 </span><span class="lineCov">      12003 :     stem-&gt;leftidx = stem-&gt;rightidx = -1;</span>
<span class="lineNum">    1807 </span><span class="lineCov">      12003 :     stem-&gt;leftline = stem-&gt;rightline = NULL;</span>
<span class="lineNum">    1808 </span><span class="lineCov">      12003 :     stem-&gt;lmin = stem-&gt;lmax = 0;</span>
<span class="lineNum">    1809 </span><span class="lineCov">      12003 :     stem-&gt;rmin = stem-&gt;rmax = 0;</span>
<span class="lineNum">    1810 </span><span class="lineCov">      12003 :     stem-&gt;ldone = stem-&gt;rdone = false;</span>
<span class="lineNum">    1811 </span><span class="lineCov">      12003 :     stem-&gt;lpcnt = stem-&gt;rpcnt = 0;</span>
<span class="lineNum">    1812 </span><span class="lineCov">      12003 :     stem-&gt;chunks = NULL;</span>
<span class="lineNum">    1813 </span><span class="lineCov">      12003 :     stem-&gt;chunk_cnt = 0;</span>
<span class="lineNum">    1814 </span><span class="lineCov">      12003 :     stem-&gt;ghost = stem-&gt;bbox = false;</span>
<span class="lineNum">    1815 </span><span class="lineCov">      12003 :     stem-&gt;positioned = false;</span>
<span class="lineNum">    1816 </span><span class="lineCov">      12003 :     stem-&gt;blue = -1;</span>
<span class="lineNum">    1817 </span><span class="lineCov">      12003 : return( stem );</span>
<a name="1818"><span class="lineNum">    1818 </span>            : }</a>
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span><span class="lineCov">     214590 : static int ParallelToDir( struct pointdata *pd,int checknext,BasePoint *dir,</span>
<span class="lineNum">    1821 </span>            :     BasePoint *opposite,SplinePoint *basesp,uint8 is_stub ) {
<span class="lineNum">    1822 </span>            :     
<span class="lineNum">    1823 </span><span class="lineCov">     214590 :     BasePoint n, o, *base = &amp;basesp-&gt;me;</span>
<span class="lineNum">    1824 </span>            :     SplinePoint *sp;
<span class="lineNum">    1825 </span><span class="lineCov">     214590 :     double angle, mid_err = ( stem_slope_error + stub_slope_error )/2;</span>
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span><span class="lineCov">     214590 :     sp = pd-&gt;sp;</span>
<span class="lineNum">    1828 </span><span class="lineCov">     214590 :     n = ( checknext ) ? pd-&gt;nextunit : pd-&gt;prevunit;</span>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span><span class="lineCov">     214590 :     angle = fabs( GetUnitAngle( dir,&amp;n ));</span>
<span class="lineNum">    1831 </span><span class="lineCov">     282362 :     if (( !is_stub &amp;&amp; angle &gt; stem_slope_error &amp;&amp; angle &lt; PI - stem_slope_error ) ||</span>
<span class="lineNum">    1832 </span><span class="lineCov">     147298 :         ( is_stub &amp; 1 &amp;&amp; angle &gt; stub_slope_error*1.5 &amp;&amp; angle &lt; PI - stub_slope_error*1.5 ) ||</span>
<span class="lineNum">    1833 </span><span class="lineCov">      69810 :         ( is_stub &amp; 6 &amp;&amp; angle &gt; mid_err &amp;&amp; angle &lt; PI - mid_err ))</span>
<span class="lineNum">    1834 </span><span class="lineCov">     146820 : return( false );</span>
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            :     /* Now sp must be on the same side of the spline as opposite */
<span class="lineNum">    1837 </span><span class="lineCov">      67770 :     o.x = opposite-&gt;x-base-&gt;x; o.y = opposite-&gt;y-base-&gt;y;</span>
<span class="lineNum">    1838 </span><span class="lineCov">      67770 :     n.x = sp-&gt;me.x-base-&gt;x; n.y = sp-&gt;me.y-base-&gt;y;</span>
<span class="lineNum">    1839 </span><span class="lineCov">      67770 :     if ( ( o.x*dir-&gt;y - o.y*dir-&gt;x )*( n.x*dir-&gt;y - n.y*dir-&gt;x ) &lt; 0 )</span>
<span class="lineNum">    1840 </span><span class="lineCov">        450 : return( false );</span>
<span class="lineNum">    1841 </span>            :     
<span class="lineNum">    1842 </span><span class="lineCov">      67320 : return( true );</span>
<a name="1843"><span class="lineNum">    1843 </span>            : }</a>
<span class="lineNum">    1844 </span>            : 
<span class="lineNum">    1845 </span><span class="lineCov">       1616 : static int NearlyParallel( BasePoint *dir,Spline *other, double t ) {</span>
<span class="lineNum">    1846 </span>            :     BasePoint odir;
<span class="lineNum">    1847 </span>            :     double olen;
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span><span class="lineCov">       1616 :     odir.x = (3*other-&gt;splines[0].a*t+2*other-&gt;splines[0].b)*t+other-&gt;splines[0].c;</span>
<span class="lineNum">    1850 </span><span class="lineCov">       1616 :     odir.y = (3*other-&gt;splines[1].a*t+2*other-&gt;splines[1].b)*t+other-&gt;splines[1].c;</span>
<span class="lineNum">    1851 </span><span class="lineCov">       1616 :     olen = sqrt( pow( odir.x,2 ) + pow( odir.y,2 ));</span>
<span class="lineNum">    1852 </span><span class="lineCov">       1616 :     if ( olen==0 )</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    1854 </span><span class="lineCov">       1616 :     odir.x /= olen; odir.y /= olen;</span>
<span class="lineNum">    1855 </span><span class="lineCov">       1616 : return( UnitsParallel( dir,&amp;odir,false ));</span>
<a name="1856"><span class="lineNum">    1856 </span>            : }</a>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span><span class="lineCov">      91440 : static double NormalDist( BasePoint *to, BasePoint *from, BasePoint *perp ) {</span>
<span class="lineNum">    1859 </span><span class="lineCov">      91440 :     double len = (to-&gt;x-from-&gt;x)*perp-&gt;y - (to-&gt;y-from-&gt;y)*perp-&gt;x;</span>
<span class="lineNum">    1860 </span><span class="lineCov">      91440 :     if ( len&lt;0 ) len = -len;</span>
<span class="lineNum">    1861 </span><span class="lineCov">      91440 : return( len );</span>
<a name="1862"><span class="lineNum">    1862 </span>            : }</a>
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span><span class="lineCov">          8 : static struct stemdata *FindOrMakeHVStem( struct glyphdata *gd,</span>
<span class="lineNum">    1865 </span>            :     struct pointdata *pd,struct pointdata *pd2,int is_h,int require_existing ) {
<span class="lineNum">    1866 </span><span class="lineCov">          8 :     int i,cove = false;</span>
<span class="lineNum">    1867 </span>            :     struct stemdata *stem;
<span class="lineNum">    1868 </span>            :     BasePoint dir;
<span class="lineNum">    1869 </span>            : 
<span class="lineNum">    1870 </span><span class="lineCov">          8 :     dir.x = ( is_h ) ? 1 : 0;</span>
<span class="lineNum">    1871 </span><span class="lineCov">          8 :     dir.y = ( is_h ) ? 0 : 1;</span>
<span class="lineNum">    1872 </span><span class="lineCov">          8 :     if ( pd2 != NULL )</span>
<span class="lineNum">    1873 </span><span class="lineCov">         16 :         cove =  ( dir.x == 0 &amp;&amp; pd-&gt;x_extr + pd2-&gt;x_extr == 3 ) || </span>
<span class="lineNum">    1874 </span><span class="lineCov">         16 :                 ( dir.y == 0 &amp;&amp; pd-&gt;y_extr + pd2-&gt;y_extr == 3 );</span>
<span class="lineNum">    1875 </span>            :     
<span class="lineNum">    1876 </span><span class="lineCov">         28 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    1877 </span><span class="lineCov">         20 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    1878 </span><span class="lineCov">         20 :         if ( IsUnitHV( &amp;stem-&gt;unit,true ) &amp;&amp;</span>
<span class="lineNum">    1879 </span><span class="lineCov">         20 :             ( pd2 != NULL &amp;&amp; BothOnStem( stem,&amp;pd-&gt;sp-&gt;me,&amp;pd2-&gt;sp-&gt;me,false,false,cove )))</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1881 </span>            :     }
<span class="lineNum">    1882 </span><span class="lineCov">          8 :     if ( i==gd-&gt;stemcnt ) stem=NULL;</span>
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span><span class="lineCov">          8 :     if ( stem == NULL &amp;&amp; pd2 != NULL &amp;&amp; !require_existing )</span>
<span class="lineNum">    1885 </span><span class="lineNoCov">          0 :         stem = NewStem( gd,&amp;dir,&amp;pd-&gt;sp-&gt;me,&amp;pd2-&gt;sp-&gt;me );</span>
<span class="lineNum">    1886 </span><span class="lineCov">          8 : return( stem );</span>
<a name="1887"><span class="lineNum">    1887 </span>            : }</a>
<span class="lineNum">    1888 </span>            : 
<span class="lineNum">    1889 </span><span class="lineCov">        137 : static int IsDiagonalEnd( struct glyphdata *gd,</span>
<span class="lineNum">    1890 </span>            :     struct pointdata *pd1,struct pointdata *pd2,int is_next,int require_existing ) {
<span class="lineNum">    1891 </span>            :     /* suppose we have something like */
<span class="lineNum">    1892 </span>            :     /*  *--*            */
<span class="lineNum">    1893 </span>            :     /*   \  \           */
<span class="lineNum">    1894 </span>            :     /*    \  \          */
<span class="lineNum">    1895 </span>            :     /* Then let's create a vertical stem between the two points */
<span class="lineNum">    1896 </span>            :     /* (and a horizontal stem if the thing is rotated 90 degrees) */
<span class="lineNum">    1897 </span>            :     double width, length1, length2, dist1, dist2;
<span class="lineNum">    1898 </span>            :     BasePoint *pt1, *pt2, *dir1, *dir2, *prevdir1, *prevdir2;
<span class="lineNum">    1899 </span>            :     SplinePoint *prevsp1, *prevsp2;
<span class="lineNum">    1900 </span>            :     struct pointdata *prevpd1, *prevpd2;
<span class="lineNum">    1901 </span>            :     int hv;
<span class="lineNum">    1902 </span>            : 
<span class="lineNum">    1903 </span><span class="lineCov">        137 :     if ( pd1-&gt;colinear || pd2-&gt;colinear )</span>
<span class="lineNum">    1904 </span><span class="lineCov">         97 : return( false );</span>
<span class="lineNum">    1905 </span><span class="lineCov">         40 :     pt1 = &amp;pd1-&gt;sp-&gt;me; pt2 = &amp;pd2-&gt;sp-&gt;me;</span>
<span class="lineNum">    1906 </span>            :     /* Both key points of a diagonal end stem should have nearly the same */
<span class="lineNum">    1907 </span>            :     /* coordinate by x or y (otherwise we can't determine by which axis   */
<span class="lineNum">    1908 </span>            :     /* it should be hinted) */
<span class="lineNum">    1909 </span><span class="lineCov">         40 :     if ( pt1-&gt;x &gt;= pt2-&gt;x - dist_error_hv &amp;&amp;  pt1-&gt;x &lt;= pt2-&gt;x + dist_error_hv ) {</span>
<span class="lineNum">    1910 </span><span class="lineCov">          8 :         width = pd1-&gt;sp-&gt;me.y - pd2-&gt;sp-&gt;me.y;</span>
<span class="lineNum">    1911 </span><span class="lineCov">          8 :         hv = 1;</span>
<span class="lineNum">    1912 </span><span class="lineCov">         32 :     } else if ( pt1-&gt;y &gt;= pt2-&gt;y - dist_error_hv &amp;&amp;  pt1-&gt;y &lt;= pt2-&gt;y + dist_error_hv ) {</span>
<span class="lineNum">    1913 </span><span class="lineCov">          4 :         width = pd1-&gt;sp-&gt;me.x - pd2-&gt;sp-&gt;me.x;</span>
<span class="lineNum">    1914 </span><span class="lineCov">          4 :         hv = 2;</span>
<span class="lineNum">    1915 </span>            :     } else
<span class="lineNum">    1916 </span><span class="lineCov">         28 : return( false );</span>
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span><span class="lineCov">         12 :     dir1 = ( is_next ) ? &amp;pd1-&gt;nextunit : &amp;pd1-&gt;prevunit;</span>
<span class="lineNum">    1919 </span><span class="lineCov">         12 :     dir2 = ( is_next ) ? &amp;pd2-&gt;prevunit : &amp;pd2-&gt;nextunit;</span>
<span class="lineNum">    1920 </span><span class="lineCov">         12 :     if ( IsUnitHV( dir1,true )) /* Must be diagonal */</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    1922 </span><span class="lineCov">         12 :     prevsp1 = ( is_next ) ? pd1-&gt;sp-&gt;next-&gt;to : pd1-&gt;sp-&gt;prev-&gt;from;</span>
<span class="lineNum">    1923 </span><span class="lineCov">         12 :     prevsp2 = ( is_next ) ? pd2-&gt;sp-&gt;prev-&gt;from : pd2-&gt;sp-&gt;next-&gt;to;</span>
<span class="lineNum">    1924 </span><span class="lineCov">         12 :     prevpd1 = &amp;gd-&gt;points[prevsp1-&gt;ptindex];</span>
<span class="lineNum">    1925 </span><span class="lineCov">         12 :     prevpd2 = &amp;gd-&gt;points[prevsp2-&gt;ptindex];</span>
<span class="lineNum">    1926 </span><span class="lineCov">         12 :     prevdir1 = ( is_next ) ? &amp;prevpd1-&gt;prevunit : &amp;prevpd1-&gt;nextunit;</span>
<span class="lineNum">    1927 </span><span class="lineCov">         12 :     prevdir2 = ( is_next ) ? &amp;prevpd2-&gt;nextunit : &amp;prevpd2-&gt;prevunit;</span>
<span class="lineNum">    1928 </span>            :     /* Ensure we have got a real diagonal, i. e. its sides are parallel */
<span class="lineNum">    1929 </span><span class="lineCov">         12 :     if ( !UnitsParallel( dir1,dir2,true ) || !UnitsParallel( prevdir1,prevdir2,true ))</span>
<span class="lineNum">    1930 </span><span class="lineCov">          4 : return( false );</span>
<span class="lineNum">    1931 </span>            : 
<span class="lineNum">    1932 </span>            :     /* Diagonal width should be smaller than its length */
<span class="lineNum">    1933 </span><span class="lineCov">          8 :     length1 = pow(( prevsp1-&gt;me.x - pt1-&gt;x ),2 ) + pow(( prevsp1-&gt;me.y - pt1-&gt;y ),2 );</span>
<span class="lineNum">    1934 </span><span class="lineCov">          8 :     length2 = pow(( prevsp2-&gt;me.x - pt2-&gt;x ),2 ) + pow(( prevsp2-&gt;me.y - pt2-&gt;y ),2 );</span>
<span class="lineNum">    1935 </span><span class="lineCov">          8 :     if ( length2 &lt; length1 ) length1 = length2;</span>
<span class="lineNum">    1936 </span><span class="lineCov">          8 :     if ( pow( width,2 ) &gt; length1 )</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span>            :     /* Finally exclude too short diagonals where the distance between key   */
<span class="lineNum">    1940 </span>            :     /* points of one edge at the direction orthogonal to the unit vector    */
<span class="lineNum">    1941 </span>            :     /* of the stem we are about to add is smaller than normal HV stem       */
<span class="lineNum">    1942 </span>            :     /* fudge. Such diagonals may be later turned into HV stems, and we will */
<span class="lineNum">    1943 </span>            :     /* result into getting two coincident hints */
<span class="lineNum">    1944 </span><span class="lineCov">          8 :     dist1 = ( hv == 1 ) ? prevsp1-&gt;me.y - pt1-&gt;y : prevsp1-&gt;me.x - pt1-&gt;x;</span>
<span class="lineNum">    1945 </span><span class="lineCov">          8 :     dist2 = ( hv == 1 ) ? prevsp2-&gt;me.y - pt2-&gt;y : prevsp2-&gt;me.x - pt2-&gt;x;</span>
<span class="lineNum">    1946 </span><span class="lineCov">          8 :     if ( dist1 &lt; 0 ) dist1 = -dist1;</span>
<span class="lineNum">    1947 </span><span class="lineCov">          8 :     if ( dist2 &lt; 0 ) dist2 = -dist2;</span>
<span class="lineNum">    1948 </span><span class="lineCov">          8 :     if ( dist1 &lt; 2*dist_error_hv &amp;&amp; dist2 &lt; 2*dist_error_hv )</span>
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span><span class="lineCov">          8 : return( hv );</span>
<a name="1952"><span class="lineNum">    1952 </span>            : }</a>
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span><span class="lineCov">      44386 : static struct stemdata *TestStem( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    1955 </span>            :     BasePoint *dir,SplinePoint *match,int is_next,int is_next2,int require_existing,uint8 is_stub,int eidx ) {
<span class="lineNum">    1956 </span>            :     struct pointdata *pd2;
<span class="lineNum">    1957 </span>            :     struct stemdata *stem, *destem;
<span class="lineNum">    1958 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    1959 </span>            :     struct linedata *otherline;
<span class="lineNum">    1960 </span>            :     double width;
<span class="lineNum">    1961 </span>            :     struct linedata *line, *line2;
<span class="lineNum">    1962 </span>            :     BasePoint *mdir, middle;
<span class="lineNum">    1963 </span><span class="lineCov">      44386 :     int de=false, hv, l_changed;</span>
<span class="lineNum">    1964 </span>            :     
<span class="lineNum">    1965 </span><span class="lineCov">      88772 :     width = ( match-&gt;me.x - pd-&gt;sp-&gt;me.x )*dir-&gt;y - </span>
<span class="lineNum">    1966 </span><span class="lineCov">      44386 :             ( match-&gt;me.y - pd-&gt;sp-&gt;me.y )*dir-&gt;x;</span>
<span class="lineNum">    1967 </span><span class="lineCov">      44386 :     if ( width &lt; 0 ) width = -width;</span>
<span class="lineNum">    1968 </span><span class="lineCov">      44386 :     if ( width &lt; .5 )</span>
<span class="lineNum">    1969 </span><span class="lineCov">        366 : return( NULL );         /* Zero width stems aren't interesting */</span>
<span class="lineNum">    1970 </span><span class="lineCov">      44020 :     if (( is_next &amp;&amp; pd-&gt;sp-&gt;next-&gt;to==match ) || ( !is_next &amp;&amp; pd-&gt;sp-&gt;prev-&gt;from==match ))</span>
<span class="lineNum">    1971 </span><span class="lineCov">         66 : return( NULL );         /* Don't want a stem between two splines that intersect */</span>
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span><span class="lineCov">      43954 :     pd2 = &amp;gd-&gt;points[match-&gt;ptindex];</span>
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span><span class="lineCov">      43954 :     line = is_next ? pd-&gt;nextline : pd-&gt;prevline;</span>
<span class="lineNum">    1976 </span><span class="lineCov">      43954 :     mdir = is_next2 ? &amp;pd2-&gt;nextunit : &amp;pd2-&gt;prevunit;</span>
<span class="lineNum">    1977 </span><span class="lineCov">      43954 :     line2 = is_next2 ? pd2-&gt;nextline : pd2-&gt;prevline;</span>
<span class="lineNum">    1978 </span><span class="lineCov">      43954 :     if ( !IsUnitHV( mdir,true ) &amp;&amp; line2 != NULL )</span>
<span class="lineNum">    1979 </span><span class="lineCov">       2084 :         mdir = &amp;line2-&gt;unit;</span>
<span class="lineNum">    1980 </span><span class="lineCov">      43954 :     if ( mdir-&gt;x==0 &amp;&amp; mdir-&gt;y==0 )</span>
<span class="lineNum">    1981 </span><span class="lineCov">        280 : return( NULL );         /* cannot determine the opposite point's direction */</span>
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span><span class="lineCov">      43674 :     if ( !UnitsParallel( mdir,dir,true ) &amp;&amp; !is_stub )</span>
<span class="lineNum">    1984 </span><span class="lineCov">        155 : return( NULL );         /* Cannot make a stem if edges are not parallel (unless it is a serif) */</span>
<span class="lineNum">    1985 </span>            :     
<span class="lineNum">    1986 </span><span class="lineCov">      43519 :     if ( is_stub &amp; 1 &amp;&amp; !IsUnitHV( dir,true )) {</span>
<span class="lineNum">    1987 </span>            :         /* For serifs we prefer the vector which is closer to horizontal/vertical */
<span class="lineNum">    1988 </span><span class="lineCov">       1288 :         middle = MiddleUnit( dir,mdir );</span>
<span class="lineNum">    1989 </span><span class="lineCov">       1288 :         if ( UnitCloserToHV( &amp;middle,dir ) == 1  &amp;&amp; UnitCloserToHV( &amp;middle,mdir ) == 1 )</span>
<span class="lineNum">    1990 </span><span class="lineCov">        124 :             dir = &amp;middle;</span>
<span class="lineNum">    1991 </span><span class="lineCov">       1164 :         else if ( UnitCloserToHV( mdir,dir ) == 1 )</span>
<span class="lineNum">    1992 </span><span class="lineCov">        616 :             dir = mdir;</span>
<span class="lineNum">    1993 </span><span class="lineCov">       2194 :         if ( !IsUnitHV( dir,true ) &amp;&amp; </span>
<span class="lineNum">    1994 </span><span class="lineCov">       1812 :             ( hint_diagonal_ends || require_existing )) </span>
<span class="lineNum">    1995 </span><span class="lineCov">        137 :             de = IsDiagonalEnd( gd,pd,pd2,is_next,require_existing );</span>
<span class="lineNum">    1996 </span>            :     }
<span class="lineNum">    1997 </span>            : 
<span class="lineNum">    1998 </span><span class="lineCov">      43519 :     stem = FindStem( gd,pd,pd2,dir,is_next2,de );</span>
<span class="lineNum">    1999 </span><span class="lineCov">      43519 :     destem = NULL;</span>
<span class="lineNum">    2000 </span><span class="lineCov">      43519 :     if ( de )</span>
<span class="lineNum">    2001 </span><span class="lineCov">          8 :         destem = FindOrMakeHVStem( gd,pd,pd2,( de == 1 ),require_existing );</span>
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span><span class="lineCov">      43519 :     if ( stem == NULL &amp;&amp; !require_existing )</span>
<span class="lineNum">    2004 </span><span class="lineCov">       8186 :         stem = NewStem( gd,dir,&amp;pd-&gt;sp-&gt;me,&amp;match-&gt;me );</span>
<span class="lineNum">    2005 </span><span class="lineCov">      43519 :     if ( stem != NULL ) {</span>
<span class="lineNum">    2006 </span><span class="lineCov">      37618 :         chunk = AddToStem( gd,stem,pd,pd2,is_next,is_next2,false );</span>
<span class="lineNum">    2007 </span><span class="lineCov">      37618 :         if ( chunk != NULL ) {</span>
<span class="lineNum">    2008 </span><span class="lineCov">      37618 :             chunk-&gt;stub = is_stub;</span>
<span class="lineNum">    2009 </span><span class="lineCov">      37618 :             chunk-&gt;l_e_idx = chunk-&gt;r_e_idx = eidx;</span>
<span class="lineNum">    2010 </span>            :         }
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineCov">      37618 :         if ( chunk != NULL &amp;&amp; gd-&gt;linecnt &gt; 0 ) {</span>
<span class="lineNum">    2013 </span><span class="lineCov">      33514 :             hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    2014 </span>            :             /* For HV stems allow assigning a line to a stem edge only */
<span class="lineNum">    2015 </span>            :             /* if that line also has an exactly HV vector */
<span class="lineNum">    2016 </span><span class="lineCov">      35549 :             if ( line != NULL &amp;&amp; (( !hv &amp;&amp;</span>
<span class="lineNum">    2017 </span><span class="lineCov">       4036 :                 UnitsParallel( &amp;stem-&gt;unit,&amp;line-&gt;unit,true ) &amp;&amp; </span>
<span class="lineNum">    2018 </span><span class="lineCov">      22603 :                 RecalcStemOffsets( stem,&amp;line-&gt;unit,true,true )) || </span>
<span class="lineNum">    2019 </span><span class="lineCov">      19258 :                 ( hv &amp;&amp; line-&gt;unit.x == stem-&gt;unit.x &amp;&amp; line-&gt;unit.y == stem-&gt;unit.y ))) {</span>
<span class="lineNum">    2020 </span>            :                 
<span class="lineNum">    2021 </span><span class="lineCov">      19858 :                 otherline = NULL; l_changed = false;</span>
<span class="lineNum">    2022 </span><span class="lineCov">      34358 :                 if (( stem-&gt;leftline == NULL || </span>
<span class="lineNum">    2023 </span><span class="lineCov">      21603 :                     stem-&gt;leftline-&gt;length &lt; line-&gt;length ) &amp;&amp; chunk-&gt;l == pd ) {</span>
<span class="lineNum">    2024 </span>            :                     
<span class="lineNum">    2025 </span><span class="lineCov">       2379 :                     stem-&gt;leftline = line;</span>
<span class="lineNum">    2026 </span><span class="lineCov">       2379 :                     l_changed = true;</span>
<span class="lineNum">    2027 </span><span class="lineCov">       2379 :                     otherline = stem-&gt;rightline;</span>
<span class="lineNum">    2028 </span><span class="lineCov">      31962 :                 } else if (( stem-&gt;rightline == NULL ||</span>
<span class="lineNum">    2029 </span><span class="lineCov">      18866 :                     stem-&gt;rightline-&gt;length &lt; line-&gt;length ) &amp;&amp; chunk-&gt;r == pd ) {</span>
<span class="lineNum">    2030 </span>            :                     
<span class="lineNum">    2031 </span><span class="lineCov">       2398 :                     stem-&gt;rightline = line;</span>
<span class="lineNum">    2032 </span><span class="lineCov">       2398 :                     l_changed = true;</span>
<span class="lineNum">    2033 </span><span class="lineCov">       2398 :                     otherline = stem-&gt;leftline;</span>
<span class="lineNum">    2034 </span>            :                 }
<span class="lineNum">    2035 </span>            :                 /* If lines are attached to both sides of a diagonal stem, */
<span class="lineNum">    2036 </span>            :                 /* then prefer the longer line */
<span class="lineNum">    2037 </span><span class="lineCov">      19858 :                 if ( !hv &amp;&amp; l_changed &amp;&amp; !stem-&gt;positioned &amp;&amp; </span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :                     ( otherline == NULL || ( otherline-&gt;length &lt; line-&gt;length )))</span>
<span class="lineNum">    2039 </span><span class="lineCov">        322 :                     SetStemUnit( stem,line-&gt;unit );</span>
<span class="lineNum">    2040 </span>            :             }
<span class="lineNum">    2041 </span><span class="lineCov">      35335 :             if ( line2 != NULL &amp;&amp; (( !hv &amp;&amp;</span>
<span class="lineNum">    2042 </span><span class="lineCov">       3622 :                 UnitsParallel( &amp;stem-&gt;unit,&amp;line2-&gt;unit,true ) &amp;&amp; </span>
<span class="lineNum">    2043 </span><span class="lineCov">      21518 :                 RecalcStemOffsets( stem,&amp;line2-&gt;unit,true,true )) || </span>
<span class="lineNum">    2044 </span><span class="lineCov">      18501 :                 ( hv &amp;&amp; line2-&gt;unit.x == stem-&gt;unit.x &amp;&amp; line2-&gt;unit.y == stem-&gt;unit.y ))) {</span>
<span class="lineNum">    2045 </span>            :                 
<span class="lineNum">    2046 </span><span class="lineCov">      18990 :                 otherline = NULL; l_changed = false;</span>
<span class="lineNum">    2047 </span><span class="lineCov">      35180 :                 if (( stem-&gt;leftline == NULL ||</span>
<span class="lineNum">    2048 </span><span class="lineCov">      22224 :                     stem-&gt;leftline-&gt;length &lt; line2-&gt;length ) &amp;&amp; chunk-&gt;l == pd2 ) {</span>
<span class="lineNum">    2049 </span>            :                     
<span class="lineNum">    2050 </span><span class="lineCov">       2178 :                     stem-&gt;leftline = line2;</span>
<span class="lineNum">    2051 </span><span class="lineCov">       2178 :                     l_changed = true;</span>
<span class="lineNum">    2052 </span><span class="lineCov">       2178 :                     otherline = stem-&gt;rightline;</span>
<span class="lineNum">    2053 </span><span class="lineCov">      31053 :                 } else if (( stem-&gt;rightline == NULL ||</span>
<span class="lineNum">    2054 </span><span class="lineCov">      19004 :                     stem-&gt;rightline-&gt;length &lt; line2-&gt;length ) &amp;&amp; chunk-&gt;r == pd2 ) {</span>
<span class="lineNum">    2055 </span>            :                     
<span class="lineNum">    2056 </span><span class="lineCov">       2227 :                     stem-&gt;rightline = line2;</span>
<span class="lineNum">    2057 </span><span class="lineCov">       2227 :                     l_changed = true;</span>
<span class="lineNum">    2058 </span><span class="lineCov">       2227 :                     otherline = stem-&gt;leftline;</span>
<span class="lineNum">    2059 </span>            :                 }
<span class="lineNum">    2060 </span><span class="lineCov">      18990 :                 if ( !hv &amp;&amp; l_changed &amp;&amp; !stem-&gt;positioned &amp;&amp; </span>
<span class="lineNum">    2061 </span><span class="lineCov">        255 :                     ( otherline == NULL || ( otherline-&gt;length &lt; line2-&gt;length )))</span>
<span class="lineNum">    2062 </span><span class="lineCov">        253 :                     SetStemUnit( stem,line2-&gt;unit );</span>
<span class="lineNum">    2063 </span>            :             }
<span class="lineNum">    2064 </span>            :         }
<span class="lineNum">    2065 </span>            :     }
<span class="lineNum">    2066 </span>            : 
<span class="lineNum">    2067 </span><span class="lineCov">      43519 :     if ( destem != NULL )</span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :         AddToStem( gd,destem,pd,pd2,is_next,!is_next,1 );</span>
<span class="lineNum">    2069 </span><span class="lineCov">      43519 : return( stem );</span>
<a name="2070"><span class="lineNum">    2070 </span>            : }</a>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineCov">        940 : static double FindSameSlope(Spline *s,BasePoint *dir,double close_to) {</span>
<span class="lineNum">    2073 </span>            :     double a, b, c, desc;
<span class="lineNum">    2074 </span>            :     double t1, t2;
<span class="lineNum">    2075 </span>            :     double d1, d2;
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span><span class="lineCov">        940 :     if ( s==NULL )</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 : return( -1e4 );</span>
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span><span class="lineCov">        940 :     a = dir-&gt;x*s-&gt;splines[1].a*3 - dir-&gt;y*s-&gt;splines[0].a*3;</span>
<span class="lineNum">    2081 </span><span class="lineCov">        940 :     b = dir-&gt;x*s-&gt;splines[1].b*2 - dir-&gt;y*s-&gt;splines[0].b*2;</span>
<span class="lineNum">    2082 </span><span class="lineCov">        940 :     c = dir-&gt;x*s-&gt;splines[1].c   - dir-&gt;y*s-&gt;splines[0].c  ;</span>
<span class="lineNum">    2083 </span><span class="lineCov">        940 :     if ( a!=0 ) {</span>
<span class="lineNum">    2084 </span><span class="lineCov">        398 :         desc = b*b - 4*a*c;</span>
<span class="lineNum">    2085 </span><span class="lineCov">        398 :         if ( desc&lt;0 )</span>
<span class="lineNum">    2086 </span><span class="lineCov">         33 : return( -1e4 );</span>
<span class="lineNum">    2087 </span><span class="lineCov">        365 :         desc = sqrt(desc);</span>
<span class="lineNum">    2088 </span><span class="lineCov">        365 :         t1 = (-b+desc)/(2*a);</span>
<span class="lineNum">    2089 </span><span class="lineCov">        365 :         t2 = (-b-desc)/(2*a);</span>
<span class="lineNum">    2090 </span><span class="lineCov">        365 :         if ( (d1=t1-close_to)&lt;0 ) d1 = -d1;</span>
<span class="lineNum">    2091 </span><span class="lineCov">        365 :         if ( (d2=t2-close_to)&lt;0 ) d2 = -d2;</span>
<span class="lineNum">    2092 </span><span class="lineCov">        365 :         if ( d2&lt;d1 &amp;&amp; t2&gt;=-.001 &amp;&amp; t2&lt;=1.001 )</span>
<span class="lineNum">    2093 </span><span class="lineCov">        102 :             t1 = t2;</span>
<span class="lineNum">    2094 </span><span class="lineCov">        542 :     } else if ( b!=0 )</span>
<span class="lineNum">    2095 </span><span class="lineCov">        528 :         t1 = -c/b;</span>
<span class="lineNum">    2096 </span>            :     else
<span class="lineNum">    2097 </span><span class="lineCov">         14 : return( -1e4 );</span>
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span><span class="lineCov">        893 : return( t1 );</span>
<span class="lineNum">    2100 </span>            : }
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            : /* This function is used when generating stem data for preexisting */
<span class="lineNum">    2103 </span>            : /* stem hints. If we already know the desired hint position, then we */
<a name="2104"><span class="lineNum">    2104 </span>            : /* can safely assign to this hint any points which meet other conditions */</a>
<span class="lineNum">    2105 </span>            : /* but have no corresponding position at the opposite edge. */
<span class="lineNum">    2106 </span><span class="lineCov">      50549 : static int HalfStemNoOpposite( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    2107 </span>            :     struct stemdata *stem,BasePoint *dir,int is_next ) {
<span class="lineNum">    2108 </span><span class="lineCov">      50549 :     int i, ret=0, allowleft, allowright, hv, corner;</span>
<span class="lineNum">    2109 </span>            :     struct stemdata *tstem;
<span class="lineNum">    2110 </span>            :     
<span class="lineNum">    2111 </span><span class="lineCov">     352270 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    2112 </span><span class="lineCov">     301721 :         tstem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    2113 </span><span class="lineCov">     301721 :         if ( tstem-&gt;bbox || !tstem-&gt;positioned || tstem == stem )</span>
<span class="lineNum">    2114 </span><span class="lineCov">     120908 :     continue;</span>
<span class="lineNum">    2115 </span><span class="lineCov">     180813 :         allowleft = ( !tstem-&gt;ghost || tstem-&gt;width == 20 );</span>
<span class="lineNum">    2116 </span><span class="lineCov">     180813 :         allowright = ( !tstem-&gt;ghost || tstem-&gt;width == 21 );</span>
<span class="lineNum">    2117 </span><span class="lineCov">     180813 :         hv = IsUnitHV( &amp;tstem-&gt;unit,true );</span>
<span class="lineNum">    2118 </span><span class="lineCov">     180813 :         corner = (( pd-&gt;x_corner &amp;&amp; hv == 2 ) || ( pd-&gt;y_corner &amp;&amp; hv == 1 ));</span>
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span><span class="lineCov">     180813 :         if ( UnitsParallel( &amp;tstem-&gt;unit,dir,true ) || tstem-&gt;ghost || corner ) {</span>
<span class="lineNum">    2121 </span><span class="lineCov">      51863 :             if ( OnStem( tstem,&amp;pd-&gt;sp-&gt;me,true ) &amp;&amp; allowleft ) {</span>
<span class="lineNum">    2122 </span><span class="lineCov">       5410 :                 if ( IsCorrectSide( gd,pd,is_next,true,&amp;tstem-&gt;unit )) {</span>
<span class="lineNum">    2123 </span><span class="lineCov">       2249 :                     AddToStem( gd,tstem,pd,NULL,is_next,false,false );</span>
<span class="lineNum">    2124 </span><span class="lineCov">       2249 :                     ret++;</span>
<span class="lineNum">    2125 </span>            :                 }
<span class="lineNum">    2126 </span><span class="lineCov">      49158 :             } else if ( OnStem( tstem,&amp;pd-&gt;sp-&gt;me,false ) &amp;&amp; allowright ) {</span>
<span class="lineNum">    2127 </span><span class="lineCov">       2554 :                 if ( IsCorrectSide( gd,pd,is_next,false,&amp;tstem-&gt;unit )) {</span>
<span class="lineNum">    2128 </span><span class="lineCov">       2103 :                     AddToStem( gd,tstem,NULL,pd,false,is_next,false );</span>
<span class="lineNum">    2129 </span><span class="lineCov">       2103 :                     ret++;</span>
<span class="lineNum">    2130 </span>            :                 }
<span class="lineNum">    2131 </span>            :             }
<span class="lineNum">    2132 </span>            :         }
<span class="lineNum">    2133 </span>            :     }
<span class="lineNum">    2134 </span><span class="lineCov">      50549 : return( ret );</span>
<a name="2135"><span class="lineNum">    2135 </span>            : }</a>
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span><span class="lineCov">        671 : static struct stemdata *HalfStem( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    2138 </span>            :     BasePoint *dir,Spline *other,double other_t,int is_next,int eidx ) {
<span class="lineNum">    2139 </span>            :     /* Find the spot on other where the slope is the same as dir */
<span class="lineNum">    2140 </span>            :     double t1;
<span class="lineNum">    2141 </span>            :     double width;
<span class="lineNum">    2142 </span>            :     BasePoint match;
<span class="lineNum">    2143 </span><span class="lineCov">        671 :     struct stemdata *stem = NULL, *tstem;</span>
<span class="lineNum">    2144 </span><span class="lineCov">        671 :     struct pointdata *pd2 = NULL, *tpd;</span>
<span class="lineNum">    2145 </span>            :     int i;
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineCov">        671 :     t1 = FindSameSlope( other,dir,other_t );</span>
<span class="lineNum">    2148 </span><span class="lineCov">        671 :     if ( t1==-1e4 )</span>
<span class="lineNum">    2149 </span><span class="lineCov">         25 : return( NULL );</span>
<span class="lineNum">    2150 </span><span class="lineCov">        646 :     if ( t1&lt;0 &amp;&amp; other-&gt;from-&gt;prev!=NULL &amp;&amp; gd-&gt;points[other-&gt;from-&gt;ptindex].colinear ) {</span>
<span class="lineNum">    2151 </span><span class="lineCov">        118 :         other = other-&gt;from-&gt;prev;</span>
<span class="lineNum">    2152 </span><span class="lineCov">        118 :         t1 = FindSameSlope(other,dir,1.0);</span>
<span class="lineNum">    2153 </span><span class="lineCov">        528 :     } else if ( t1&gt;1 &amp;&amp; other-&gt;to-&gt;next!=NULL &amp;&amp; gd-&gt;points[other-&gt;to-&gt;ptindex].colinear ) {</span>
<span class="lineNum">    2154 </span><span class="lineCov">        151 :         other = other-&gt;to-&gt;next;</span>
<span class="lineNum">    2155 </span><span class="lineCov">        151 :         t1 = FindSameSlope(other,dir,0.0);</span>
<span class="lineNum">    2156 </span>            :     }
<span class="lineNum">    2157 </span>            : 
<span class="lineNum">    2158 </span><span class="lineCov">        646 :     if ( t1&lt;-.001 || t1&gt;1.001 )</span>
<span class="lineNum">    2159 </span><span class="lineCov">        140 : return( NULL );</span>
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span>            :     /* Ok. the opposite edge has the right slope at t1 */
<span class="lineNum">    2162 </span>            :     /* Now see if we can make a one sided stem out of these two */
<span class="lineNum">    2163 </span><span class="lineCov">        506 :     match.x = ((other-&gt;splines[0].a*t1+other-&gt;splines[0].b)*t1+other-&gt;splines[0].c)*t1+other-&gt;splines[0].d;</span>
<span class="lineNum">    2164 </span><span class="lineCov">        506 :     match.y = ((other-&gt;splines[1].a*t1+other-&gt;splines[1].b)*t1+other-&gt;splines[1].c)*t1+other-&gt;splines[1].d;</span>
<span class="lineNum">    2165 </span>            : 
<span class="lineNum">    2166 </span><span class="lineCov">        506 :     width = (match.x-pd-&gt;sp-&gt;me.x)*dir-&gt;y - (match.y-pd-&gt;sp-&gt;me.y)*dir-&gt;x;</span>
<span class="lineNum">    2167 </span>            :     /* offset = (match.x-pd-&gt;sp-&gt;me.x)*dir-&gt;x + (match.y-pd-&gt;sp-&gt;me.y)*dir-&gt;y;*/
<span class="lineNum">    2168 </span><span class="lineCov">        506 :     if ( width&lt;.5 &amp;&amp; width&gt;-.5 )</span>
<span class="lineNum">    2169 </span><span class="lineCov">         36 : return( NULL );         /* Zero width stems aren't interesting */</span>
<span class="lineNum">    2170 </span>            : 
<span class="lineNum">    2171 </span><span class="lineCov">        470 :     if ( isnan(t1))</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         IError( &quot;NaN value in HalfStem&quot; );</span>
<span class="lineNum">    2173 </span>            : 
<span class="lineNum">    2174 </span><span class="lineCov">        470 :     if ( is_next ) {</span>
<span class="lineNum">    2175 </span><span class="lineCov">        267 :         pd-&gt;nextedges[eidx] = other;</span>
<span class="lineNum">    2176 </span><span class="lineCov">        267 :         pd-&gt;next_e_t[eidx] = t1;</span>
<span class="lineNum">    2177 </span>            :     } else {
<span class="lineNum">    2178 </span><span class="lineCov">        203 :         pd-&gt;prevedges[eidx] = other;</span>
<span class="lineNum">    2179 </span><span class="lineCov">        203 :         pd-&gt;prev_e_t[eidx] = t1;</span>
<span class="lineNum">    2180 </span>            :     }
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span>            :     /* In my experience the only case where this function may be useful */
<span class="lineNum">    2183 </span>            :     /* is when it occasionally finds a real spline point which for some */
<span class="lineNum">    2184 </span>            :     /* reasons has been neglected by other tests and yet forms a valid  */
<span class="lineNum">    2185 </span>            :     /* pair for the first point. So run through points and see if we    */
<span class="lineNum">    2186 </span>            :     /* have actually got just a position on spline midway between to points, */
<span class="lineNum">    2187 </span>            :     /* or it is a normal point allowing to make a normal stem chunk */
<span class="lineNum">    2188 </span><span class="lineCov">      28315 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) {</span>
<span class="lineNum">    2189 </span><span class="lineCov">      28045 :         tpd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    2190 </span><span class="lineCov">      28045 :         if ( tpd-&gt;sp != NULL &amp;&amp; tpd-&gt;sp-&gt;me.x == match.x &amp;&amp; tpd-&gt;sp-&gt;me.y == match.y ) {</span>
<span class="lineNum">    2191 </span><span class="lineCov">        200 :             pd2 = tpd;</span>
<span class="lineNum">    2192 </span><span class="lineCov">        200 :     break;</span>
<span class="lineNum">    2193 </span>            :         }
<span class="lineNum">    2194 </span>            :     }
<span class="lineNum">    2195 </span><span class="lineCov">       3041 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    2196 </span><span class="lineCov">       2831 :         tstem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    2197 </span><span class="lineCov">       3561 :         if ( UnitsParallel( &amp;tstem-&gt;unit,dir,true ) &amp;&amp; </span>
<span class="lineNum">    2198 </span><span class="lineCov">        730 :             BothOnStem( tstem,&amp;pd-&gt;base,&amp;match,false,false,false )) {</span>
<span class="lineNum">    2199 </span><span class="lineCov">        260 :             stem = tstem;</span>
<span class="lineNum">    2200 </span><span class="lineCov">        260 :     break;</span>
<span class="lineNum">    2201 </span>            :         }
<span class="lineNum">    2202 </span>            :     }
<span class="lineNum">    2203 </span><span class="lineCov">        470 :     if ( stem == NULL )</span>
<span class="lineNum">    2204 </span><span class="lineCov">        210 :         stem = NewStem(gd,dir,&amp;pd-&gt;sp-&gt;me,&amp;match);</span>
<span class="lineNum">    2205 </span>            :     
<span class="lineNum">    2206 </span><span class="lineCov">        470 :     AddToStem( gd,stem,pd,pd2,is_next,false,false );</span>
<span class="lineNum">    2207 </span><span class="lineCov">        470 : return( stem );</span>
<a name="2208"><span class="lineNum">    2208 </span>            : }</a>
<span class="lineNum">    2209 </span>            : 
<span class="lineNum">    2210 </span><span class="lineCov">       3894 : static int ConnectsAcross( struct glyphdata *gd,SplinePoint *sp,</span>
<span class="lineNum">    2211 </span>            :     int is_next,Spline *findme,int eidx ) {
<span class="lineNum">    2212 </span><span class="lineCov">       3894 :     struct pointdata *pd = &amp;gd-&gt;points[sp-&gt;ptindex];</span>
<span class="lineNum">    2213 </span>            :     Spline *other, *test;
<span class="lineNum">    2214 </span>            :     BasePoint dir;
<span class="lineNum">    2215 </span>            : 
<span class="lineNum">    2216 </span><span class="lineCov">       3894 :     other = ( is_next ) ? pd-&gt;nextedges[eidx] : pd-&gt;prevedges[eidx];</span>
<span class="lineNum">    2217 </span>            : 
<span class="lineNum">    2218 </span><span class="lineCov">       3894 :     if ( other==findme )</span>
<span class="lineNum">    2219 </span><span class="lineCov">        921 : return( true );</span>
<span class="lineNum">    2220 </span><span class="lineCov">       2973 :     if ( other==NULL )</span>
<span class="lineNum">    2221 </span><span class="lineCov">        290 : return( false );</span>
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span><span class="lineCov">       2683 :     dir.x = ( is_next ) ? -pd-&gt;nextunit.x : pd-&gt;prevunit.x;</span>
<span class="lineNum">    2224 </span><span class="lineCov">       2683 :     dir.y = ( is_next ) ? -pd-&gt;nextunit.y : pd-&gt;prevunit.y;</span>
<span class="lineNum">    2225 </span><span class="lineCov">       2683 :     test = other-&gt;to-&gt;next;</span>
<span class="lineNum">    2226 </span><span class="lineCov">      15379 :     while ( test!=NULL &amp;&amp; test != other &amp;&amp;</span>
<span class="lineNum">    2227 </span><span class="lineCov">      12696 :             gd-&gt;points[test-&gt;from-&gt;ptindex].nextunit.x * dir.x +</span>
<span class="lineNum">    2228 </span><span class="lineCov">       6348 :             gd-&gt;points[test-&gt;from-&gt;ptindex].nextunit.y * dir.y &gt; 0 ) {</span>
<span class="lineNum">    2229 </span><span class="lineCov">       4318 :         if ( test==findme )</span>
<span class="lineNum">    2230 </span><span class="lineCov">        653 : return( true );</span>
<span class="lineNum">    2231 </span><span class="lineCov">       3665 :         test = test-&gt;to-&gt;next;</span>
<span class="lineNum">    2232 </span>            :     }
<span class="lineNum">    2233 </span>            :             
<span class="lineNum">    2234 </span><span class="lineCov">       2030 :     dir.x = ( is_next ) ? pd-&gt;nextunit.x : -pd-&gt;prevunit.x;</span>
<span class="lineNum">    2235 </span><span class="lineCov">       2030 :     dir.y = ( is_next ) ? pd-&gt;nextunit.y : -pd-&gt;prevunit.y;</span>
<span class="lineNum">    2236 </span><span class="lineCov">       2030 :     test = other-&gt;from-&gt;prev;</span>
<span class="lineNum">    2237 </span><span class="lineCov">      10199 :     while ( test!=NULL &amp;&amp; test != other &amp;&amp;</span>
<span class="lineNum">    2238 </span><span class="lineCov">       8168 :             gd-&gt;points[test-&gt;to-&gt;ptindex].prevunit.x * dir.x +</span>
<span class="lineNum">    2239 </span><span class="lineCov">       4084 :             gd-&gt;points[test-&gt;to-&gt;ptindex].prevunit.y * dir.y &gt; 0 ) {</span>
<span class="lineNum">    2240 </span><span class="lineCov">       2731 :         if ( test==findme )</span>
<span class="lineNum">    2241 </span><span class="lineCov">        676 : return( true );</span>
<span class="lineNum">    2242 </span><span class="lineCov">       2055 :         test = test-&gt;from-&gt;prev;</span>
<span class="lineNum">    2243 </span>            :     }
<span class="lineNum">    2244 </span><span class="lineCov">       1354 : return( false );</span>
<a name="2245"><span class="lineNum">    2245 </span>            : }</a>
<span class="lineNum">    2246 </span>            : 
<span class="lineNum">    2247 </span><span class="lineCov">        935 : static int ConnectsAcrossToStem( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    2248 </span>            :     int is_next,struct stemdata *target,int is_l,int eidx ) {
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span>            :     Spline *other, *test;
<span class="lineNum">    2251 </span>            :     BasePoint dir;
<span class="lineNum">    2252 </span>            :     struct pointdata *tpd;
<span class="lineNum">    2253 </span>            :     int ecnt, stemidx;
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span><span class="lineCov">        935 :     ecnt = ( is_next ) ? pd-&gt;next_e_cnt : pd-&gt;prev_e_cnt;</span>
<span class="lineNum">    2256 </span><span class="lineCov">        935 :     if ( ecnt &lt; eidx + 1 )</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    2258 </span><span class="lineCov">        935 :     other = ( is_next ) ? pd-&gt;nextedges[eidx] : pd-&gt;prevedges[eidx];</span>
<span class="lineNum">    2259 </span>            : 
<span class="lineNum">    2260 </span><span class="lineCov">        935 :     test = other;</span>
<span class="lineNum">    2261 </span><span class="lineCov">        935 :     dir.x = ( is_next ) ? pd-&gt;nextunit.x : -pd-&gt;prevunit.x;</span>
<span class="lineNum">    2262 </span><span class="lineCov">        935 :     dir.y = ( is_next ) ? pd-&gt;nextunit.y : -pd-&gt;prevunit.y;</span>
<span class="lineNum">    2263 </span>            :     do {
<span class="lineNum">    2264 </span><span class="lineCov">       4062 :         tpd = &amp;gd-&gt;points[test-&gt;to-&gt;ptindex];</span>
<span class="lineNum">    2265 </span><span class="lineCov">       4062 :         stemidx = IsStemAssignedToPoint( tpd,target,false );</span>
<span class="lineNum">    2266 </span><span class="lineCov">       4384 :         if ( stemidx != -1 &amp;&amp; tpd-&gt;prev_is_l[stemidx] == !is_l &amp;&amp;</span>
<span class="lineNum">    2267 </span><span class="lineCov">        322 :             IsSplinePeak( gd,tpd,rint( target-&gt;unit.y ),rint( target-&gt;unit.y ),7 ))</span>
<span class="lineNum">    2268 </span><span class="lineCov">        257 : return( true );</span>
<span class="lineNum">    2269 </span>            :         
<span class="lineNum">    2270 </span><span class="lineCov">       3805 :         test = test-&gt;to-&gt;next;</span>
<span class="lineNum">    2271 </span><span class="lineCov">       7491 :     } while ( test!=NULL &amp;&amp; test != other &amp;&amp; stemidx == -1 &amp;&amp;</span>
<span class="lineNum">    2272 </span><span class="lineCov">       7491 :         ( tpd-&gt;prevunit.x * dir.x + tpd-&gt;prevunit.y * dir.y &gt;= 0 ));</span>
<span class="lineNum">    2273 </span>            :             
<span class="lineNum">    2274 </span><span class="lineCov">        678 :     test = other;</span>
<span class="lineNum">    2275 </span><span class="lineCov">        678 :     dir.x = ( is_next ) ? -pd-&gt;nextunit.x : pd-&gt;prevunit.x;</span>
<span class="lineNum">    2276 </span><span class="lineCov">        678 :     dir.y = ( is_next ) ? -pd-&gt;nextunit.y : pd-&gt;prevunit.y;</span>
<span class="lineNum">    2277 </span>            :     do {
<span class="lineNum">    2278 </span><span class="lineCov">       2905 :         tpd = &amp;gd-&gt;points[test-&gt;from-&gt;ptindex];</span>
<span class="lineNum">    2279 </span><span class="lineCov">       2905 :         stemidx = IsStemAssignedToPoint( tpd,target,true );</span>
<span class="lineNum">    2280 </span><span class="lineCov">       3154 :         if ( stemidx != -1 &amp;&amp; tpd-&gt;next_is_l[stemidx] == !is_l &amp;&amp;</span>
<span class="lineNum">    2281 </span><span class="lineCov">        249 :             IsSplinePeak( gd,tpd,rint( target-&gt;unit.y ),rint( target-&gt;unit.y ),7 ))</span>
<span class="lineNum">    2282 </span><span class="lineCov">        164 : return( true );</span>
<span class="lineNum">    2283 </span>            : 
<span class="lineNum">    2284 </span><span class="lineCov">       2741 :         test = test-&gt;from-&gt;prev;</span>
<span class="lineNum">    2285 </span><span class="lineCov">       5366 :     } while ( test!=NULL &amp;&amp; test != other &amp;&amp; stemidx == -1 &amp;&amp;</span>
<span class="lineNum">    2286 </span><span class="lineCov">       5366 :         ( tpd-&gt;nextunit.x * dir.x + tpd-&gt;nextunit.y * dir.y &gt;= 0 ));</span>
<span class="lineNum">    2287 </span><span class="lineCov">        514 : return( false );</span>
<a name="2288"><span class="lineNum">    2288 </span>            : }</a>
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span><span class="lineCov">       3442 : static double RecalcT( Spline *base,SplinePoint *from, SplinePoint *to, double curt ) {</span>
<span class="lineNum">    2291 </span>            :     double baselen, fromlen, tolen, ret;
<span class="lineNum">    2292 </span>            :     Spline *cur;
<span class="lineNum">    2293 </span>            :     
<span class="lineNum">    2294 </span><span class="lineCov">       3442 :     baselen = SplineLength( base );</span>
<span class="lineNum">    2295 </span><span class="lineCov">       3442 :     fromlen = baselen * curt;</span>
<span class="lineNum">    2296 </span><span class="lineCov">       3442 :     tolen = baselen * ( 1 - curt );</span>
<span class="lineNum">    2297 </span>            :     
<span class="lineNum">    2298 </span><span class="lineCov">       3442 :     cur = base-&gt;from-&gt;prev;</span>
<span class="lineNum">    2299 </span><span class="lineCov">      12316 :     while ( cur != NULL &amp;&amp; cur-&gt;to != from ) {</span>
<span class="lineNum">    2300 </span><span class="lineCov">       5432 :         fromlen += SplineLength( cur );</span>
<span class="lineNum">    2301 </span><span class="lineCov">       5432 :         cur = cur-&gt;from-&gt;prev;</span>
<span class="lineNum">    2302 </span>            :     }
<span class="lineNum">    2303 </span><span class="lineCov">       3442 :     cur = base-&gt;to-&gt;next;</span>
<span class="lineNum">    2304 </span><span class="lineCov">      11714 :     while ( cur!= NULL &amp;&amp; cur-&gt;from != to ) {</span>
<span class="lineNum">    2305 </span><span class="lineCov">       4830 :         tolen += SplineLength( cur );</span>
<span class="lineNum">    2306 </span><span class="lineCov">       4830 :         cur = cur-&gt;to-&gt;next;</span>
<span class="lineNum">    2307 </span>            :     }
<span class="lineNum">    2308 </span><span class="lineCov">       3442 :     ret = fromlen/( fromlen + tolen );</span>
<span class="lineNum">    2309 </span><span class="lineCov">       3442 : return( ret );</span>
<a name="2310"><span class="lineNum">    2310 </span>            : }</a>
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span><span class="lineCov">      71200 : static int BuildStem( struct glyphdata *gd,struct pointdata *pd,int is_next,</span>
<span class="lineNum">    2313 </span>            :     int require_existing,int has_existing,int eidx ) {
<span class="lineNum">    2314 </span>            :     BasePoint *dir;
<span class="lineNum">    2315 </span>            :     Spline *other, *cur;
<span class="lineNum">    2316 </span>            :     double t;
<span class="lineNum">    2317 </span>            :     double tod, fromd, dist;
<span class="lineNum">    2318 </span>            :     SplinePoint *testpt, *topt, *frompt;
<span class="lineNum">    2319 </span>            :     struct linedata *line;
<span class="lineNum">    2320 </span>            :     struct pointdata *testpd, *topd, *frompd;
<span class="lineNum">    2321 </span><span class="lineCov">      71200 :     int tp, fp, t_needs_recalc=false, ret=0;</span>
<span class="lineNum">    2322 </span><span class="lineCov">      71200 :     uint8 tstub=0, fstub=0;</span>
<span class="lineNum">    2323 </span>            :     BasePoint opposite;
<span class="lineNum">    2324 </span><span class="lineCov">      71200 :     struct stemdata *stem=NULL;</span>
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span><span class="lineCov">      71200 :     if ( is_next ) {</span>
<span class="lineNum">    2327 </span><span class="lineCov">      35614 :         dir = &amp;pd-&gt;nextunit;</span>
<span class="lineNum">    2328 </span><span class="lineCov">      35614 :         other = pd-&gt;nextedges[eidx];</span>
<span class="lineNum">    2329 </span><span class="lineCov">      35614 :         cur = pd-&gt;sp-&gt;next;</span>
<span class="lineNum">    2330 </span><span class="lineCov">      35614 :         t = pd-&gt;next_e_t[eidx];</span>
<span class="lineNum">    2331 </span><span class="lineCov">      35614 :         dist = pd-&gt;next_dist[eidx];</span>
<span class="lineNum">    2332 </span>            :     } else {
<span class="lineNum">    2333 </span><span class="lineCov">      35586 :         dir = &amp;pd-&gt;prevunit;</span>
<span class="lineNum">    2334 </span><span class="lineCov">      35586 :         other = pd-&gt;prevedges[eidx];</span>
<span class="lineNum">    2335 </span><span class="lineCov">      35586 :         cur = pd-&gt;sp-&gt;prev;</span>
<span class="lineNum">    2336 </span><span class="lineCov">      35586 :         t = pd-&gt;prev_e_t[eidx];</span>
<span class="lineNum">    2337 </span><span class="lineCov">      35586 :         dist = pd-&gt;prev_dist[eidx];</span>
<span class="lineNum">    2338 </span>            :     }
<span class="lineNum">    2339 </span><span class="lineCov">      71200 :     topt = other-&gt;to; frompt = other-&gt;from;</span>
<span class="lineNum">    2340 </span><span class="lineCov">      71200 :     topd = &amp;gd-&gt;points[topt-&gt;ptindex];</span>
<span class="lineNum">    2341 </span><span class="lineCov">      71200 :     frompd = &amp;gd-&gt;points[frompt-&gt;ptindex];</span>
<span class="lineNum">    2342 </span>            :     
<span class="lineNum">    2343 </span><span class="lineCov">      71200 :     line = is_next ? pd-&gt;nextline : pd-&gt;prevline;</span>
<span class="lineNum">    2344 </span><span class="lineCov">      71200 :     if ( !IsUnitHV( dir,true ) &amp;&amp; line != NULL)</span>
<span class="lineNum">    2345 </span><span class="lineCov">       4697 :         dir = &amp;line-&gt;unit;</span>
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span><span class="lineCov">      71200 :     if ( other==NULL )</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2349 </span>            : 
<span class="lineNum">    2350 </span><span class="lineCov">      71200 :     opposite.x = ((other-&gt;splines[0].a*t+other-&gt;splines[0].b)*t+other-&gt;splines[0].c)*t+other-&gt;splines[0].d;</span>
<span class="lineNum">    2351 </span><span class="lineCov">      71200 :     opposite.y = ((other-&gt;splines[1].a*t+other-&gt;splines[1].b)*t+other-&gt;splines[1].c)*t+other-&gt;splines[1].d;</span>
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span><span class="lineCov">      71200 :     if ( eidx == 0 ) tstub = IsStubOrIntersection( gd,dir,pd,topd,is_next,false );</span>
<span class="lineNum">    2354 </span><span class="lineCov">      71200 :     if ( eidx == 0 ) fstub = IsStubOrIntersection( gd,dir,pd,frompd,is_next,true );</span>
<span class="lineNum">    2355 </span><span class="lineCov">      71200 :     tp = ParallelToDir( topd,false,dir,&amp;opposite,pd-&gt;sp,tstub );</span>
<span class="lineNum">    2356 </span><span class="lineCov">      71200 :     fp = ParallelToDir( frompd,true,dir,&amp;opposite,pd-&gt;sp,fstub );</span>
<span class="lineNum">    2357 </span>            :     
<span class="lineNum">    2358 </span>            :     /* if none of the opposite points is parallel to the needed vector, then    */
<span class="lineNum">    2359 </span>            :     /* give it one more chance by skipping those points and looking at the next */
<span class="lineNum">    2360 </span>            :     /* and previous one. This can be useful in situations where the opposite    */
<span class="lineNum">    2361 </span>            :     /* edge cannot be correctly detected just because there are too many points */
<span class="lineNum">    2362 </span>            :     /* on the spline (which is a very common situation for poorly designed      */
<span class="lineNum">    2363 </span>            :     /* fonts or fonts with quadratic splines). */
<span class="lineNum">    2364 </span>            :     /* But do that only for colinear spline segments and ensure that there are  */
<span class="lineNum">    2365 </span>            :     /* no bends between two splines. */
<span class="lineNum">    2366 </span><span class="lineCov">      71200 :     if ( !tp &amp;&amp; ( !fp || t &gt; 0.5 ) &amp;&amp;</span>
<span class="lineNum">    2367 </span><span class="lineCov">      19940 :         topd-&gt;colinear &amp;&amp; &amp;other-&gt;to-&gt;next != NULL ) {</span>
<span class="lineNum">    2368 </span><span class="lineCov">      19940 :         testpt = topt-&gt;next-&gt;to; </span>
<span class="lineNum">    2369 </span><span class="lineCov">      19940 :         testpd = &amp;gd-&gt;points[testpt-&gt;ptindex];</span>
<span class="lineNum">    2370 </span><span class="lineCov">      19940 :         BasePoint *initdir = &amp;topd-&gt;prevunit;</span>
<span class="lineNum">    2371 </span><span class="lineCov">     117085 :         while ( !tp &amp;&amp; topd-&gt;colinear &amp;&amp; pd-&gt;sp != testpt &amp;&amp; other-&gt;from != testpt &amp;&amp; (</span>
<span class="lineNum">    2372 </span><span class="lineCov">      86418 :             testpd-&gt;prevunit.x * initdir-&gt;x +</span>
<span class="lineNum">    2373 </span><span class="lineCov">      43209 :             testpd-&gt;prevunit.y * initdir-&gt;y &gt; 0 )) {</span>
<span class="lineNum">    2374 </span>            : 
<span class="lineNum">    2375 </span><span class="lineCov">      33996 :             topt = testpt; topd = testpd;</span>
<span class="lineNum">    2376 </span><span class="lineCov">      33996 :             tp = ParallelToDir( topd,false,dir,&amp;opposite,pd-&gt;sp,false );</span>
<span class="lineNum">    2377 </span><span class="lineCov">      33996 :             testpt = topt-&gt;next-&gt;to; </span>
<span class="lineNum">    2378 </span><span class="lineCov">      33996 :             testpd = &amp;gd-&gt;points[testpt-&gt;ptindex];</span>
<span class="lineNum">    2379 </span>            :         }
<span class="lineNum">    2380 </span><span class="lineCov">      19940 :         if ( tp ) t_needs_recalc = true;</span>
<span class="lineNum">    2381 </span>            :     }
<span class="lineNum">    2382 </span><span class="lineCov">      71200 :     if ( !fp &amp;&amp; ( !fp || t &lt; 0.5 ) &amp;&amp;</span>
<span class="lineNum">    2383 </span><span class="lineCov">      27281 :         frompd-&gt;colinear &amp;&amp; &amp;other-&gt;from-&gt;prev != NULL ) {</span>
<span class="lineNum">    2384 </span><span class="lineCov">      27281 :         testpt = frompt-&gt;prev-&gt;from; </span>
<span class="lineNum">    2385 </span><span class="lineCov">      27281 :         testpd = &amp;gd-&gt;points[testpt-&gt;ptindex];</span>
<span class="lineNum">    2386 </span><span class="lineCov">      27281 :         BasePoint *initdir = &amp;frompd-&gt;prevunit;</span>
<span class="lineNum">    2387 </span><span class="lineCov">     148140 :         while ( !fp &amp;&amp; frompd-&gt;colinear &amp;&amp; pd-&gt;sp != testpt &amp;&amp; other-&gt;to != testpt &amp;&amp; (</span>
<span class="lineNum">    2388 </span><span class="lineCov">     110768 :             testpd-&gt;prevunit.x * initdir-&gt;x +</span>
<span class="lineNum">    2389 </span><span class="lineCov">      55384 :             testpd-&gt;prevunit.y * initdir-&gt;y &gt; 0 )) {</span>
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span><span class="lineCov">      38194 :             frompt = testpt; frompd = testpd;</span>
<span class="lineNum">    2392 </span><span class="lineCov">      38194 :             fp = ParallelToDir( frompd,true,dir,&amp;opposite,pd-&gt;sp,false );</span>
<span class="lineNum">    2393 </span><span class="lineCov">      38194 :             testpt = frompt-&gt;prev-&gt;from; </span>
<span class="lineNum">    2394 </span><span class="lineCov">      38194 :             testpd = &amp;gd-&gt;points[testpt-&gt;ptindex];</span>
<span class="lineNum">    2395 </span>            :         }
<span class="lineNum">    2396 </span><span class="lineCov">      27281 :         if ( fp ) t_needs_recalc = true;</span>
<span class="lineNum">    2397 </span>            :     }
<span class="lineNum">    2398 </span><span class="lineCov">      71200 :     if ( t_needs_recalc )</span>
<span class="lineNum">    2399 </span><span class="lineCov">       3442 :         t = RecalcT( other,frompt,topt,t );</span>
<span class="lineNum">    2400 </span><span class="lineCov">      71200 :     if ( !tp &amp;&amp; !fp ) {</span>
<span class="lineNum">    2401 </span><span class="lineCov">      25480 :         if ( has_existing )</span>
<span class="lineNum">    2402 </span><span class="lineCov">      15922 :             ret = HalfStemNoOpposite( gd,pd,NULL,dir,is_next );</span>
<span class="lineNum">    2403 </span><span class="lineCov">      25480 : return( ret );</span>
<span class="lineNum">    2404 </span>            :     }
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span>            :     /* We have several conflicting metrics for getting the &quot;better&quot; stem */
<span class="lineNum">    2407 </span>            :     /* Generally we prefer the stem with the smaller width (but not always. See tilde) */
<span class="lineNum">    2408 </span>            :     /* Generally we prefer the stem formed by the point closer to the intersection */
<span class="lineNum">    2409 </span><span class="lineCov">      45720 :     tod = (1-t)*NormalDist( &amp;topt-&gt;me,&amp;pd-&gt;sp-&gt;me,dir );</span>
<span class="lineNum">    2410 </span><span class="lineCov">      45720 :     fromd = t*NormalDist( &amp;frompt-&gt;me,&amp;pd-&gt;sp-&gt;me,dir );</span>
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span><span class="lineCov">      45720 :     if ( tp &amp;&amp; (( tod&lt;fromd ) ||</span>
<span class="lineNum">    2413 </span><span class="lineCov">       4125 :         ( !fp &amp;&amp; ( tod&lt;2*fromd || dist &lt; topd-&gt;prev_dist[eidx] || </span>
<span class="lineNum">    2414 </span><span class="lineCov">       2348 :             ConnectsAcross( gd,frompt,true,cur,eidx ) || NearlyParallel( dir,other,t ))))) {</span>
<span class="lineNum">    2415 </span><span class="lineCov">      22134 :         stem = TestStem( gd,pd,dir,topt,is_next,false,require_existing,tstub,eidx );</span>
<span class="lineNum">    2416 </span>            :     }
<span class="lineNum">    2417 </span><span class="lineCov">      45720 :     if ( stem == NULL &amp;&amp; fp &amp;&amp; (( fromd&lt;tod ) ||</span>
<span class="lineNum">    2418 </span><span class="lineCov">       3678 :         ( !tp &amp;&amp; ( fromd&lt;2*tod || dist &lt; frompd-&gt;next_dist[eidx] || </span>
<span class="lineNum">    2419 </span><span class="lineCov">       2188 :             ConnectsAcross( gd,topt,false,cur,eidx ) || NearlyParallel( dir,other,t ))))) {</span>
<span class="lineNum">    2420 </span><span class="lineCov">      22252 :         stem = TestStem( gd,pd,dir,frompt,is_next,true,require_existing,fstub,eidx );</span>
<span class="lineNum">    2421 </span>            :     }
<span class="lineNum">    2422 </span><span class="lineCov">      47188 :     if ( eidx == 0 &amp;&amp; stem == NULL &amp;&amp; !require_existing &amp;&amp; cur!=NULL &amp;&amp; </span>
<span class="lineNum">    2423 </span><span class="lineCov">       2880 :         !other-&gt;knownlinear &amp;&amp; !cur-&gt;knownlinear )</span>
<span class="lineNum">    2424 </span><span class="lineCov">        671 :         stem = HalfStem( gd,pd,dir,other,t,is_next,eidx );</span>
<span class="lineNum">    2425 </span><span class="lineCov">      45720 :     if ( stem != NULL ) ret = 1;</span>
<span class="lineNum">    2426 </span><span class="lineCov">      45720 :     if ( has_existing )</span>
<span class="lineNum">    2427 </span><span class="lineCov">      23148 :         ret += HalfStemNoOpposite( gd,pd,stem,dir,is_next );</span>
<span class="lineNum">    2428 </span><span class="lineCov">      45720 : return( ret );</span>
<a name="2429"><span class="lineNum">    2429 </span>            : }</a>
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span><span class="lineCov">       1644 : static void AssignLinePointsToStems( struct glyphdata *gd ) {</span>
<span class="lineNum">    2432 </span>            :     struct pointdata *pd;
<span class="lineNum">    2433 </span>            :     struct stemdata *stem;
<span class="lineNum">    2434 </span>            :     struct linedata *line;
<span class="lineNum">    2435 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    2436 </span><span class="lineCov">       1644 :     int i, j, stem_hv, line_hv, needs_hv=false;</span>
<span class="lineNum">    2437 </span>            :     
<span class="lineNum">    2438 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) if ( !gd-&gt;stems[i].toobig ) {</span>
<span class="lineNum">    2439 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    2440 </span><span class="lineCov">      10651 :         stem_hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    2441 </span><span class="lineCov">      20758 :         needs_hv = ( stem_hv || ( stem-&gt;chunk_cnt == 1 &amp;&amp; </span>
<span class="lineNum">    2442 </span><span class="lineCov">       2468 :             stem-&gt;chunks[0].stub &amp;&amp; IsUnitHV( &amp;stem-&gt;unit,false )));</span>
<span class="lineNum">    2443 </span>            :         
<span class="lineNum">    2444 </span><span class="lineCov">      10651 :         if ( stem-&gt;leftline != NULL ) {</span>
<span class="lineNum">    2445 </span><span class="lineCov">       4551 :             line = stem-&gt;leftline;</span>
<span class="lineNum">    2446 </span><span class="lineCov">       4551 :             line_hv = ( needs_hv &amp;&amp; LineFitsHV( line ));</span>
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span><span class="lineCov">       4551 :             if ( needs_hv &amp;&amp; !line_hv )</span>
<span class="lineNum">    2449 </span><span class="lineCov">          4 :                 stem-&gt;leftline = NULL;</span>
<span class="lineNum">    2450 </span>            :             else {
<span class="lineNum">    2451 </span><span class="lineCov">      16510 :                 for ( j=0; j&lt;line-&gt;pcnt; j++ ) {</span>
<span class="lineNum">    2452 </span><span class="lineCov">      11963 :                     pd = line-&gt;points[j];</span>
<span class="lineNum">    2453 </span><span class="lineCov">      19109 :                     if ( pd-&gt;prevline == line &amp;&amp; OnStem( stem,&amp;pd-&gt;base,true ) &amp;&amp;</span>
<span class="lineNum">    2454 </span><span class="lineCov">       7146 :                         IsStemAssignedToPoint( pd,stem,false ) == -1) {</span>
<span class="lineNum">    2455 </span><span class="lineCov">       1128 :                         chunk = AddToStem( gd,stem,pd,NULL,false,false,false );</span>
<span class="lineNum">    2456 </span><span class="lineCov">       1128 :                         chunk-&gt;lpotential = true;</span>
<span class="lineNum">    2457 </span><span class="lineCov">      19295 :                     } if ( pd-&gt;nextline == line &amp;&amp; OnStem( stem,&amp;pd-&gt;base,true ) &amp;&amp;</span>
<span class="lineNum">    2458 </span><span class="lineCov">       7332 :                         IsStemAssignedToPoint( pd,stem,true ) == -1 ) {</span>
<span class="lineNum">    2459 </span><span class="lineCov">        737 :                         chunk = AddToStem( gd,stem,pd,NULL,true,false,false );</span>
<span class="lineNum">    2460 </span><span class="lineCov">        737 :                         chunk-&gt;lpotential = true;</span>
<span class="lineNum">    2461 </span>            :                     }
<span class="lineNum">    2462 </span>            :                 }
<span class="lineNum">    2463 </span>            :             }
<span class="lineNum">    2464 </span>            :         }
<span class="lineNum">    2465 </span><span class="lineCov">      10651 :         if ( stem-&gt;rightline != NULL ) {</span>
<span class="lineNum">    2466 </span><span class="lineCov">       4623 :             line = stem-&gt;rightline;</span>
<span class="lineNum">    2467 </span><span class="lineCov">       4623 :             line_hv = ( needs_hv &amp;&amp; LineFitsHV( line ));</span>
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span><span class="lineCov">       4623 :             if ( needs_hv &amp;&amp; !line_hv )</span>
<span class="lineNum">    2470 </span><span class="lineCov">          2 :                 stem-&gt;rightline = NULL;</span>
<span class="lineNum">    2471 </span>            :             else {
<span class="lineNum">    2472 </span><span class="lineCov">      17077 :                 for ( j=0; j&lt;line-&gt;pcnt; j++ ) {</span>
<span class="lineNum">    2473 </span><span class="lineCov">      12456 :                     pd = line-&gt;points[j];</span>
<span class="lineNum">    2474 </span><span class="lineCov">      20038 :                     if ( pd-&gt;prevline == line &amp;&amp; OnStem( stem,&amp;pd-&gt;base,false ) &amp;&amp;</span>
<span class="lineNum">    2475 </span><span class="lineCov">       7582 :                         IsStemAssignedToPoint( pd,stem,false ) == -1 ) {</span>
<span class="lineNum">    2476 </span><span class="lineCov">       1277 :                         chunk = AddToStem( gd,stem,NULL,pd,false,false,false );</span>
<span class="lineNum">    2477 </span><span class="lineCov">       1277 :                         chunk-&gt;rpotential = true;</span>
<span class="lineNum">    2478 </span><span class="lineCov">      19914 :                     } if ( pd-&gt;nextline == line &amp;&amp; OnStem( stem,&amp;pd-&gt;base,false ) &amp;&amp;</span>
<span class="lineNum">    2479 </span><span class="lineCov">       7458 :                         IsStemAssignedToPoint( pd,stem,true ) == -1 ) {</span>
<span class="lineNum">    2480 </span><span class="lineCov">        703 :                         chunk = AddToStem( gd,stem,NULL,pd,false,true,false );</span>
<span class="lineNum">    2481 </span><span class="lineCov">        703 :                         chunk-&gt;rpotential = true;</span>
<span class="lineNum">    2482 </span>            :                     }
<span class="lineNum">    2483 </span>            :                 }
<span class="lineNum">    2484 </span>            :             }
<span class="lineNum">    2485 </span>            :         }
<span class="lineNum">    2486 </span>            :     }
<a name="2487"><span class="lineNum">    2487 </span><span class="lineCov">       1644 : }</span></a>
<span class="lineNum">    2488 </span>            : 
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 : static struct stemdata *DiagonalCornerStem( struct glyphdata *gd,</span>
<span class="lineNum">    2490 </span>            :     struct pointdata *pd,int require_existing ) {
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :     Spline *other = pd-&gt;bothedge;</span>
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :     struct pointdata *pfrom = NULL, *pto = NULL, *pd2 = NULL, *pd3=NULL;</span>
<span class="lineNum">    2493 </span>            :     double width, length;
<span class="lineNum">    2494 </span>            :     struct stemdata *stem;
<span class="lineNum">    2495 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    2496 </span>            : 
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :     pfrom = &amp;gd-&gt;points[other-&gt;from-&gt;ptindex];</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :     pto = &amp;gd-&gt;points[other-&gt;to-&gt;ptindex];</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :     if ( pd-&gt;symetrical_h &amp;&amp; pto-&gt;symetrical_h &amp;&amp; pd-&gt;both_e_t&gt;.9 )</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :         pd2 = pto;</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :     else if ( pd-&gt;symetrical_h &amp;&amp; pfrom-&gt;symetrical_h &amp;&amp; pd-&gt;both_e_t&lt;.1 )</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :         pd2 = pfrom;</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :     else if ( pd-&gt;symetrical_v &amp;&amp; pto-&gt;symetrical_v &amp;&amp; pd-&gt;both_e_t&gt;.9 )</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :         pd2 = pto;</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :     else if ( pd-&gt;symetrical_v &amp;&amp; pfrom-&gt;symetrical_v &amp;&amp; pd-&gt;both_e_t&lt;.1 )</span>
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :         pd2 = pfrom;</span>
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :     else if ( pd-&gt;symetrical_h &amp;&amp; other-&gt;islinear &amp;&amp; other-&gt;splines[1].c==0 ) {</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :         pd2 = pfrom;</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :         pd3 = pto;</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :     } else if ( pd-&gt;symetrical_v &amp;&amp; other-&gt;islinear &amp;&amp; other-&gt;splines[0].c==0 ) {</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :         pd2 = pfrom;</span>
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :         pd3 = pto;</span>
<span class="lineNum">    2513 </span>            :     } else
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :     if ( pd-&gt;symetrical_v )</span>
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :         width = (pd-&gt;sp-&gt;me.x-pd2-&gt;sp-&gt;me.x);</span>
<span class="lineNum">    2518 </span>            :     else
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :         width = (pd-&gt;sp-&gt;me.y-pd2-&gt;sp-&gt;me.y);</span>
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :     length = (pd-&gt;sp-&gt;next-&gt;to-&gt;me.x-pd-&gt;sp-&gt;me.x)*(pd-&gt;sp-&gt;next-&gt;to-&gt;me.x-pd-&gt;sp-&gt;me.x) +</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :              (pd-&gt;sp-&gt;next-&gt;to-&gt;me.y-pd-&gt;sp-&gt;me.y)*(pd-&gt;sp-&gt;next-&gt;to-&gt;me.y-pd-&gt;sp-&gt;me.y);</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :     if ( width*width&gt;length )</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2524 </span>            : 
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :     stem = FindOrMakeHVStem(gd,pd,pd2,pd-&gt;symetrical_h,require_existing);</span>
<span class="lineNum">    2526 </span>            :     
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :     if ( pd3 == NULL &amp;&amp; stem != NULL )</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :         chunk = AddToStem( gd,stem,pd,pd2,2,2,2 );</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :     else if ( stem != NULL ) {</span>
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :         chunk = AddToStem( gd,stem,pd,pd2,2,2,3 );</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :         chunk = AddToStem( gd,stem,pd,pd3,2,2,3 );</span>
<span class="lineNum">    2532 </span>            :     }
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 : return( stem );</span>
<a name="2534"><span class="lineNum">    2534 </span>            : }</a>
<span class="lineNum">    2535 </span>            : 
<span class="lineNum">    2536 </span><span class="lineCov">      21330 : static int chunk_cmp( const void *_p1, const void *_p2 ) {</span>
<span class="lineNum">    2537 </span><span class="lineCov">      21330 :     const struct stem_chunk *ch1 = _p1, *ch2 = _p2;</span>
<span class="lineNum">    2538 </span>            :     
<span class="lineNum">    2539 </span>            :     struct stemdata *stem;
<span class="lineNum">    2540 </span><span class="lineCov">      21330 :     double loff1=0,roff1=0,loff2=0,roff2=0;</span>
<span class="lineNum">    2541 </span>            :     
<span class="lineNum">    2542 </span><span class="lineCov">      21330 :     stem = ch1-&gt;parent;</span>
<span class="lineNum">    2543 </span><span class="lineCov">      21330 :     if ( stem==NULL )</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2545 </span>            : 
<span class="lineNum">    2546 </span><span class="lineCov">      21330 :     if ( ch1-&gt;l != NULL )</span>
<span class="lineNum">    2547 </span><span class="lineCov">      37566 :         loff1 = ( ch1-&gt;l-&gt;sp-&gt;me.x - stem-&gt;left.x ) * stem-&gt;unit.x +</span>
<span class="lineNum">    2548 </span><span class="lineCov">      18783 :                 ( ch1-&gt;l-&gt;sp-&gt;me.y - stem-&gt;left.y ) * stem-&gt;unit.y;</span>
<span class="lineNum">    2549 </span><span class="lineCov">      21330 :     if ( ch1-&gt;r != NULL )</span>
<span class="lineNum">    2550 </span><span class="lineCov">      36240 :         roff1 = ( ch1-&gt;r-&gt;sp-&gt;me.x - stem-&gt;right.x ) * stem-&gt;unit.x +</span>
<span class="lineNum">    2551 </span><span class="lineCov">      18120 :                 ( ch1-&gt;r-&gt;sp-&gt;me.y - stem-&gt;right.y ) * stem-&gt;unit.y;</span>
<span class="lineNum">    2552 </span><span class="lineCov">      21330 :     if ( ch2-&gt;l != NULL )</span>
<span class="lineNum">    2553 </span><span class="lineCov">      31356 :         loff2 = ( ch2-&gt;l-&gt;sp-&gt;me.x - stem-&gt;left.x ) * stem-&gt;unit.x +</span>
<span class="lineNum">    2554 </span><span class="lineCov">      15678 :                 ( ch2-&gt;l-&gt;sp-&gt;me.y - stem-&gt;left.y ) * stem-&gt;unit.y;</span>
<span class="lineNum">    2555 </span><span class="lineCov">      21330 :     if ( ch2-&gt;r != NULL )</span>
<span class="lineNum">    2556 </span><span class="lineCov">      33838 :         roff2 = ( ch2-&gt;r-&gt;sp-&gt;me.x - stem-&gt;right.x ) * stem-&gt;unit.x +</span>
<span class="lineNum">    2557 </span><span class="lineCov">      16919 :                 ( ch2-&gt;r-&gt;sp-&gt;me.y - stem-&gt;right.y ) * stem-&gt;unit.y;</span>
<span class="lineNum">    2558 </span>            :         
<span class="lineNum">    2559 </span><span class="lineCov">      21330 :     if ( loff1&gt;loff2 )</span>
<span class="lineNum">    2560 </span><span class="lineCov">       6949 : return( 1 );</span>
<span class="lineNum">    2561 </span><span class="lineCov">      14381 :     else if ( loff1&lt;loff2 )</span>
<span class="lineNum">    2562 </span><span class="lineCov">       8331 : return( -1 );</span>
<span class="lineNum">    2563 </span>            :     else {
<span class="lineNum">    2564 </span><span class="lineCov">       6050 :         if ( roff1&gt;roff2 )</span>
<span class="lineNum">    2565 </span><span class="lineCov">       3388 : return( 1 );</span>
<span class="lineNum">    2566 </span><span class="lineCov">       2662 :         else if ( roff1&lt;roff2 )</span>
<span class="lineNum">    2567 </span><span class="lineCov">       2649 : return( -1 );</span>
<span class="lineNum">    2568 </span>            :         else
<span class="lineNum">    2569 </span><span class="lineCov">         13 : return( 0 );</span>
<span class="lineNum">    2570 </span>            :     }
<a name="2571"><span class="lineNum">    2571 </span>            : }</a>
<span class="lineNum">    2572 </span>            : 
<span class="lineNum">    2573 </span><span class="lineCov">       4128 : static int stem_cmp( const void *_p1, const void *_p2 ) {</span>
<span class="lineNum">    2574 </span><span class="lineCov">       4128 :     struct stemdata * const *st1 = _p1, * const *st2 = _p2;</span>
<span class="lineNum">    2575 </span>            :     double start1, end1, start2, end2;
<span class="lineNum">    2576 </span>            :     
<span class="lineNum">    2577 </span><span class="lineCov">       4128 :     if ( fabs( (*st1)-&gt;unit.x ) &gt; fabs( (*st1)-&gt;unit.y )) {</span>
<span class="lineNum">    2578 </span><span class="lineCov">       2565 :         start1 = (*st1)-&gt;right.y; end1 = (*st1)-&gt;left.y;</span>
<span class="lineNum">    2579 </span><span class="lineCov">       2565 :         start2 = (*st2)-&gt;right.y; end2 = (*st2)-&gt;left.y;</span>
<span class="lineNum">    2580 </span>            :     } else {
<span class="lineNum">    2581 </span><span class="lineCov">       1563 :         start1 = (*st1)-&gt;left.x; end1 = (*st1)-&gt;right.x;</span>
<span class="lineNum">    2582 </span><span class="lineCov">       1563 :         start2 = (*st2)-&gt;left.x; end2 = (*st2)-&gt;right.x;</span>
<span class="lineNum">    2583 </span>            :     }
<span class="lineNum">    2584 </span>            :         
<span class="lineNum">    2585 </span><span class="lineCov">       4128 :     if ( start1 &gt; start2 )</span>
<span class="lineNum">    2586 </span><span class="lineCov">       1419 : return( 1 );</span>
<span class="lineNum">    2587 </span><span class="lineCov">       2709 :     else if ( start1 &lt; start2 )</span>
<span class="lineNum">    2588 </span><span class="lineCov">       2550 : return( -1 );</span>
<span class="lineNum">    2589 </span>            :     else {
<span class="lineNum">    2590 </span><span class="lineCov">        159 :         if ( end1 &gt; end2 )</span>
<span class="lineNum">    2591 </span><span class="lineCov">         49 : return( 1 );</span>
<span class="lineNum">    2592 </span><span class="lineCov">        110 :         else if ( end1 &lt; end2 )</span>
<span class="lineNum">    2593 </span><span class="lineCov">         11 : return( -1 );</span>
<span class="lineNum">    2594 </span>            :         else
<span class="lineNum">    2595 </span><span class="lineCov">         99 : return( 0 );</span>
<span class="lineNum">    2596 </span>            :     }
<a name="2597"><span class="lineNum">    2597 </span>            : }</a>
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span><span class="lineCov">      81264 : static void FixupT( struct pointdata *pd,int stemidx,int isnext, int eidx ) {</span>
<span class="lineNum">    2600 </span>            :     /* When we calculated &quot;next/prev_e_t&quot; we deliberately did not use pd1-&gt;me */
<span class="lineNum">    2601 </span>            :     /*  (because things get hard at intersections) so our t is only an approx-*/
<span class="lineNum">    2602 </span>            :     /*  imation. We can do a lot better now */
<span class="lineNum">    2603 </span>            :     Spline *s;
<span class="lineNum">    2604 </span>            :     Spline myline;
<span class="lineNum">    2605 </span>            :     SplinePoint end1, end2;
<span class="lineNum">    2606 </span>            :     double width,t,sign, len, dot;
<span class="lineNum">    2607 </span>            :     BasePoint pts[9];
<span class="lineNum">    2608 </span>            :     extended lts[10], sts[10];
<span class="lineNum">    2609 </span>            :     BasePoint diff;
<span class="lineNum">    2610 </span>            :     struct stemdata *stem ;
<span class="lineNum">    2611 </span>            :     
<span class="lineNum">    2612 </span><span class="lineCov">      81264 :     if ( pd == NULL || stemidx == -1 )</span>
<span class="lineNum">    2613 </span><span class="lineCov">      55251 : return;</span>
<span class="lineNum">    2614 </span><span class="lineCov">      57271 :     stem = ( isnext ) ? pd-&gt;nextstems[stemidx] : pd-&gt;prevstems[stemidx];</span>
<span class="lineNum">    2615 </span><span class="lineCov">     114542 :     width = ( stem-&gt;right.x - stem-&gt;left.x )*stem-&gt;unit.y - </span>
<span class="lineNum">    2616 </span><span class="lineCov">      57271 :             ( stem-&gt;right.y-stem-&gt;left.y )*stem-&gt;unit.x;</span>
<span class="lineNum">    2617 </span><span class="lineCov">      57271 :     s = ( isnext ) ? pd-&gt;nextedges[eidx] : pd-&gt;prevedges[eidx];</span>
<span class="lineNum">    2618 </span><span class="lineCov">      57271 :     if ( s==NULL )</span>
<span class="lineNum">    2619 </span><span class="lineCov">        193 : return;</span>
<span class="lineNum">    2620 </span><span class="lineCov">      57078 :     diff.x = s-&gt;to-&gt;me.x-s-&gt;from-&gt;me.x;</span>
<span class="lineNum">    2621 </span><span class="lineCov">      57078 :     diff.y = s-&gt;to-&gt;me.y-s-&gt;from-&gt;me.y;</span>
<span class="lineNum">    2622 </span><span class="lineCov">      57078 :     if ( diff.x&lt;.001 &amp;&amp; diff.x&gt;-.001 &amp;&amp; diff.y&lt;.001 &amp;&amp; diff.y&gt;-.001 )</span>
<span class="lineNum">    2623 </span><span class="lineNoCov">          0 : return;         /* Zero length splines give us NaNs */</span>
<span class="lineNum">    2624 </span><span class="lineCov">      57078 :     len = sqrt( pow( diff.x,2 ) + pow( diff.y,2 ));</span>
<span class="lineNum">    2625 </span><span class="lineCov">      57078 :     dot = ( diff.x*stem-&gt;unit.x + diff.y*stem-&gt;unit.y )/len;</span>
<span class="lineNum">    2626 </span><span class="lineCov">      57078 :     if ( dot &lt; .0004 &amp;&amp; dot &gt; -.0004 )</span>
<span class="lineNum">    2627 </span><span class="lineCov">        286 : return;         /* It's orthogonal to our stem */</span>
<span class="lineNum">    2628 </span>            : 
<span class="lineNum">    2629 </span><span class="lineCov">      56792 :     if (( stem-&gt;unit.x==1 || stem-&gt;unit.x==-1 ) &amp;&amp; s-&gt;knownlinear )</span>
<span class="lineNum">    2630 </span><span class="lineCov">      11165 :         t = (pd-&gt;sp-&gt;me.x-s-&gt;from-&gt;me.x)/(s-&gt;to-&gt;me.x-s-&gt;from-&gt;me.x);</span>
<span class="lineNum">    2631 </span><span class="lineCov">      45627 :     else if (( stem-&gt;unit.y==1 || stem-&gt;unit.y==-1 ) &amp;&amp; s-&gt;knownlinear )</span>
<span class="lineNum">    2632 </span><span class="lineCov">      11054 :         t = (pd-&gt;sp-&gt;me.y-s-&gt;from-&gt;me.y)/(s-&gt;to-&gt;me.y-s-&gt;from-&gt;me.y);</span>
<span class="lineNum">    2633 </span>            :     else {
<span class="lineNum">    2634 </span><span class="lineCov">      34573 :         memset(&amp;myline,0,sizeof(myline));</span>
<span class="lineNum">    2635 </span><span class="lineCov">      34573 :         memset(&amp;end1,0,sizeof(end1));</span>
<span class="lineNum">    2636 </span><span class="lineCov">      34573 :         memset(&amp;end2,0,sizeof(end2));</span>
<span class="lineNum">    2637 </span><span class="lineCov">      34573 :         sign = (( isnext &amp;&amp; pd-&gt;next_is_l[stemidx] ) || ( !isnext &amp;&amp; pd-&gt;prev_is_l[stemidx] )) ? 1 : -1;</span>
<span class="lineNum">    2638 </span><span class="lineCov">      34573 :         myline.knownlinear = myline.islinear = true;</span>
<span class="lineNum">    2639 </span><span class="lineCov">      34573 :         end1.me = pd-&gt;sp-&gt;me;</span>
<span class="lineNum">    2640 </span><span class="lineCov">      34573 :         end2.me.x = pd-&gt;sp-&gt;me.x+1.1*sign*width*stem-&gt;l_to_r.x;</span>
<span class="lineNum">    2641 </span><span class="lineCov">      34573 :         end2.me.y = pd-&gt;sp-&gt;me.y+1.1*sign*width*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    2642 </span><span class="lineCov">      34573 :         end1.nextcp = end1.prevcp = end1.me;</span>
<span class="lineNum">    2643 </span><span class="lineCov">      34573 :         end2.nextcp = end2.prevcp = end2.me;</span>
<span class="lineNum">    2644 </span><span class="lineCov">      34573 :         end1.nonextcp = end1.noprevcp = end2.nonextcp = end2.noprevcp = true;</span>
<span class="lineNum">    2645 </span><span class="lineCov">      34573 :         end1.next = &amp;myline; end2.prev = &amp;myline;</span>
<span class="lineNum">    2646 </span><span class="lineCov">      34573 :         myline.from = &amp;end1; myline.to = &amp;end2;</span>
<span class="lineNum">    2647 </span><span class="lineCov">      34573 :         myline.splines[0].d = end1.me.x;</span>
<span class="lineNum">    2648 </span><span class="lineCov">      34573 :         myline.splines[0].c = end2.me.x-end1.me.x;</span>
<span class="lineNum">    2649 </span><span class="lineCov">      34573 :         myline.splines[1].d = end1.me.y;</span>
<span class="lineNum">    2650 </span><span class="lineCov">      34573 :         myline.splines[1].c = end2.me.y-end1.me.y;</span>
<span class="lineNum">    2651 </span><span class="lineCov">      34573 :         if ( SplinesIntersect(&amp;myline,s,pts,lts,sts)&lt;=0 )</span>
<span class="lineNum">    2652 </span><span class="lineCov">       6786 : return;</span>
<span class="lineNum">    2653 </span><span class="lineCov">      27787 :         t = sts[0];</span>
<span class="lineNum">    2654 </span>            :     }
<span class="lineNum">    2655 </span><span class="lineCov">      50006 :     if ( isnan(t))</span>
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :         IError( &quot;NaN value in FixupT&quot; );</span>
<span class="lineNum">    2657 </span><span class="lineCov">      50006 :     if ( isnext )</span>
<span class="lineNum">    2658 </span><span class="lineCov">      24867 :         pd-&gt;next_e_t[eidx] = t;</span>
<span class="lineNum">    2659 </span>            :     else
<span class="lineNum">    2660 </span><span class="lineCov">      25139 :         pd-&gt;prev_e_t[eidx] = t;</span>
<span class="lineNum">    2661 </span>            : }
<span class="lineNum">    2662 </span>            : 
<a name="2663"><span class="lineNum">    2663 </span>            : /* flags: 1 -- accept curved extrema, 2 -- accept angles, */</a>
<span class="lineNum">    2664 </span>            : /*      4 -- analyze segments (not just single points)    */
<span class="lineNum">    2665 </span><span class="lineCov">      32883 : static int IsSplinePeak( struct glyphdata *gd,struct pointdata *pd,</span>
<span class="lineNum">    2666 </span>            :     int outer,int is_x,int flags ) {
<span class="lineNum">    2667 </span>            :     
<span class="lineNum">    2668 </span>            :     double base, next, prev, nextctl, prevctl, unit_p, unit_n;
<span class="lineNum">    2669 </span>            :     Spline *s, *snext, *sprev;
<span class="lineNum">    2670 </span>            :     struct monotonic **space, *m;
<span class="lineNum">    2671 </span>            :     int wprev, wnext, i, desired;
<span class="lineNum">    2672 </span><span class="lineCov">      32883 :     SplinePoint *sp = pd-&gt;sp;</span>
<span class="lineNum">    2673 </span>            :     
<span class="lineNum">    2674 </span><span class="lineCov">      32883 :     base = ((real *) &amp;sp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    2675 </span><span class="lineCov">      32883 :     nextctl = sp-&gt;nonextcp ? base : ((real *) &amp;sp-&gt;nextcp.x)[!is_x];</span>
<span class="lineNum">    2676 </span><span class="lineCov">      32883 :     prevctl = sp-&gt;noprevcp ? base : ((real *) &amp;sp-&gt;prevcp.x)[!is_x];</span>
<span class="lineNum">    2677 </span><span class="lineCov">      32883 :     next = prev = base;</span>
<span class="lineNum">    2678 </span><span class="lineCov">      32883 :     snext = sp-&gt;next; sprev = sp-&gt;prev;</span>
<span class="lineNum">    2679 </span>            :     
<span class="lineNum">    2680 </span><span class="lineCov">      32883 :     if ( snext-&gt;to == NULL || sprev-&gt;from == NULL )</span>
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    2682 </span><span class="lineCov">      32883 :     if (!( flags &amp; 2) &amp;&amp; ( sp-&gt;nonextcp || sp-&gt;noprevcp ))</span>
<span class="lineNum">    2683 </span><span class="lineCov">       5480 : return( false );</span>
<span class="lineNum">    2684 </span><span class="lineCov">      27403 :     else if (!( flags &amp; 1 ) &amp;&amp; ( pd-&gt;colinear ))</span>
<span class="lineNum">    2685 </span><span class="lineCov">        300 : return( false );</span>
<span class="lineNum">    2686 </span>            : 
<span class="lineNum">    2687 </span><span class="lineCov">      27103 :     if ( flags &amp; 4 ) {</span>
<span class="lineNum">    2688 </span><span class="lineCov">       9846 :         while ( snext-&gt;to-&gt;next != NULL &amp;&amp; snext-&gt;to != sp &amp;&amp; next == base ) {</span>
<span class="lineNum">    2689 </span><span class="lineCov">       3894 :             next = ((real *) &amp;snext-&gt;to-&gt;me.x)[!is_x];</span>
<span class="lineNum">    2690 </span><span class="lineCov">       3894 :             snext = snext-&gt;to-&gt;next;</span>
<span class="lineNum">    2691 </span>            :         }
<span class="lineNum">    2692 </span>            : 
<span class="lineNum">    2693 </span><span class="lineCov">       9894 :         while ( sprev-&gt;from-&gt;prev != NULL &amp;&amp; sprev-&gt;from != sp &amp;&amp; prev == base ) {</span>
<span class="lineNum">    2694 </span><span class="lineCov">       3942 :             prev = ((real *) &amp;sprev-&gt;from-&gt;me.x)[!is_x];</span>
<span class="lineNum">    2695 </span><span class="lineCov">       3942 :             sprev = sprev-&gt;from-&gt;prev;</span>
<span class="lineNum">    2696 </span>            :         }
<span class="lineNum">    2697 </span>            :     } else {
<span class="lineNum">    2698 </span><span class="lineCov">      24127 :         next = ((real *) &amp;snext-&gt;to-&gt;me.x)[!is_x];</span>
<span class="lineNum">    2699 </span><span class="lineCov">      24127 :         prev = ((real *) &amp;sprev-&gt;from-&gt;me.x)[!is_x];</span>
<span class="lineNum">    2700 </span>            :     }
<span class="lineNum">    2701 </span>            :     
<span class="lineNum">    2702 </span><span class="lineCov">      27103 :     if ( prev&lt;base &amp;&amp; next&lt;base &amp;&amp; nextctl&lt;=base &amp;&amp; prevctl&lt;=base )</span>
<span class="lineNum">    2703 </span><span class="lineCov">       9709 :         desired = ( outer ) ? -1 : 1;</span>
<span class="lineNum">    2704 </span><span class="lineCov">      17394 :     else if ( prev&gt;base &amp;&amp; next&gt;base &amp;&amp; prevctl&gt;=base &amp;&amp; nextctl&gt;=base )</span>
<span class="lineNum">    2705 </span><span class="lineCov">       9231 :         desired = ( outer ) ? 1 : -1;</span>
<span class="lineNum">    2706 </span>            :     else
<span class="lineNum">    2707 </span><span class="lineCov">       8163 : return( false );</span>
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span><span class="lineCov">      18940 :     MonotonicFindAt( gd-&gt;ms,is_x,((real *) &amp;sp-&gt;me.x)[is_x],space = gd-&gt;space );</span>
<span class="lineNum">    2710 </span><span class="lineCov">      18940 :     wprev = wnext = 0;</span>
<span class="lineNum">    2711 </span><span class="lineCov">     111528 :     for ( i=0; space[i]!=NULL; ++i ) {</span>
<span class="lineNum">    2712 </span><span class="lineCov">      92588 :         m = space[i];</span>
<span class="lineNum">    2713 </span><span class="lineCov">      92588 :         s = m-&gt;s;</span>
<span class="lineNum">    2714 </span>            : 
<span class="lineNum">    2715 </span><span class="lineCov">      92588 :         if ( s-&gt;from == sp )</span>
<span class="lineNum">    2716 </span><span class="lineCov">      13277 :             wnext = ((&amp;m-&gt;xup)[is_x] ? 1 : -1 );</span>
<span class="lineNum">    2717 </span><span class="lineCov">      79311 :         else if ( s-&gt;to == sp )</span>
<span class="lineNum">    2718 </span><span class="lineCov">      15036 :             wprev = ((&amp;m-&gt;xup)[is_x] ? 1 : -1 );</span>
<span class="lineNum">    2719 </span>            :     }
<span class="lineNum">    2720 </span>            : 
<span class="lineNum">    2721 </span><span class="lineCov">      18940 :     if ( wnext != 0 &amp;&amp; wprev != 0 &amp;&amp; wnext != wprev ) {</span>
<span class="lineNum">    2722 </span><span class="lineCov">       1926 :         unit_p = (&amp;pd-&gt;prevunit.x)[!is_x];</span>
<span class="lineNum">    2723 </span><span class="lineCov">       1926 :         unit_n = (&amp;pd-&gt;nextunit.x)[!is_x];</span>
<span class="lineNum">    2724 </span><span class="lineCov">       2608 :         if ( unit_p &lt; unit_n &amp;&amp; (</span>
<span class="lineNum">    2725 </span><span class="lineCov">        435 :             ( outer &amp;&amp; wprev == 1 ) || ( !outer &amp;&amp; wprev == -1 )))</span>
<span class="lineNum">    2726 </span><span class="lineCov">        639 : return( desired );</span>
<span class="lineNum">    2727 </span><span class="lineCov">       1287 :         else if ( unit_p &gt; unit_n &amp;&amp; (</span>
<span class="lineNum">    2728 </span><span class="lineCov">        370 :             ( outer &amp;&amp; wnext == 1 ) || ( !outer &amp;&amp; wnext == -1 )))</span>
<span class="lineNum">    2729 </span><span class="lineCov">        605 : return( desired );</span>
<span class="lineNum">    2730 </span>            :     } else {
<span class="lineNum">    2731 </span><span class="lineCov">      17014 :         if ( wnext == desired || wprev == desired )</span>
<span class="lineNum">    2732 </span><span class="lineCov">      11943 : return( desired );</span>
<span class="lineNum">    2733 </span>            :     }
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span><span class="lineCov">       5753 : return( false );</span>
<a name="2736"><span class="lineNum">    2736 </span>            : }</a>
<span class="lineNum">    2737 </span>            : 
<span class="lineNum">    2738 </span><span class="lineCov">      17647 : static struct pointdata *FindClosestOpposite( </span>
<span class="lineNum">    2739 </span>            :     struct stemdata *stem,struct stem_chunk **chunk,SplinePoint *sp,int *next ) {
<span class="lineNum">    2740 </span>            : 
<span class="lineNum">    2741 </span><span class="lineCov">      17647 :     struct pointdata *pd, *ret=NULL;</span>
<span class="lineNum">    2742 </span>            :     struct stem_chunk *testchunk;
<span class="lineNum">    2743 </span><span class="lineCov">      17647 :     double test, proj=1e4;</span>
<span class="lineNum">    2744 </span>            :     int i, is_l;
<span class="lineNum">    2745 </span>            :     
<span class="lineNum">    2746 </span><span class="lineCov">      78717 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    2747 </span><span class="lineCov">      61070 :         testchunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    2748 </span><span class="lineCov">      61070 :         pd = NULL;</span>
<span class="lineNum">    2749 </span><span class="lineCov">      61070 :         if ( testchunk-&gt;l != NULL &amp;&amp; testchunk-&gt;l-&gt;sp==sp ) {</span>
<span class="lineNum">    2750 </span><span class="lineCov">       9368 :             pd = testchunk-&gt;r;</span>
<span class="lineNum">    2751 </span><span class="lineCov">       9368 :             is_l = false;</span>
<span class="lineNum">    2752 </span><span class="lineCov">      51702 :         } else if ( testchunk-&gt;r != NULL &amp;&amp; testchunk-&gt;r-&gt;sp==sp ) {</span>
<span class="lineNum">    2753 </span><span class="lineCov">      10085 :             pd = testchunk-&gt;l;</span>
<span class="lineNum">    2754 </span><span class="lineCov">      10085 :             is_l = true;</span>
<span class="lineNum">    2755 </span>            :         }
<span class="lineNum">    2756 </span>            :         
<span class="lineNum">    2757 </span><span class="lineCov">      61070 :         if ( pd != NULL ) {</span>
<span class="lineNum">    2758 </span><span class="lineCov">      28618 :             test = ( pd-&gt;sp-&gt;me.x-sp-&gt;me.x ) * stem-&gt;unit.x +</span>
<span class="lineNum">    2759 </span><span class="lineCov">      14309 :                    ( pd-&gt;sp-&gt;me.y-sp-&gt;me.y ) * stem-&gt;unit.y;</span>
<span class="lineNum">    2760 </span><span class="lineCov">      14309 :             if ( test &lt; 0 ) test = -test;</span>
<span class="lineNum">    2761 </span><span class="lineCov">      14309 :             if ( test &lt; proj ) {</span>
<span class="lineNum">    2762 </span><span class="lineCov">      13486 :                 ret = pd;</span>
<span class="lineNum">    2763 </span><span class="lineCov">      13486 :                 proj = test;</span>
<span class="lineNum">    2764 </span><span class="lineCov">      13486 :                 *chunk = testchunk;</span>
<span class="lineNum">    2765 </span>            :             }
<span class="lineNum">    2766 </span>            :         }
<span class="lineNum">    2767 </span>            :     }
<span class="lineNum">    2768 </span><span class="lineCov">      17647 :     if ( ret != NULL )</span>
<span class="lineNum">    2769 </span><span class="lineCov">      12503 :         *next = ( is_l ) ? (*chunk)-&gt;lnext : (*chunk)-&gt;rnext;</span>
<span class="lineNum">    2770 </span><span class="lineCov">      17647 : return( ret );</span>
<a name="2771"><span class="lineNum">    2771 </span>            : }</a>
<span class="lineNum">    2772 </span>            : 
<span class="lineNum">    2773 </span><span class="lineCov">      12503 : static int ValueChunk( struct glyphdata *gd,struct vchunk *vchunks,</span>
<span class="lineNum">    2774 </span>            :     int chcnt,int idx,int l_base ) {
<span class="lineNum">    2775 </span>            :     
<span class="lineNum">    2776 </span><span class="lineCov">      12503 :     int peak1=0, peak2=0, val=0; </span>
<span class="lineNum">    2777 </span>            :     int i, is_x, base_next, opp_next;
<span class="lineNum">    2778 </span>            :     struct pointdata *base, *opp, *frompd, *topd;
<span class="lineNum">    2779 </span><span class="lineCov">      12503 :     struct stem_chunk *chunk = vchunks[idx].chunk, *tchunk;</span>
<span class="lineNum">    2780 </span><span class="lineCov">      12503 :     struct stemdata *stem = chunk-&gt;parent;</span>
<span class="lineNum">    2781 </span>            :     double norm, dist;
<span class="lineNum">    2782 </span>            :     Spline *sbase, *sopp, *other;
<span class="lineNum">    2783 </span>            :     
<span class="lineNum">    2784 </span>            :     /* If a stem was already present before generating glyph data, */
<span class="lineNum">    2785 </span>            :     /* then it should always be preferred in case of a conflict    */
<span class="lineNum">    2786 </span><span class="lineCov">      12503 :     if ( stem-&gt;positioned || chunk-&gt;stemcheat ) val++;</span>
<span class="lineNum">    2787 </span>            :     
<span class="lineNum">    2788 </span><span class="lineCov">      12503 :     if ( l_base ) {</span>
<span class="lineNum">    2789 </span><span class="lineCov">       5899 :         base = chunk-&gt;l; opp = chunk-&gt;r;</span>
<span class="lineNum">    2790 </span><span class="lineCov">       5899 :         base_next = chunk-&gt;lnext; opp_next = chunk-&gt;rnext;</span>
<span class="lineNum">    2791 </span>            :     } else {
<span class="lineNum">    2792 </span><span class="lineCov">       6604 :         base = chunk-&gt;r; opp = chunk-&gt;l;</span>
<span class="lineNum">    2793 </span><span class="lineCov">       6604 :         base_next = chunk-&gt;rnext; opp_next = chunk-&gt;lnext;</span>
<span class="lineNum">    2794 </span>            :     }
<span class="lineNum">    2795 </span><span class="lineCov">      12503 :     sbase = ( base_next ) ? base-&gt;sp-&gt;next : base-&gt;sp-&gt;prev;</span>
<span class="lineNum">    2796 </span><span class="lineCov">      12503 :     sopp = ( opp_next ) ? opp-&gt;sp-&gt;next : opp-&gt;sp-&gt;prev;</span>
<span class="lineNum">    2797 </span><span class="lineCov">      12503 :     other = ( opp_next ) ? opp-&gt;nextedges[0] : opp-&gt;prevedges[0];</span>
<span class="lineNum">    2798 </span>            :     
<span class="lineNum">    2799 </span>            :     /* If there are 2 conflicting chunks belonging to different stems but       */
<span class="lineNum">    2800 </span>            :     /* based on the same point, then we have to decide which stem is &quot;better&quot;   */
<span class="lineNum">    2801 </span>            :     /* for that point. We compare stems (or rather chunks) by assigning a       */
<span class="lineNum">    2802 </span>            :     /* value to each of them and then prefer the stem whose value is positive.  */
<span class="lineNum">    2803 </span>            :     /* A chunk gets a +1 value bonus in the following cases:                    */
<span class="lineNum">    2804 </span>            :     /* - The stem is vertical/horizontal and splines are curved in the same     */
<span class="lineNum">    2805 </span>            :     /*   direction at both sides of the chunk;                                  */
<span class="lineNum">    2806 </span>            :     /* - A stem has both its width and the distance between the opposite points */
<span class="lineNum">    2807 </span>            :     /*   smaller than another stem;                                             */
<span class="lineNum">    2808 </span>            :     /* - The common side of two stems is a straight line formed by two points   */
<span class="lineNum">    2809 </span>            :     /*   and the opposite point can be projected to line segment between those  */
<span class="lineNum">    2810 </span>            :     /*   two points. */
<span class="lineNum">    2811 </span><span class="lineCov">      12503 :     if ( IsUnitHV( &amp;stem-&gt;unit,true ) &amp;&amp; !sbase-&gt;knownlinear ) {</span>
<span class="lineNum">    2812 </span><span class="lineCov">       4378 :         is_x = (int) rint( stem-&gt;unit.y );</span>
<span class="lineNum">    2813 </span><span class="lineCov">       4378 :         peak1 = ( is_x ) ? base-&gt;x_extr : base-&gt;y_extr;</span>
<span class="lineNum">    2814 </span><span class="lineCov">       4378 :         peak2 = ( is_x ) ? opp-&gt;x_extr  : opp-&gt;y_extr;</span>
<span class="lineNum">    2815 </span>            : 
<span class="lineNum">    2816 </span><span class="lineCov">       8756 :         dist =  ( base-&gt;base.x - opp-&gt;base.x )*stem-&gt;unit.x +</span>
<span class="lineNum">    2817 </span><span class="lineCov">       4378 :                 ( base-&gt;base.y - opp-&gt;base.y )*stem-&gt;unit.y;</span>
<span class="lineNum">    2818 </span>            :         
<span class="lineNum">    2819 </span>            :         /* Are there any stems attached to the same base point which     */
<span class="lineNum">    2820 </span>            :         /* are narrower than the distance between two points forming the */
<span class="lineNum">    2821 </span>            :         /* given chunk? */
<span class="lineNum">    2822 </span><span class="lineCov">      11388 :         for ( i=0; i&lt;chcnt; i++ ) {</span>
<span class="lineNum">    2823 </span><span class="lineCov">       8353 :             tchunk = vchunks[i].chunk;</span>
<span class="lineNum">    2824 </span><span class="lineCov">       8353 :             if ( tchunk == NULL || tchunk == chunk || chunk-&gt;l == NULL || chunk-&gt;r == NULL )</span>
<span class="lineNum">    2825 </span><span class="lineCov">       4618 :         continue;</span>
<span class="lineNum">    2826 </span><span class="lineCov">       3735 :             norm = tchunk-&gt;parent-&gt;width;</span>
<span class="lineNum">    2827 </span><span class="lineCov">       3735 :             if ( norm &lt; fabs( dist ))</span>
<span class="lineNum">    2828 </span><span class="lineCov">       1343 :         break;</span>
<span class="lineNum">    2829 </span>            :         }
<span class="lineNum">    2830 </span>            : 
<span class="lineNum">    2831 </span>            :         /* If both points are curved in the same direction, then check also    */
<span class="lineNum">    2832 </span>            :         /* the &quot;line of sight&quot; between those points (if there are interventing */
<span class="lineNum">    2833 </span>            :         /* splines, then it is not a real feature bend)*/
<span class="lineNum">    2834 </span><span class="lineCov">       4378 :         if ( i == chcnt &amp;&amp; peak1 + peak2 == 3 &amp;&amp; ConnectsAcross( gd,base-&gt;sp,opp_next,sopp,0 ))</span>
<span class="lineNum">    2835 </span><span class="lineCov">        946 :             val++;</span>
<span class="lineNum">    2836 </span>            :     }
<span class="lineNum">    2837 </span>            :     
<span class="lineNum">    2838 </span><span class="lineCov">      12503 :     frompd = &amp;gd-&gt;points[sbase-&gt;from-&gt;ptindex];</span>
<span class="lineNum">    2839 </span><span class="lineCov">      12503 :     topd = &amp;gd-&gt;points[sbase-&gt;to-&gt;ptindex];</span>
<span class="lineNum">    2840 </span>            :     
<span class="lineNum">    2841 </span><span class="lineCov">      21032 :     if (IsStemAssignedToPoint( frompd,stem,true ) != -1 &amp;&amp;</span>
<span class="lineNum">    2842 </span><span class="lineCov">       8529 :         IsStemAssignedToPoint( topd,stem,false ) != -1 )</span>
<span class="lineNum">    2843 </span><span class="lineCov">       5835 :         if ( other == sbase ) val++;</span>
<span class="lineNum">    2844 </span>            : 
<span class="lineNum">    2845 </span><span class="lineCov">      12503 :     dist = vchunks[idx].dist;</span>
<span class="lineNum">    2846 </span><span class="lineCov">      30182 :     for ( i=0; i&lt;chcnt; i++ ) {</span>
<span class="lineNum">    2847 </span><span class="lineCov">      22976 :         tchunk = vchunks[i].chunk;</span>
<span class="lineNum">    2848 </span><span class="lineCov">      32134 :         if ( tchunk == NULL || tchunk == chunk ||</span>
<span class="lineNum">    2849 </span><span class="lineCov">      17609 :             ( vchunks[idx].parallel &amp;&amp; !vchunks[i].parallel ))</span>
<span class="lineNum">    2850 </span><span class="lineCov">      14308 :     continue;</span>
<span class="lineNum">    2851 </span><span class="lineCov">       8668 :         if ( vchunks[i].dist &lt;= dist || tchunk-&gt;parent-&gt;width &lt;= stem-&gt;width )</span>
<span class="lineNum">    2852 </span>            :     break;
<span class="lineNum">    2853 </span>            :     }
<span class="lineNum">    2854 </span><span class="lineCov">      12503 :     if ( i==chcnt ) val++;</span>
<span class="lineNum">    2855 </span>            : 
<span class="lineNum">    2856 </span>            :     /* If just one of the checked chunks has both its sides parallel            */
<span class="lineNum">    2857 </span>            :     /* to the stem direction, then we consider it is always worth to be output. */
<span class="lineNum">    2858 </span>            :     /* This check was introduced to avoid situations where a stem marking       */
<span class="lineNum">    2859 </span>            :     /* a feature termination can be preferred to another stem which controls    */
<span class="lineNum">    2860 </span>            :     /* the main part of the same feature */
<span class="lineNum">    2861 </span><span class="lineCov">      12503 :     if ( vchunks[idx].parallel ) {</span>
<span class="lineNum">    2862 </span><span class="lineCov">      23480 :         for ( i=0; i&lt;chcnt; i++ ) {</span>
<span class="lineNum">    2863 </span><span class="lineCov">      19650 :             if ( vchunks[i].chunk == NULL || vchunks[i].chunk == chunk )</span>
<span class="lineNum">    2864 </span><span class="lineCov">      11400 :         continue;</span>
<span class="lineNum">    2865 </span><span class="lineCov">       8250 :             if ( vchunks[i].parallel )</span>
<span class="lineNum">    2866 </span><span class="lineCov">       7760 :         break;</span>
<span class="lineNum">    2867 </span>            :         }
<span class="lineNum">    2868 </span><span class="lineCov">      11590 :         if ( i == chcnt ) val++;</span>
<span class="lineNum">    2869 </span>            :     }
<span class="lineNum">    2870 </span>            :     
<span class="lineNum">    2871 </span><span class="lineCov">      12503 : return( val );</span>
<a name="2872"><span class="lineNum">    2872 </span>            : }</a>
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span><span class="lineCov">       8338 : static void CheckPotential( struct glyphdata *gd,struct pointdata *pd,int is_next ) {</span>
<span class="lineNum">    2875 </span>            :     int i, j, is_l, next1, stemcnt, val;
<span class="lineNum">    2876 </span><span class="lineCov">       8338 :     int val_cnt=0;</span>
<span class="lineNum">    2877 </span>            :     BasePoint *lunit, *runit;
<span class="lineNum">    2878 </span>            :     struct stemdata **stems;
<span class="lineNum">    2879 </span>            :     struct vchunk *vchunks;
<span class="lineNum">    2880 </span>            :     struct stem_chunk *cur;
<span class="lineNum">    2881 </span>            :     
<span class="lineNum">    2882 </span><span class="lineCov">       8338 :     stemcnt = ( is_next ) ? pd-&gt;nextcnt : pd-&gt;prevcnt;</span>
<span class="lineNum">    2883 </span><span class="lineCov">       8338 :     stems = ( is_next ) ? pd-&gt;nextstems : pd-&gt;prevstems;</span>
<span class="lineNum">    2884 </span><span class="lineCov">       8338 :     vchunks = calloc( stemcnt,sizeof( VChunk ));</span>
<span class="lineNum">    2885 </span>            :     
<span class="lineNum">    2886 </span><span class="lineCov">      25985 :     for ( i=0; i&lt;stemcnt; i++ ) {</span>
<span class="lineNum">    2887 </span><span class="lineCov">      17647 :         is_l = ( is_next ) ? pd-&gt;next_is_l[i] : pd-&gt;prev_is_l[i];</span>
<span class="lineNum">    2888 </span><span class="lineCov">      17647 :         FindClosestOpposite( stems[i],&amp;vchunks[i].chunk,pd-&gt;sp,&amp;next1 );</span>
<span class="lineNum">    2889 </span><span class="lineCov">      17647 :         if ( vchunks[i].chunk == NULL )</span>
<span class="lineNum">    2890 </span><span class="lineCov">       5144 :     continue;</span>
<span class="lineNum">    2891 </span><span class="lineCov">      12503 :         cur = vchunks[i].chunk;</span>
<span class="lineNum">    2892 </span><span class="lineCov">      12503 :         if ( vchunks[i].value &gt; 0 ) val_cnt++;</span>
<span class="lineNum">    2893 </span><span class="lineCov">      25006 :         vchunks[i].dist  =  pow( cur-&gt;l-&gt;base.x - cur-&gt;r-&gt;base.x,2 ) + </span>
<span class="lineNum">    2894 </span><span class="lineCov">      12503 :                             pow( cur-&gt;l-&gt;base.y - cur-&gt;r-&gt;base.y,2 );</span>
<span class="lineNum">    2895 </span><span class="lineCov">      12503 :         lunit = ( cur-&gt;lnext ) ? &amp;cur-&gt;l-&gt;nextunit : &amp;cur-&gt;l-&gt;prevunit;</span>
<span class="lineNum">    2896 </span><span class="lineCov">      12503 :         runit = ( cur-&gt;rnext ) ? &amp;cur-&gt;r-&gt;nextunit : &amp;cur-&gt;r-&gt;prevunit;</span>
<span class="lineNum">    2897 </span><span class="lineCov">      24473 :         vchunks[i].parallel =   UnitsParallel( lunit,&amp;stems[i]-&gt;unit,2 ) &amp;&amp;</span>
<span class="lineNum">    2898 </span><span class="lineCov">      11970 :                                 UnitsParallel( runit,&amp;stems[i]-&gt;unit,2 );</span>
<span class="lineNum">    2899 </span>            :     }
<span class="lineNum">    2900 </span>            :     
<span class="lineNum">    2901 </span><span class="lineCov">      25985 :     for ( i=0; i&lt;stemcnt; i++ ) if ( vchunks[i].chunk != NULL ) {</span>
<span class="lineNum">    2902 </span><span class="lineCov">      12503 :         vchunks[i].value = ValueChunk( gd,vchunks,stemcnt,i,is_l );</span>
<span class="lineNum">    2903 </span><span class="lineCov">      12503 :         if ( vchunks[i].value ) val_cnt++;</span>
<span class="lineNum">    2904 </span>            :     }
<span class="lineNum">    2905 </span>            : 
<span class="lineNum">    2906 </span>            :     /* If we was unable to figure out any reasons for which at least */
<span class="lineNum">    2907 </span>            :     /* one of the checked chunks should really be output, then keep  */
<span class="lineNum">    2908 </span>            :     /* all the 'potential' flags as they are and do nothing */
<span class="lineNum">    2909 </span><span class="lineCov">       8338 :     if ( val_cnt &gt; 0 ) {</span>
<span class="lineNum">    2910 </span><span class="lineCov">      22333 :         for ( i=0; i&lt;stemcnt; i++ ) if ( vchunks[i].chunk != NULL )  {</span>
<span class="lineNum">    2911 </span><span class="lineCov">      10887 :             is_l = ( is_next ) ? pd-&gt;next_is_l[i] : pd-&gt;prev_is_l[i];</span>
<span class="lineNum">    2912 </span><span class="lineCov">      10887 :             val = vchunks[i].value;</span>
<span class="lineNum">    2913 </span><span class="lineCov">      44385 :             for ( j=0; j&lt;stems[i]-&gt;chunk_cnt; j++ ) {</span>
<span class="lineNum">    2914 </span><span class="lineCov">      33498 :                 cur = &amp;stems[i]-&gt;chunks[j];</span>
<span class="lineNum">    2915 </span><span class="lineCov">      33498 :                 if ( is_l &amp;&amp; cur-&gt;l == pd ) {</span>
<span class="lineNum">    2916 </span><span class="lineCov">      12046 :                     if ( val &gt; 0 ) cur-&gt;lpotential = false;</span>
<span class="lineNum">    2917 </span><span class="lineCov">       1279 :                     else cur-&gt;lpotential = true;</span>
<span class="lineNum">    2918 </span><span class="lineCov">      27475 :                 } else if ( !is_l &amp;&amp; cur-&gt;r == pd ) {</span>
<span class="lineNum">    2919 </span><span class="lineCov">       6598 :                     if ( val &gt; 0 ) cur-&gt;rpotential = false;</span>
<span class="lineNum">    2920 </span><span class="lineCov">       1430 :                     else cur-&gt;rpotential = true;</span>
<span class="lineNum">    2921 </span>            :                 }
<span class="lineNum">    2922 </span>            :             }
<span class="lineNum">    2923 </span>            :         }
<span class="lineNum">    2924 </span>            :     }
<span class="lineNum">    2925 </span><span class="lineCov">       8338 :     free( vchunks );</span>
<a name="2926"><span class="lineNum">    2926 </span><span class="lineCov">       8338 : }</span></a>
<span class="lineNum">    2927 </span>            : 
<span class="lineNum">    2928 </span><span class="lineCov">      22734 : static int StemIsActiveAt( struct glyphdata *gd,struct stemdata *stem,double stempos ) {</span>
<span class="lineNum">    2929 </span>            :     BasePoint pos,cpos,mpos;
<span class="lineNum">    2930 </span>            :     int which;
<span class="lineNum">    2931 </span>            :     double test;
<span class="lineNum">    2932 </span>            :     double lmin, lmax, rmin, rmax, loff, roff, minoff, maxoff;
<span class="lineNum">    2933 </span>            :     struct monotonic **space, *m;
<span class="lineNum">    2934 </span>            :     int winding, nw, closest, i, j;
<span class="lineNum">    2935 </span>            : 
<span class="lineNum">    2936 </span><span class="lineCov">      22734 :     pos.x = stem-&gt;left.x + stempos*stem-&gt;unit.x;</span>
<span class="lineNum">    2937 </span><span class="lineCov">      22734 :     pos.y = stem-&gt;left.y + stempos*stem-&gt;unit.y;</span>
<span class="lineNum">    2938 </span>            : 
<span class="lineNum">    2939 </span><span class="lineCov">      22734 :     if ( IsUnitHV( &amp;stem-&gt;unit,true )) {</span>
<span class="lineNum">    2940 </span><span class="lineCov">      20453 :         which = stem-&gt;unit.x==0;</span>
<span class="lineNum">    2941 </span><span class="lineCov">      20453 :         MonotonicFindAt(gd-&gt;ms,which,((real *) &amp;pos.x)[which],space = gd-&gt;space);</span>
<span class="lineNum">    2942 </span><span class="lineCov">      20453 :         test = ((real *) &amp;pos.x)[!which];</span>
<span class="lineNum">    2943 </span>            : 
<span class="lineNum">    2944 </span><span class="lineCov">      40906 :         lmin = ( stem-&gt;lmax - 2*dist_error_hv &lt; -dist_error_hv ) ? </span>
<span class="lineNum">    2945 </span><span class="lineCov">      20453 :             stem-&gt;lmax - 2*dist_error_hv : -dist_error_hv;</span>
<span class="lineNum">    2946 </span><span class="lineCov">      40906 :         lmax = ( stem-&gt;lmin + 2*dist_error_hv &gt; dist_error_hv ) ? </span>
<span class="lineNum">    2947 </span><span class="lineCov">      20453 :             stem-&gt;lmin + 2*dist_error_hv : dist_error_hv;</span>
<span class="lineNum">    2948 </span><span class="lineCov">      40906 :         rmin = ( stem-&gt;rmax - 2*dist_error_hv &lt; -dist_error_hv ) ? </span>
<span class="lineNum">    2949 </span><span class="lineCov">      20453 :             stem-&gt;rmax - 2*dist_error_hv : -dist_error_hv;</span>
<span class="lineNum">    2950 </span><span class="lineCov">      40906 :         rmax = ( stem-&gt;rmin + 2*dist_error_hv &gt; dist_error_hv ) ? </span>
<span class="lineNum">    2951 </span><span class="lineCov">      20453 :             stem-&gt;rmin + 2*dist_error_hv : dist_error_hv;</span>
<span class="lineNum">    2952 </span><span class="lineCov">      20453 :         minoff = test + ( lmin * stem-&gt;unit.y - lmax * stem-&gt;unit.x );</span>
<span class="lineNum">    2953 </span><span class="lineCov">      20453 :         maxoff = test + ( lmax * stem-&gt;unit.y - lmin * stem-&gt;unit.x );</span>
<span class="lineNum">    2954 </span>            : 
<span class="lineNum">    2955 </span><span class="lineCov">      20453 :         winding = 0; closest = -1;</span>
<span class="lineNum">    2956 </span><span class="lineCov">      54050 :         for ( i=0; space[i]!=NULL; ++i ) {</span>
<span class="lineNum">    2957 </span><span class="lineCov">      52591 :             m = space[i];</span>
<span class="lineNum">    2958 </span><span class="lineCov">      52591 :             nw = ((&amp;m-&gt;xup)[which] ? 1 : -1 );</span>
<span class="lineNum">    2959 </span><span class="lineCov">      52591 :             if ( m-&gt;other &gt;= minoff &amp;&amp; m-&gt;other &lt;= maxoff &amp;&amp; nw == 1 ) {</span>
<span class="lineNum">    2960 </span><span class="lineCov">      17486 :                 closest = i;</span>
<span class="lineNum">    2961 </span><span class="lineCov">      17486 :         break;</span>
<span class="lineNum">    2962 </span><span class="lineCov">      35105 :             } else if ( m-&gt;other &gt; maxoff )</span>
<span class="lineNum">    2963 </span><span class="lineCov">       1508 :         break;</span>
<span class="lineNum">    2964 </span><span class="lineCov">      33597 :             winding += nw;</span>
<span class="lineNum">    2965 </span>            :         }
<span class="lineNum">    2966 </span><span class="lineCov">      20453 :         if ( closest &lt; 0 )</span>
<span class="lineNum">    2967 </span><span class="lineCov">       2967 : return( false );</span>
<span class="lineNum">    2968 </span>            : 
<span class="lineNum">    2969 </span><span class="lineCov">      17486 :         cpos.x = ( which ) ? m-&gt;other : pos.x ;</span>
<span class="lineNum">    2970 </span><span class="lineCov">      17486 :         cpos.y = ( which ) ? pos.y : m-&gt;other ;</span>
<span class="lineNum">    2971 </span><span class="lineCov">      34972 :         loff = ( cpos.x - stem-&gt;left.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    2972 </span><span class="lineCov">      17486 :                ( cpos.y - stem-&gt;left.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    2973 </span><span class="lineCov">      17486 :         if ( loff &gt; lmax || loff &lt; lmin )</span>
<span class="lineNum">    2974 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    2975 </span>            : 
<span class="lineNum">    2976 </span><span class="lineCov">      17486 :         j = MatchWinding(space,i,nw,winding,which,0);</span>
<span class="lineNum">    2977 </span><span class="lineCov">      17486 :         if ( j==-1 )</span>
<span class="lineNum">    2978 </span><span class="lineCov">        649 : return( false );</span>
<span class="lineNum">    2979 </span><span class="lineCov">      16837 :         m = space[j];</span>
<span class="lineNum">    2980 </span>            : 
<span class="lineNum">    2981 </span><span class="lineCov">      16837 :         mpos.x = ( which ) ? m-&gt;other : pos.x ;</span>
<span class="lineNum">    2982 </span><span class="lineCov">      16837 :         mpos.y = ( which ) ? pos.y : m-&gt;other ;</span>
<span class="lineNum">    2983 </span><span class="lineCov">      33674 :         roff = ( mpos.x - stem-&gt;right.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    2984 </span><span class="lineCov">      16837 :                ( mpos.y - stem-&gt;right.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    2985 </span><span class="lineCov">      16837 :         if ( roff &gt;= rmin &amp;&amp; roff &lt;= rmax )</span>
<span class="lineNum">    2986 </span><span class="lineCov">      14771 : return( true );</span>
<span class="lineNum">    2987 </span><span class="lineCov">       2066 : return( false );</span>
<span class="lineNum">    2988 </span>            :     } else {
<span class="lineNum">    2989 </span><span class="lineCov">       2281 : return( StillStem( gd,dist_error_diag,&amp;pos,stem ));</span>
<span class="lineNum">    2990 </span>            :     }
<span class="lineNum">    2991 </span>            : }
<span class="lineNum">    2992 </span>            : 
<span class="lineNum">    2993 </span>            : /* This function is used to check the distance between a hint's edge */
<a name="2994"><span class="lineNum">    2994 </span>            : /* and a spline and determine the extet where this hint can be */</a>
<span class="lineNum">    2995 </span>            : /* considered &quot;active&quot;. */
<span class="lineNum">    2996 </span><span class="lineCov">      32572 : static int WalkSpline( struct glyphdata *gd, struct pointdata *pd,int gonext,</span>
<span class="lineNum">    2997 </span>            :     struct stemdata *stem,int is_l,int force_ac,BasePoint *res ) {
<span class="lineNum">    2998 </span>            :     
<span class="lineNum">    2999 </span>            :     int i, curved;
<span class="lineNum">    3000 </span>            :     double off, dist, min, max;
<span class="lineNum">    3001 </span>            :     double incr, err;
<span class="lineNum">    3002 </span>            :     double t, ratio, width;
<span class="lineNum">    3003 </span>            :     Spline *s;
<span class="lineNum">    3004 </span>            :     BasePoint *base, *nunit, pos, good;
<span class="lineNum">    3005 </span>            :     SplinePoint *sp, *nsp;
<span class="lineNum">    3006 </span>            :     struct pointdata *npd;
<span class="lineNum">    3007 </span>            : 
<span class="lineNum">    3008 </span><span class="lineCov">      32572 :     err = ( IsUnitHV( &amp;stem-&gt;unit,true )) ? dist_error_hv : dist_error_diag;</span>
<span class="lineNum">    3009 </span><span class="lineCov">      32572 :     width = stem-&gt;width;</span>
<span class="lineNum">    3010 </span><span class="lineCov">      32572 :     ratio = gd-&gt;emsize/( 6 * width );</span>
<span class="lineNum">    3011 </span><span class="lineCov">      32572 :     if ( err &gt; width/2) err = width/2;</span>
<span class="lineNum">    3012 </span>            : 
<span class="lineNum">    3013 </span><span class="lineCov">      32572 :     sp = pd-&gt;sp;</span>
<span class="lineNum">    3014 </span><span class="lineCov">      32572 :     base = ( is_l ) ? &amp;stem-&gt;left : &amp;stem-&gt;right;</span>
<span class="lineNum">    3015 </span><span class="lineCov">      32572 :     min = ( is_l ) ? stem-&gt;lmax - 2*err : stem-&gt;rmax - 2*err;</span>
<span class="lineNum">    3016 </span><span class="lineCov">      32572 :     max = ( is_l ) ? stem-&gt;lmin + 2*err : stem-&gt;rmin + 2*err;</span>
<span class="lineNum">    3017 </span>            :     
<span class="lineNum">    3018 </span><span class="lineCov">      32572 :     s = ( gonext ) ? sp-&gt;next : sp-&gt;prev;</span>
<span class="lineNum">    3019 </span><span class="lineCov">      32572 :     nsp = ( gonext ) ? s-&gt;to : s-&gt;from;</span>
<span class="lineNum">    3020 </span><span class="lineCov">      32572 :     npd   = &amp;gd-&gt;points[nsp-&gt;ptindex];</span>
<span class="lineNum">    3021 </span><span class="lineCov">      32572 :     nunit = ( gonext ) ? &amp;npd-&gt;prevunit : &amp;npd-&gt;nextunit;</span>
<span class="lineNum">    3022 </span><span class="lineCov">      32572 :     good = sp-&gt;me;</span>
<span class="lineNum">    3023 </span>            :     
<span class="lineNum">    3024 </span><span class="lineCov">      65144 :     off   = ( nsp-&gt;me.x - base-&gt;x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    3025 </span><span class="lineCov">      32572 :             ( nsp-&gt;me.y - base-&gt;y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    3026 </span>            :     /* Some splines have tiny control points and are almost flat */
<span class="lineNum">    3027 </span>            :     /*  think of them as lines then rather than treating them as curves */
<span class="lineNum">    3028 </span>            :     /*  figure out how long they remain within a few orthoganal units of */
<span class="lineNum">    3029 </span>            :     /*  the point */
<span class="lineNum">    3030 </span>            :     /* We used to check the distance between a control point and a spline */
<span class="lineNum">    3031 </span>            :     /* and consider the segment &quot;flat&quot; if this distance is smaller than   */
<span class="lineNum">    3032 </span>            :     /* the normal allowed &quot;error&quot; value. However this method doesn't produce */
<span class="lineNum">    3033 </span>            :     /* consistent results if the spline is not long enough (as usual for  */
<span class="lineNum">    3034 </span>            :     /* fonts with quadratic splines). So now we consider a spline &quot;flat&quot;  */
<span class="lineNum">    3035 </span>            :     /* only if it never deviates too far from the hint's edge and both    */
<span class="lineNum">    3036 </span>            :     /* its terminal points are snappable to the same hint */
<span class="lineNum">    3037 </span><span class="lineCov">      61890 :     curved = ( IsStemAssignedToPoint( npd,stem,gonext ) == -1 &amp;&amp;</span>
<span class="lineNum">    3038 </span><span class="lineCov">      18918 :         ( off &lt; min || off &gt; max || !UnitsParallel( &amp;stem-&gt;unit,nunit,true )));</span>
<span class="lineNum">    3039 </span>            : 
<span class="lineNum">    3040 </span>            :     /* If a spline does deviate from the edge too far to consider it flat, */
<span class="lineNum">    3041 </span>            :     /* then we calculate the extent where the spline and the edge are still */
<span class="lineNum">    3042 </span>            :     /* close enough to consider the hint active at this zone. If the hint is */
<span class="lineNum">    3043 </span>            :     /* still active at the end of the spline, we can check some subsequent splines */
<span class="lineNum">    3044 </span>            :     /* too. This method produces better effect than any &quot;magic&quot; manipulations */
<span class="lineNum">    3045 </span>            :     /* with control point coordinates, because it takes into account just the */
<span class="lineNum">    3046 </span>            :     /* spline configuration rather than point positions */
<span class="lineNum">    3047 </span><span class="lineCov">      32572 :     if ( curved ) {</span>
<span class="lineNum">    3048 </span><span class="lineCov">      29318 :         max = err = dist_error_curve;</span>
<span class="lineNum">    3049 </span><span class="lineCov">      29318 :         min = -dist_error_curve;</span>
<span class="lineNum">    3050 </span>            :         /* The following statement forces our code to detect an active zone */
<span class="lineNum">    3051 </span>            :         /* even if all checks actually fail. This makes sense for stems */
<span class="lineNum">    3052 </span>            :         /* marking arks and bends */
<span class="lineNum">    3053 </span><span class="lineCov">      29318 :         if ( force_ac )</span>
<span class="lineNum">    3054 </span><span class="lineCov">      26769 :             good = ( gonext ) ? sp-&gt;nextcp : sp-&gt;prevcp;</span>
<span class="lineNum">    3055 </span>            :         /* If a spline is closer to the opposite stem edge than to the current edge, then we */
<span class="lineNum">    3056 </span>            :         /* can no longer consider the stem active at this point */
<span class="lineNum">    3057 </span><span class="lineCov">      29318 :         if ( err &gt; width/2 ) err = width/2;</span>
<span class="lineNum">    3058 </span>            :         
<span class="lineNum">    3059 </span><span class="lineCov">      29318 :         t = ( gonext ) ? 0.9999 : 0.0001;</span>
<span class="lineNum">    3060 </span><span class="lineCov">       6015 :         for ( ; ; s = ( gonext ) ? s-&gt;to-&gt;next : s-&gt;from-&gt;prev ) {</span>
<span class="lineNum">    3061 </span><span class="lineCov">      35333 :             pos.x = ((s-&gt;splines[0].a*t+s-&gt;splines[0].b)*t+s-&gt;splines[0].c)*t+s-&gt;splines[0].d;</span>
<span class="lineNum">    3062 </span><span class="lineCov">      35333 :             pos.y = ((s-&gt;splines[1].a*t+s-&gt;splines[1].b)*t+s-&gt;splines[1].c)*t+s-&gt;splines[1].d;</span>
<span class="lineNum">    3063 </span><span class="lineCov">      70666 :             off   = ( pos.x - base-&gt;x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    3064 </span><span class="lineCov">      35333 :                     ( pos.y - base-&gt;y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    3065 </span><span class="lineCov">      70666 :             dist  = ( pos.x - sp-&gt;me.x )*stem-&gt;unit.x +</span>
<span class="lineNum">    3066 </span><span class="lineCov">      35333 :                     ( pos.y - sp-&gt;me.y )*stem-&gt;unit.y;</span>
<span class="lineNum">    3067 </span><span class="lineCov">      35333 :             nsp   = ( gonext ) ? s-&gt;to : s-&gt;from;</span>
<span class="lineNum">    3068 </span><span class="lineCov">      35333 :             npd   = &amp;gd-&gt;points[nsp-&gt;ptindex];</span>
<span class="lineNum">    3069 </span><span class="lineCov">      35333 :             if (fabs( off ) &lt; max &amp;&amp; fabs( dist ) &lt;= ( width + width * ratio ) &amp;&amp;</span>
<span class="lineNum">    3070 </span><span class="lineCov">      26280 :                 nsp != sp &amp;&amp; npd-&gt;colinear &amp;&amp; !npd-&gt;x_extr &amp;&amp; !npd-&gt;y_extr &amp;&amp; </span>
<span class="lineNum">    3071 </span><span class="lineCov">       9718 :                 StillStem( gd,err,&amp;pos,stem ))</span>
<span class="lineNum">    3072 </span><span class="lineCov">       6015 :                 good = pos;</span>
<span class="lineNum">    3073 </span>            :             else
<span class="lineNum">    3074 </span>            :         break;
<span class="lineNum">    3075 </span><span class="lineCov">       6015 :         }</span>
<span class="lineNum">    3076 </span>            :     }
<span class="lineNum">    3077 </span><span class="lineCov">      32572 :     t = .5;</span>
<span class="lineNum">    3078 </span><span class="lineCov">      32572 :     incr = ( gonext ) ? .25 : -.25;</span>
<span class="lineNum">    3079 </span><span class="lineCov">     228004 :     for ( i=0; i&lt;6; ++i ) {</span>
<span class="lineNum">    3080 </span><span class="lineCov">     195432 :         pos.x = ((s-&gt;splines[0].a*t+s-&gt;splines[0].b)*t+s-&gt;splines[0].c)*t+s-&gt;splines[0].d;</span>
<span class="lineNum">    3081 </span><span class="lineCov">     195432 :         pos.y = ((s-&gt;splines[1].a*t+s-&gt;splines[1].b)*t+s-&gt;splines[1].c)*t+s-&gt;splines[1].d;</span>
<span class="lineNum">    3082 </span><span class="lineCov">     390864 :         off   = ( pos.x - base-&gt;x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    3083 </span><span class="lineCov">     195432 :                 ( pos.y - base-&gt;y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    3084 </span><span class="lineCov">     390864 :         dist  = ( pos.x - sp-&gt;me.x )*stem-&gt;unit.x +</span>
<span class="lineNum">    3085 </span><span class="lineCov">     195432 :                 ( pos.y - sp-&gt;me.y )*stem-&gt;unit.y;</span>
<span class="lineNum">    3086 </span>            :         /* Don't check StillStem for non-curved segments, as they are subject */
<span class="lineNum">    3087 </span>            :         /* to further projection-related tests anyway */
<span class="lineNum">    3088 </span><span class="lineCov">     341947 :         if ( off &gt; min &amp;&amp; off &lt; max &amp;&amp; ( !curved || </span>
<span class="lineNum">    3089 </span><span class="lineCov">     292497 :             ( fabs( dist ) &lt; ( width + width * ratio ) &amp;&amp;</span>
<span class="lineNum">    3090 </span><span class="lineCov">     145982 :             StillStem( gd,err,&amp;pos,stem )))) {</span>
<span class="lineNum">    3091 </span>            :             
<span class="lineNum">    3092 </span><span class="lineCov">     100100 :             good = pos;</span>
<span class="lineNum">    3093 </span><span class="lineCov">     100100 :             t += incr;</span>
<span class="lineNum">    3094 </span>            :         } else
<span class="lineNum">    3095 </span><span class="lineCov">      95332 :             t -= incr;</span>
<span class="lineNum">    3096 </span><span class="lineCov">     195432 :         incr/=2;</span>
<span class="lineNum">    3097 </span>            :     }
<span class="lineNum">    3098 </span><span class="lineCov">      32572 :     *res = good;</span>
<span class="lineNum">    3099 </span><span class="lineCov">      32572 : return( curved );</span>
<a name="3100"><span class="lineNum">    3100 </span>            : }</a>
<span class="lineNum">    3101 </span>            : 
<span class="lineNum">    3102 </span><span class="lineCov">      25162 : static int AdjustForImperfectSlopeMatch( SplinePoint *sp,BasePoint *pos,</span>
<span class="lineNum">    3103 </span>            :     BasePoint *newpos,struct stemdata *stem,int is_l ) {
<span class="lineNum">    3104 </span>            :    
<span class="lineNum">    3105 </span>            :     double poff, err, min, max;
<span class="lineNum">    3106 </span>            :     BasePoint *base;
<span class="lineNum">    3107 </span>            :     
<span class="lineNum">    3108 </span><span class="lineCov">      25162 :     base = ( is_l ) ? &amp;stem-&gt;left : &amp;stem-&gt;right;</span>
<span class="lineNum">    3109 </span><span class="lineCov">      25162 :     err = ( IsUnitHV( &amp;stem-&gt;unit,true )) ? dist_error_hv : dist_error_diag;</span>
<span class="lineNum">    3110 </span><span class="lineCov">      25162 :     min = ( is_l ) ? stem-&gt;lmax - 2*err : stem-&gt;rmax - 2*err;</span>
<span class="lineNum">    3111 </span><span class="lineCov">      25162 :     max = ( is_l ) ? stem-&gt;lmin + 2*err : stem-&gt;rmin + 2*err;</span>
<span class="lineNum">    3112 </span>            :     
<span class="lineNum">    3113 </span>            :     /* Possible if the stem unit has been attached to a line. It is */
<span class="lineNum">    3114 </span>            :     /* hard to prevent this */
<span class="lineNum">    3115 </span><span class="lineCov">      25162 :     if ( min &gt; max ) {</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :         min = stem-&gt;lmin; max = stem-&gt;lmax;</span>
<span class="lineNum">    3117 </span>            :     }
<span class="lineNum">    3118 </span>            : 
<span class="lineNum">    3119 </span><span class="lineCov">      50324 :     poff =  ( pos-&gt;x - base-&gt;x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    3120 </span><span class="lineCov">      25162 :             ( pos-&gt;y - base-&gt;y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    3121 </span><span class="lineCov">      25162 :     if ( poff &gt; min &amp;&amp; poff &lt; max ) {</span>
<span class="lineNum">    3122 </span><span class="lineCov">      24794 :         *newpos = *pos;</span>
<span class="lineNum">    3123 </span><span class="lineCov">      24794 : return( false );</span>
<span class="lineNum">    3124 </span><span class="lineCov">        368 :     } else if ( poff &lt;= min )</span>
<span class="lineNum">    3125 </span><span class="lineCov">        190 :         err = fabs( min );</span>
<span class="lineNum">    3126 </span><span class="lineCov">        178 :     else if ( poff &gt;= max )</span>
<span class="lineNum">    3127 </span><span class="lineCov">        178 :         err = fabs( max );</span>
<span class="lineNum">    3128 </span>            : 
<span class="lineNum">    3129 </span><span class="lineCov">        368 :     newpos-&gt;x = sp-&gt;me.x + err*( pos-&gt;x - sp-&gt;me.x )/fabs( poff );</span>
<span class="lineNum">    3130 </span><span class="lineCov">        368 :     newpos-&gt;y = sp-&gt;me.y + err*( pos-&gt;y - sp-&gt;me.y )/fabs( poff );</span>
<span class="lineNum">    3131 </span><span class="lineCov">        368 : return( true );</span>
<a name="3132"><span class="lineNum">    3132 </span>            : }</a>
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span><span class="lineCov">      48160 : static int AddLineSegment( struct stemdata *stem,struct segment *space,int cnt,</span>
<span class="lineNum">    3135 </span>            :     int is_l,struct pointdata *pd,int base_next,struct glyphdata *gd ) {
<span class="lineNum">    3136 </span>            :     
<span class="lineNum">    3137 </span>            :     double s, e, t, dot;
<span class="lineNum">    3138 </span>            :     BasePoint stemp, etemp;
<span class="lineNum">    3139 </span>            :     BasePoint *start, *end, *par_unit;
<span class="lineNum">    3140 </span><span class="lineCov">      48160 :     int same_dir, corner = 0, par;</span>
<span class="lineNum">    3141 </span><span class="lineCov">      48160 :     int scurved = false, ecurved = false, c, hv;</span>
<span class="lineNum">    3142 </span>            :     SplinePoint *sp, *psp, *nsp;
<span class="lineNum">    3143 </span>            :     double b;
<span class="lineNum">    3144 </span>            :     uint8 extr;
<span class="lineNum">    3145 </span>            :     
<span class="lineNum">    3146 </span><span class="lineCov">      87559 :     if ( pd==NULL || (sp = pd-&gt;sp)==NULL || sp-&gt;ticked ||</span>
<span class="lineNum">    3147 </span><span class="lineCov">      78798 :             sp-&gt;next==NULL || sp-&gt;prev==NULL )</span>
<span class="lineNum">    3148 </span><span class="lineCov">       8761 : return( cnt );</span>
<span class="lineNum">    3149 </span><span class="lineCov">      39399 :     end = &amp;sp-&gt;me;</span>
<span class="lineNum">    3150 </span><span class="lineCov">      39399 :     start = &amp;sp-&gt;me;</span>
<span class="lineNum">    3151 </span><span class="lineCov">      39399 :     par_unit = ( base_next ) ? &amp;pd-&gt;nextunit : &amp;pd-&gt;prevunit;</span>
<span class="lineNum">    3152 </span>            :     /* Do the spline and the stem unit point in the same direction ? */
<span class="lineNum">    3153 </span><span class="lineCov">      78798 :     dot =   ( stem-&gt;unit.x * par_unit-&gt;x ) +</span>
<span class="lineNum">    3154 </span><span class="lineCov">      39399 :             ( stem-&gt;unit.y * par_unit-&gt;y );</span>
<span class="lineNum">    3155 </span><span class="lineCov">      39399 :     same_dir = (( dot &gt; 0 &amp;&amp; base_next ) || ( dot &lt; 0 &amp;&amp; !base_next ));</span>
<span class="lineNum">    3156 </span><span class="lineCov">      39399 :     if ( stem-&gt;unit.x == 1 ) corner = pd-&gt;y_corner;</span>
<span class="lineNum">    3157 </span><span class="lineCov">      21904 :     else if ( stem-&gt;unit.y == 1 ) corner = pd-&gt;x_corner;</span>
<span class="lineNum">    3158 </span>            :     
<span class="lineNum">    3159 </span><span class="lineCov">      78798 :     dot =   ( stem-&gt;unit.x * pd-&gt;nextunit.x ) +</span>
<span class="lineNum">    3160 </span><span class="lineCov">      39399 :             ( stem-&gt;unit.y * pd-&gt;nextunit.y );</span>
<span class="lineNum">    3161 </span>            :     /* We used to apply normal checks only if the point's unit vector pointing */
<span class="lineNum">    3162 </span>            :     /* in the direction we are going to check is nearly parallel to the stem unit. */
<span class="lineNum">    3163 </span>            :     /* But this is not the best method, because a spline, &quot;parallel&quot; to our */
<span class="lineNum">    3164 </span>            :     /* stem, may actually have filled space at a wrong side. On the other hand, */
<span class="lineNum">    3165 </span>            :     /* sometimes it makes sense to calculate active space even for splines */
<span class="lineNum">    3166 </span>            :     /* connected to our base point under an angle which is too large to consider */
<span class="lineNum">    3167 </span>            :     /* the direction &quot;parallel&quot;. So now we check the units' direction first */
<span class="lineNum">    3168 </span>            :     /* and then (just for straight splines) also their parallelity. */
<span class="lineNum">    3169 </span><span class="lineCov">      39399 :     if (( dot &gt; 0 &amp;&amp; same_dir ) || ( dot &lt; 0 &amp;&amp; !same_dir )) {</span>
<span class="lineNum">    3170 </span>            :         /* If the segment sp-start doesn't have exactly the right slope, then */
<span class="lineNum">    3171 </span>            :         /*  we can only use that bit of it which is less than a standard error */
<span class="lineNum">    3172 </span><span class="lineCov">      30001 :         par = UnitsParallel( &amp;stem-&gt;unit,&amp;pd-&gt;nextunit,0 );</span>
<span class="lineNum">    3173 </span><span class="lineCov">      30001 :         if ( !sp-&gt;next-&gt;knownlinear ) {</span>
<span class="lineNum">    3174 </span><span class="lineCov">      16233 :             ecurved = WalkSpline( gd,pd,true,stem,is_l,par,&amp;etemp );</span>
<span class="lineNum">    3175 </span>            :             /* Can merge, but treat as curved relatively to projections */
<span class="lineNum">    3176 </span><span class="lineCov">      16233 :             if ( !ecurved ) ecurved = 2;</span>
<span class="lineNum">    3177 </span><span class="lineCov">      16233 :             end = &amp;etemp;</span>
<span class="lineNum">    3178 </span><span class="lineCov">      13768 :         } else if ( par || corner )  {</span>
<span class="lineNum">    3179 </span><span class="lineCov">      12589 :             nsp = sp-&gt;next-&gt;to;</span>
<span class="lineNum">    3180 </span><span class="lineCov">      12589 :             ecurved = AdjustForImperfectSlopeMatch( sp,&amp;nsp-&gt;me,&amp;etemp,stem,is_l );</span>
<span class="lineNum">    3181 </span><span class="lineCov">      12589 :             end = &amp;etemp;</span>
<span class="lineNum">    3182 </span>            :         }
<span class="lineNum">    3183 </span>            :     }
<span class="lineNum">    3184 </span><span class="lineCov">      78798 :     dot =   ( stem-&gt;unit.x * pd-&gt;prevunit.x ) +</span>
<span class="lineNum">    3185 </span><span class="lineCov">      39399 :             ( stem-&gt;unit.y * pd-&gt;prevunit.y );</span>
<span class="lineNum">    3186 </span><span class="lineCov">      39399 :     if (( dot &lt; 0 &amp;&amp; same_dir ) || ( dot &gt; 0 &amp;&amp; !same_dir )) {</span>
<span class="lineNum">    3187 </span><span class="lineCov">      30054 :         par = UnitsParallel( &amp;stem-&gt;unit,&amp;pd-&gt;prevunit,0 );</span>
<span class="lineNum">    3188 </span><span class="lineCov">      30054 :         if ( !sp-&gt;prev-&gt;knownlinear ) {</span>
<span class="lineNum">    3189 </span><span class="lineCov">      16339 :             scurved = WalkSpline( gd,pd,false,stem,is_l,par,&amp;stemp );</span>
<span class="lineNum">    3190 </span><span class="lineCov">      16339 :             if ( !scurved ) scurved = 2;</span>
<span class="lineNum">    3191 </span><span class="lineCov">      16339 :             start = &amp;stemp;</span>
<span class="lineNum">    3192 </span><span class="lineCov">      13715 :         } else if ( par || corner ) {</span>
<span class="lineNum">    3193 </span><span class="lineCov">      12573 :             psp = sp-&gt;prev-&gt;from;</span>
<span class="lineNum">    3194 </span><span class="lineCov">      12573 :             scurved = AdjustForImperfectSlopeMatch( sp,&amp;psp-&gt;me,&amp;stemp,stem,is_l );</span>
<span class="lineNum">    3195 </span><span class="lineCov">      12573 :             start = &amp;stemp;</span>
<span class="lineNum">    3196 </span>            :         }
<span class="lineNum">    3197 </span>            :     }
<span class="lineNum">    3198 </span><span class="lineCov">      39399 :     sp-&gt;ticked = true;</span>
<span class="lineNum">    3199 </span>            : 
<span class="lineNum">    3200 </span><span class="lineCov">      78798 :     s = (start-&gt;x-stem-&gt;left.x)*stem-&gt;unit.x +</span>
<span class="lineNum">    3201 </span><span class="lineCov">      39399 :         (start-&gt;y-stem-&gt;left.y)*stem-&gt;unit.y;</span>
<span class="lineNum">    3202 </span><span class="lineCov">      78798 :     e = (  end-&gt;x-stem-&gt;left.x)*stem-&gt;unit.x +</span>
<span class="lineNum">    3203 </span><span class="lineCov">      39399 :         (  end-&gt;y-stem-&gt;left.y)*stem-&gt;unit.y;</span>
<span class="lineNum">    3204 </span><span class="lineCov">      78798 :     b = (sp-&gt;me.x-stem-&gt;left.x)*stem-&gt;unit.x +</span>
<span class="lineNum">    3205 </span><span class="lineCov">      39399 :         (sp-&gt;me.y-stem-&gt;left.y)*stem-&gt;unit.y;</span>
<span class="lineNum">    3206 </span>            : 
<span class="lineNum">    3207 </span><span class="lineCov">      39399 :     if ( s == e )</span>
<span class="lineNum">    3208 </span><span class="lineCov">         75 : return( cnt );</span>
<span class="lineNum">    3209 </span><span class="lineCov">      39324 :     if ( s &gt; e ) {</span>
<span class="lineNum">    3210 </span><span class="lineCov">      19937 :         t = s; c = scurved;</span>
<span class="lineNum">    3211 </span><span class="lineCov">      19937 :         s = e; e = t;</span>
<span class="lineNum">    3212 </span><span class="lineCov">      19937 :         scurved = ecurved; ecurved = c;</span>
<span class="lineNum">    3213 </span>            :     }
<span class="lineNum">    3214 </span><span class="lineCov">      39324 :     space[cnt].start = s;</span>
<span class="lineNum">    3215 </span><span class="lineCov">      39324 :     space[cnt].end = e;</span>
<span class="lineNum">    3216 </span><span class="lineCov">      39324 :     space[cnt].sbase = space[cnt].ebase = b;</span>
<span class="lineNum">    3217 </span><span class="lineCov">      39324 :     space[cnt].scurved = scurved;</span>
<span class="lineNum">    3218 </span><span class="lineCov">      39324 :     space[cnt].ecurved = ecurved;</span>
<span class="lineNum">    3219 </span>            :     
<span class="lineNum">    3220 </span><span class="lineCov">      39324 :     hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    3221 </span><span class="lineCov">      39324 :     if ( hv ) {</span>
<span class="lineNum">    3222 </span>            :         /* For vertical/horizontal stems we assign a special meaning to  */
<span class="lineNum">    3223 </span>            :         /* the 'curved' field. It will be non-zero if the key point of   */
<span class="lineNum">    3224 </span>            :         /* this segment is positioned on a prominent curve:              */
<span class="lineNum">    3225 </span>            :         /* 1 if the inner side of that curve is inside of the contour    */
<span class="lineNum">    3226 </span>            :         /* and 2 otherwise. */
<span class="lineNum">    3227 </span>            :         /* Later, if we get a pair of &quot;inner&quot; and &quot;outer&quot; curves, then   */
<span class="lineNum">    3228 </span>            :         /* we are probably dealing with a feature's bend which should be */
<span class="lineNum">    3229 </span>            :         /* necessarily marked with a hint. Checks we apply for this type */
<span class="lineNum">    3230 </span>            :         /* of curved segments should be less strict than in other cases. */
<span class="lineNum">    3231 </span><span class="lineCov">      31897 :         extr = ( hv == 1 ) ? pd-&gt;y_extr : pd-&gt;x_extr;</span>
<span class="lineNum">    3232 </span><span class="lineCov">      31897 :         space[cnt].curved = extr;</span>
<span class="lineNum">    3233 </span>            :     } else {
<span class="lineNum">    3234 </span>            :         /* For diagonal stems we consider a segment &quot;curved&quot; if both its */
<span class="lineNum">    3235 </span>            :         /* start and end are curved. Curved segments usually cannot be   */
<span class="lineNum">    3236 </span>            :         /* merged (unless scurved or ecurved is equal to 2) and are not  */
<span class="lineNum">    3237 </span>            :         /* checked for &quot;projections&quot;. */
<span class="lineNum">    3238 </span><span class="lineCov">       7427 :         space[cnt].curved = scurved &amp;&amp; ecurved;</span>
<span class="lineNum">    3239 </span>            :     }
<span class="lineNum">    3240 </span><span class="lineCov">      39324 : return( cnt+1 );</span>
<a name="3241"><span class="lineNum">    3241 </span>            : }</a>
<span class="lineNum">    3242 </span>            : 
<span class="lineNum">    3243 </span><span class="lineCov">      79169 : static int InActive(double projection,struct segment *segments, int cnt) {</span>
<span class="lineNum">    3244 </span>            :     int i;
<span class="lineNum">    3245 </span>            : 
<span class="lineNum">    3246 </span><span class="lineCov">     139254 :     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    3247 </span><span class="lineCov">      96770 :         if ( projection&gt;=segments[i].start &amp;&amp; projection&lt;=segments[i].end )</span>
<span class="lineNum">    3248 </span><span class="lineCov">      36685 : return( true );</span>
<span class="lineNum">    3249 </span>            :     }
<span class="lineNum">    3250 </span><span class="lineCov">      42484 : return( false );</span>
<a name="3251"><span class="lineNum">    3251 </span>            : }</a>
<span class="lineNum">    3252 </span>            : 
<span class="lineNum">    3253 </span><span class="lineCov">      21804 : static int MergeSegments(struct segment *space, int cnt) {</span>
<span class="lineNum">    3254 </span>            :     int i,j;
<span class="lineNum">    3255 </span>            :     double middle;
<span class="lineNum">    3256 </span>            : 
<span class="lineNum">    3257 </span><span class="lineCov">      47921 :     for ( i=j=0; i&lt;cnt; ++i, ++j ) {</span>
<span class="lineNum">    3258 </span><span class="lineCov">      26117 :         if ( i!=j )</span>
<span class="lineNum">    3259 </span><span class="lineCov">       3218 :             space[j] = space[i];</span>
<span class="lineNum">    3260 </span><span class="lineCov">      66471 :         while ( i+1&lt;cnt &amp;&amp; space[i+1].start&lt;space[j].end ) {</span>
<span class="lineNum">    3261 </span><span class="lineCov">      14237 :             if ( space[i+1].end &gt;= space[j].end ) {</span>
<span class="lineNum">    3262 </span>            :                 
<span class="lineNum">    3263 </span>            :                 /* If there are 2 overlapping segments and neither the  */
<span class="lineNum">    3264 </span>            :                 /* end of the first segment nor the start of the second */
<span class="lineNum">    3265 </span>            :                 /* one are curved we can merge them. Otherwise we have  */
<span class="lineNum">    3266 </span>            :                 /* to preserve them both, but modify their start/end properties */
<span class="lineNum">    3267 </span>            :                 /* so that the overlap is removed */
<span class="lineNum">    3268 </span><span class="lineCov">      13881 :                 if ( space[j].ecurved != 1 &amp;&amp; space[i+1].scurved != 1 ) {</span>
<span class="lineNum">    3269 </span><span class="lineCov">      13673 :                     space[j].end = space[i+1].end;</span>
<span class="lineNum">    3270 </span><span class="lineCov">      13673 :                     space[j].ebase = space[i+1].ebase;</span>
<span class="lineNum">    3271 </span><span class="lineCov">      13673 :                     space[j].ecurved = space[i+1].ecurved;</span>
<span class="lineNum">    3272 </span><span class="lineCov">      13673 :                     space[j].curved = false;</span>
<span class="lineNum">    3273 </span><span class="lineCov">        208 :                 } else if ( space[j].ecurved != 1 &amp;&amp; space[i+1].scurved == 1 ) {</span>
<span class="lineNum">    3274 </span><span class="lineCov">         72 :                     space[i+1].start = space[j].end;</span>
<span class="lineNum">    3275 </span><span class="lineCov">         72 :                     --i;</span>
<span class="lineNum">    3276 </span><span class="lineCov">        136 :                 } else if ( space[j].ecurved == 1 &amp;&amp; space[i+1].scurved != 1 ) {</span>
<span class="lineNum">    3277 </span><span class="lineCov">         59 :                     space[j].end = space[i+1].start;</span>
<span class="lineNum">    3278 </span><span class="lineCov">         59 :                     --i;</span>
<span class="lineNum">    3279 </span>            :                 } else {
<span class="lineNum">    3280 </span><span class="lineCov">         77 :                     middle = (space[j].end + space[i+1].start)/2;</span>
<span class="lineNum">    3281 </span><span class="lineCov">         77 :                     space[j].end = space[i+1].start = middle;</span>
<span class="lineNum">    3282 </span><span class="lineCov">         77 :                     --i;</span>
<span class="lineNum">    3283 </span>            :                 }
<span class="lineNum">    3284 </span>            :             }
<span class="lineNum">    3285 </span><span class="lineCov">      14237 :             ++i;</span>
<span class="lineNum">    3286 </span>            :         }
<span class="lineNum">    3287 </span>            :     }
<span class="lineNum">    3288 </span><span class="lineCov">      21804 : return( j );</span>
<a name="3289"><span class="lineNum">    3289 </span>            : }</a>
<span class="lineNum">    3290 </span>            : 
<span class="lineNum">    3291 </span><span class="lineCov">       9528 : static int MergeSegmentsFinal( struct segment *space, int cnt ) {</span>
<span class="lineNum">    3292 </span>            :     int i,j;
<span class="lineNum">    3293 </span>            : 
<span class="lineNum">    3294 </span><span class="lineCov">      20981 :     for ( i=j=0; i&lt;cnt; ++i, ++j ) {</span>
<span class="lineNum">    3295 </span><span class="lineCov">      11453 :         if ( i!=j )</span>
<span class="lineNum">    3296 </span><span class="lineCov">        101 :             space[j] = space[i];</span>
<span class="lineNum">    3297 </span><span class="lineCov">      23252 :         while ( i+1&lt;cnt &amp;&amp; space[i+1].start&lt;=space[j].end ) {</span>
<span class="lineNum">    3298 </span><span class="lineCov">        346 :             if ( space[i+1].end&gt;space[j].end ) {</span>
<span class="lineNum">    3299 </span><span class="lineCov">        332 :                 space[j].end = space[i+1].end;</span>
<span class="lineNum">    3300 </span><span class="lineCov">        332 :                 space[j].ebase = space[i+1].ebase;</span>
<span class="lineNum">    3301 </span><span class="lineCov">        332 :                 space[j].ecurved = space[i+1].ecurved;</span>
<span class="lineNum">    3302 </span><span class="lineCov">        332 :                 space[j].curved = false;</span>
<span class="lineNum">    3303 </span>            :             }
<span class="lineNum">    3304 </span><span class="lineCov">        346 :             ++i;</span>
<span class="lineNum">    3305 </span>            :         }
<span class="lineNum">    3306 </span>            :     }
<span class="lineNum">    3307 </span><span class="lineCov">       9528 : return( j );</span>
<a name="3308"><span class="lineNum">    3308 </span>            : }</a>
<span class="lineNum">    3309 </span>            : 
<span class="lineNum">    3310 </span><span class="lineCov">      11356 : static void FigureStemActive( struct glyphdata *gd, struct stemdata *stem ) {</span>
<span class="lineNum">    3311 </span><span class="lineCov">      11356 :     int i, j, pcnt=0;</span>
<span class="lineNum">    3312 </span><span class="lineCov">      11356 :     struct pointdata *pd, **pspace = gd-&gt;pspace;</span>
<span class="lineNum">    3313 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    3314 </span><span class="lineCov">      11356 :     struct segment *lspace = gd-&gt;lspace, *rspace = gd-&gt;rspace;</span>
<span class="lineNum">    3315 </span><span class="lineCov">      11356 :     struct segment *bothspace = gd-&gt;bothspace, *activespace = gd-&gt;activespace;</span>
<span class="lineNum">    3316 </span>            :     int lcnt, rcnt, bcnt, bpos, acnt, cove, startset, endset;
<span class="lineNum">    3317 </span>            :     double middle, width, len, clen, gap, lseg, rseg;
<span class="lineNum">    3318 </span>            :     double err, lmin, rmax, loff, roff, last, s, e, sbase, ebase;
<span class="lineNum">    3319 </span>            :     double proj, proj2, proj3, orig_proj, ptemp;
<span class="lineNum">    3320 </span>            : 
<span class="lineNum">    3321 </span><span class="lineCov">      11356 :     width = stem-&gt;width;</span>
<span class="lineNum">    3322 </span>            :     
<span class="lineNum">    3323 </span><span class="lineCov">     629867 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL )</span>
<span class="lineNum">    3324 </span><span class="lineCov">     316432 :         gd-&gt;points[i].sp-&gt;ticked = false;</span>
<span class="lineNum">    3325 </span>            : 
<span class="lineNum">    3326 </span><span class="lineCov">      11356 :     lcnt = rcnt = 0;</span>
<span class="lineNum">    3327 </span><span class="lineCov">      35436 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    3328 </span><span class="lineCov">      24080 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    3329 </span><span class="lineCov">      24080 :         if ( chunk-&gt;stemcheat )</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    3331 </span><span class="lineCov">      24080 :         lcnt = AddLineSegment( stem,lspace,lcnt,true ,chunk-&gt;l,chunk-&gt;lnext,gd );</span>
<span class="lineNum">    3332 </span><span class="lineCov">      24080 :         rcnt = AddLineSegment( stem,rspace,rcnt,false,chunk-&gt;r,chunk-&gt;rnext,gd );</span>
<span class="lineNum">    3333 </span>            :     }
<span class="lineNum">    3334 </span><span class="lineCov">      11356 :     bcnt = 0;</span>
<span class="lineNum">    3335 </span><span class="lineCov">      11356 :     if ( lcnt!=0 &amp;&amp; rcnt!=0 ) {</span>
<span class="lineNum">    3336 </span>            :         /* For curved segments we can extend left and right active segments    */
<span class="lineNum">    3337 </span>            :         /* a bit to ensure that they do overlap and thus can be marked with an */
<span class="lineNum">    3338 </span>            :         /* active zone */
<span class="lineNum">    3339 </span><span class="lineCov">      10536 :         if ( rcnt == lcnt &amp;&amp; stem-&gt;chunk_cnt == lcnt ) {</span>
<span class="lineNum">    3340 </span><span class="lineCov">      17738 :             for ( i=0; i&lt;lcnt; i++ ) {</span>
<span class="lineNum">    3341 </span>            :                 /* If it's a feature bend, then our tests should be more liberal */
<span class="lineNum">    3342 </span><span class="lineCov">      10558 :                 cove = (( rspace[i].curved + lspace[i].curved ) == 3 );</span>
<span class="lineNum">    3343 </span><span class="lineCov">      10558 :                 gap = 0;</span>
<span class="lineNum">    3344 </span><span class="lineCov">      10558 :                 if ( lspace[i].start&gt;rspace[i].end &amp;&amp; lspace[i].scurved &amp;&amp; rspace[i].ecurved )</span>
<span class="lineNum">    3345 </span><span class="lineCov">        198 :                     gap = lspace[i].start-rspace[i].end;</span>
<span class="lineNum">    3346 </span><span class="lineCov">      10360 :                 else if ( rspace[i].start&gt;lspace[i].end &amp;&amp; rspace[i].scurved &amp;&amp; lspace[i].ecurved )</span>
<span class="lineNum">    3347 </span><span class="lineCov">        136 :                     gap = rspace[i].start-lspace[i].end;</span>
<span class="lineNum">    3348 </span><span class="lineCov">      10224 :                 else if ( !cove )</span>
<span class="lineNum">    3349 </span><span class="lineCov">       8703 :             continue;</span>
<span class="lineNum">    3350 </span>            : 
<span class="lineNum">    3351 </span><span class="lineCov">       1855 :                 lseg = lspace[i].end - lspace[i].start;</span>
<span class="lineNum">    3352 </span><span class="lineCov">       1855 :                 rseg = rspace[i].end - rspace[i].start;</span>
<span class="lineNum">    3353 </span><span class="lineCov">       2181 :                 if (( cove &amp;&amp; gap &lt; (lseg &gt; rseg ? lseg : rseg )) ||</span>
<span class="lineNum">    3354 </span><span class="lineCov">        442 :                     ( gap &lt; ( lseg + rseg )/2 &amp;&amp; !stem-&gt;chunks[i].stub )) {</span>
<span class="lineNum">    3355 </span><span class="lineCov">       1609 :                     if ( lspace[i].ebase&lt;rspace[i].start )</span>
<span class="lineNum">    3356 </span><span class="lineCov">         42 :                         rspace[i].start = lspace[i].ebase;</span>
<span class="lineNum">    3357 </span><span class="lineCov">       1567 :                     else if ( lspace[i].sbase&gt;rspace[i].end )</span>
<span class="lineNum">    3358 </span><span class="lineCov">         68 :                         rspace[i].end = lspace[i].sbase;</span>
<span class="lineNum">    3359 </span><span class="lineCov">       1609 :                     if ( rspace[i].ebase&lt;lspace[i].start )</span>
<span class="lineNum">    3360 </span><span class="lineCov">         65 :                         lspace[i].start = rspace[i].ebase;</span>
<span class="lineNum">    3361 </span><span class="lineCov">       1544 :                     else if ( rspace[i].sbase&gt;lspace[i].end )</span>
<span class="lineNum">    3362 </span><span class="lineCov">         36 :                         lspace[i].end = rspace[i].sbase;</span>
<span class="lineNum">    3363 </span>            :                 }
<span class="lineNum">    3364 </span>            :             }
<span class="lineNum">    3365 </span>            :         }
<span class="lineNum">    3366 </span><span class="lineCov">      10536 :         qsort(lspace,lcnt,sizeof(struct segment),segment_cmp);</span>
<span class="lineNum">    3367 </span><span class="lineCov">      10536 :         qsort(rspace,rcnt,sizeof(struct segment),segment_cmp);</span>
<span class="lineNum">    3368 </span><span class="lineCov">      10536 :         lcnt = MergeSegments( lspace,lcnt );</span>
<span class="lineNum">    3369 </span><span class="lineCov">      10536 :         rcnt = MergeSegments( rspace,rcnt );</span>
<span class="lineNum">    3370 </span><span class="lineCov">      22880 :         for ( i=j=bcnt=0; i&lt;lcnt &amp;&amp; j&lt;rcnt; ++i ) {</span>
<span class="lineNum">    3371 </span><span class="lineCov">      25731 :             while ( j&lt;rcnt &amp;&amp; rspace[j].end&lt;=lspace[i].start )</span>
<span class="lineNum">    3372 </span><span class="lineCov">       1043 :                 ++j;</span>
<span class="lineNum">    3373 </span><span class="lineCov">      32077 :             while ( j&lt;rcnt &amp;&amp; rspace[j].start&lt;=lspace[i].end ) {</span>
<span class="lineNum">    3374 </span><span class="lineCov">      12022 :                 cove = (( rspace[j].curved + lspace[i].curved ) == 3 );</span>
<span class="lineNum">    3375 </span>            :                 
<span class="lineNum">    3376 </span><span class="lineCov">      24044 :                 s = ( rspace[j].start &gt; lspace[i].start ) ?</span>
<span class="lineNum">    3377 </span><span class="lineCov">      12022 :                     rspace[j].start : lspace[i].start;</span>
<span class="lineNum">    3378 </span><span class="lineCov">      24044 :                 e = ( rspace[j].end &lt; lspace[i].end ) ?</span>
<span class="lineNum">    3379 </span><span class="lineCov">      12022 :                     rspace[j].end : lspace[i].end;</span>
<span class="lineNum">    3380 </span><span class="lineCov">      24044 :                 sbase = ( rspace[j].start &gt; lspace[i].start ) ?</span>
<span class="lineNum">    3381 </span><span class="lineCov">      12022 :                     lspace[i].sbase : rspace[j].sbase;</span>
<span class="lineNum">    3382 </span><span class="lineCov">      24044 :                 ebase = ( rspace[j].end &lt; lspace[i].end ) ?</span>
<span class="lineNum">    3383 </span><span class="lineCov">      12022 :                     lspace[i].ebase : rspace[j].ebase;</span>
<span class="lineNum">    3384 </span>            :                 
<span class="lineNum">    3385 </span><span class="lineCov">      12022 :                 middle = ( lspace[i].start + rspace[j].start )/2;</span>
<span class="lineNum">    3386 </span><span class="lineCov">      12022 :                 bothspace[bcnt].start = ( cove &amp;&amp; middle &lt; s ) ? middle : s;</span>
<span class="lineNum">    3387 </span><span class="lineCov">      12022 :                 if ( rspace[j].start &gt; lspace[i].start )</span>
<span class="lineNum">    3388 </span><span class="lineCov">      10752 :                     bothspace[bcnt].scurved = ( rspace[j].scurved || sbase &lt; s ) ?</span>
<span class="lineNum">    3389 </span><span class="lineCov">       9303 :                         rspace[j].scurved : lspace[i].scurved;</span>
<span class="lineNum">    3390 </span>            :                 else
<span class="lineNum">    3391 </span><span class="lineCov">      18303 :                     bothspace[bcnt].scurved = ( lspace[i].scurved || sbase &lt; s ) ?</span>
<span class="lineNum">    3392 </span><span class="lineCov">      12064 :                         lspace[i].scurved : rspace[j].scurved;</span>
<span class="lineNum">    3393 </span>            :                 
<span class="lineNum">    3394 </span><span class="lineCov">      12022 :                 middle = ( lspace[i].end + rspace[j].end )/2;</span>
<span class="lineNum">    3395 </span><span class="lineCov">      12022 :                 bothspace[bcnt].end = ( cove &amp;&amp; middle &gt; e ) ? middle : e;</span>
<span class="lineNum">    3396 </span><span class="lineCov">      12022 :                 if ( rspace[j].end &lt; lspace[i].end )</span>
<span class="lineNum">    3397 </span><span class="lineCov">      10900 :                     bothspace[bcnt].ecurved = ( rspace[j].ecurved || ebase &gt; e ) ?</span>
<span class="lineNum">    3398 </span><span class="lineCov">       9513 :                         rspace[j].ecurved : lspace[i].ecurved;</span>
<span class="lineNum">    3399 </span>            :                 else
<span class="lineNum">    3400 </span><span class="lineCov">      18008 :                     bothspace[bcnt].ecurved = ( lspace[i].ecurved || ebase &gt; e ) ?</span>
<span class="lineNum">    3401 </span><span class="lineCov">      12052 :                         lspace[i].ecurved : rspace[j].ecurved;</span>
<span class="lineNum">    3402 </span>            :                 
<span class="lineNum">    3403 </span><span class="lineCov">      24044 :                 sbase = ( rspace[j].sbase &gt; lspace[i].sbase ) ?</span>
<span class="lineNum">    3404 </span><span class="lineCov">      12022 :                     rspace[j].sbase : lspace[i].sbase;</span>
<span class="lineNum">    3405 </span><span class="lineCov">      24044 :                 ebase = ( rspace[j].ebase &lt; lspace[i].ebase ) ?</span>
<span class="lineNum">    3406 </span><span class="lineCov">      12022 :                     rspace[j].ebase : lspace[i].ebase;</span>
<span class="lineNum">    3407 </span><span class="lineCov">      12022 :                 if ( sbase &gt; bothspace[bcnt].end )</span>
<span class="lineNum">    3408 </span><span class="lineCov">        678 :                     sbase = ebase = bothspace[bcnt].end;</span>
<span class="lineNum">    3409 </span><span class="lineCov">      11344 :                 else if ( ebase &lt; bothspace[bcnt].start )</span>
<span class="lineNum">    3410 </span><span class="lineCov">        638 :                     sbase = ebase = bothspace[bcnt].start;</span>
<span class="lineNum">    3411 </span><span class="lineCov">      10706 :                 else if ( ebase &lt; sbase )</span>
<span class="lineNum">    3412 </span><span class="lineCov">       3376 :                     ebase = sbase = ( ebase + sbase )/2;</span>
<span class="lineNum">    3413 </span><span class="lineCov">      12022 :                 bothspace[bcnt].sbase = sbase;</span>
<span class="lineNum">    3414 </span><span class="lineCov">      12022 :                 bothspace[bcnt].ebase = ebase;</span>
<span class="lineNum">    3415 </span>            : 
<span class="lineNum">    3416 </span><span class="lineCov">      12022 :                 bothspace[bcnt++].curved = rspace[j].curved || lspace[i].curved;</span>
<span class="lineNum">    3417 </span>            : 
<span class="lineNum">    3418 </span><span class="lineCov">      12022 :                 if ( rspace[j].end&gt;lspace[i].end )</span>
<span class="lineNum">    3419 </span><span class="lineCov">       4633 :             break;</span>
<span class="lineNum">    3420 </span><span class="lineCov">       7389 :                 ++j;</span>
<span class="lineNum">    3421 </span>            :             }
<span class="lineNum">    3422 </span>            :         }
<span class="lineNum">    3423 </span>            :     }
<span class="lineNum">    3424 </span>            : #if GLYPH_DATA_DEBUG
<span class="lineNum">    3425 </span>            :     fprintf( stderr, &quot;Active zones for stem l=%.2f,%.2f r=%.2f,%.2f dir=%.2f,%.2f:\n&quot;,
<span class="lineNum">    3426 </span>            :         stem-&gt;left.x,stem-&gt;left.y,stem-&gt;right.x,stem-&gt;right.y,stem-&gt;unit.x,stem-&gt;unit.y );
<span class="lineNum">    3427 </span>            :     for ( i=0; i&lt;lcnt; i++ ) {
<span class="lineNum">    3428 </span>            :         fprintf( stderr, &quot;\tleft space curved=%d\n&quot;,lspace[i].curved );
<span class="lineNum">    3429 </span>            :         fprintf( stderr, &quot;\t\tstart=%.2f,base=%.2f,curved=%d\n&quot;,
<span class="lineNum">    3430 </span>            :             lspace[i].start,lspace[i].sbase,lspace[i].scurved );
<span class="lineNum">    3431 </span>            :         fprintf( stderr, &quot;\t\tend=%.2f,base=%.2f,curved=%d\n&quot;,
<span class="lineNum">    3432 </span>            :             lspace[i].end,lspace[i].ebase,lspace[i].ecurved );
<span class="lineNum">    3433 </span>            :     }
<span class="lineNum">    3434 </span>            :     for ( i=0; i&lt;rcnt; i++ ) {
<span class="lineNum">    3435 </span>            :         fprintf( stderr, &quot;\tright space curved=%d\n&quot;,rspace[i].curved );
<span class="lineNum">    3436 </span>            :         fprintf( stderr, &quot;\t\tstart=%.2f,base=%.2f,curved=%d\n&quot;,
<span class="lineNum">    3437 </span>            :             rspace[i].start,rspace[i].sbase,rspace[i].scurved );
<span class="lineNum">    3438 </span>            :         fprintf( stderr, &quot;\t\tend=%.2f,base=%.2f,curved=%d\n&quot;,
<span class="lineNum">    3439 </span>            :             rspace[i].end,rspace[i].ebase,rspace[i].ecurved );
<span class="lineNum">    3440 </span>            :     }
<span class="lineNum">    3441 </span>            :     for ( i=0; i&lt;bcnt; i++ ) {
<span class="lineNum">    3442 </span>            :         fprintf( stderr, &quot;\tboth space\n&quot; );
<span class="lineNum">    3443 </span>            :         fprintf( stderr, &quot;\t\tstart=%.2f,base=%.2f,curved=%d\n&quot;,
<span class="lineNum">    3444 </span>            :             bothspace[i].start,bothspace[i].sbase,bothspace[i].scurved );
<span class="lineNum">    3445 </span>            :         fprintf( stderr, &quot;\t\tend=%.2f,base=%.2f,curved=%d\n&quot;,
<span class="lineNum">    3446 </span>            :             bothspace[i].end,bothspace[i].ebase,bothspace[i].ecurved );
<span class="lineNum">    3447 </span>            :     }
<span class="lineNum">    3448 </span>            :     fprintf( stderr,&quot;\n&quot; );
<span class="lineNum">    3449 </span>            : #endif
<span class="lineNum">    3450 </span>            : 
<span class="lineNum">    3451 </span><span class="lineCov">      30080 :     err = ( stem-&gt;unit.x == 0 || stem-&gt;unit.y == 0 ) ?</span>
<span class="lineNum">    3452 </span><span class="lineCov">      20023 :         dist_error_hv : dist_error_diag;</span>
<span class="lineNum">    3453 </span><span class="lineCov">      11356 :     lmin = ( stem-&gt;lmin &lt; -err ) ? stem-&gt;lmin : -err;</span>
<span class="lineNum">    3454 </span><span class="lineCov">      11356 :     rmax = ( stem-&gt;rmax &gt; err ) ? stem-&gt;rmax : err;</span>
<span class="lineNum">    3455 </span><span class="lineCov">      11356 :     acnt = 0;</span>
<span class="lineNum">    3456 </span><span class="lineCov">      11356 :     if ( bcnt!=0 ) {</span>
<span class="lineNum">    3457 </span><span class="lineCov">     535367 :         for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( (pd = &amp;gd-&gt;points[i])-&gt;sp!=NULL ) {</span>
<span class="lineNum">    3458 </span>            :             /* Let's say we have a stem. And then inside that stem we have */
<span class="lineNum">    3459 </span>            :             /*  another rectangle. So our first stem isn't really a stem any */
<span class="lineNum">    3460 </span>            :             /*  more (because we hit another edge first), yet it's still reasonable*/
<span class="lineNum">    3461 </span>            :             /*  to align the original stem */
<span class="lineNum">    3462 </span>            :             /* Now suppose the rectangle is rotated a bit so we can't make */
<span class="lineNum">    3463 </span>            :             /*  a stem from it. What do we do here? */
<span class="lineNum">    3464 </span><span class="lineCov">     538862 :             loff =  ( pd-&gt;sp-&gt;me.x - stem-&gt;left.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    3465 </span><span class="lineCov">     269431 :                     ( pd-&gt;sp-&gt;me.y - stem-&gt;left.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    3466 </span><span class="lineCov">     538862 :             roff =  ( pd-&gt;sp-&gt;me.x - stem-&gt;right.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    3467 </span><span class="lineCov">     269431 :                     ( pd-&gt;sp-&gt;me.y - stem-&gt;right.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    3468 </span>            :                 
<span class="lineNum">    3469 </span><span class="lineCov">     269431 :             if ( loff &gt;= lmin &amp;&amp; roff &lt;= rmax ) {</span>
<span class="lineNum">    3470 </span><span class="lineCov">     158338 :                 pd-&gt;projection = (pd-&gt;sp-&gt;me.x - stem-&gt;left.x)*stem-&gt;unit.x +</span>
<span class="lineNum">    3471 </span><span class="lineCov">      79169 :                                  (pd-&gt;sp-&gt;me.y - stem-&gt;left.y)*stem-&gt;unit.y;</span>
<span class="lineNum">    3472 </span><span class="lineCov">      79169 :                 if ( InActive(pd-&gt;projection,bothspace,bcnt) )</span>
<span class="lineNum">    3473 </span><span class="lineCov">      36685 :                     pspace[pcnt++] = pd;</span>
<span class="lineNum">    3474 </span>            :             }
<span class="lineNum">    3475 </span>            :         }
<span class="lineNum">    3476 </span><span class="lineCov">       9888 :         qsort(pspace,pcnt,sizeof(struct pointdata *),proj_cmp);</span>
<span class="lineNum">    3477 </span>            : 
<span class="lineNum">    3478 </span><span class="lineCov">       9888 :         bpos = i = 0;</span>
<span class="lineNum">    3479 </span><span class="lineCov">      31798 :         while ( bpos&lt;bcnt ) {</span>
<span class="lineNum">    3480 </span><span class="lineCov">      12022 :             if ( bothspace[bpos].curved || pcnt==0 ) {</span>
<span class="lineNum">    3481 </span><span class="lineCov">       4891 :                 activespace[acnt++] = bothspace[bpos++];</span>
<span class="lineNum">    3482 </span>            :             } else {
<span class="lineNum">    3483 </span><span class="lineCov">       7131 :                 last = bothspace[bpos].start;</span>
<span class="lineNum">    3484 </span><span class="lineCov">       7131 :                 startset = false; endset = false;</span>
<span class="lineNum">    3485 </span>            : 
<span class="lineNum">    3486 </span><span class="lineCov">      11895 :                 if ( bothspace[bpos].scurved || </span>
<span class="lineNum">    3487 </span><span class="lineCov">       4764 :                     StemIsActiveAt( gd,stem,bothspace[bpos].start+0.0015 )) {</span>
<span class="lineNum">    3488 </span>            :                     
<span class="lineNum">    3489 </span><span class="lineCov">       6394 :                     activespace[acnt].scurved = bothspace[bpos].scurved;</span>
<span class="lineNum">    3490 </span><span class="lineCov">       6394 :                     activespace[acnt].start  = bothspace[bpos].start;</span>
<span class="lineNum">    3491 </span><span class="lineCov">       6394 :                     startset = true;</span>
<span class="lineNum">    3492 </span>            :                 }
<span class="lineNum">    3493 </span>            :                 
<span class="lineNum">    3494 </span>            :                 /* If the stem is preceded by a curved segment, then skip     */
<span class="lineNum">    3495 </span>            :                 /* the first point position and start from the next one.      */
<span class="lineNum">    3496 </span>            :                 /* (Otherwise StemIsActiveAt() may consider the stem is       */
<span class="lineNum">    3497 </span>            :                 /* &quot;inactive&quot; at the fragment between the start of the active */
<span class="lineNum">    3498 </span>            :                 /* space and the first point actually belonging to this stem) */
<span class="lineNum">    3499 </span><span class="lineCov">       7131 :                 if ( bothspace[bpos].scurved ) {</span>
<span class="lineNum">    3500 </span><span class="lineCov">       2367 :                     while ( pcnt&gt;i &amp;&amp; pspace[i]-&gt;projection &lt; bothspace[bpos].sbase ) i++;</span>
<span class="lineNum">    3501 </span>            :                     
<span class="lineNum">    3502 </span><span class="lineCov">       2367 :                     if ( pcnt &gt; i &amp;&amp; pspace[i]-&gt;projection &gt;= bothspace[bpos].sbase ) {</span>
<span class="lineNum">    3503 </span><span class="lineCov">       2316 :                         last = activespace[acnt].end = pspace[i]-&gt;projection;</span>
<span class="lineNum">    3504 </span><span class="lineCov">       2316 :                         activespace[acnt].ecurved = false;</span>
<span class="lineNum">    3505 </span><span class="lineCov">       2316 :                         activespace[acnt].curved = false;</span>
<span class="lineNum">    3506 </span><span class="lineCov">       2316 :                         endset=true;</span>
<span class="lineNum">    3507 </span>            :                     }
<span class="lineNum">    3508 </span>            :                 }
<span class="lineNum">    3509 </span>            :                 
<span class="lineNum">    3510 </span><span class="lineCov">      50325 :                 while ( i&lt;pcnt &amp;&amp; (</span>
<span class="lineNum">    3511 </span><span class="lineCov">      46967 :                     ( !bothspace[bpos].ecurved &amp;&amp; pspace[i]-&gt;projection&lt;bothspace[bpos].end ) ||</span>
<span class="lineNum">    3512 </span><span class="lineCov">      19459 :                     ( bothspace[bpos].ecurved &amp;&amp; pspace[i]-&gt;projection&lt;=bothspace[bpos].ebase ))) {</span>
<span class="lineNum">    3513 </span><span class="lineCov">      14902 :                     if ( last==activespace[acnt].start &amp;&amp; pspace[i]-&gt;projection &gt;= last ) {</span>
<span class="lineNum">    3514 </span>            : 
<span class="lineNum">    3515 </span><span class="lineCov">      20604 :                         if ( !StemIsActiveAt( gd,stem,last+(( 1.001*pspace[i]-&gt;projection-last )/2.001 ))) {</span>
<span class="lineNum">    3516 </span><span class="lineCov">       3440 :                             last = activespace[acnt].start = pspace[i]-&gt;projection;</span>
<span class="lineNum">    3517 </span><span class="lineCov">       3440 :                             activespace[acnt].scurved = false;</span>
<span class="lineNum">    3518 </span><span class="lineCov">       3440 :                             startset = true; endset = false;</span>
<span class="lineNum">    3519 </span>            :                         } else {
<span class="lineNum">    3520 </span><span class="lineCov">       6862 :                             last = activespace[acnt].end = pspace[i]-&gt;projection;</span>
<span class="lineNum">    3521 </span><span class="lineCov">       6862 :                             activespace[acnt].ecurved = false;</span>
<span class="lineNum">    3522 </span><span class="lineCov">       6862 :                             activespace[acnt].curved = false;</span>
<span class="lineNum">    3523 </span><span class="lineCov">       6862 :                             endset = true;</span>
<span class="lineNum">    3524 </span>            :                         }
<span class="lineNum">    3525 </span><span class="lineCov">       4600 :                     } else if (( last==activespace[acnt].end || !startset )</span>
<span class="lineNum">    3526 </span><span class="lineCov">       3356 :                         &amp;&amp; pspace[i]-&gt;projection &gt;= last) {</span>
<span class="lineNum">    3527 </span>            :                         
<span class="lineNum">    3528 </span><span class="lineCov">       3018 :                         if ( !StemIsActiveAt( gd,stem,last+(( 1.001*pspace[i]-&gt;projection-last )/2.001 )) || </span>
<span class="lineNum">    3529 </span>            :                             !startset ) {
<span class="lineNum">    3530 </span>            :                             
<span class="lineNum">    3531 </span><span class="lineCov">        928 :                             if ( startset ) acnt++;</span>
<span class="lineNum">    3532 </span><span class="lineCov">        928 :                             last = activespace[acnt].start = pspace[i]-&gt;projection;</span>
<span class="lineNum">    3533 </span><span class="lineCov">        928 :                             activespace[acnt].scurved = false;</span>
<span class="lineNum">    3534 </span><span class="lineCov">        928 :                             startset = true; endset = false;</span>
<span class="lineNum">    3535 </span>            :                         } else {
<span class="lineNum">    3536 </span><span class="lineCov">       2090 :                             last = activespace[acnt].end = pspace[i]-&gt;projection;</span>
<span class="lineNum">    3537 </span><span class="lineCov">       2090 :                             activespace[acnt].ecurved = false;</span>
<span class="lineNum">    3538 </span><span class="lineCov">       2090 :                             activespace[acnt].curved = false;</span>
<span class="lineNum">    3539 </span><span class="lineCov">       2090 :                             endset = true;</span>
<span class="lineNum">    3540 </span>            :                         }
<span class="lineNum">    3541 </span>            :                     }
<span class="lineNum">    3542 </span><span class="lineCov">      14902 :                     ++i;</span>
<span class="lineNum">    3543 </span>            :                 }
<span class="lineNum">    3544 </span>            :                 
<span class="lineNum">    3545 </span><span class="lineCov">      11781 :                 if (( bothspace[bpos].ecurved || </span>
<span class="lineNum">    3546 </span><span class="lineCov">      11088 :                     StemIsActiveAt( gd,stem,bothspace[bpos].end-0.0015 )) &amp;&amp;</span>
<span class="lineNum">    3547 </span>            :                     startset ) {
<span class="lineNum">    3548 </span>            : 
<span class="lineNum">    3549 </span><span class="lineCov">       6436 :                     activespace[acnt].end = bothspace[bpos].end;</span>
<span class="lineNum">    3550 </span><span class="lineCov">       6436 :                     activespace[acnt].ecurved = bothspace[bpos].ecurved;</span>
<span class="lineNum">    3551 </span><span class="lineCov">       6436 :                     activespace[acnt].curved = bothspace[bpos].curved;</span>
<span class="lineNum">    3552 </span><span class="lineCov">       6436 :                     endset = true;</span>
<span class="lineNum">    3553 </span>            :                 }
<span class="lineNum">    3554 </span><span class="lineCov">       7131 :                 ++bpos;</span>
<span class="lineNum">    3555 </span><span class="lineCov">       7131 :                 if ( endset ) ++acnt;</span>
<span class="lineNum">    3556 </span>            :             }
<span class="lineNum">    3557 </span>            :         }
<span class="lineNum">    3558 </span>            :     }
<span class="lineNum">    3559 </span>            : 
<span class="lineNum">    3560 </span><span class="lineCov">      35436 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    3561 </span><span class="lineCov">      24080 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    3562 </span>            :         /* stemcheat 1 -- diagonal edge stem;
<span class="lineNum">    3563 </span>            :          *           2 -- diagonal corner stem with a sharp top;
<span class="lineNum">    3564 </span>            :          *           3 -- diagonal corner stem with a flat top;
<span class="lineNum">    3565 </span>            :          *           4 -- bounding box hint */
<span class="lineNum">    3566 </span><span class="lineCov">      24080 :         if ( chunk-&gt;stemcheat==3 &amp;&amp; chunk-&gt;l!=NULL &amp;&amp; chunk-&gt;r!=NULL &amp;&amp;</span>
<span class="lineNum">    3567 </span><span class="lineNoCov">          0 :                 i+1&lt;stem-&gt;chunk_cnt &amp;&amp;</span>
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :                 stem-&gt;chunks[i+1].stemcheat==3 &amp;&amp; </span>
<span class="lineNum">    3569 </span><span class="lineNoCov">          0 :                 ( chunk-&gt;l==stem-&gt;chunks[i+1].l ||</span>
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :                 chunk-&gt;r==stem-&gt;chunks[i+1].r )) {</span>
<span class="lineNum">    3571 </span>            :             
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 :             SplinePoint *sp = chunk-&gt;l==stem-&gt;chunks[i+1].l ?</span>
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :                 chunk-&gt;l-&gt;sp : chunk-&gt;r-&gt;sp;</span>
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :             proj =  (sp-&gt;me.x - stem-&gt;left.x) *stem-&gt;unit.x +</span>
<span class="lineNum">    3575 </span><span class="lineNoCov">          0 :                     (sp-&gt;me.y - stem-&gt;left.y) *stem-&gt;unit.y;</span>
<span class="lineNum">    3576 </span>            : 
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :             SplinePoint *sp2 = chunk-&gt;l==stem-&gt;chunks[i+1].l ?</span>
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :                 chunk-&gt;r-&gt;sp : chunk-&gt;l-&gt;sp;</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :             SplinePoint *sp3 = chunk-&gt;l==stem-&gt;chunks[i+1].l ?</span>
<span class="lineNum">    3580 </span><span class="lineNoCov">          0 :                 stem-&gt;chunks[i+1].r-&gt;sp : stem-&gt;chunks[i+1].l-&gt;sp;</span>
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 :             proj2 = (sp2-&gt;me.x - stem-&gt;left.x) *stem-&gt;unit.x +</span>
<span class="lineNum">    3582 </span><span class="lineNoCov">          0 :                     (sp2-&gt;me.y - stem-&gt;left.y) *stem-&gt;unit.y;</span>
<span class="lineNum">    3583 </span><span class="lineNoCov">          0 :             proj3 = (sp3-&gt;me.x - stem-&gt;left.x) *stem-&gt;unit.x +</span>
<span class="lineNum">    3584 </span><span class="lineNoCov">          0 :                     (sp3-&gt;me.y - stem-&gt;left.y) *stem-&gt;unit.y;</span>
<span class="lineNum">    3585 </span>            : 
<span class="lineNum">    3586 </span><span class="lineNoCov">          0 :             if ( proj2&gt;proj3 ) {</span>
<span class="lineNum">    3587 </span><span class="lineNoCov">          0 :                 ptemp = proj2; proj2 = proj3; proj3 = ptemp;</span>
<span class="lineNum">    3588 </span>            :             }
<span class="lineNum">    3589 </span>            :             
<span class="lineNum">    3590 </span><span class="lineNoCov">          0 :             if ( (proj3-proj2) &lt; width ) {</span>
<span class="lineNum">    3591 </span><span class="lineNoCov">          0 :                 activespace[acnt  ].curved = true;</span>
<span class="lineNum">    3592 </span><span class="lineNoCov">          0 :                 proj2 -= width/2;</span>
<span class="lineNum">    3593 </span><span class="lineNoCov">          0 :                 proj3 += width/2;</span>
<span class="lineNum">    3594 </span>            :             } else {
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :                 activespace[acnt  ].curved = false;</span>
<span class="lineNum">    3596 </span>            :             }
<span class="lineNum">    3597 </span>            :             
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :             activespace[acnt].start = proj2;</span>
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :             activespace[acnt].end = proj3;</span>
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :             activespace[acnt].sbase = activespace[acnt].ebase = proj;</span>
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :             acnt++;</span>
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :             ++i;</span>
<span class="lineNum">    3603 </span><span class="lineCov">      24080 :         } else if ( chunk-&gt;stemcheat &amp;&amp; chunk-&gt;l!=NULL &amp;&amp; chunk-&gt;r!=NULL ) {</span>
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :             SplinePoint *sp = chunk-&gt;l-&gt;sp;</span>
<span class="lineNum">    3605 </span><span class="lineNoCov">          0 :             proj =  ( sp-&gt;me.x - stem-&gt;left.x ) * stem-&gt;unit.x +</span>
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :                     ( sp-&gt;me.y - stem-&gt;left.y ) * stem-&gt;unit.y;</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :             orig_proj = proj;</span>
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :             SplinePoint *other = chunk-&gt;lnext ? sp-&gt;next-&gt;to : sp-&gt;prev-&gt;from;</span>
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :             len  =  (other-&gt;me.x - sp-&gt;me.x) * stem-&gt;unit.x +</span>
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :                     (other-&gt;me.y - sp-&gt;me.y) * stem-&gt;unit.y;</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :             if ( chunk-&gt;stemcheat == 2 )</span>
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :                 proj -= width/2;</span>
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 :             else if ( len&lt;0 )</span>
<span class="lineNum">    3614 </span><span class="lineNoCov">          0 :                 proj -= width;</span>
<span class="lineNum">    3615 </span><span class="lineNoCov">          0 :             activespace[acnt].curved = true;</span>
<span class="lineNum">    3616 </span><span class="lineNoCov">          0 :             activespace[acnt].start = proj;</span>
<span class="lineNum">    3617 </span><span class="lineNoCov">          0 :             activespace[acnt].end = proj+width;</span>
<span class="lineNum">    3618 </span><span class="lineNoCov">          0 :             activespace[acnt].sbase = activespace[acnt].ebase = orig_proj;</span>
<span class="lineNum">    3619 </span><span class="lineNoCov">          0 :             acnt++;</span>
<span class="lineNum">    3620 </span>            :         }
<span class="lineNum">    3621 </span>            :     }
<span class="lineNum">    3622 </span>            : 
<span class="lineNum">    3623 </span><span class="lineCov">      11356 :     if ( acnt!=0 ) {</span>
<span class="lineNum">    3624 </span><span class="lineCov">       9528 :         stem-&gt;activecnt = MergeSegmentsFinal( activespace,acnt );</span>
<span class="lineNum">    3625 </span><span class="lineCov">       9528 :         stem-&gt;active = malloc(acnt*sizeof(struct segment));</span>
<span class="lineNum">    3626 </span><span class="lineCov">       9528 :         memcpy(stem-&gt;active,activespace,acnt*sizeof(struct segment));</span>
<span class="lineNum">    3627 </span>            :     }
<span class="lineNum">    3628 </span>            : 
<span class="lineNum">    3629 </span><span class="lineCov">      11356 :     len = clen = 0;</span>
<span class="lineNum">    3630 </span><span class="lineCov">      23155 :     for ( i=0; i&lt;acnt; ++i ) {</span>
<span class="lineNum">    3631 </span><span class="lineCov">      11799 :         if ( stem-&gt;active[i].curved )</span>
<span class="lineNum">    3632 </span><span class="lineCov">       4766 :             clen += stem-&gt;active[i].end-stem-&gt;active[i].start;</span>
<span class="lineNum">    3633 </span>            :         else
<span class="lineNum">    3634 </span><span class="lineCov">       7033 :             len += stem-&gt;active[i].end-stem-&gt;active[i].start;</span>
<span class="lineNum">    3635 </span>            :     }
<span class="lineNum">    3636 </span><span class="lineCov">      11356 :     stem-&gt;len = len; stem-&gt;clen = len+clen;</span>
<a name="3637"><span class="lineNum">    3637 </span><span class="lineCov">      11356 : }</span></a>
<span class="lineNum">    3638 </span>            : 
<span class="lineNum">    3639 </span><span class="lineCov">       1644 : static void GDStemsFixupIntersects(struct glyphdata *gd) {</span>
<span class="lineNum">    3640 </span>            :     int i, j, stemidx;
<span class="lineNum">    3641 </span>            :     struct stemdata *stem;
<span class="lineNum">    3642 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    3643 </span>            : 
<span class="lineNum">    3644 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    3645 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3646 </span><span class="lineCov">      33531 :         for ( j=0; j&lt;stem-&gt;chunk_cnt; ++j ) {</span>
<span class="lineNum">    3647 </span><span class="lineCov">      22880 :             chunk = &amp;stem-&gt;chunks[j];</span>
<span class="lineNum">    3648 </span><span class="lineCov">      22880 :             if ( chunk-&gt;l!=NULL ) {</span>
<span class="lineNum">    3649 </span><span class="lineCov">      20273 :                 stemidx = IsStemAssignedToPoint( chunk-&gt;l,stem,true );</span>
<span class="lineNum">    3650 </span><span class="lineCov">      20273 :                 FixupT( chunk-&gt;l,stemidx,true,chunk-&gt;l_e_idx );</span>
<span class="lineNum">    3651 </span><span class="lineCov">      20273 :                 stemidx = IsStemAssignedToPoint( chunk-&gt;l,stem,false );</span>
<span class="lineNum">    3652 </span><span class="lineCov">      20273 :                 FixupT( chunk-&gt;l,stemidx,false,chunk-&gt;l_e_idx );</span>
<span class="lineNum">    3653 </span>            :             }
<span class="lineNum">    3654 </span><span class="lineCov">      22880 :             if ( chunk-&gt;r!=NULL ) {</span>
<span class="lineNum">    3655 </span><span class="lineCov">      20359 :                 stemidx = IsStemAssignedToPoint( chunk-&gt;r,stem,true );</span>
<span class="lineNum">    3656 </span><span class="lineCov">      20359 :                 FixupT( chunk-&gt;r,stemidx,true,chunk-&gt;r_e_idx );</span>
<span class="lineNum">    3657 </span><span class="lineCov">      20359 :                 stemidx = IsStemAssignedToPoint( chunk-&gt;r,stem,false );</span>
<span class="lineNum">    3658 </span><span class="lineCov">      20359 :                 FixupT( chunk-&gt;r,stemidx,false,chunk-&gt;r_e_idx );</span>
<span class="lineNum">    3659 </span>            :             }
<span class="lineNum">    3660 </span>            :         }
<span class="lineNum">    3661 </span>            :     }
<a name="3662"><span class="lineNum">    3662 </span><span class="lineCov">       1644 : }</span></a>
<span class="lineNum">    3663 </span>            : 
<span class="lineNum">    3664 </span><span class="lineCov">       2052 : static int StemsWouldConflict( struct stemdata *stem1,struct stemdata *stem2 ) {</span>
<span class="lineNum">    3665 </span>            :     double loff, roff, s1, s2, e1, e2;
<span class="lineNum">    3666 </span>            :     int acnt1, acnt2;
<span class="lineNum">    3667 </span>            :     
<span class="lineNum">    3668 </span><span class="lineCov">       2052 :     if ( stem1 == stem2 || !UnitsParallel( &amp;stem1-&gt;unit,&amp;stem2-&gt;unit,true ))</span>
<span class="lineNum">    3669 </span><span class="lineCov">       1261 : return( false );</span>
<span class="lineNum">    3670 </span>            : 
<span class="lineNum">    3671 </span><span class="lineCov">       1582 :     loff = ( stem2-&gt;left.x - stem1-&gt;left.x ) * stem1-&gt;unit.y -</span>
<span class="lineNum">    3672 </span><span class="lineCov">        791 :            ( stem2-&gt;left.y - stem1-&gt;left.y ) * stem1-&gt;unit.x;</span>
<span class="lineNum">    3673 </span><span class="lineCov">       1582 :     roff = ( stem2-&gt;right.x - stem1-&gt;right.x ) * stem1-&gt;unit.y -</span>
<span class="lineNum">    3674 </span><span class="lineCov">        791 :            ( stem2-&gt;right.y - stem1-&gt;right.y ) * stem1-&gt;unit.x;</span>
<span class="lineNum">    3675 </span><span class="lineCov">        791 :     loff = fabs( loff ); roff = fabs( roff );</span>
<span class="lineNum">    3676 </span><span class="lineCov">        791 :     if ( loff &gt; stem1-&gt;width || roff &gt; stem1-&gt;width )</span>
<span class="lineNum">    3677 </span><span class="lineCov">        395 : return( false );</span>
<span class="lineNum">    3678 </span>            : 
<span class="lineNum">    3679 </span><span class="lineCov">        396 :     acnt1 = stem1-&gt;activecnt;</span>
<span class="lineNum">    3680 </span><span class="lineCov">        396 :     acnt2 = stem2-&gt;activecnt;</span>
<span class="lineNum">    3681 </span><span class="lineCov">        396 :     if ( acnt1 == 0 || acnt2 == 0 )</span>
<span class="lineNum">    3682 </span><span class="lineCov">          9 : return( false );</span>
<span class="lineNum">    3683 </span><span class="lineCov">        387 :     s1 = stem1-&gt;active[0].start; e1 = stem1-&gt;active[acnt1-1].end;</span>
<span class="lineNum">    3684 </span><span class="lineCov">        387 :     s2 = stem2-&gt;active[0].start; e2 = stem2-&gt;active[acnt2-1].end;</span>
<span class="lineNum">    3685 </span>            :     
<span class="lineNum">    3686 </span><span class="lineCov">        774 :     loff = ( stem2-&gt;left.x - stem1-&gt;left.x ) * stem1-&gt;unit.x +</span>
<span class="lineNum">    3687 </span><span class="lineCov">        387 :            ( stem2-&gt;left.y - stem1-&gt;left.y ) * stem1-&gt;unit.y;</span>
<span class="lineNum">    3688 </span><span class="lineCov">        652 :     if (( s2+loff &gt;= s1 &amp;&amp; s2+loff &lt;= e1 ) || ( e2+loff &gt;= s1 &amp;&amp; e2+loff &lt;= e1 ) ||</span>
<span class="lineNum">    3689 </span><span class="lineCov">        435 :         ( s2+loff &lt;= s1 &amp;&amp; e2+loff &gt;= e1 ) || ( e2+loff &lt;= s1 &amp;&amp; s2+loff &gt;= e1 ))</span>
<span class="lineNum">    3690 </span><span class="lineCov">        180 : return( true );</span>
<span class="lineNum">    3691 </span>            : 
<span class="lineNum">    3692 </span><span class="lineCov">        207 : return( false );</span>
<span class="lineNum">    3693 </span>            : }
<span class="lineNum">    3694 </span>            : 
<span class="lineNum">    3695 </span>            : /* Convert diagonal stems generated for stubs and intersections to horizontal */
<a name="3696"><span class="lineNum">    3696 </span>            : /* or vertical, if they have just one chunk. This should be done before calculating */</a>
<span class="lineNum">    3697 </span>            : /* active zones, as they are calculated against each stem's unit vector */
<span class="lineNum">    3698 </span><span class="lineCov">       1644 : static void GDNormalizeStubs( struct glyphdata *gd ) {</span>
<span class="lineNum">    3699 </span>            :     int i, j, hv;
<span class="lineNum">    3700 </span>            :     struct stemdata *stem;
<span class="lineNum">    3701 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    3702 </span>            :     BasePoint newdir;
<span class="lineNum">    3703 </span>            :     
<span class="lineNum">    3704 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    3705 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3706 </span><span class="lineCov">      10651 :         if ( stem-&gt;positioned )</span>
<span class="lineNum">    3707 </span><span class="lineCov">       2255 :     continue;</span>
<span class="lineNum">    3708 </span>            :         
<span class="lineNum">    3709 </span><span class="lineCov">       8396 :         if ( !IsUnitHV( &amp;stem-&gt;unit,true )) {</span>
<span class="lineNum">    3710 </span><span class="lineCov">       2629 :             hv = IsUnitHV( &amp;stem-&gt;unit,false );</span>
<span class="lineNum">    3711 </span><span class="lineCov">       2629 :             if ( hv &amp;&amp; StemFitsHV( stem,( hv == 1 ),3 )) {</span>
<span class="lineNum">    3712 </span><span class="lineCov">        152 :                 if ( hv == 2 &amp;&amp; stem-&gt;unit.y &lt; 0 )</span>
<span class="lineNum">    3713 </span><span class="lineCov">         21 :                     SwapEdges( gd,stem );</span>
<span class="lineNum">    3714 </span>            : 
<span class="lineNum">    3715 </span><span class="lineCov">        152 :                 newdir.x = fabs( rint( stem-&gt;unit.x ));</span>
<span class="lineNum">    3716 </span><span class="lineCov">        152 :                 newdir.y = fabs( rint( stem-&gt;unit.y ));</span>
<span class="lineNum">    3717 </span><span class="lineCov">        152 :                 SetStemUnit( stem,newdir );</span>
<span class="lineNum">    3718 </span>            :                 
<span class="lineNum">    3719 </span><span class="lineCov">        304 :                 for ( j=0; j&lt;stem-&gt;chunk_cnt &amp;&amp; stem-&gt;leftidx == -1 &amp;&amp; stem-&gt;rightidx == -1; j++ ) {</span>
<span class="lineNum">    3720 </span><span class="lineCov">        152 :                     chunk = &amp;stem-&gt;chunks[j];</span>
<span class="lineNum">    3721 </span>            :                     
<span class="lineNum">    3722 </span><span class="lineCov">        152 :                     if ( stem-&gt;leftidx == -1 &amp;&amp; chunk-&gt;l != NULL )</span>
<span class="lineNum">    3723 </span><span class="lineCov">        152 :                         stem-&gt;leftidx = GetValidPointDataIndex( gd,chunk-&gt;l-&gt;sp,stem );</span>
<span class="lineNum">    3724 </span><span class="lineCov">        152 :                     if ( stem-&gt;rightidx == -1 &amp;&amp; chunk-&gt;r != NULL )</span>
<span class="lineNum">    3725 </span><span class="lineCov">        152 :                         stem-&gt;rightidx = GetValidPointDataIndex( gd,chunk-&gt;r-&gt;sp,stem );</span>
<span class="lineNum">    3726 </span>            :                 }
<span class="lineNum">    3727 </span>            :             }
<span class="lineNum">    3728 </span>            :         }
<span class="lineNum">    3729 </span>            :     }
<a name="3730"><span class="lineNum">    3730 </span><span class="lineCov">       1644 : }</span></a>
<span class="lineNum">    3731 </span>            : 
<span class="lineNum">    3732 </span><span class="lineCov">       1644 : static void GDFindUnlikelyStems( struct glyphdata *gd ) {</span>
<span class="lineNum">    3733 </span>            :     double width, minl, ratio;
<span class="lineNum">    3734 </span>            :     int i, j, k, stem_cnt, ls_cnt, rs_cnt, ltick, rtick;
<span class="lineNum">    3735 </span>            :     struct pointdata *lpd, *rpd;
<span class="lineNum">    3736 </span>            :     Spline *ls, *rs;
<span class="lineNum">    3737 </span>            :     SplinePoint *lsp, *rsp;
<span class="lineNum">    3738 </span>            :     BasePoint *lunit, *runit, *slunit, *srunit, *sunit;
<span class="lineNum">    3739 </span>            :     struct stemdata *stem, *stem1, *tstem;
<span class="lineNum">    3740 </span>            :     struct stemdata **tstems, **lstems, **rstems;
<span class="lineNum">    3741 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    3742 </span>            : 
<span class="lineNum">    3743 </span><span class="lineCov">       1644 :     GDStemsFixupIntersects( gd );</span>
<span class="lineNum">    3744 </span>            :    
<span class="lineNum">    3745 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    3746 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3747 </span>            : 
<span class="lineNum">    3748 </span>            :         /* If stem had been already present in the spline char before we */
<span class="lineNum">    3749 </span>            :         /* started generating glyph data, then it should never be */
<span class="lineNum">    3750 </span>            :         /* considered &quot;too big&quot; */
<span class="lineNum">    3751 </span><span class="lineCov">      10651 :         if ( stem-&gt;positioned )</span>
<span class="lineNum">    3752 </span><span class="lineCov">       2255 :     continue;</span>
<span class="lineNum">    3753 </span>            : 
<span class="lineNum">    3754 </span>            :         /* If a stem has straight edges, and it is wider than tall */
<span class="lineNum">    3755 </span>            :         /*  then it is unlikely to be a real stem */
<span class="lineNum">    3756 </span><span class="lineCov">       8396 :         width = stem-&gt;width;</span>
<span class="lineNum">    3757 </span><span class="lineCov">       8396 :         ratio = IsUnitHV( &amp;stem-&gt;unit,true ) ? gd-&gt;emsize/( 6 * width ) : -0.25;</span>
<span class="lineNum">    3758 </span><span class="lineCov">       8396 :         stem-&gt;toobig =  ( stem-&gt;clen + stem-&gt;clen * ratio &lt; width );</span>
<span class="lineNum">    3759 </span>            :     }
<span class="lineNum">    3760 </span>            : 
<span class="lineNum">    3761 </span>            :     /* One more check for curved stems. If a stem has just one active */
<span class="lineNum">    3762 </span>            :     /* segment, this segment is curved and the stem has no conflicts, */
<span class="lineNum">    3763 </span>            :     /* then select the active segment length which allows us to consider */
<span class="lineNum">    3764 </span>            :     /* this stem suitable for PS output by such a way, that stems connecting */
<span class="lineNum">    3765 </span>            :     /* the opposite sides of a circle are always accepted */
<span class="lineNum">    3766 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) if ( gd-&gt;stems[i].toobig ) {</span>
<span class="lineNum">    3767 </span><span class="lineCov">       3300 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3768 </span><span class="lineCov">       3300 :         width = stem-&gt;width;</span>
<span class="lineNum">    3769 </span>            : 
<span class="lineNum">    3770 </span><span class="lineCov">       4675 :         if ( IsUnitHV( &amp;stem-&gt;unit,true ) &amp;&amp; stem-&gt;activecnt == 1 &amp;&amp; </span>
<span class="lineNum">    3771 </span><span class="lineCov">       1710 :             stem-&gt;active[0].curved &amp;&amp; width/2 &gt; dist_error_curve ) {</span>
<span class="lineNum">    3772 </span>            :             
<span class="lineNum">    3773 </span><span class="lineCov">       2349 :             for ( j=0; j&lt;gd-&gt;stemcnt; ++j) {</span>
<span class="lineNum">    3774 </span><span class="lineCov">       2194 :                 stem1 = &amp;gd-&gt;stems[j];</span>
<span class="lineNum">    3775 </span>            : 
<span class="lineNum">    3776 </span><span class="lineCov">       2194 :                 if ( !stem1-&gt;toobig &amp;&amp; StemsWouldConflict( stem,stem1 ))</span>
<span class="lineNum">    3777 </span><span class="lineCov">        180 :             break;</span>
<span class="lineNum">    3778 </span>            :             }
<span class="lineNum">    3779 </span>            : 
<span class="lineNum">    3780 </span><span class="lineCov">        335 :             if ( j == gd-&gt;stemcnt ) {</span>
<span class="lineNum">    3781 </span><span class="lineCov">        155 :                 minl = sqrt( pow( width/2,2 ) - pow( width/2 - dist_error_curve,2 ));</span>
<span class="lineNum">    3782 </span><span class="lineCov">        155 :                 if ( stem-&gt;clen &gt;= minl ) stem-&gt;toobig = false;</span>
<span class="lineNum">    3783 </span>            :             }
<span class="lineNum">    3784 </span>            :         }
<span class="lineNum">    3785 </span>            :     }
<span class="lineNum">    3786 </span>            : 
<span class="lineNum">    3787 </span>            :     /* And finally a check for stubs and feature terminations. We don't */
<span class="lineNum">    3788 </span>            :     /* want such things to be controlled by any special hints, if there */
<span class="lineNum">    3789 </span>            :     /* is already a hint controlling the middle of the same feature */
<span class="lineNum">    3790 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    3791 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3792 </span><span class="lineCov">      10651 :         if ( stem-&gt;positioned )</span>
<span class="lineNum">    3793 </span><span class="lineCov">       2255 :     continue;</span>
<span class="lineNum">    3794 </span>            :         
<span class="lineNum">    3795 </span><span class="lineCov">       8396 :         if ( stem-&gt;chunk_cnt == 1 &amp;&amp; stem-&gt;chunks[0].stub &amp; 3 ) {</span>
<span class="lineNum">    3796 </span><span class="lineCov">        741 :             chunk = &amp;stem-&gt;chunks[0];</span>
<span class="lineNum">    3797 </span><span class="lineCov">        741 :             slunit = chunk-&gt;lnext ? &amp;chunk-&gt;l-&gt;nextunit : &amp;chunk-&gt;l-&gt;prevunit;</span>
<span class="lineNum">    3798 </span><span class="lineCov">        741 :             srunit = chunk-&gt;rnext ? &amp;chunk-&gt;r-&gt;nextunit : &amp;chunk-&gt;r-&gt;prevunit;</span>
<span class="lineNum">    3799 </span>            :             
<span class="lineNum">    3800 </span>            :             /* This test is valid only for features which are not exactly horizontal/    */
<span class="lineNum">    3801 </span>            :             /* vertical. But we can't check this using the stem unit, as it may have     */
<span class="lineNum">    3802 </span>            :             /* already beeen reset to HV. So we use the units of this stem's base points */
<span class="lineNum">    3803 </span>            :             /* instead. */
<span class="lineNum">    3804 </span><span class="lineCov">        741 :             if ( IsUnitHV( slunit,true ) &amp;&amp; IsUnitHV( srunit,true ))</span>
<span class="lineNum">    3805 </span><span class="lineCov">        314 :     continue;</span>
<span class="lineNum">    3806 </span><span class="lineCov">        427 :             if ( UnitCloserToHV( srunit,slunit ) &gt; 0 ) sunit = srunit;</span>
<span class="lineNum">    3807 </span><span class="lineCov">        214 :             else sunit = slunit;</span>
<span class="lineNum">    3808 </span>            :             
<span class="lineNum">    3809 </span><span class="lineCov">        427 :             lpd = chunk-&gt;l; lsp = lpd-&gt;sp; lstems = tstems = NULL;</span>
<span class="lineNum">    3810 </span><span class="lineCov">        427 :             ls_cnt = 0;</span>
<span class="lineNum">    3811 </span>            :             do {
<span class="lineNum">    3812 </span><span class="lineCov">       1791 :                 stem_cnt = (( chunk-&gt;lnext &amp;&amp; lpd == chunk-&gt;l ) ||</span>
<span class="lineNum">    3813 </span><span class="lineCov">       1249 :                             ( !chunk-&gt;lnext &amp;&amp; lpd != chunk-&gt;l )) ? lpd-&gt;nextcnt : lpd-&gt;prevcnt;</span>
<span class="lineNum">    3814 </span><span class="lineCov">        955 :                 for ( j=0; j&lt;stem_cnt; j++ ) {</span>
<span class="lineNum">    3815 </span><span class="lineCov">       1697 :                     tstems= (( chunk-&gt;lnext &amp;&amp; lpd == chunk-&gt;l ) ||</span>
<span class="lineNum">    3816 </span><span class="lineCov">       1177 :                             ( !chunk-&gt;lnext &amp;&amp; lpd != chunk-&gt;l )) ? lpd-&gt;nextstems : lpd-&gt;prevstems;</span>
<span class="lineNum">    3817 </span><span class="lineCov">        554 :                     tstem = tstems[j];</span>
<span class="lineNum">    3818 </span><span class="lineCov">        554 :                     if ( tstem != stem ) {</span>
<span class="lineNum">    3819 </span><span class="lineCov">        174 :                         lstems = tstems;</span>
<span class="lineNum">    3820 </span><span class="lineCov">        174 :                         ls_cnt = stem_cnt;</span>
<span class="lineNum">    3821 </span><span class="lineCov">        174 :                 break;</span>
<span class="lineNum">    3822 </span>            :                     }
<span class="lineNum">    3823 </span>            :                 }
<span class="lineNum">    3824 </span><span class="lineCov">        575 :                 if( lstems != NULL )</span>
<span class="lineNum">    3825 </span><span class="lineCov">        174 :             break;</span>
<span class="lineNum">    3826 </span><span class="lineCov">        401 :                 ls = ( chunk-&gt;lnext ) ? lsp-&gt;next : lsp-&gt;prev;</span>
<span class="lineNum">    3827 </span><span class="lineCov">        401 :                 if ( ls == NULL )</span>
<span class="lineNum">    3828 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3829 </span><span class="lineCov">        401 :                 lsp = ( chunk-&gt;lnext ) ? ls-&gt;to : ls-&gt;from;</span>
<span class="lineNum">    3830 </span><span class="lineCov">        401 :                 lpd = &amp;gd-&gt;points[lsp-&gt;ptindex];</span>
<span class="lineNum">    3831 </span><span class="lineCov">        401 :                 lunit = ( chunk-&gt;lnext ) ? &amp;lpd-&gt;prevunit : &amp;lpd-&gt;nextunit;</span>
<span class="lineNum">    3832 </span><span class="lineCov">       1200 :             } while ( lpd != chunk-&gt;l &amp;&amp; lpd != chunk-&gt;r &amp;&amp;</span>
<span class="lineNum">    3833 </span><span class="lineCov">        799 :                 UnitsParallel( lunit,sunit,false ));</span>
<span class="lineNum">    3834 </span>            : 
<span class="lineNum">    3835 </span><span class="lineCov">        427 :             rpd = chunk-&gt;r; rsp = rpd-&gt;sp; rstems = tstems = NULL;</span>
<span class="lineNum">    3836 </span><span class="lineCov">        427 :             rs_cnt = 0;</span>
<span class="lineNum">    3837 </span>            :             do {
<span class="lineNum">    3838 </span><span class="lineCov">       1855 :                 stem_cnt = (( chunk-&gt;rnext &amp;&amp; rpd == chunk-&gt;r ) ||</span>
<span class="lineNum">    3839 </span><span class="lineCov">       1317 :                             ( !chunk-&gt;rnext &amp;&amp; rpd != chunk-&gt;r )) ? rpd-&gt;nextcnt : rpd-&gt;prevcnt;</span>
<span class="lineNum">    3840 </span><span class="lineCov">        975 :                 for ( j=0; j&lt;stem_cnt; j++ ) {</span>
<span class="lineNum">    3841 </span><span class="lineCov">       1671 :                     tstems= (( chunk-&gt;rnext &amp;&amp; rpd == chunk-&gt;r ) ||</span>
<span class="lineNum">    3842 </span><span class="lineCov">       1177 :                             ( !chunk-&gt;rnext &amp;&amp; rpd != chunk-&gt;r )) ? rpd-&gt;nextstems : rpd-&gt;prevstems;</span>
<span class="lineNum">    3843 </span><span class="lineCov">        542 :                     tstem = tstems[j];</span>
<span class="lineNum">    3844 </span><span class="lineCov">        542 :                     if ( tstem != stem ) {</span>
<span class="lineNum">    3845 </span><span class="lineCov">        158 :                         rstems = tstems;</span>
<span class="lineNum">    3846 </span><span class="lineCov">        158 :                         rs_cnt = stem_cnt;</span>
<span class="lineNum">    3847 </span><span class="lineCov">        158 :                 break;</span>
<span class="lineNum">    3848 </span>            :                     }
<span class="lineNum">    3849 </span>            :                 }
<span class="lineNum">    3850 </span><span class="lineCov">        591 :                 if( rstems != NULL )</span>
<span class="lineNum">    3851 </span><span class="lineCov">        158 :             break;</span>
<span class="lineNum">    3852 </span><span class="lineCov">        433 :                 rs = ( chunk-&gt;rnext ) ? rsp-&gt;next : rsp-&gt;prev;</span>
<span class="lineNum">    3853 </span><span class="lineCov">        433 :                 if ( rs == NULL )</span>
<span class="lineNum">    3854 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3855 </span><span class="lineCov">        433 :                 rsp = ( chunk-&gt;rnext ) ? rs-&gt;to : rs-&gt;from;</span>
<span class="lineNum">    3856 </span><span class="lineCov">        433 :                 rpd = &amp;gd-&gt;points[rsp-&gt;ptindex];</span>
<span class="lineNum">    3857 </span><span class="lineCov">        433 :                 runit = ( chunk-&gt;rnext ) ? &amp;rpd-&gt;prevunit : &amp;rpd-&gt;nextunit;</span>
<span class="lineNum">    3858 </span><span class="lineCov">       1291 :             } while ( rpd != chunk-&gt;r &amp;&amp; rpd != chunk-&gt;l &amp;&amp;</span>
<span class="lineNum">    3859 </span><span class="lineCov">        858 :                 UnitsParallel( runit,sunit,false ));</span>
<span class="lineNum">    3860 </span>            :             
<span class="lineNum">    3861 </span><span class="lineCov">        854 :             if ( lstems != NULL &amp;&amp; rstems !=NULL ) {</span>
<span class="lineNum">    3862 </span><span class="lineCov">        228 :                 for ( j=0; j&lt;ls_cnt &amp;&amp; !stem-&gt;toobig; j++ ) {</span>
<span class="lineNum">    3863 </span><span class="lineCov">        272 :                     for ( k=0; k&lt;rs_cnt &amp;&amp; !stem-&gt;toobig; k++ ) {</span>
<span class="lineNum">    3864 </span><span class="lineCov">        157 :                         if ( lstems[j] == rstems[k] &amp;&amp; IsUnitHV( &amp;lstems[j]-&gt;unit,true )) {</span>
<span class="lineNum">    3865 </span><span class="lineCov">         56 :                             stem-&gt;toobig = true;</span>
<span class="lineNum">    3866 </span>            :                         }
<span class="lineNum">    3867 </span>            :                     }
<span class="lineNum">    3868 </span>            :                 }
<span class="lineNum">    3869 </span>            :             }
<span class="lineNum">    3870 </span>            :         }
<span class="lineNum">    3871 </span>            : 
<span class="lineNum">    3872 </span>            :         /* One more check for intersections between a curved segment and a */
<span class="lineNum">    3873 </span>            :         /* straight feature. Imagine a curve intersected by two bars, like in a Euro */
<span class="lineNum">    3874 </span>            :         /* glyph. Very probably we will get two chunks, one controlling the uppest   */
<span class="lineNum">    3875 </span>            :         /* two points of intersection, and another the lowest two, and most probably */
<span class="lineNum">    3876 </span>            :         /* these two chunks will get merged into a single stem (so this stem will    */
<span class="lineNum">    3877 </span>            :         /* even get an exactly vertical vector). Yet we don't need this stem because */
<span class="lineNum">    3878 </span>            :         /* there is already a stem controlling the middle of the curve (between two  */
<span class="lineNum">    3879 </span>            :         /* bars).*/
<span class="lineNum">    3880 </span><span class="lineCov">      10198 :         else if ( stem-&gt;chunk_cnt == 2 &amp;&amp; </span>
<span class="lineNum">    3881 </span><span class="lineCov">       6022 :             (( stem-&gt;chunks[0].stub &amp; 7 &amp;&amp; stem-&gt;chunks[1].stub &amp; 6 ) ||</span>
<span class="lineNum">    3882 </span><span class="lineCov">       2560 :              ( stem-&gt;chunks[0].stub &amp; 6 &amp;&amp; stem-&gt;chunks[1].stub &amp; 7 ))) {</span>
<span class="lineNum">    3883 </span><span class="lineCov">       1083 :             for ( j=0; j&lt;gd-&gt;stemcnt; ++j) {</span>
<span class="lineNum">    3884 </span><span class="lineCov">        948 :                 stem1 = &amp;gd-&gt;stems[j];</span>
<span class="lineNum">    3885 </span><span class="lineCov">        948 :                 if ( !stem1-&gt;toobig &amp;&amp; StemsWouldConflict( stem,stem1 ))</span>
<span class="lineNum">    3886 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3887 </span>            :             }
<span class="lineNum">    3888 </span>            : 
<span class="lineNum">    3889 </span><span class="lineCov">        135 :             if ( j &lt; gd-&gt;stemcnt )</span>
<span class="lineNum">    3890 </span><span class="lineNoCov">          0 :                 stem-&gt;toobig = true;</span>
<span class="lineNum">    3891 </span>            :         }
<span class="lineNum">    3892 </span>            :     }
<span class="lineNum">    3893 </span>            : 
<span class="lineNum">    3894 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    3895 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3896 </span><span class="lineCov">      10651 :         if ( IsUnitHV( &amp;stem-&gt;unit,true ))</span>
<span class="lineNum">    3897 </span><span class="lineCov">       7962 :     continue;</span>
<span class="lineNum">    3898 </span>            : 
<span class="lineNum">    3899 </span>            :         /* If a diagonal stem doesn't have at least 2 points assigned to   */
<span class="lineNum">    3900 </span>            :         /* each edge, then we probably can't instruct it. However we don't */
<span class="lineNum">    3901 </span>            :         /* disable stems which have just one point on each side, if those  */
<span class="lineNum">    3902 </span>            :         /* points are inflection points, as such stems may be useful for   */
<span class="lineNum">    3903 </span>            :         /* metafont routines */
<span class="lineNum">    3904 </span><span class="lineCov">       2689 :         if ( stem-&gt;lpcnt &lt; 2 || stem-&gt;rpcnt &lt; 2 ) {</span>
<span class="lineNum">    3905 </span><span class="lineCov">       2124 :             lpd = rpd = NULL;</span>
<span class="lineNum">    3906 </span><span class="lineCov">       4248 :             for ( j=0; j&lt;stem-&gt;chunk_cnt &amp;&amp; lpd == NULL &amp;&amp; rpd == NULL; j++ ) {</span>
<span class="lineNum">    3907 </span><span class="lineCov">       2124 :                 chunk = &amp;stem-&gt;chunks[j];</span>
<span class="lineNum">    3908 </span><span class="lineCov">       2124 :                 if ( chunk-&gt;l != NULL ) lpd = chunk-&gt;l;</span>
<span class="lineNum">    3909 </span><span class="lineCov">       2124 :                 if ( chunk-&gt;r != NULL ) rpd = chunk-&gt;r;</span>
<span class="lineNum">    3910 </span>            :             }
<span class="lineNum">    3911 </span><span class="lineCov">       6214 :             if (lpd == NULL || rpd == NULL ||</span>
<span class="lineNum">    3912 </span><span class="lineCov">       2134 :                 !IsInflectionPoint( gd,lpd ) || !IsInflectionPoint( gd,rpd ) || stem-&gt;clen &lt; stem-&gt;width )</span>
<span class="lineNum">    3913 </span><span class="lineCov">       2066 :                 stem-&gt;toobig = 2;</span>
<span class="lineNum">    3914 </span><span class="lineCov">        565 :         } else if ( stem-&gt;activecnt &gt;= stem-&gt;chunk_cnt )</span>
<span class="lineNum">    3915 </span><span class="lineCov">         19 :             stem-&gt;toobig = 2;</span>
<span class="lineNum">    3916 </span>            :     }
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span>            :     /* When using preexisting stem data, occasionally we can get two slightly      */
<span class="lineNum">    3919 </span>            :     /* different stems (one predefined, another recently detected) with nearly     */
<span class="lineNum">    3920 </span>            :     /* parallel vectors, sharing some points at both sides. Attempting to instruct */
<span class="lineNum">    3921 </span>            :     /* them both would lead to very odd effects. So we must disable one */
<span class="lineNum">    3922 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    3923 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    3924 </span><span class="lineCov">      10651 :         if ( !stem-&gt;positioned || IsUnitHV( &amp;stem-&gt;unit,true ))</span>
<span class="lineNum">    3925 </span><span class="lineCov">      10439 :     continue;</span>
<span class="lineNum">    3926 </span>            :         
<span class="lineNum">    3927 </span><span class="lineCov">       1953 :         for ( j=0; j&lt;gd-&gt;stemcnt; ++j ) {</span>
<span class="lineNum">    3928 </span><span class="lineCov">       1741 :             tstem = &amp;gd-&gt;stems[j];</span>
<span class="lineNum">    3929 </span><span class="lineCov">       1741 :             if ( tstem == stem || tstem-&gt;toobig || !UnitsParallel( &amp;stem-&gt;unit,&amp;tstem-&gt;unit,false ))</span>
<span class="lineNum">    3930 </span><span class="lineCov">       1619 :         continue;</span>
<span class="lineNum">    3931 </span>            :             
<span class="lineNum">    3932 </span><span class="lineCov">        122 :             ltick = false; rtick = false;</span>
<span class="lineNum">    3933 </span><span class="lineCov">        564 :             for ( k=0; k&lt;stem-&gt;chunk_cnt &amp;&amp; ( !ltick || !rtick ); k++ ) {</span>
<span class="lineNum">    3934 </span><span class="lineCov">        442 :                 chunk =  &amp;stem-&gt;chunks[k];</span>
<span class="lineNum">    3935 </span>            :                 
<span class="lineNum">    3936 </span><span class="lineCov">        874 :                 if ( chunk-&gt;l != NULL &amp;&amp;</span>
<span class="lineNum">    3937 </span><span class="lineCov">        864 :                     IsStemAssignedToPoint( chunk-&gt;l,stem ,chunk-&gt;lnext ) != -1 &amp;&amp;</span>
<span class="lineNum">    3938 </span><span class="lineCov">        432 :                     IsStemAssignedToPoint( chunk-&gt;l,tstem,chunk-&gt;lnext ) != -1 )</span>
<span class="lineNum">    3939 </span><span class="lineCov">          9 :                     ltick = true;</span>
<span class="lineNum">    3940 </span><span class="lineCov">        865 :                 if ( chunk-&gt;r != NULL &amp;&amp;</span>
<span class="lineNum">    3941 </span><span class="lineCov">        846 :                     IsStemAssignedToPoint( chunk-&gt;r,stem ,chunk-&gt;rnext ) != -1 &amp;&amp;</span>
<span class="lineNum">    3942 </span><span class="lineCov">        423 :                     IsStemAssignedToPoint( chunk-&gt;r,tstem,chunk-&gt;rnext ) != -1 )</span>
<span class="lineNum">    3943 </span><span class="lineCov">          8 :                     rtick = true;</span>
<span class="lineNum">    3944 </span>            :             }
<span class="lineNum">    3945 </span><span class="lineCov">        122 :             if ( ltick &amp;&amp; rtick ) tstem-&gt;toobig = 2;</span>
<span class="lineNum">    3946 </span>            :         }
<span class="lineNum">    3947 </span>            :     }
<a name="3948"><span class="lineNum">    3948 </span><span class="lineCov">       1644 : }</span></a>
<span class="lineNum">    3949 </span>            : 
<span class="lineNum">    3950 </span><span class="lineCov">       8808 : static int StemPointOnDiag( struct glyphdata *gd,struct stemdata *stem,</span>
<span class="lineNum">    3951 </span>            :     struct pointdata *pd ) {
<span class="lineNum">    3952 </span>            :     
<span class="lineNum">    3953 </span>            :     struct stemdata *tstem;
<span class="lineNum">    3954 </span>            :     int i, is_next, stemcnt;
<span class="lineNum">    3955 </span>            :     
<span class="lineNum">    3956 </span><span class="lineCov">       8808 :     if ( gd-&gt;only_hv || pd-&gt;colinear )</span>
<span class="lineNum">    3957 </span><span class="lineCov">       4476 : return( false );</span>
<span class="lineNum">    3958 </span>            :     
<span class="lineNum">    3959 </span><span class="lineCov">       4332 :     is_next = IsStemAssignedToPoint( pd,stem,false ) != -1;</span>
<span class="lineNum">    3960 </span><span class="lineCov">       4332 :     stemcnt = ( is_next ) ? pd-&gt;nextcnt : pd-&gt;prevcnt;</span>
<span class="lineNum">    3961 </span>            :     
<span class="lineNum">    3962 </span><span class="lineCov">       8983 :     for ( i=0; i&lt;stemcnt; i++ ) {</span>
<span class="lineNum">    3963 </span><span class="lineCov">       5017 :         tstem = ( is_next ) ? pd-&gt;nextstems[i] : pd-&gt;prevstems[i];</span>
<span class="lineNum">    3964 </span><span class="lineCov">       5493 :         if ( !IsUnitHV( &amp;tstem-&gt;unit,true ) &amp;&amp;</span>
<span class="lineNum">    3965 </span><span class="lineCov">        870 :             tstem-&gt;lpcnt &gt;= 2 &amp;&amp; tstem-&gt;rpcnt &gt;=2 )</span>
<span class="lineNum">    3966 </span><span class="lineCov">        366 : return( true );</span>
<span class="lineNum">    3967 </span>            :     }
<span class="lineNum">    3968 </span><span class="lineCov">       3966 : return( false );</span>
<a name="3969"><span class="lineNum">    3969 </span>            : }</a>
<span class="lineNum">    3970 </span>            : 
<span class="lineNum">    3971 </span><span class="lineCov">       3104 : static void FindRefPointsExisting( struct glyphdata *gd,struct stemdata *stem ) {</span>
<span class="lineNum">    3972 </span>            :     int i;
<span class="lineNum">    3973 </span>            :     int pos, lbase, rbase, is_x;
<span class="lineNum">    3974 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    3975 </span>            :     struct pointdata *pd;
<span class="lineNum">    3976 </span>            : 
<span class="lineNum">    3977 </span><span class="lineCov">       3104 :     is_x = (int) rint( stem-&gt;unit.y );</span>
<span class="lineNum">    3978 </span><span class="lineCov">       3104 :     lbase = ((real *) &amp;stem-&gt;left.x)[!is_x];</span>
<span class="lineNum">    3979 </span><span class="lineCov">       3104 :     rbase = ((real *) &amp;stem-&gt;right.x)[!is_x];</span>
<span class="lineNum">    3980 </span>            : 
<span class="lineNum">    3981 </span><span class="lineCov">       9604 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    3982 </span><span class="lineCov">       6500 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    3983 </span>            : 
<span class="lineNum">    3984 </span><span class="lineCov">       6500 :         if ( chunk-&gt;ltick ) {</span>
<span class="lineNum">    3985 </span><span class="lineCov">       4821 :             pd = chunk-&gt;l;</span>
<span class="lineNum">    3986 </span><span class="lineCov">       4821 :             pos = ((real *) &amp;pd-&gt;sp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    3987 </span><span class="lineCov">       4821 :             if ( pos == lbase ) {</span>
<span class="lineNum">    3988 </span><span class="lineCov">       4359 :                 pd-&gt;value++;</span>
<span class="lineNum">    3989 </span><span class="lineCov">       4359 :                 if ( pd-&gt;sp-&gt;ptindex &lt; gd-&gt;realcnt )</span>
<span class="lineNum">    3990 </span><span class="lineCov">       4151 :                     pd-&gt;value++;</span>
<span class="lineNum">    3991 </span><span class="lineCov">       4359 :                 if ( StemPointOnDiag( gd,stem,pd ))</span>
<span class="lineNum">    3992 </span><span class="lineCov">        201 :                     pd-&gt;value++;</span>
<span class="lineNum">    3993 </span>            :             }
<span class="lineNum">    3994 </span>            :         }
<span class="lineNum">    3995 </span>            : 
<span class="lineNum">    3996 </span><span class="lineCov">       6500 :         if ( chunk-&gt;rtick ) {</span>
<span class="lineNum">    3997 </span><span class="lineCov">       4942 :             pd = chunk-&gt;r;</span>
<span class="lineNum">    3998 </span><span class="lineCov">       4942 :             pos = ((real *) &amp;pd-&gt;sp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    3999 </span><span class="lineCov">       4942 :             if ( pos == rbase ) {</span>
<span class="lineNum">    4000 </span><span class="lineCov">       4449 :                 pd-&gt;value++;</span>
<span class="lineNum">    4001 </span><span class="lineCov">       4449 :                 if ( pd-&gt;sp-&gt;ptindex &lt; gd-&gt;realcnt )</span>
<span class="lineNum">    4002 </span><span class="lineCov">       4294 :                     pd-&gt;value++;</span>
<span class="lineNum">    4003 </span><span class="lineCov">       4449 :                 if ( StemPointOnDiag( gd,stem,pd ))</span>
<span class="lineNum">    4004 </span><span class="lineCov">        165 :                     pd-&gt;value++;</span>
<span class="lineNum">    4005 </span>            :             }
<span class="lineNum">    4006 </span>            :         }
<span class="lineNum">    4007 </span>            :     }
<a name="4008"><span class="lineNum">    4008 </span><span class="lineCov">       3104 : }</span></a>
<span class="lineNum">    4009 </span>            : 
<span class="lineNum">    4010 </span><span class="lineCov">       6389 : static void FindRefPointsNew( struct glyphdata *gd,struct stemdata *stem ) {</span>
<span class="lineNum">    4011 </span>            :     int i, j;
<span class="lineNum">    4012 </span>            :     int pos, lpos, rpos, testpos, is_x;
<span class="lineNum">    4013 </span>            :     int lval, rval;
<span class="lineNum">    4014 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    4015 </span>            :     struct pointdata *lmost1, *lmost2, *rmost1, *rmost2;
<span class="lineNum">    4016 </span>            :     double llen, prevllen, rlen, prevrlen;
<span class="lineNum">    4017 </span>            :     SplinePoint *sp, *tsp;
<span class="lineNum">    4018 </span>            :     uint8 *lextr, *rextr;
<span class="lineNum">    4019 </span>            : 
<span class="lineNum">    4020 </span><span class="lineCov">       6389 :     is_x = (int) rint( stem-&gt;unit.y );</span>
<span class="lineNum">    4021 </span><span class="lineCov">       6389 :     lpos = ((real *) &amp;stem-&gt;left.x)[!is_x];</span>
<span class="lineNum">    4022 </span><span class="lineCov">       6389 :     rpos = ((real *) &amp;stem-&gt;right.x)[!is_x];</span>
<span class="lineNum">    4023 </span>            : 
<span class="lineNum">    4024 </span><span class="lineCov">       6389 :     lmost1 = rmost1 = lmost2 = rmost2 = NULL;</span>
<span class="lineNum">    4025 </span><span class="lineCov">       6389 :     llen = prevllen = rlen = prevrlen = 0;</span>
<span class="lineNum">    4026 </span><span class="lineCov">      22158 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4027 </span><span class="lineCov">      15769 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4028 </span>            : 
<span class="lineNum">    4029 </span><span class="lineCov">      15769 :         if ( chunk-&gt;ltick ) {</span>
<span class="lineNum">    4030 </span><span class="lineCov">      12296 :             sp = chunk-&gt;l-&gt;sp;</span>
<span class="lineNum">    4031 </span><span class="lineCov">      12296 :             pos = ((real *) &amp;sp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    4032 </span><span class="lineCov">      12296 :             lval = 0;</span>
<span class="lineNum">    4033 </span><span class="lineCov">      26243 :             for ( j=0; j&lt;i; j++ ) if ( stem-&gt;chunks[j].ltick ) {</span>
<span class="lineNum">    4034 </span><span class="lineCov">      10520 :                 tsp = stem-&gt;chunks[j].l-&gt;sp;</span>
<span class="lineNum">    4035 </span><span class="lineCov">      10520 :                 testpos = ((real *) &amp;tsp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    4036 </span><span class="lineCov">      10520 :                 if ( pos == testpos ) {</span>
<span class="lineNum">    4037 </span><span class="lineCov">       9527 :                     lval = stem-&gt;chunks[j].l-&gt;value;</span>
<span class="lineNum">    4038 </span><span class="lineCov">       9527 :                     stem-&gt;chunks[j].l-&gt;value++;</span>
<span class="lineNum">    4039 </span>            :                     /* An additional bonus for points which form together */
<span class="lineNum">    4040 </span>            :                     /* a longer stem segment */
<span class="lineNum">    4041 </span><span class="lineCov">       9527 :                     if ( sp-&gt;next-&gt;to == tsp || sp-&gt;prev-&gt;from == tsp ) {</span>
<span class="lineNum">    4042 </span><span class="lineCov">       9312 :                         llen = fabs(( sp-&gt;me.x - tsp-&gt;me.x )*stem-&gt;unit.x +</span>
<span class="lineNum">    4043 </span><span class="lineCov">       4656 :                                     ( sp-&gt;me.y - tsp-&gt;me.y )*stem-&gt;unit.y );</span>
<span class="lineNum">    4044 </span><span class="lineCov">       4656 :                         if ( llen &gt; prevllen ) {</span>
<span class="lineNum">    4045 </span><span class="lineCov">       3929 :                             lmost1 = stem-&gt;chunks[j].l;</span>
<span class="lineNum">    4046 </span><span class="lineCov">       3929 :                             lmost2 = chunk-&gt;l;</span>
<span class="lineNum">    4047 </span><span class="lineCov">       3929 :                             prevllen = llen;</span>
<span class="lineNum">    4048 </span>            :                         }
<span class="lineNum">    4049 </span>            :                     }
<span class="lineNum">    4050 </span>            :                 }
<span class="lineNum">    4051 </span>            :             }
<span class="lineNum">    4052 </span><span class="lineCov">      12296 :             chunk-&gt;l-&gt;value = lval+1;</span>
<span class="lineNum">    4053 </span>            : 
<span class="lineNum">    4054 </span><span class="lineCov">      18767 :             if ( lval == 0 &amp;&amp;</span>
<span class="lineNum">    4055 </span><span class="lineCov">      12805 :                 ( stem-&gt;lmin - ( pos - lpos ) &gt; -dist_error_hv ) &amp;&amp;</span>
<span class="lineNum">    4056 </span><span class="lineCov">       6334 :                 ( stem-&gt;lmax - ( pos - lpos ) &lt; dist_error_hv ))</span>
<span class="lineNum">    4057 </span><span class="lineCov">       6138 :                 chunk-&gt;l-&gt;value++;</span>
<span class="lineNum">    4058 </span>            :         }
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span><span class="lineCov">      15769 :         if ( chunk-&gt;rtick ) {</span>
<span class="lineNum">    4061 </span><span class="lineCov">      12555 :             sp = chunk-&gt;r-&gt;sp;</span>
<span class="lineNum">    4062 </span><span class="lineCov">      12555 :             pos = ((real *) &amp;sp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    4063 </span><span class="lineCov">      12555 :             rval = 0;</span>
<span class="lineNum">    4064 </span><span class="lineCov">      26837 :             for ( j=0; j&lt;i; j++ ) if ( stem-&gt;chunks[j].rtick ) {</span>
<span class="lineNum">    4065 </span><span class="lineCov">      11531 :                 tsp = stem-&gt;chunks[j].r-&gt;sp;</span>
<span class="lineNum">    4066 </span><span class="lineCov">      11531 :                 testpos = ((real *) &amp;tsp-&gt;me.x)[!is_x];</span>
<span class="lineNum">    4067 </span><span class="lineCov">      11531 :                 if ( pos == testpos ) {</span>
<span class="lineNum">    4068 </span><span class="lineCov">      10127 :                     rval = stem-&gt;chunks[j].r-&gt;value;</span>
<span class="lineNum">    4069 </span><span class="lineCov">      10127 :                     stem-&gt;chunks[j].r-&gt;value++;</span>
<span class="lineNum">    4070 </span><span class="lineCov">      10127 :                     if ( sp-&gt;next-&gt;to == tsp || sp-&gt;prev-&gt;from == tsp ) {</span>
<span class="lineNum">    4071 </span><span class="lineCov">       9710 :                         rlen = fabs(( sp-&gt;me.x - tsp-&gt;me.x )*stem-&gt;unit.x +</span>
<span class="lineNum">    4072 </span><span class="lineCov">       4855 :                                     ( sp-&gt;me.y - tsp-&gt;me.y )*stem-&gt;unit.y );</span>
<span class="lineNum">    4073 </span><span class="lineCov">       4855 :                         if ( rlen &gt; prevrlen ) {</span>
<span class="lineNum">    4074 </span><span class="lineCov">       4055 :                             rmost1 = stem-&gt;chunks[j].r;</span>
<span class="lineNum">    4075 </span><span class="lineCov">       4055 :                             rmost2 = chunk-&gt;r;</span>
<span class="lineNum">    4076 </span><span class="lineCov">       4055 :                             prevrlen = rlen;</span>
<span class="lineNum">    4077 </span>            :                         }
<span class="lineNum">    4078 </span>            :                     }
<span class="lineNum">    4079 </span>            :                 }
<span class="lineNum">    4080 </span>            :             }
<span class="lineNum">    4081 </span><span class="lineCov">      12555 :             chunk-&gt;r-&gt;value = rval+1;</span>
<span class="lineNum">    4082 </span>            : 
<span class="lineNum">    4083 </span><span class="lineCov">      19014 :             if ( rval == 0 &amp;&amp;</span>
<span class="lineNum">    4084 </span><span class="lineCov">      12793 :                 ( stem-&gt;rmin - ( pos - rpos ) &gt; -dist_error_hv ) &amp;&amp;</span>
<span class="lineNum">    4085 </span><span class="lineCov">       6334 :                 ( stem-&gt;rmax - ( pos - rpos ) &lt; dist_error_hv ))</span>
<span class="lineNum">    4086 </span><span class="lineCov">       6201 :                 chunk-&gt;r-&gt;value++;</span>
<span class="lineNum">    4087 </span>            :         }
<span class="lineNum">    4088 </span>            :     }
<span class="lineNum">    4089 </span><span class="lineCov">       6389 :     if ( lmost1 != NULL &amp;&amp; lmost2 != NULL ) {</span>
<span class="lineNum">    4090 </span><span class="lineCov">       3649 :         lmost1-&gt;value++; lmost2-&gt;value++;</span>
<span class="lineNum">    4091 </span>            :     }
<span class="lineNum">    4092 </span><span class="lineCov">       6389 :     if ( rmost1 != NULL &amp;&amp; rmost2 != NULL ) {</span>
<span class="lineNum">    4093 </span><span class="lineCov">       3736 :         rmost1-&gt;value++; rmost2-&gt;value++;</span>
<span class="lineNum">    4094 </span>            :     }
<span class="lineNum">    4095 </span>            :     
<span class="lineNum">    4096 </span>            :     /* Extrema points get an additional value bonus. This should     */
<span class="lineNum">    4097 </span>            :     /* prevent us from preferring wrong points for stems controlling */
<span class="lineNum">    4098 </span>            :     /* curved segments */
<span class="lineNum">    4099 </span>            :     /* Third pass to assign bonuses to extrema points (especially    */
<span class="lineNum">    4100 </span>            :     /* to those extrema which are opposed to another extremum point) */
<span class="lineNum">    4101 </span><span class="lineCov">      22158 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4102 </span><span class="lineCov">      15769 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4103 </span><span class="lineCov">      15769 :         if ( chunk-&gt;ltick ) {</span>
<span class="lineNum">    4104 </span><span class="lineCov">      12296 :             lextr = ( is_x ) ? &amp;chunk-&gt;l-&gt;x_extr : &amp;chunk-&gt;l-&gt;y_extr;</span>
<span class="lineNum">    4105 </span><span class="lineCov">      12296 :             if ( *lextr ) chunk-&gt;l-&gt;value++;</span>
<span class="lineNum">    4106 </span>            :         }
<span class="lineNum">    4107 </span><span class="lineCov">      15769 :         if ( chunk-&gt;rtick ) {</span>
<span class="lineNum">    4108 </span><span class="lineCov">      12555 :             rextr = ( is_x ) ? &amp;chunk-&gt;r-&gt;x_extr : &amp;chunk-&gt;r-&gt;y_extr;</span>
<span class="lineNum">    4109 </span><span class="lineCov">      12555 :             if ( *rextr ) chunk-&gt;r-&gt;value++;</span>
<span class="lineNum">    4110 </span>            :         }
<span class="lineNum">    4111 </span>            : 
<span class="lineNum">    4112 </span><span class="lineCov">      15769 :         if ( chunk-&gt;ltick &amp;&amp; chunk-&gt;rtick ) {</span>
<span class="lineNum">    4113 </span><span class="lineCov">       9096 :             lextr = ( is_x ) ? &amp;chunk-&gt;l-&gt;x_extr : &amp;chunk-&gt;l-&gt;y_extr;</span>
<span class="lineNum">    4114 </span><span class="lineCov">       9096 :             rextr = ( is_x ) ? &amp;chunk-&gt;r-&gt;x_extr : &amp;chunk-&gt;r-&gt;y_extr;</span>
<span class="lineNum">    4115 </span><span class="lineCov">       9096 :             if ( *lextr &amp;&amp; *rextr ) {</span>
<span class="lineNum">    4116 </span><span class="lineCov">       1297 :                 chunk-&gt;l-&gt;value++;</span>
<span class="lineNum">    4117 </span><span class="lineCov">       1297 :                 chunk-&gt;r-&gt;value++;</span>
<span class="lineNum">    4118 </span>            :             }
<span class="lineNum">    4119 </span>            :         }
<span class="lineNum">    4120 </span>            :     }
<a name="4121"><span class="lineNum">    4121 </span><span class="lineCov">       6389 : }</span></a>
<span class="lineNum">    4122 </span>            : 
<span class="lineNum">    4123 </span><span class="lineCov">      12334 : static void NormalizeStem( struct glyphdata *gd,struct stemdata *stem ) {</span>
<span class="lineNum">    4124 </span>            :     int i;
<span class="lineNum">    4125 </span>            :     int is_x, lval, rval, val, lset, rset, best;
<span class="lineNum">    4126 </span><span class="lineCov">      12334 :     double loff=0, roff=0;</span>
<span class="lineNum">    4127 </span>            :     BasePoint lold, rold;
<span class="lineNum">    4128 </span>            :     SplinePoint *lbest, *rbest;
<span class="lineNum">    4129 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    4130 </span>            :     
<span class="lineNum">    4131 </span>            :     /* First sort the stem chunks by their coordinates */
<span class="lineNum">    4132 </span><span class="lineCov">      12334 :     if ( IsUnitHV( &amp;stem-&gt;unit,true )) {</span>
<span class="lineNum">    4133 </span><span class="lineCov">       9493 :         qsort( stem-&gt;chunks,stem-&gt;chunk_cnt,sizeof( struct stem_chunk ),chunk_cmp );</span>
<span class="lineNum">    4134 </span><span class="lineCov">       9493 :         is_x = (int) rint( stem-&gt;unit.y );</span>
<span class="lineNum">    4135 </span>            : 
<span class="lineNum">    4136 </span>            :         /* For HV stems we have to check all chunks once more in order */
<span class="lineNum">    4137 </span>            :         /* to figure out &quot;left&quot; and &quot;right&quot; positions most typical */
<span class="lineNum">    4138 </span>            :         /* for this stem. We perform this by assigning a value to */
<span class="lineNum">    4139 </span>            :         /* left and right side of this chunk. */
<span class="lineNum">    4140 </span>            : 
<span class="lineNum">    4141 </span>            :         /* First pass to determine some point properties necessary */
<span class="lineNum">    4142 </span>            :         /* for subsequent operations */
<span class="lineNum">    4143 </span><span class="lineCov">      31762 :         for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4144 </span><span class="lineCov">      22269 :             chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4145 </span><span class="lineCov">      22269 :             if ( chunk-&gt;ltick )</span>
<span class="lineNum">    4146 </span>            :                 /* reset the point's &quot;value&quot; to zero */
<span class="lineNum">    4147 </span><span class="lineCov">      17117 :                 chunk-&gt;l-&gt;value = 0;</span>
<span class="lineNum">    4148 </span><span class="lineCov">      22269 :             if ( chunk-&gt;rtick )</span>
<span class="lineNum">    4149 </span><span class="lineCov">      17497 :                 chunk-&gt;r-&gt;value = 0;</span>
<span class="lineNum">    4150 </span>            :         }
<span class="lineNum">    4151 </span>            : 
<span class="lineNum">    4152 </span>            :         /* Second pass to check which positions relative to stem edges are */
<span class="lineNum">    4153 </span>            :         /* most common for this stem. Each position which repeats */
<span class="lineNum">    4154 </span>            :         /* more than once gets a plus 1 value bonus */
<span class="lineNum">    4155 </span><span class="lineCov">       9493 :         if ( stem-&gt;positioned ) FindRefPointsExisting( gd,stem );</span>
<span class="lineNum">    4156 </span><span class="lineCov">       6389 :         else FindRefPointsNew( gd,stem );</span>
<span class="lineNum">    4157 </span>            : 
<span class="lineNum">    4158 </span><span class="lineCov">       9493 :         best = -1; val = 0;</span>
<span class="lineNum">    4159 </span><span class="lineCov">      31762 :         for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4160 </span><span class="lineCov">      22269 :             chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4161 </span><span class="lineCov">      22269 :             lval = ( chunk-&gt;l != NULL ) ? chunk-&gt;l-&gt;value : 0;</span>
<span class="lineNum">    4162 </span><span class="lineCov">      22269 :             rval = ( chunk-&gt;r != NULL ) ? chunk-&gt;r-&gt;value : 0;</span>
<span class="lineNum">    4163 </span><span class="lineCov">      40311 :             if ((( chunk-&gt;l != NULL &amp;&amp; chunk-&gt;l-&gt;value &gt; 0 &amp;&amp; </span>
<span class="lineNum">    4164 </span><span class="lineCov">      22386 :                 GetValidPointDataIndex( gd,chunk-&gt;l-&gt;sp,stem ) != -1 ) ||</span>
<span class="lineNum">    4165 </span><span class="lineCov">      24953 :                 ( stem-&gt;ghost &amp;&amp; stem-&gt;width == 21 )) &amp;&amp; </span>
<span class="lineNum">    4166 </span><span class="lineCov">      50533 :                 (( chunk-&gt;r != NULL &amp;&amp; chunk-&gt;r-&gt;value &gt; 0 &amp;&amp;</span>
<span class="lineNum">    4167 </span><span class="lineCov">      19271 :                 GetValidPointDataIndex( gd,chunk-&gt;r-&gt;sp,stem ) != -1 ) ||</span>
<span class="lineNum">    4168 </span><span class="lineCov">       5144 :                 ( stem-&gt;ghost &amp;&amp; stem-&gt;width == 20 )) &amp;&amp; lval + rval &gt; val ) {</span>
<span class="lineNum">    4169 </span>            :                 
<span class="lineNum">    4170 </span><span class="lineCov">       9299 :                 best = i;</span>
<span class="lineNum">    4171 </span><span class="lineCov">       9299 :                 val = lval + rval;</span>
<span class="lineNum">    4172 </span>            :             }
<span class="lineNum">    4173 </span>            :         }
<span class="lineNum">    4174 </span><span class="lineCov">       9493 :         if ( best &gt; -1 ) {</span>
<span class="lineNum">    4175 </span><span class="lineCov">       8813 :             if ( !stem-&gt;ghost || stem-&gt;width == 20 ) {</span>
<span class="lineNum">    4176 </span><span class="lineCov">       8323 :                 lold = stem-&gt;left;</span>
<span class="lineNum">    4177 </span><span class="lineCov">       8323 :                 lbest = stem-&gt;chunks[best].l-&gt;sp;</span>
<span class="lineNum">    4178 </span><span class="lineCov">       8323 :                 stem-&gt;left = lbest-&gt;me;</span>
<span class="lineNum">    4179 </span><span class="lineCov">       8323 :                 stem-&gt;leftidx = GetValidPointDataIndex( gd,lbest,stem );</span>
<span class="lineNum">    4180 </span>            : 
<span class="lineNum">    4181 </span>            :                 /* Now assign &quot;left&quot; and &quot;right&quot; properties of the stem     */
<span class="lineNum">    4182 </span>            :                 /* to point coordinates taken from the most &quot;typical&quot; chunk */
<span class="lineNum">    4183 </span>            :                 /* of this stem. We also have to recalculate stem width and */
<span class="lineNum">    4184 </span>            :                 /* left/right offset values */
<span class="lineNum">    4185 </span><span class="lineCov">      16646 :                 loff = ( stem-&gt;left.x - lold.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    4186 </span><span class="lineCov">       8323 :                        ( stem-&gt;left.y - lold.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    4187 </span><span class="lineCov">       8323 :                 stem-&gt;lmin -= loff; stem-&gt;lmax -= loff;</span>
<span class="lineNum">    4188 </span>            :             }
<span class="lineNum">    4189 </span><span class="lineCov">       8813 :             if ( !stem-&gt;ghost || stem-&gt;width == 21 ) {</span>
<span class="lineNum">    4190 </span><span class="lineCov">       8340 :                 rold = stem-&gt;right;</span>
<span class="lineNum">    4191 </span><span class="lineCov">       8340 :                 rbest = stem-&gt;chunks[best].r-&gt;sp;</span>
<span class="lineNum">    4192 </span><span class="lineCov">       8340 :                 stem-&gt;right = rbest-&gt;me;</span>
<span class="lineNum">    4193 </span><span class="lineCov">       8340 :                 stem-&gt;rightidx = GetValidPointDataIndex( gd,rbest,stem );</span>
<span class="lineNum">    4194 </span><span class="lineCov">      16680 :                 roff = ( stem-&gt;right.x - rold.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    4195 </span><span class="lineCov">       8340 :                        ( stem-&gt;right.y - rold.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    4196 </span><span class="lineCov">       8340 :                 stem-&gt;rmin -= roff; stem-&gt;rmax -= roff;</span>
<span class="lineNum">    4197 </span>            :             }
<span class="lineNum">    4198 </span><span class="lineCov">       8813 :             if ( !stem-&gt;ghost )</span>
<span class="lineNum">    4199 </span><span class="lineCov">      15700 :                 stem-&gt;width = ( stem-&gt;right.x - stem-&gt;left.x ) * stem-&gt;unit.y -</span>
<span class="lineNum">    4200 </span><span class="lineCov">       7850 :                               ( stem-&gt;right.y - stem-&gt;left.y ) * stem-&gt;unit.x;</span>
<span class="lineNum">    4201 </span>            :         } else {
<span class="lineNum">    4202 </span><span class="lineCov">       1537 :             for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4203 </span><span class="lineCov">        857 :                 chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4204 </span><span class="lineCov">        857 :                 if ( chunk-&gt;l != NULL &amp;&amp; ( !stem-&gt;ghost || stem-&gt;width == 20 )) {</span>
<span class="lineNum">    4205 </span><span class="lineCov">        539 :                     stem-&gt;leftidx = GetValidPointDataIndex( gd,chunk-&gt;l-&gt;sp,stem );</span>
<span class="lineNum">    4206 </span>            :                 }
<span class="lineNum">    4207 </span><span class="lineCov">        857 :                 if ( chunk-&gt;r != NULL &amp;&amp; ( !stem-&gt;ghost || stem-&gt;width == 21 )) {</span>
<span class="lineNum">    4208 </span><span class="lineCov">        588 :                     stem-&gt;rightidx = GetValidPointDataIndex( gd,chunk-&gt;r-&gt;sp,stem );</span>
<span class="lineNum">    4209 </span>            :                 }
<span class="lineNum">    4210 </span>            :             }
<span class="lineNum">    4211 </span>            :         }
<span class="lineNum">    4212 </span>            :     } else {
<span class="lineNum">    4213 </span><span class="lineCov">       2841 :         qsort( stem-&gt;chunks,stem-&gt;chunk_cnt,sizeof( struct stem_chunk ),chunk_cmp );</span>
<span class="lineNum">    4214 </span><span class="lineCov">       2841 :         lset = false; rset = false;</span>
<span class="lineNum">    4215 </span>            :         /* Search for a pair of points whose vectors are really parallel. */
<span class="lineNum">    4216 </span>            :         /* This check is necessary because a diagonal stem can start from */
<span class="lineNum">    4217 </span>            :         /* a feature termination, and our checks for such terminations    */
<span class="lineNum">    4218 </span>            :         /* are more &quot;liberal&quot; than in other cases. However we don't want  */
<span class="lineNum">    4219 </span>            :         /* considering such a pair of points basic for this stem */
<span class="lineNum">    4220 </span><span class="lineCov">       3496 :         for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4221 </span><span class="lineCov">       3079 :             chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4222 </span>            :             BasePoint *lu, *ru;
<span class="lineNum">    4223 </span><span class="lineCov">       3079 :             if ( chunk-&gt;l != NULL &amp;&amp; chunk-&gt;r != NULL ) {</span>
<span class="lineNum">    4224 </span><span class="lineCov">       2812 :                 lu = chunk-&gt;lnext ? &amp;chunk-&gt;l-&gt;nextunit : &amp;chunk-&gt;l-&gt;prevunit;</span>
<span class="lineNum">    4225 </span><span class="lineCov">       2812 :                 ru = chunk-&gt;rnext ? &amp;chunk-&gt;r-&gt;nextunit : &amp;chunk-&gt;r-&gt;prevunit;</span>
<span class="lineNum">    4226 </span><span class="lineCov">       2812 :                 if ( UnitsParallel( lu,ru,true )) {</span>
<span class="lineNum">    4227 </span><span class="lineCov">       4848 :                     loff =  ( chunk-&gt;l-&gt;sp-&gt;me.x - stem-&gt;left.x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    4228 </span><span class="lineCov">       2424 :                             ( chunk-&gt;l-&gt;sp-&gt;me.y - stem-&gt;left.y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    4229 </span><span class="lineCov">       4848 :                     roff =  ( chunk-&gt;r-&gt;sp-&gt;me.x - stem-&gt;right.x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    4230 </span><span class="lineCov">       2424 :                             ( chunk-&gt;r-&gt;sp-&gt;me.y - stem-&gt;right.y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    4231 </span><span class="lineCov">       2424 :                     stem-&gt;left = chunk-&gt;l-&gt;sp-&gt;me;</span>
<span class="lineNum">    4232 </span><span class="lineCov">       2424 :                     stem-&gt;right = chunk-&gt;r-&gt;sp-&gt;me;</span>
<span class="lineNum">    4233 </span><span class="lineCov">       2424 :                     RecalcStemOffsets( stem,&amp;stem-&gt;unit,loff != 0,roff != 0 );</span>
<span class="lineNum">    4234 </span><span class="lineCov">       2424 :         break;</span>
<span class="lineNum">    4235 </span>            :                 }
<span class="lineNum">    4236 </span>            :             }
<span class="lineNum">    4237 </span>            :         }
<span class="lineNum">    4238 </span>            :         /* If the above check fails, just select the first point (relatively) */
<span class="lineNum">    4239 </span>            :         /* to the stem direction both at the left and the right edge */
<span class="lineNum">    4240 </span><span class="lineCov">       2972 :         if ( i == stem-&gt;chunk_cnt ) for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4241 </span><span class="lineCov">        456 :             chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    4242 </span><span class="lineCov">        456 :             if ( !lset &amp;&amp; chunk-&gt;l != NULL ) {</span>
<span class="lineNum">    4243 </span><span class="lineCov">        750 :                 loff =  ( chunk-&gt;l-&gt;sp-&gt;me.x - stem-&gt;left.x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    4244 </span><span class="lineCov">        375 :                         ( chunk-&gt;l-&gt;sp-&gt;me.y - stem-&gt;left.y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    4245 </span><span class="lineCov">        375 :                 stem-&gt;left = chunk-&gt;l-&gt;sp-&gt;me;</span>
<span class="lineNum">    4246 </span><span class="lineCov">        375 :                 lset = true;</span>
<span class="lineNum">    4247 </span>            :             }
<span class="lineNum">    4248 </span><span class="lineCov">        456 :             if ( !rset &amp;&amp; chunk-&gt;r != NULL ) {</span>
<span class="lineNum">    4249 </span><span class="lineCov">        734 :                 roff =  ( chunk-&gt;r-&gt;sp-&gt;me.x - stem-&gt;right.x )*stem-&gt;l_to_r.x +</span>
<span class="lineNum">    4250 </span><span class="lineCov">        367 :                         ( chunk-&gt;r-&gt;sp-&gt;me.y - stem-&gt;right.y )*stem-&gt;l_to_r.y;</span>
<span class="lineNum">    4251 </span><span class="lineCov">        367 :                 stem-&gt;right = chunk-&gt;r-&gt;sp-&gt;me;</span>
<span class="lineNum">    4252 </span><span class="lineCov">        367 :                 rset = true;</span>
<span class="lineNum">    4253 </span>            :             }
<span class="lineNum">    4254 </span><span class="lineCov">        456 :             if ( lset &amp;&amp; rset ) {</span>
<span class="lineNum">    4255 </span><span class="lineCov">        325 :                 RecalcStemOffsets( stem,&amp;stem-&gt;unit,loff != 0,roff != 0 );</span>
<span class="lineNum">    4256 </span><span class="lineCov">        325 :         break;</span>
<span class="lineNum">    4257 </span>            :             }
<span class="lineNum">    4258 </span>            :         }
<span class="lineNum">    4259 </span>            :     }
<a name="4260"><span class="lineNum">    4260 </span><span class="lineCov">      12334 : }</span></a>
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span><span class="lineCov">        434 : static void AssignPointsToBBoxHint( struct glyphdata *gd,DBounds *bounds,</span>
<span class="lineNum">    4263 </span>            :     struct stemdata *stem,int is_v ) {
<span class="lineNum">    4264 </span>            :     
<span class="lineNum">    4265 </span>            :     double min, max, test, left, right;
<span class="lineNum">    4266 </span>            :     double dist, prevdist;
<span class="lineNum">    4267 </span>            :     int i, j;
<span class="lineNum">    4268 </span><span class="lineCov">        434 :     int lcnt=0, rcnt=0, closest;</span>
<span class="lineNum">    4269 </span>            :     BasePoint dir;
<span class="lineNum">    4270 </span>            :     SplinePoint **lpoints, **rpoints;
<span class="lineNum">    4271 </span>            :     struct pointdata *pd, *pd1, *pd2;
<span class="lineNum">    4272 </span>            :     
<span class="lineNum">    4273 </span><span class="lineCov">        434 :     lpoints = calloc( gd-&gt;pcnt,sizeof( SplinePoint *));</span>
<span class="lineNum">    4274 </span><span class="lineCov">        434 :     rpoints = calloc( gd-&gt;pcnt,sizeof( SplinePoint *));</span>
<span class="lineNum">    4275 </span><span class="lineCov">        434 :     dir.x = !is_v; dir.y = is_v;</span>
<span class="lineNum">    4276 </span><span class="lineCov">       5626 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    4277 </span><span class="lineCov">       3315 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    4278 </span><span class="lineCov">       3315 :         min = ( is_v ) ? bounds-&gt;minx : bounds-&gt;miny;</span>
<span class="lineNum">    4279 </span><span class="lineCov">       3315 :         max = ( is_v ) ? bounds-&gt;maxx : bounds-&gt;maxy;</span>
<span class="lineNum">    4280 </span><span class="lineCov">       3315 :         test = ( is_v ) ? pd-&gt;base.x : pd-&gt;base.y;</span>
<span class="lineNum">    4281 </span><span class="lineCov">       4083 :         if ( test &gt;= min &amp;&amp; test &lt; min + dist_error_hv &amp;&amp; (</span>
<span class="lineNum">    4282 </span><span class="lineCov">       1138 :             IsCorrectSide( gd,pd,true,is_v,&amp;dir ) || IsCorrectSide( gd,pd,false,is_v,&amp;dir )))</span>
<span class="lineNum">    4283 </span><span class="lineCov">        546 :             lpoints[lcnt++] = pd-&gt;sp;</span>
<span class="lineNum">    4284 </span><span class="lineCov">       3568 :         else if ( test &gt; max - dist_error_hv &amp;&amp; test &lt;= max &amp;&amp; (</span>
<span class="lineNum">    4285 </span><span class="lineCov">       1173 :             IsCorrectSide( gd,pd,true,!is_v,&amp;dir ) || IsCorrectSide( gd,pd,false,!is_v,&amp;dir )))</span>
<span class="lineNum">    4286 </span><span class="lineCov">        585 :             rpoints[rcnt++] = pd-&gt;sp;</span>
<span class="lineNum">    4287 </span>            :     }
<span class="lineNum">    4288 </span><span class="lineCov">        434 :     if ( lcnt &gt; 0 &amp;&amp; rcnt &gt; 0 ) {</span>
<span class="lineNum">    4289 </span><span class="lineCov">        290 :         if ( stem == NULL ) {</span>
<span class="lineNum">    4290 </span><span class="lineCov">        107 :             stem = NewStem( gd,&amp;dir,&amp;lpoints[0]-&gt;me,&amp;rpoints[0]-&gt;me );</span>
<span class="lineNum">    4291 </span><span class="lineCov">        107 :             stem-&gt;bbox = true;</span>
<span class="lineNum">    4292 </span><span class="lineCov">        107 :             stem-&gt;len = stem-&gt;width;</span>
<span class="lineNum">    4293 </span><span class="lineCov">        107 :             stem-&gt;leftidx = GetValidPointDataIndex( gd,lpoints[0],stem );</span>
<span class="lineNum">    4294 </span><span class="lineCov">        107 :             stem-&gt;rightidx = GetValidPointDataIndex( gd,rpoints[0],stem );</span>
<span class="lineNum">    4295 </span>            :         }
<span class="lineNum">    4296 </span><span class="lineCov">        794 :         for ( i=0; i&lt;lcnt; ++i ) {</span>
<span class="lineNum">    4297 </span><span class="lineCov">        504 :             closest = -1;</span>
<span class="lineNum">    4298 </span><span class="lineCov">        504 :             dist = 1e4; prevdist = 1e4;</span>
<span class="lineNum">    4299 </span><span class="lineCov">       1656 :             for ( j=0; j&lt;rcnt; ++j ) {</span>
<span class="lineNum">    4300 </span><span class="lineCov">       1152 :                 left = ( is_v ) ? lpoints[i]-&gt;me.y : lpoints[i]-&gt;me.x;</span>
<span class="lineNum">    4301 </span><span class="lineCov">       1152 :                 right = ( is_v ) ? rpoints[j]-&gt;me.y : rpoints[j]-&gt;me.x;</span>
<span class="lineNum">    4302 </span><span class="lineCov">       1152 :                 dist = fabs( left - right );</span>
<span class="lineNum">    4303 </span><span class="lineCov">       1152 :                 if ( dist &lt; prevdist ) {</span>
<span class="lineNum">    4304 </span><span class="lineCov">        834 :                     closest = j;</span>
<span class="lineNum">    4305 </span><span class="lineCov">        834 :                     prevdist = dist;</span>
<span class="lineNum">    4306 </span>            :                 }
<span class="lineNum">    4307 </span>            :             }
<span class="lineNum">    4308 </span><span class="lineCov">        504 :             pd1 = &amp;gd-&gt;points[lpoints[i]-&gt;ptindex];</span>
<span class="lineNum">    4309 </span><span class="lineCov">        504 :             pd2 = &amp;gd-&gt;points[rpoints[closest]-&gt;ptindex];</span>
<span class="lineNum">    4310 </span><span class="lineCov">        504 :             AddToStem( gd,stem,pd1,pd2,false,true,4 );</span>
<span class="lineNum">    4311 </span>            :         }
<span class="lineNum">    4312 </span><span class="lineCov">        290 :         qsort( stem-&gt;chunks,stem-&gt;chunk_cnt,sizeof( struct stem_chunk ),chunk_cmp );</span>
<span class="lineNum">    4313 </span>            :     }
<span class="lineNum">    4314 </span><span class="lineCov">        434 :     free( lpoints );</span>
<span class="lineNum">    4315 </span><span class="lineCov">        434 :     free( rpoints );</span>
<a name="4316"><span class="lineNum">    4316 </span><span class="lineCov">        434 : }</span></a>
<span class="lineNum">    4317 </span>            : 
<span class="lineNum">    4318 </span><span class="lineCov">       1644 : static void CheckForBoundingBoxHints( struct glyphdata *gd ) {</span>
<span class="lineNum">    4319 </span>            :     /* Adobe seems to add hints at the bounding boxes of glyphs with no hints */
<span class="lineNum">    4320 </span>            :     int i, hv;
<span class="lineNum">    4321 </span><span class="lineCov">       1644 :     int hcnt=0, vcnt=0; </span>
<span class="lineNum">    4322 </span>            :     double cw, ch;
<span class="lineNum">    4323 </span><span class="lineCov">       1644 :     struct stemdata *stem, *hstem=NULL,*vstem=NULL;</span>
<span class="lineNum">    4324 </span>            :     DBounds bounds;
<span class="lineNum">    4325 </span>            :     
<span class="lineNum">    4326 </span><span class="lineCov">       1644 :     SplineCharFindBounds( gd-&gt;sc,&amp;bounds );</span>
<span class="lineNum">    4327 </span>            : 
<span class="lineNum">    4328 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    4329 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4330 </span><span class="lineCov">      10651 :         hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    4331 </span><span class="lineCov">      10651 :         if ( !hv )</span>
<span class="lineNum">    4332 </span><span class="lineCov">       2689 :     continue;</span>
<span class="lineNum">    4333 </span><span class="lineCov">       7962 :         if ( stem-&gt;toobig ) {</span>
<span class="lineNum">    4334 </span><span class="lineCov">       2532 :             if ( stem-&gt;left.x == bounds.minx &amp;&amp; stem-&gt;right.x == bounds.maxx )</span>
<span class="lineNum">    4335 </span><span class="lineCov">        393 :                 vstem = stem;</span>
<span class="lineNum">    4336 </span><span class="lineCov">       2139 :             else if ( stem-&gt;right.y == bounds.miny &amp;&amp; stem-&gt;left.y == bounds.maxy )</span>
<span class="lineNum">    4337 </span><span class="lineCov">        532 :                 hstem = stem;</span>
<span class="lineNum">    4338 </span><span class="lineCov">       2532 :     continue;</span>
<span class="lineNum">    4339 </span>            :         }
<span class="lineNum">    4340 </span><span class="lineCov">       5430 :         if ( hv == 1 ) {</span>
<span class="lineNum">    4341 </span><span class="lineCov">       2883 :             if ( stem-&gt;bbox ) hstem = stem;</span>
<span class="lineNum">    4342 </span><span class="lineCov">       2812 :             else ++hcnt;</span>
<span class="lineNum">    4343 </span><span class="lineCov">       2547 :         } else if ( hv == 2 ) {</span>
<span class="lineNum">    4344 </span><span class="lineCov">       2547 :             if ( stem-&gt;bbox ) vstem = stem;</span>
<span class="lineNum">    4345 </span><span class="lineCov">       2465 :             else ++vcnt;</span>
<span class="lineNum">    4346 </span>            :         }
<span class="lineNum">    4347 </span>            :     }
<span class="lineNum">    4348 </span><span class="lineCov">       1644 :     if ( hcnt!=0 &amp;&amp; vcnt!=0 &amp;&amp; </span>
<span class="lineNum">    4349 </span><span class="lineCov">        401 :         ( hstem == NULL || !hstem-&gt;positioned ) &amp;&amp; </span>
<span class="lineNum">    4350 </span><span class="lineCov">        257 :         ( vstem == NULL || !vstem-&gt;positioned ))</span>
<span class="lineNum">    4351 </span><span class="lineCov">       2657 : return;</span>
<span class="lineNum">    4352 </span>            : 
<span class="lineNum">    4353 </span><span class="lineCov">        631 :     ch = bounds.maxy - bounds.miny;</span>
<span class="lineNum">    4354 </span><span class="lineCov">        631 :     cw = bounds.maxx - bounds.minx;</span>
<span class="lineNum">    4355 </span>            :     
<span class="lineNum">    4356 </span><span class="lineCov">        631 :     if ( ch &gt; 0 &amp;&amp; (( hstem != NULL &amp;&amp; hstem-&gt;positioned ) || </span>
<span class="lineNum">    4357 </span><span class="lineCov">        338 :         ( hcnt == 0 &amp;&amp; ch &lt; gd-&gt;emsize/3 ))) {</span>
<span class="lineNum">    4358 </span><span class="lineCov">        177 :         if ( hstem != NULL &amp;&amp; hstem-&gt;toobig ) hstem-&gt;toobig = false;</span>
<span class="lineNum">    4359 </span><span class="lineCov">        177 :         AssignPointsToBBoxHint( gd,&amp;bounds,hstem,false );</span>
<span class="lineNum">    4360 </span><span class="lineCov">        177 :         if ( hstem != NULL ) NormalizeStem( gd,hstem );</span>
<span class="lineNum">    4361 </span>            :     }
<span class="lineNum">    4362 </span><span class="lineCov">        631 :     if ( cw &gt; 0 &amp;&amp; (( vstem != NULL &amp;&amp; vstem-&gt;positioned ) || </span>
<span class="lineNum">    4363 </span><span class="lineCov">        434 :         ( vcnt == 0 &amp;&amp; cw &lt; gd-&gt;emsize/3 ))) {</span>
<span class="lineNum">    4364 </span><span class="lineCov">        247 :         if ( vstem != NULL &amp;&amp; vstem-&gt;toobig ) vstem-&gt;toobig = false;</span>
<span class="lineNum">    4365 </span><span class="lineCov">        247 :         AssignPointsToBBoxHint( gd,&amp;bounds,vstem,true );</span>
<span class="lineNum">    4366 </span><span class="lineCov">        247 :         if ( vstem != NULL ) NormalizeStem( gd,vstem );</span>
<span class="lineNum">    4367 </span>            :     }
<a name="4368"><span class="lineNum">    4368 </span>            : }</a>
<span class="lineNum">    4369 </span>            : 
<span class="lineNum">    4370 </span><span class="lineCov">       1372 : static struct stemdata *FindOrMakeGhostStem( struct glyphdata *gd,</span>
<span class="lineNum">    4371 </span>            :     SplinePoint *sp,int blue,double width ) {
<span class="lineNum">    4372 </span>            :     int i, j, hasl, hasr;
<span class="lineNum">    4373 </span><span class="lineCov">       1372 :     struct stemdata *stem=NULL, *tstem;</span>
<span class="lineNum">    4374 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    4375 </span>            :     BasePoint dir,left,right;
<span class="lineNum">    4376 </span>            :     double min, max;
<span class="lineNum">    4377 </span>            : 
<span class="lineNum">    4378 </span><span class="lineCov">       1372 :     dir.x = 1; dir.y = 0;</span>
<span class="lineNum">    4379 </span><span class="lineCov">       8809 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    4380 </span><span class="lineCov">       8314 :         tstem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4381 </span><span class="lineCov">       8314 :         if ( tstem-&gt;blue == blue &amp;&amp; tstem-&gt;ghost &amp;&amp; tstem-&gt;width == width ) {</span>
<span class="lineNum">    4382 </span><span class="lineCov">        845 :             stem = tstem;</span>
<span class="lineNum">    4383 </span><span class="lineCov">        845 :     break;</span>
<span class="lineNum">    4384 </span>            :         /* If the stem controlling this blue zone is not for a ghost hint,    */
<span class="lineNum">    4385 </span>            :         /* then we check if it has both left and right points, to ensure that */
<span class="lineNum">    4386 </span>            :         /* we don't occasionally assign an additional point to a stem which   */
<span class="lineNum">    4387 </span>            :         /* has already been rejected in favor of another stem */
<span class="lineNum">    4388 </span><span class="lineCov">       7469 :         } else if ( tstem-&gt;blue == blue &amp;&amp; !tstem-&gt;ghost &amp;&amp; !tstem-&gt;toobig ) {</span>
<span class="lineNum">    4389 </span><span class="lineCov">        195 :             min = ( width == 20 ) ? tstem-&gt;left.y - tstem-&gt;lmin - 2*dist_error_hv :</span>
<span class="lineNum">    4390 </span><span class="lineCov">         63 :                                     tstem-&gt;right.y - tstem-&gt;rmin - 2*dist_error_hv;</span>
<span class="lineNum">    4391 </span><span class="lineCov">        195 :             max = ( width == 20 ) ? tstem-&gt;left.y - tstem-&gt;lmax + 2*dist_error_hv :</span>
<span class="lineNum">    4392 </span><span class="lineCov">         63 :                                     tstem-&gt;right.y - tstem-&gt;rmax + 2*dist_error_hv;</span>
<span class="lineNum">    4393 </span>            :             
<span class="lineNum">    4394 </span><span class="lineCov">        132 :             if ( sp-&gt;me.y &lt;= min || sp-&gt;me.y &gt;= max )</span>
<span class="lineNum">    4395 </span><span class="lineCov">        100 :     continue;</span>
<span class="lineNum">    4396 </span>            :             
<span class="lineNum">    4397 </span><span class="lineCov">         32 :             hasl = false; hasr = false; j = 0;</span>
<span class="lineNum">    4398 </span><span class="lineCov">         97 :             while ( j &lt; tstem-&gt;chunk_cnt &amp;&amp; ( !hasl || !hasr )) {</span>
<span class="lineNum">    4399 </span><span class="lineCov">         33 :                 chunk = &amp;tstem-&gt;chunks[j];</span>
<span class="lineNum">    4400 </span><span class="lineCov">         33 :                 if ( chunk-&gt;l != NULL &amp;&amp; !chunk-&gt;lpotential )</span>
<span class="lineNum">    4401 </span><span class="lineCov">         32 :                     hasl = true;</span>
<span class="lineNum">    4402 </span><span class="lineCov">         33 :                 if ( chunk-&gt;r != NULL &amp;&amp; !chunk-&gt;rpotential )</span>
<span class="lineNum">    4403 </span><span class="lineCov">         33 :                     hasr = true;</span>
<span class="lineNum">    4404 </span><span class="lineCov">         33 :                 j++;</span>
<span class="lineNum">    4405 </span>            :             }
<span class="lineNum">    4406 </span><span class="lineCov">         32 :             if ( hasl &amp;&amp; hasr ) {</span>
<span class="lineNum">    4407 </span><span class="lineCov">         32 :                 stem = tstem;</span>
<span class="lineNum">    4408 </span><span class="lineCov">         32 :     break;</span>
<span class="lineNum">    4409 </span>            :             }
<span class="lineNum">    4410 </span>            :         }
<span class="lineNum">    4411 </span>            :     }
<span class="lineNum">    4412 </span>            : 
<span class="lineNum">    4413 </span><span class="lineCov">       1372 :     if ( stem == NULL ) {</span>
<span class="lineNum">    4414 </span><span class="lineCov">        495 :         left.x = right.x = sp-&gt;me.x;</span>
<span class="lineNum">    4415 </span><span class="lineCov">        495 :         left.y = ( width == 21 ) ? sp-&gt;me.y + 21 : sp-&gt;me.y;</span>
<span class="lineNum">    4416 </span><span class="lineCov">        495 :         right.y = ( width == 21 ) ? sp-&gt;me.y : sp-&gt;me.y - 20;</span>
<span class="lineNum">    4417 </span>            : 
<span class="lineNum">    4418 </span><span class="lineCov">        495 :         stem = NewStem( gd,&amp;dir,&amp;left,&amp;right );</span>
<span class="lineNum">    4419 </span><span class="lineCov">        495 :         stem-&gt;ghost = true;</span>
<span class="lineNum">    4420 </span><span class="lineCov">        495 :         stem-&gt;width = width;</span>
<span class="lineNum">    4421 </span><span class="lineCov">        495 :         stem-&gt;blue = blue;</span>
<span class="lineNum">    4422 </span>            :     }
<span class="lineNum">    4423 </span><span class="lineCov">       1372 : return( stem );</span>
<a name="4424"><span class="lineNum">    4424 </span>            : }</a>
<span class="lineNum">    4425 </span>            : 
<span class="lineNum">    4426 </span><span class="lineCov">       2019 : static int AddGhostSegment( struct pointdata *pd,int cnt,double base,struct segment *space ) {</span>
<span class="lineNum">    4427 </span>            :     double s, e, temp, pos, spos, epos;
<span class="lineNum">    4428 </span>            :     SplinePoint *sp, *nsp, *nsp2, *psp, *psp2;
<span class="lineNum">    4429 </span>            :     
<span class="lineNum">    4430 </span><span class="lineCov">       2019 :     sp = nsp = psp = pd-&gt;sp;</span>
<span class="lineNum">    4431 </span><span class="lineCov">       2019 :     pos = pd-&gt;sp-&gt;me.y;</span>
<span class="lineNum">    4432 </span>            :     
<span class="lineNum">    4433 </span>            :     /* First check if there are points on the same line lying further */
<span class="lineNum">    4434 </span>            :     /* in the desired direction */
<span class="lineNum">    4435 </span><span class="lineCov">       2019 :     if (( sp-&gt;next != NULL ) &amp;&amp; ( sp-&gt;next-&gt;to-&gt;me.y == pos ))</span>
<span class="lineNum">    4436 </span><span class="lineCov">        963 :         nsp = sp-&gt;next-&gt;to;</span>
<span class="lineNum">    4437 </span><span class="lineCov">       2019 :     if (( sp-&gt;prev != NULL ) &amp;&amp; ( sp-&gt;prev-&gt;from-&gt;me.y == pos ))</span>
<span class="lineNum">    4438 </span><span class="lineCov">        962 :         psp = sp-&gt;prev-&gt;from;</span>
<span class="lineNum">    4439 </span>            :     
<span class="lineNum">    4440 </span><span class="lineCov">       2019 :     if ( psp != sp ) {</span>
<span class="lineNum">    4441 </span><span class="lineCov">        962 :         s = psp-&gt;me.x;</span>
<span class="lineNum">    4442 </span><span class="lineCov">       1057 :     } else if ( psp-&gt;noprevcp ) {</span>
<span class="lineNum">    4443 </span><span class="lineCov">        880 :         psp2 = psp-&gt;prev-&gt;from;</span>
<span class="lineNum">    4444 </span><span class="lineCov">        880 :         if ( psp2-&gt;me.y != psp-&gt;me.y ) {</span>
<span class="lineNum">    4445 </span><span class="lineCov">        880 :             s = ( psp-&gt;me.x - psp2-&gt;me.x )/( psp-&gt;me.y - psp2-&gt;me.y )*20.0;</span>
<span class="lineNum">    4446 </span><span class="lineCov">        880 :             if ( s &lt; 0 ) s = -s;</span>
<span class="lineNum">    4447 </span><span class="lineCov">        880 :             if ( psp2-&gt;me.x&lt;psp-&gt;me.x )</span>
<span class="lineNum">    4448 </span><span class="lineCov">        155 :                 s = ( psp-&gt;me.x-psp2-&gt;me.x &lt; s ) ? psp2-&gt;me.x : psp-&gt;me.x-s;</span>
<span class="lineNum">    4449 </span>            :             else
<span class="lineNum">    4450 </span><span class="lineCov">        725 :                 s = ( psp2-&gt;me.x-psp-&gt;me.x &lt; s ) ? psp2-&gt;me.x : psp-&gt;me.x+s;</span>
<span class="lineNum">    4451 </span>            :         } else
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :             s = psp-&gt;me.x;</span>
<span class="lineNum">    4453 </span>            :     } else {
<span class="lineNum">    4454 </span><span class="lineCov">        177 :         s = ( pd-&gt;sp-&gt;me.x + psp-&gt;prevcp.x )/2;</span>
<span class="lineNum">    4455 </span>            :     }
<span class="lineNum">    4456 </span>            : 
<span class="lineNum">    4457 </span><span class="lineCov">       2019 :     if ( nsp != sp ) {</span>
<span class="lineNum">    4458 </span><span class="lineCov">        963 :         e = nsp-&gt;me.x;</span>
<span class="lineNum">    4459 </span><span class="lineCov">       1056 :     } else if ( nsp-&gt;nonextcp ) {</span>
<span class="lineNum">    4460 </span><span class="lineCov">        902 :         nsp2 = nsp-&gt;next-&gt;to;</span>
<span class="lineNum">    4461 </span><span class="lineCov">        902 :         if ( nsp2-&gt;me.y != nsp-&gt;me.y ) {</span>
<span class="lineNum">    4462 </span><span class="lineCov">        902 :             e = ( nsp-&gt;me.x - nsp2-&gt;me.x )/( nsp-&gt;me.y - nsp2-&gt;me.y )*20.0;</span>
<span class="lineNum">    4463 </span><span class="lineCov">        902 :             if ( e &lt; 0 ) e = -e;</span>
<span class="lineNum">    4464 </span><span class="lineCov">        902 :             if ( nsp2-&gt;me.x&lt;nsp-&gt;me.x )</span>
<span class="lineNum">    4465 </span><span class="lineCov">        167 :                 e = ( nsp-&gt;me.x-nsp2-&gt;me.x &lt; e ) ? nsp2-&gt;me.x : nsp-&gt;me.x-e;</span>
<span class="lineNum">    4466 </span>            :             else
<span class="lineNum">    4467 </span><span class="lineCov">        735 :                 e = ( nsp2-&gt;me.x-nsp-&gt;me.x &lt; e )  ? nsp2-&gt;me.x : nsp-&gt;me.x+e;</span>
<span class="lineNum">    4468 </span>            :         } else
<span class="lineNum">    4469 </span><span class="lineNoCov">          0 :             e = nsp-&gt;me.x;</span>
<span class="lineNum">    4470 </span>            :     } else {
<span class="lineNum">    4471 </span><span class="lineCov">        154 :         e = ( pd-&gt;sp-&gt;me.x + nsp-&gt;nextcp.x )/2;</span>
<span class="lineNum">    4472 </span>            :     }
<span class="lineNum">    4473 </span>            :     
<span class="lineNum">    4474 </span><span class="lineCov">       2019 :     spos = psp-&gt;me.x; epos = nsp-&gt;me.x;</span>
<span class="lineNum">    4475 </span><span class="lineCov">       2019 :     if ( s&gt;e ) {</span>
<span class="lineNum">    4476 </span><span class="lineCov">        991 :         temp = s; s = e; e = temp;</span>
<span class="lineNum">    4477 </span><span class="lineCov">        991 :         temp = spos; spos = epos; epos = temp;</span>
<span class="lineNum">    4478 </span>            :     }
<span class="lineNum">    4479 </span>            :     
<span class="lineNum">    4480 </span><span class="lineCov">       2019 :     space[cnt].start = s - base;</span>
<span class="lineNum">    4481 </span><span class="lineCov">       2019 :     space[cnt].end = e - base;</span>
<span class="lineNum">    4482 </span><span class="lineCov">       2019 :     space[cnt].sbase = spos - base;</span>
<span class="lineNum">    4483 </span><span class="lineCov">       2019 :     space[cnt].ebase = epos - base;</span>
<span class="lineNum">    4484 </span><span class="lineCov">       2019 :     space[cnt].ecurved = space[cnt].scurved = space[cnt].curved = ( false );</span>
<span class="lineNum">    4485 </span>            :     
<span class="lineNum">    4486 </span><span class="lineCov">       2019 :     return( cnt+1 );</span>
<a name="4487"><span class="lineNum">    4487 </span>            : }</a>
<span class="lineNum">    4488 </span>            : 
<span class="lineNum">    4489 </span><span class="lineCov">        732 : static void FigureGhostActive( struct glyphdata *gd,struct stemdata *stem ) {</span>
<span class="lineNum">    4490 </span>            :     int acnt, i;
<span class="lineNum">    4491 </span><span class="lineCov">        732 :     real len = 0;</span>
<span class="lineNum">    4492 </span><span class="lineCov">        732 :     struct segment *activespace = gd-&gt;activespace;</span>
<span class="lineNum">    4493 </span>            :     struct pointdata *valid;
<span class="lineNum">    4494 </span>            :     
<span class="lineNum">    4495 </span><span class="lineCov">        732 :     if ( !stem-&gt;ghost )</span>
<span class="lineNum">    4496 </span><span class="lineCov">        732 : return;</span>
<span class="lineNum">    4497 </span>            : 
<span class="lineNum">    4498 </span><span class="lineCov">        732 :     acnt = 0;</span>
<span class="lineNum">    4499 </span><span class="lineCov">       2751 :     for ( i=0; i&lt;stem-&gt;chunk_cnt; ++i ) {</span>
<span class="lineNum">    4500 </span><span class="lineCov">       4038 :         valid = ( stem-&gt;chunks[i].l != NULL) ? </span>
<span class="lineNum">    4501 </span><span class="lineCov">       2019 :             stem-&gt;chunks[i].l : stem-&gt;chunks[i].r;</span>
<span class="lineNum">    4502 </span><span class="lineCov">       2019 :         acnt = AddGhostSegment( valid,acnt,stem-&gt;left.x,activespace );</span>
<span class="lineNum">    4503 </span>            :     }
<span class="lineNum">    4504 </span><span class="lineCov">        732 :     qsort(activespace,acnt,sizeof(struct segment),segment_cmp);</span>
<span class="lineNum">    4505 </span><span class="lineCov">        732 :     acnt = MergeSegments( activespace,acnt );</span>
<span class="lineNum">    4506 </span><span class="lineCov">        732 :     stem-&gt;activecnt = acnt;</span>
<span class="lineNum">    4507 </span><span class="lineCov">        732 :     if ( acnt!=0 ) {</span>
<span class="lineNum">    4508 </span><span class="lineCov">        731 :         stem-&gt;active = malloc(acnt*sizeof(struct segment));</span>
<span class="lineNum">    4509 </span><span class="lineCov">        731 :         memcpy( stem-&gt;active,activespace,acnt*sizeof( struct segment ));</span>
<span class="lineNum">    4510 </span>            :     }
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span><span class="lineCov">       1788 :     for ( i=0; i&lt;acnt; ++i ) {</span>
<span class="lineNum">    4513 </span><span class="lineCov">       1056 :         len += stem-&gt;active[i].end-stem-&gt;active[i].start;</span>
<span class="lineNum">    4514 </span>            :     }
<span class="lineNum">    4515 </span><span class="lineCov">        732 :     stem-&gt;clen = stem-&gt;len = len;</span>
<a name="4516"><span class="lineNum">    4516 </span>            : }</a>
<span class="lineNum">    4517 </span>            : 
<span class="lineNum">    4518 </span><span class="lineCov">       1644 : static void CheckForGhostHints( struct glyphdata *gd ) {</span>
<span class="lineNum">    4519 </span>            :     /* PostScript doesn't allow a hint to stretch from one alignment zone to */
<span class="lineNum">    4520 </span>            :     /*  another. (Alignment zones are the things in bluevalues).  */
<span class="lineNum">    4521 </span>            :     /* Oops, I got this wrong. PS doesn't allow a hint to start in a bottom */
<span class="lineNum">    4522 </span>            :     /*  zone and stretch to a top zone. Everything in OtherBlues is a bottom */
<span class="lineNum">    4523 </span>            :     /*  zone. The baseline entry in BlueValues is also a bottom zone. Every- */
<span class="lineNum">    4524 </span>            :     /*  thing else in BlueValues is a top-zone. */
<span class="lineNum">    4525 </span>            :     /* This means */
<span class="lineNum">    4526 </span>            :     /*  that we can't define a horizontal stem hint which stretches from */
<span class="lineNum">    4527 </span>            :     /*  the baseline to the top of a capital I, or the x-height of lower i */
<span class="lineNum">    4528 </span>            :     /*  If we find any such hints we must remove them, and replace them with */
<span class="lineNum">    4529 </span>            :     /*  ghost hints. The bottom hint has height -21, and the top -20 */
<span class="lineNum">    4530 </span><span class="lineCov">       1644 :     BlueData *bd = &amp;gd-&gt;bd;</span>
<span class="lineNum">    4531 </span>            :     struct stemdata *stem;
<span class="lineNum">    4532 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    4533 </span>            :     struct pointdata *pd;
<span class="lineNum">    4534 </span>            :     real base;
<span class="lineNum">    4535 </span>            :     int i, j, leftfound, rightfound, has_h, peak, fuzz;
<span class="lineNum">    4536 </span>            :     
<span class="lineNum">    4537 </span><span class="lineCov">       1644 :     fuzz = gd-&gt;fuzz;</span>
<span class="lineNum">    4538 </span>            : 
<span class="lineNum">    4539 </span>            :     /* look for any stems stretching from one zone to another and remove them */
<span class="lineNum">    4540 </span>            :     /*  (I used to turn them into ghost hints here, but that didn't work (for */
<span class="lineNum">    4541 </span>            :     /*  example on &quot;E&quot; where we don't need any ghosts from the big stem because*/
<span class="lineNum">    4542 </span>            :     /*  the narrow stems provide the hints that PS needs */
<span class="lineNum">    4543 </span>            :     /* However, there are counter-examples. in Garamond-Pro the &quot;T&quot; character */
<span class="lineNum">    4544 </span>            :     /*  has a horizontal stem at the top which stretches between two adjacent */
<span class="lineNum">    4545 </span>            :     /*  bluezones. Removing it is wrong. Um... Thanks Adobe */
<span class="lineNum">    4546 </span>            :     /* I misunderstood. Both of these were top-zones */
<span class="lineNum">    4547 </span><span class="lineCov">      12402 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    4548 </span><span class="lineCov">      10758 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4549 </span><span class="lineCov">      10758 :         if ( IsUnitHV( &amp;stem-&gt;unit,true ) != 1)</span>
<span class="lineNum">    4550 </span><span class="lineCov">       6553 :     continue;</span>
<span class="lineNum">    4551 </span>            :         
<span class="lineNum">    4552 </span><span class="lineCov">       4205 :         leftfound = rightfound = -1;</span>
<span class="lineNum">    4553 </span><span class="lineCov">      19625 :         for ( j=0; j&lt;bd-&gt;bluecnt; ++j ) {</span>
<span class="lineNum">    4554 </span><span class="lineCov">      15420 :             if ( stem-&gt;left.y&gt;=bd-&gt;blues[j][0]-fuzz &amp;&amp; stem-&gt;left.y&lt;=bd-&gt;blues[j][1]+fuzz )</span>
<span class="lineNum">    4555 </span><span class="lineCov">       1365 :                 leftfound = j;</span>
<span class="lineNum">    4556 </span><span class="lineCov">      14055 :             else if ( stem-&gt;right.y&gt;=bd-&gt;blues[j][0]-fuzz &amp;&amp; stem-&gt;right.y&lt;=bd-&gt;blues[j][1]+fuzz )</span>
<span class="lineNum">    4557 </span><span class="lineCov">       1339 :                 rightfound = j;</span>
<span class="lineNum">    4558 </span>            :         }
<span class="lineNum">    4559 </span>            :         /* Assign value 2 to indicate this stem should be ignored also for TTF instrs */
<span class="lineNum">    4560 </span><span class="lineCov">       4573 :         if ( leftfound !=-1 &amp;&amp; rightfound !=-1 &amp;&amp; </span>
<span class="lineNum">    4561 </span><span class="lineCov">        736 :             ( stem-&gt;left.y &gt; 0 &amp;&amp; stem-&gt;right.y &lt;= 0 ))</span>
<span class="lineNum">    4562 </span><span class="lineCov">        362 :             stem-&gt;toobig = 2;</span>
<span class="lineNum">    4563 </span>            :         /* Otherwise mark the stem as controlling a specific blue zone */
<span class="lineNum">    4564 </span><span class="lineCov">       3843 :         else if ( leftfound != -1 &amp;&amp; ( rightfound == -1 || stem-&gt;left.y &gt; 0 ))</span>
<span class="lineNum">    4565 </span><span class="lineCov">       1003 :             stem-&gt;blue = leftfound;</span>
<span class="lineNum">    4566 </span><span class="lineCov">       2840 :         else if ( rightfound != -1 &amp;&amp; ( leftfound == -1 || stem-&gt;right.y &lt;= 0 ))</span>
<span class="lineNum">    4567 </span><span class="lineCov">        971 :             stem-&gt;blue = rightfound;</span>
<span class="lineNum">    4568 </span>            :     }
<span class="lineNum">    4569 </span>            : 
<span class="lineNum">    4570 </span>            :     /* Now look and see if we can find any edges which lie in */
<span class="lineNum">    4571 </span>            :     /*  these zones.  Edges which are not currently in hints */
<span class="lineNum">    4572 </span>            :     /* Use the winding number to determine top or bottom */
<span class="lineNum">    4573 </span><span class="lineCov">      58854 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    4574 </span><span class="lineCov">      30622 :         has_h = false;</span>
<span class="lineNum">    4575 </span><span class="lineCov">      48424 :         for ( j=0; j&lt;gd-&gt;points[i].prevcnt; j++ ) {</span>
<span class="lineNum">    4576 </span><span class="lineCov">      25358 :             stem = gd-&gt;points[i].prevstems[j];</span>
<span class="lineNum">    4577 </span><span class="lineCov">      25358 :             if ( !stem-&gt;toobig &amp;&amp; IsUnitHV( &amp;stem-&gt;unit,true ) == 1 ) {</span>
<span class="lineNum">    4578 </span><span class="lineCov">       7556 :                 has_h = true;</span>
<span class="lineNum">    4579 </span><span class="lineCov">       7556 :         break;</span>
<span class="lineNum">    4580 </span>            :             }
<span class="lineNum">    4581 </span>            :         }
<span class="lineNum">    4582 </span><span class="lineCov">      48450 :         for ( j=0; j&lt;gd-&gt;points[i].nextcnt; j++ ) {</span>
<span class="lineNum">    4583 </span><span class="lineCov">      25375 :             stem = gd-&gt;points[i].nextstems[j];</span>
<span class="lineNum">    4584 </span><span class="lineCov">      25375 :             if ( !stem-&gt;toobig &amp;&amp; IsUnitHV( &amp;stem-&gt;unit,true ) == 1 ) {</span>
<span class="lineNum">    4585 </span><span class="lineCov">       7547 :                 has_h = true;</span>
<span class="lineNum">    4586 </span><span class="lineCov">       7547 :         break;</span>
<span class="lineNum">    4587 </span>            :             }
<span class="lineNum">    4588 </span>            :         }
<span class="lineNum">    4589 </span><span class="lineCov">      30622 :         if ( has_h )</span>
<span class="lineNum">    4590 </span><span class="lineCov">      10168 :     continue;</span>
<span class="lineNum">    4591 </span>            :         
<span class="lineNum">    4592 </span><span class="lineCov">      20454 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    4593 </span><span class="lineCov">      20454 :         base = pd-&gt;sp-&gt;me.y;</span>
<span class="lineNum">    4594 </span><span class="lineCov">      91589 :         for ( j=0; j&lt;bd-&gt;bluecnt; ++j ) {</span>
<span class="lineNum">    4595 </span><span class="lineCov">      71135 :             if ( base&gt;=bd-&gt;blues[j][0]-fuzz &amp;&amp; base&lt;=bd-&gt;blues[j][1]+fuzz ) {</span>
<span class="lineNum">    4596 </span><span class="lineCov">       2405 :                 peak = IsSplinePeak( gd,pd,false,false,7 );</span>
<span class="lineNum">    4597 </span><span class="lineCov">       2405 :                 if ( peak &gt; 0 ) {</span>
<span class="lineNum">    4598 </span><span class="lineCov">        710 :                     stem = FindOrMakeGhostStem( gd,pd-&gt;sp,j,20 );</span>
<span class="lineNum">    4599 </span><span class="lineCov">        710 :                     chunk = AddToStem( gd,stem,pd,NULL,2,false,false );</span>
<span class="lineNum">    4600 </span><span class="lineCov">       1695 :                 } else if ( peak &lt; 0 ) {</span>
<span class="lineNum">    4601 </span><span class="lineCov">        662 :                     stem = FindOrMakeGhostStem( gd,pd-&gt;sp,j,21 );</span>
<span class="lineNum">    4602 </span><span class="lineCov">        662 :                     chunk = AddToStem( gd,stem,NULL,pd,2,false,false );</span>
<span class="lineNum">    4603 </span>            :                 }
<span class="lineNum">    4604 </span>            :             }
<span class="lineNum">    4605 </span>            :         }
<span class="lineNum">    4606 </span>            :     }
<span class="lineNum">    4607 </span>            :     
<span class="lineNum">    4608 </span><span class="lineCov">      12897 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    4609 </span><span class="lineCov">      11253 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4610 </span><span class="lineCov">      11253 :         if ( !stem-&gt;ghost )</span>
<span class="lineNum">    4611 </span><span class="lineCov">      10521 :     continue;</span>
<span class="lineNum">    4612 </span><span class="lineCov">        732 :         NormalizeStem( gd,stem );</span>
<span class="lineNum">    4613 </span><span class="lineCov">        732 :         FigureGhostActive( gd,stem );</span>
<span class="lineNum">    4614 </span>            :     }
<a name="4615"><span class="lineNum">    4615 </span><span class="lineCov">       1644 : }</span></a>
<span class="lineNum">    4616 </span>            : 
<span class="lineNum">    4617 </span><span class="lineCov">         74 : static void MarkDStemCorner( struct glyphdata *gd,struct pointdata *pd ) {</span>
<span class="lineNum">    4618 </span><span class="lineCov">         74 :     int x_dir = pd-&gt;x_corner;</span>
<span class="lineNum">    4619 </span><span class="lineCov">         74 :     int hv, is_l, i, peak, has_stem = false;</span>
<span class="lineNum">    4620 </span>            :     struct stemdata *stem;
<span class="lineNum">    4621 </span>            :     BasePoint left,right,unit;
<span class="lineNum">    4622 </span>            :     
<span class="lineNum">    4623 </span><span class="lineCov">        155 :     for ( i=0; i&lt;pd-&gt;prevcnt &amp;&amp; !has_stem; i++ ) {</span>
<span class="lineNum">    4624 </span><span class="lineCov">         81 :         stem = pd-&gt;prevstems[i];</span>
<span class="lineNum">    4625 </span><span class="lineCov">         81 :         hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    4626 </span><span class="lineCov">         81 :         if ( !stem-&gt;toobig &amp;&amp; (</span>
<span class="lineNum">    4627 </span><span class="lineCov">         19 :             ( x_dir &amp;&amp;  hv == 1 ) ||</span>
<span class="lineNum">    4628 </span><span class="lineCov">         34 :             ( !x_dir &amp;&amp; hv == 2 )))</span>
<span class="lineNum">    4629 </span><span class="lineNoCov">          0 :             has_stem = true;</span>
<span class="lineNum">    4630 </span>            :     }
<span class="lineNum">    4631 </span><span class="lineCov">        158 :     for ( i=0; i&lt;pd-&gt;nextcnt &amp;&amp; !has_stem; i++ ) {</span>
<span class="lineNum">    4632 </span><span class="lineCov">         84 :         stem = pd-&gt;nextstems[i];</span>
<span class="lineNum">    4633 </span><span class="lineCov">         84 :         hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    4634 </span><span class="lineCov">         84 :         if ( !stem-&gt;toobig &amp;&amp; (</span>
<span class="lineNum">    4635 </span><span class="lineCov">         34 :             ( x_dir &amp;&amp;  hv == 1 ) ||</span>
<span class="lineNum">    4636 </span><span class="lineCov">         22 :             ( !x_dir &amp;&amp; hv == 2 )))</span>
<span class="lineNum">    4637 </span><span class="lineNoCov">          0 :             has_stem = true;</span>
<span class="lineNum">    4638 </span>            :     }
<span class="lineNum">    4639 </span><span class="lineCov">         74 :     if ( has_stem )</span>
<span class="lineNum">    4640 </span><span class="lineCov">         74 : return;</span>
<span class="lineNum">    4641 </span>            :     
<span class="lineNum">    4642 </span><span class="lineCov">         74 :     peak = IsSplinePeak( gd,pd,x_dir,x_dir,2 );</span>
<span class="lineNum">    4643 </span><span class="lineCov">         74 :     unit.x = !x_dir; unit.y = x_dir;</span>
<span class="lineNum">    4644 </span>            :     
<span class="lineNum">    4645 </span><span class="lineCov">         74 :     if ( peak &gt; 0 ) {</span>
<span class="lineNum">    4646 </span><span class="lineCov">         35 :         left.x = x_dir ? pd-&gt;sp-&gt;me.x + 21 : pd-&gt;sp-&gt;me.x;</span>
<span class="lineNum">    4647 </span><span class="lineCov">         35 :         right.x = x_dir ? pd-&gt;sp-&gt;me.x : pd-&gt;sp-&gt;me.x;</span>
<span class="lineNum">    4648 </span><span class="lineCov">         35 :         left.y = x_dir ? pd-&gt;sp-&gt;me.y : pd-&gt;sp-&gt;me.y;</span>
<span class="lineNum">    4649 </span><span class="lineCov">         35 :         right.y = x_dir ? pd-&gt;sp-&gt;me.y : pd-&gt;sp-&gt;me.y - 20;</span>
<span class="lineNum">    4650 </span>            :         
<span class="lineNum">    4651 </span><span class="lineCov">         39 :     } else if ( peak &lt; 0 ) {</span>
<span class="lineNum">    4652 </span><span class="lineCov">         39 :         left.x = x_dir ? pd-&gt;sp-&gt;me.x : pd-&gt;sp-&gt;me.x;</span>
<span class="lineNum">    4653 </span><span class="lineCov">         39 :         right.x = x_dir ? pd-&gt;sp-&gt;me.x - 20 : pd-&gt;sp-&gt;me.x;</span>
<span class="lineNum">    4654 </span><span class="lineCov">         39 :         left.y = x_dir ? pd-&gt;sp-&gt;me.y : pd-&gt;sp-&gt;me.y + 21;</span>
<span class="lineNum">    4655 </span><span class="lineCov">         39 :         right.y = x_dir ? pd-&gt;sp-&gt;me.y : pd-&gt;sp-&gt;me.y;</span>
<span class="lineNum">    4656 </span>            :     }
<span class="lineNum">    4657 </span><span class="lineCov">         74 :     is_l = IsCorrectSide( gd,pd,true,true,&amp;unit );</span>
<span class="lineNum">    4658 </span><span class="lineCov">        478 :     for ( i=0; i&lt;gd-&gt;stemcnt; i++ ) {</span>
<span class="lineNum">    4659 </span><span class="lineCov">        443 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4660 </span><span class="lineCov">        553 :         if (!stem-&gt;toobig &amp;&amp; UnitsParallel( &amp;unit,&amp;stem-&gt;unit,true ) &amp;&amp; </span>
<span class="lineNum">    4661 </span><span class="lineCov">        110 :             OnStem( stem,&amp;pd-&gt;sp-&gt;me,is_l ))</span>
<span class="lineNum">    4662 </span><span class="lineCov">         39 :     break;</span>
<span class="lineNum">    4663 </span>            :     }
<span class="lineNum">    4664 </span><span class="lineCov">         74 :     if ( i == gd-&gt;stemcnt ) {</span>
<span class="lineNum">    4665 </span><span class="lineCov">         35 :         stem = NewStem( gd,&amp;unit,&amp;left,&amp;right );</span>
<span class="lineNum">    4666 </span><span class="lineCov">         35 :         stem-&gt;ghost = 2;</span>
<span class="lineNum">    4667 </span>            :     }
<span class="lineNum">    4668 </span><span class="lineCov">         74 :     AddToStem( gd,stem,pd,NULL,2,false,false );</span>
<a name="4669"><span class="lineNum">    4669 </span>            : }</a>
<span class="lineNum">    4670 </span>            : 
<span class="lineNum">    4671 </span><span class="lineCov">        548 : static void MarkDStemCorners( struct glyphdata *gd ) {</span>
<span class="lineNum">    4672 </span>            :     struct stemdata *stem;
<span class="lineNum">    4673 </span>            :     struct stem_chunk *schunk, *echunk;
<span class="lineNum">    4674 </span>            :     int i;
<span class="lineNum">    4675 </span>            :     
<span class="lineNum">    4676 </span><span class="lineCov">       5183 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    4677 </span><span class="lineCov">       4635 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4678 </span><span class="lineCov">       4635 :         if ( stem-&gt;toobig || IsUnitHV( &amp;stem-&gt;unit,true ))</span>
<span class="lineNum">    4679 </span><span class="lineCov">       4369 :     continue;</span>
<span class="lineNum">    4680 </span>            :         
<span class="lineNum">    4681 </span><span class="lineCov">        266 :         schunk = &amp;stem-&gt;chunks[0];</span>
<span class="lineNum">    4682 </span><span class="lineCov">        266 :         echunk = &amp;stem-&gt;chunks[stem-&gt;chunk_cnt - 1];</span>
<span class="lineNum">    4683 </span>            :         
<span class="lineNum">    4684 </span><span class="lineCov">        517 :         if ( schunk-&gt;l != NULL &amp;&amp; schunk-&gt;r != NULL &amp;&amp; </span>
<span class="lineNum">    4685 </span><span class="lineCov">        475 :             fabs( schunk-&gt;l-&gt;base.x - schunk-&gt;r-&gt;base.x ) &gt; dist_error_hv &amp;&amp;</span>
<span class="lineNum">    4686 </span><span class="lineCov">        375 :             fabs( schunk-&gt;l-&gt;base.y - schunk-&gt;r-&gt;base.y ) &gt; dist_error_hv &amp;&amp; (</span>
<span class="lineNum">    4687 </span><span class="lineCov">        304 :             ( schunk-&gt;l-&gt;x_corner == 1 &amp;&amp; schunk-&gt;r-&gt;y_corner == 1 ) ||</span>
<span class="lineNum">    4688 </span><span class="lineCov">        147 :             ( schunk-&gt;l-&gt;y_corner == 1 &amp;&amp; schunk-&gt;r-&gt;x_corner == 1 ))) {</span>
<span class="lineNum">    4689 </span><span class="lineCov">         17 :             MarkDStemCorner( gd,schunk-&gt;l );</span>
<span class="lineNum">    4690 </span><span class="lineCov">         17 :             MarkDStemCorner( gd,schunk-&gt;r );</span>
<span class="lineNum">    4691 </span>            :         }
<span class="lineNum">    4692 </span><span class="lineCov">        521 :         if ( echunk-&gt;l != NULL &amp;&amp; echunk-&gt;r != NULL &amp;&amp;</span>
<span class="lineNum">    4693 </span><span class="lineCov">        487 :             fabs( echunk-&gt;l-&gt;base.x - echunk-&gt;r-&gt;base.x ) &gt; dist_error_hv &amp;&amp;</span>
<span class="lineNum">    4694 </span><span class="lineCov">        385 :             fabs( echunk-&gt;l-&gt;base.y - echunk-&gt;r-&gt;base.y ) &gt; dist_error_hv &amp;&amp; (</span>
<span class="lineNum">    4695 </span><span class="lineCov">        309 :             ( echunk-&gt;l-&gt;x_corner == 1 &amp;&amp; echunk-&gt;r-&gt;y_corner == 1 ) ||</span>
<span class="lineNum">    4696 </span><span class="lineCov">        160 :             ( echunk-&gt;l-&gt;y_corner == 1 &amp;&amp; echunk-&gt;r-&gt;x_corner == 1 ))) {</span>
<span class="lineNum">    4697 </span><span class="lineCov">         20 :             MarkDStemCorner( gd,echunk-&gt;l );</span>
<span class="lineNum">    4698 </span><span class="lineCov">         20 :             MarkDStemCorner( gd,echunk-&gt;r );</span>
<span class="lineNum">    4699 </span>            :         }
<span class="lineNum">    4700 </span>            :     }
<span class="lineNum">    4701 </span><span class="lineCov">        548 : }</span>
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span>            : #if GLYPH_DATA_DEBUG
<span class="lineNum">    4704 </span>            : static void DumpGlyphData( struct glyphdata *gd ) {
<span class="lineNum">    4705 </span>            :     int i, j;
<span class="lineNum">    4706 </span>            :     struct stemdata *stem;
<span class="lineNum">    4707 </span>            :     struct linedata *line;
<span class="lineNum">    4708 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    4709 </span>            : 
<span class="lineNum">    4710 </span>            :     if ( gd-&gt;linecnt &gt; 0 )
<span class="lineNum">    4711 </span>            :         fprintf( stderr, &quot;\nDumping line data for %s\n&quot;,gd-&gt;sc-&gt;name );
<span class="lineNum">    4712 </span>            :     for ( i=0; i&lt;gd-&gt;linecnt; ++i ) {
<span class="lineNum">    4713 </span>            :         line = &amp;gd-&gt;lines[i];
<span class="lineNum">    4714 </span>            :         fprintf( stderr, &quot;line vector=%.4f,%.4f base=%.2f,%.2f length=%.4f\n&quot;, 
<span class="lineNum">    4715 </span>            :             line-&gt;unit.x,line-&gt;unit.y,line-&gt;online.x,line-&gt;online.y,line-&gt;length );
<span class="lineNum">    4716 </span>            :         for( j=0; j&lt;line-&gt;pcnt;++j ) {
<span class="lineNum">    4717 </span>            :             fprintf( stderr, &quot;\tpoint num=%d, x=%.2f, y=%.2f, prev=%d, next=%d\n&quot;,
<span class="lineNum">    4718 </span>            :                 line-&gt;points[j]-&gt;sp-&gt;ttfindex, line-&gt;points[j]-&gt;sp-&gt;me.x,
<span class="lineNum">    4719 </span>            :                 line-&gt;points[j]-&gt;sp-&gt;me.y, 
<span class="lineNum">    4720 </span>            :                 line-&gt;points[j]-&gt;prevline==line, line-&gt;points[j]-&gt;nextline==line );
<span class="lineNum">    4721 </span>            :         }
<span class="lineNum">    4722 </span>            :         fprintf( stderr, &quot;\n&quot; );
<span class="lineNum">    4723 </span>            :     }
<span class="lineNum">    4724 </span>            :     
<span class="lineNum">    4725 </span>            :     if ( gd-&gt;stemcnt &gt; 0 )
<span class="lineNum">    4726 </span>            :         fprintf( stderr, &quot;\nDumping stem data for %s\n&quot;,gd-&gt;sc-&gt;name );
<span class="lineNum">    4727 </span>            :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {
<span class="lineNum">    4728 </span>            :         stem = &amp;gd-&gt;stems[i];
<span class="lineNum">    4729 </span>            :         fprintf( stderr, &quot;stem l=%.2f,%.2f idx=%d r=%.2f,%.2f idx=%d vector=%.4f,%.4f\n\twidth=%.2f chunk_cnt=%d len=%.4f clen=%.4f ghost=%d blue=%d toobig=%d\n\tlmin=%.2f,lmax=%.2f,rmin=%.2f,rmax=%.2f,lpcnt=%d,rpcnt=%d\n&quot;,
<span class="lineNum">    4730 </span>            :             stem-&gt;left.x,stem-&gt;left.y,stem-&gt;leftidx,
<span class="lineNum">    4731 </span>            :             stem-&gt;right.x,stem-&gt;right.y,stem-&gt;rightidx,
<span class="lineNum">    4732 </span>            :             stem-&gt;unit.x,stem-&gt;unit.y,stem-&gt;width,
<span class="lineNum">    4733 </span>            :             stem-&gt;chunk_cnt,stem-&gt;len,stem-&gt;clen,stem-&gt;ghost,stem-&gt;blue,stem-&gt;toobig,
<span class="lineNum">    4734 </span>            :             stem-&gt;lmin,stem-&gt;lmax,stem-&gt;rmin,stem-&gt;rmax,stem-&gt;lpcnt,stem-&gt;rpcnt );
<span class="lineNum">    4735 </span>            :         for ( j=0; j&lt;stem-&gt;chunk_cnt; ++j ) {
<span class="lineNum">    4736 </span>            :             chunk = &amp;stem-&gt;chunks[j];
<span class="lineNum">    4737 </span>            :             if ( chunk-&gt;l!=NULL &amp;&amp; chunk-&gt;r!=NULL )
<span class="lineNum">    4738 </span>            :                 fprintf (stderr, &quot;\tchunk l=%.2f,%.2f potential=%d r=%.2f,%.2f potential=%d stub=%d\n&quot;,
<span class="lineNum">    4739 </span>            :                     chunk-&gt;l-&gt;sp-&gt;me.x, chunk-&gt;l-&gt;sp-&gt;me.y, chunk-&gt;lpotential,
<span class="lineNum">    4740 </span>            :                     chunk-&gt;r-&gt;sp-&gt;me.x, chunk-&gt;r-&gt;sp-&gt;me.y, chunk-&gt;rpotential, chunk-&gt;stub );
<span class="lineNum">    4741 </span>            :             else if ( chunk-&gt;l!=NULL )
<span class="lineNum">    4742 </span>            :                 fprintf (stderr, &quot;\tchunk l=%.2f,%.2f potential=%d\n&quot;,
<span class="lineNum">    4743 </span>            :                     chunk-&gt;l-&gt;sp-&gt;me.x, chunk-&gt;l-&gt;sp-&gt;me.y, chunk-&gt;lpotential);
<span class="lineNum">    4744 </span>            :             else if ( chunk-&gt;r!=NULL )
<span class="lineNum">    4745 </span>            :                 fprintf (stderr, &quot;\tchunk r=%.2f,%.2f potential=%d\n&quot;,
<span class="lineNum">    4746 </span>            :                     chunk-&gt;r-&gt;sp-&gt;me.x, chunk-&gt;r-&gt;sp-&gt;me.y, chunk-&gt;rpotential);
<span class="lineNum">    4747 </span>            :         }
<span class="lineNum">    4748 </span>            :         fprintf( stderr, &quot;\n&quot; );
<span class="lineNum">    4749 </span>            :     }
<span class="lineNum">    4750 </span>            : 
<span class="lineNum">    4751 </span>            :     if ( gd-&gt;hbundle != NULL || gd-&gt;vbundle != NULL )
<span class="lineNum">    4752 </span>            :         fprintf( stderr, &quot;\nDumping HV stem bundles for %s\n&quot;,gd-&gt;sc-&gt;name );
<span class="lineNum">    4753 </span>            :     if ( gd-&gt;hbundle != NULL ) for ( i=0; i&lt;gd-&gt;hbundle-&gt;cnt; i++ ) {
<span class="lineNum">    4754 </span>            :         stem = gd-&gt;hbundle-&gt;stemlist[i];
<span class="lineNum">    4755 </span>            :         fprintf( stderr, &quot;H stem l=%.2f,%.2f r=%.2f,%.2f slave=%d\n&quot;,
<span class="lineNum">    4756 </span>            :             stem-&gt;left.x,stem-&gt;left.y,stem-&gt;right.x,stem-&gt;right.y,stem-&gt;master!=NULL );
<span class="lineNum">    4757 </span>            :         if ( stem-&gt;dep_cnt &gt; 0 ) for ( j=0; j&lt;stem-&gt;dep_cnt; j++ ) {
<span class="lineNum">    4758 </span>            :             fprintf( stderr, &quot;\tslave l=%.2f,%.2f r=%.2f,%.2f mode=%c left=%d\n&quot;,
<span class="lineNum">    4759 </span>            :                 stem-&gt;dependent[j].stem-&gt;left.x,stem-&gt;dependent[j].stem-&gt;left.y,
<span class="lineNum">    4760 </span>            :                 stem-&gt;dependent[j].stem-&gt;right.x,stem-&gt;dependent[j].stem-&gt;right.y,
<span class="lineNum">    4761 </span>            :                 stem-&gt;dependent[j].dep_type,stem-&gt;dependent[j].lbase );
<span class="lineNum">    4762 </span>            :         }
<span class="lineNum">    4763 </span>            :         if ( stem-&gt;serif_cnt &gt; 0 ) for ( j=0; j&lt;stem-&gt;serif_cnt; j++ ) {
<span class="lineNum">    4764 </span>            :             fprintf( stderr, &quot;\tserif l=%.2f,%.2f r=%.2f,%.2f ball=%d left=%d\n&quot;,
<span class="lineNum">    4765 </span>            :                 stem-&gt;serifs[j].stem-&gt;left.x,stem-&gt;serifs[j].stem-&gt;left.y,
<span class="lineNum">    4766 </span>            :                 stem-&gt;serifs[j].stem-&gt;right.x,stem-&gt;serifs[j].stem-&gt;right.y,
<span class="lineNum">    4767 </span>            :                 stem-&gt;serifs[j].is_ball,stem-&gt;serifs[j].lbase );
<span class="lineNum">    4768 </span>            :         }
<span class="lineNum">    4769 </span>            :     }
<span class="lineNum">    4770 </span>            :     fprintf( stderr, &quot;\n&quot; );
<span class="lineNum">    4771 </span>            :     if ( gd-&gt;vbundle != NULL ) for ( i=0; i&lt;gd-&gt;vbundle-&gt;cnt; i++ ) {
<span class="lineNum">    4772 </span>            :         stem = gd-&gt;vbundle-&gt;stemlist[i];
<span class="lineNum">    4773 </span>            :         fprintf( stderr, &quot;V stem l=%.2f,%.2f r=%.2f,%.2f slave=%d\n&quot;,
<span class="lineNum">    4774 </span>            :             stem-&gt;left.x,stem-&gt;left.y,stem-&gt;right.x,stem-&gt;right.y,stem-&gt;master!=NULL );
<span class="lineNum">    4775 </span>            :         if ( stem-&gt;dep_cnt &gt; 0 ) for ( j=0; j&lt;stem-&gt;dep_cnt; j++ ) {
<span class="lineNum">    4776 </span>            :             fprintf( stderr, &quot;\tslave l=%.2f,%.2f r=%.2f,%.2f mode=%c left=%d\n&quot;,
<span class="lineNum">    4777 </span>            :                 stem-&gt;dependent[j].stem-&gt;left.x,stem-&gt;dependent[j].stem-&gt;left.y,
<span class="lineNum">    4778 </span>            :                 stem-&gt;dependent[j].stem-&gt;right.x,stem-&gt;dependent[j].stem-&gt;right.y,
<span class="lineNum">    4779 </span>            :                 stem-&gt;dependent[j].dep_type,stem-&gt;dependent[j].lbase );
<span class="lineNum">    4780 </span>            :         }
<span class="lineNum">    4781 </span>            :         if ( stem-&gt;serif_cnt &gt; 0 ) for ( j=0; j&lt;stem-&gt;serif_cnt; j++ ) {
<span class="lineNum">    4782 </span>            :             fprintf( stderr, &quot;\tserif l=%.2f,%.2f r=%.2f,%.2f ball=%d left=%d\n&quot;,
<span class="lineNum">    4783 </span>            :                 stem-&gt;serifs[j].stem-&gt;left.x,stem-&gt;serifs[j].stem-&gt;left.y,
<span class="lineNum">    4784 </span>            :                 stem-&gt;serifs[j].stem-&gt;right.x,stem-&gt;serifs[j].stem-&gt;right.y,
<span class="lineNum">    4785 </span>            :                 stem-&gt;serifs[j].is_ball,stem-&gt;serifs[j].lbase );
<span class="lineNum">    4786 </span>            :         }
<span class="lineNum">    4787 </span>            :         if ( stem-&gt;prev_c_m != NULL ) {
<span class="lineNum">    4788 </span>            :             fprintf( stderr,&quot;\tprev counter master: l=%.2f r=%.2f\n&quot;,
<span class="lineNum">    4789 </span>            :                 stem-&gt;prev_c_m-&gt;left.x,stem-&gt;prev_c_m-&gt;right.x );
<span class="lineNum">    4790 </span>            :         }
<span class="lineNum">    4791 </span>            :         if ( stem-&gt;next_c_m != NULL ) {
<span class="lineNum">    4792 </span>            :             fprintf( stderr,&quot;\tnext counter master: l=%.2f r=%.2f\n&quot;,
<span class="lineNum">    4793 </span>            :                 stem-&gt;next_c_m-&gt;left.x,stem-&gt;next_c_m-&gt;right.x );
<span class="lineNum">    4794 </span>            :         }
<span class="lineNum">    4795 </span>            :     }
<span class="lineNum">    4796 </span>            :     fprintf( stderr, &quot;\n&quot; );
<span class="lineNum">    4797 </span>            : 
<span class="lineNum">    4798 </span>            :     if ( gd-&gt;ibundle != NULL ) for ( i=0; i&lt;gd-&gt;ibundle-&gt;cnt; i++ ) {
<span class="lineNum">    4799 </span>            :         stem = gd-&gt;ibundle-&gt;stemlist[i];
<span class="lineNum">    4800 </span>            :         fprintf( stderr, &quot;I stem l=%.2f,%.2f r=%.2f,%.2f slave=%d\n&quot;,
<span class="lineNum">    4801 </span>            :             stem-&gt;left.x,stem-&gt;left.y,stem-&gt;right.x,stem-&gt;right.y,stem-&gt;master!=NULL );
<span class="lineNum">    4802 </span>            :         if ( stem-&gt;dep_cnt &gt; 0 ) for ( j=0; j&lt;stem-&gt;dep_cnt; j++ ) {
<span class="lineNum">    4803 </span>            :             fprintf( stderr, &quot;\tslave l=%.2f,%.2f r=%.2f,%.2f mode=%c left=%d\n&quot;,
<span class="lineNum">    4804 </span>            :                 stem-&gt;dependent[j].stem-&gt;left.x,stem-&gt;dependent[j].stem-&gt;left.y,
<span class="lineNum">    4805 </span>            :                 stem-&gt;dependent[j].stem-&gt;right.x,stem-&gt;dependent[j].stem-&gt;right.y,
<span class="lineNum">    4806 </span>            :                 stem-&gt;dependent[j].dep_type,stem-&gt;dependent[j].lbase );
<span class="lineNum">    4807 </span>            :         }
<span class="lineNum">    4808 </span>            :         if ( stem-&gt;serif_cnt &gt; 0 ) for ( j=0; j&lt;stem-&gt;serif_cnt; j++ ) {
<span class="lineNum">    4809 </span>            :             fprintf( stderr, &quot;\tserif l=%.2f,%.2f r=%.2f,%.2f ball=%d left=%d\n&quot;,
<span class="lineNum">    4810 </span>            :                 stem-&gt;serifs[j].stem-&gt;left.x,stem-&gt;serifs[j].stem-&gt;left.y,
<span class="lineNum">    4811 </span>            :                 stem-&gt;serifs[j].stem-&gt;right.x,stem-&gt;serifs[j].stem-&gt;right.y,
<span class="lineNum">    4812 </span>            :                 stem-&gt;serifs[j].is_ball,stem-&gt;serifs[j].lbase );
<span class="lineNum">    4813 </span>            :         }
<span class="lineNum">    4814 </span>            :     }
<span class="lineNum">    4815 </span>            :     fprintf( stderr, &quot;\n&quot; );
<span class="lineNum">    4816 </span>            : }
<a name="4817"><span class="lineNum">    4817 </span>            : #endif</a>
<span class="lineNum">    4818 </span>            : 
<span class="lineNum">    4819 </span><span class="lineCov">        404 : static void AssignPointsToStems( struct glyphdata *gd,int startnum,DBounds *bounds ) {</span>
<span class="lineNum">    4820 </span>            :     int i;
<span class="lineNum">    4821 </span>            :     struct pointdata *pd;
<span class="lineNum">    4822 </span><span class="lineCov">        404 :     struct stemdata *stem = NULL;</span>
<span class="lineNum">    4823 </span>            :     BasePoint dir;
<span class="lineNum">    4824 </span>            :     
<span class="lineNum">    4825 </span><span class="lineCov">      28500 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    4826 </span><span class="lineCov">      11170 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    4827 </span><span class="lineCov">      11170 :         if ( pd-&gt;prev_e_cnt &gt; 0 )</span>
<span class="lineNum">    4828 </span><span class="lineCov">       6771 :             BuildStem( gd,pd,false,true,true,0 );</span>
<span class="lineNum">    4829 </span>            :         else
<span class="lineNum">    4830 </span><span class="lineCov">       4399 :             HalfStemNoOpposite( gd,pd,stem,&amp;pd-&gt;prevunit,false );</span>
<span class="lineNum">    4831 </span>            : 
<span class="lineNum">    4832 </span><span class="lineCov">      11170 :         if ( pd-&gt;next_e_cnt &gt; 0 )</span>
<span class="lineNum">    4833 </span><span class="lineCov">       6798 :             BuildStem( gd,pd,true,true,true,0 );</span>
<span class="lineNum">    4834 </span>            :         else
<span class="lineNum">    4835 </span><span class="lineCov">       4372 :             HalfStemNoOpposite( gd,pd,stem,&amp;pd-&gt;nextunit,true );</span>
<span class="lineNum">    4836 </span>            : 
<span class="lineNum">    4837 </span><span class="lineCov">      11170 :         if ( pd-&gt;x_corner ) {</span>
<span class="lineNum">    4838 </span><span class="lineCov">        964 :             if ( pd-&gt;bothedge!=NULL )</span>
<span class="lineNum">    4839 </span><span class="lineNoCov">          0 :                 stem = DiagonalCornerStem( gd,pd,true );</span>
<span class="lineNum">    4840 </span><span class="lineCov">        964 :             dir.x = 0; dir.y = 1;</span>
<span class="lineNum">    4841 </span><span class="lineCov">        964 :             HalfStemNoOpposite( gd,pd,stem,&amp;dir,2 );</span>
<span class="lineNum">    4842 </span><span class="lineCov">      10206 :         } else if ( pd-&gt;y_corner ) {</span>
<span class="lineNum">    4843 </span><span class="lineCov">        614 :             if ( pd-&gt;bothedge!=NULL )</span>
<span class="lineNum">    4844 </span><span class="lineNoCov">          0 :                 stem = DiagonalCornerStem( gd,pd,true );</span>
<span class="lineNum">    4845 </span><span class="lineCov">        614 :             dir.x = 1; dir.y = 0;</span>
<span class="lineNum">    4846 </span><span class="lineCov">        614 :             HalfStemNoOpposite( gd,pd,stem,&amp;dir,2 );</span>
<span class="lineNum">    4847 </span>            :         }
<span class="lineNum">    4848 </span>            :     }
<span class="lineNum">    4849 </span><span class="lineCov">        404 :     gd-&gt;lspace = malloc(gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    4850 </span><span class="lineCov">        404 :     gd-&gt;rspace = malloc(gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    4851 </span><span class="lineCov">        404 :     gd-&gt;bothspace = malloc(3*gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    4852 </span><span class="lineCov">        404 :     gd-&gt;activespace = malloc(3*gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    4853 </span>            : #if GLYPH_DATA_DEBUG
<span class="lineNum">    4854 </span>            :     fprintf( stderr,&quot;Going to calculate stem active zones for %s\n&quot;,gd-&gt;sc-&gt;name );
<span class="lineNum">    4855 </span>            : #endif
<span class="lineNum">    4856 </span><span class="lineCov">       1119 :     for ( i=startnum; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    4857 </span><span class="lineCov">        715 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    4858 </span><span class="lineCov">        715 :         NormalizeStem( gd,stem );</span>
<span class="lineNum">    4859 </span><span class="lineCov">        715 :         if ( gd-&gt;stems[i].ghost )</span>
<span class="lineNum">    4860 </span><span class="lineNoCov">          0 :             FigureGhostActive( gd,stem );</span>
<span class="lineNum">    4861 </span><span class="lineCov">        715 :         else if ( gd-&gt;stems[i].bbox )</span>
<span class="lineNum">    4862 </span><span class="lineCov">         10 :             AssignPointsToBBoxHint( gd,bounds,stem,( stem-&gt;unit.y == 1 ));</span>
<span class="lineNum">    4863 </span>            :         else
<span class="lineNum">    4864 </span><span class="lineCov">        705 :             FigureStemActive( gd,&amp;gd-&gt;stems[i] );</span>
<span class="lineNum">    4865 </span>            :     }
<span class="lineNum">    4866 </span>            : #if GLYPH_DATA_DEBUG
<span class="lineNum">    4867 </span>            :     DumpGlyphData( gd );
<span class="lineNum">    4868 </span>            : #endif
<span class="lineNum">    4869 </span>            : 
<span class="lineNum">    4870 </span><span class="lineCov">        404 :     free(gd-&gt;lspace);                gd-&gt;lspace = NULL;</span>
<span class="lineNum">    4871 </span><span class="lineCov">        404 :     free(gd-&gt;rspace);                gd-&gt;rspace = NULL;</span>
<span class="lineNum">    4872 </span><span class="lineCov">        404 :     free(gd-&gt;bothspace);     gd-&gt;bothspace = NULL;</span>
<span class="lineNum">    4873 </span><span class="lineCov">        404 :     free(gd-&gt;activespace);   gd-&gt;activespace = NULL;</span>
<a name="4874"><span class="lineNum">    4874 </span><span class="lineCov">        404 : }</span></a>
<span class="lineNum">    4875 </span>            : 
<span class="lineNum">    4876 </span><span class="lineCov">        135 : static void _DStemInfoToStemData( struct glyphdata *gd,DStemInfo *dsi,int *startcnt ) {</span>
<span class="lineNum">    4877 </span>            :     struct stemdata *stem;
<span class="lineNum">    4878 </span>            :     
<span class="lineNum">    4879 </span><span class="lineCov">        135 :     if ( gd-&gt;stems == NULL ) {</span>
<span class="lineNum">    4880 </span><span class="lineNoCov">          0 :         gd-&gt;stems = calloc( 2*gd-&gt;pcnt,sizeof( struct stemdata ));</span>
<span class="lineNum">    4881 </span><span class="lineNoCov">          0 :         gd-&gt;stemcnt = 0;</span>
<span class="lineNum">    4882 </span>            :     }
<span class="lineNum">    4883 </span><span class="lineCov">        135 :     *startcnt = gd-&gt;stemcnt;</span>
<span class="lineNum">    4884 </span><span class="lineCov">        482 :     while ( dsi != NULL ) {</span>
<span class="lineNum">    4885 </span><span class="lineCov">        212 :         stem = NewStem( gd,&amp;dsi-&gt;unit,&amp;dsi-&gt;left,&amp;dsi-&gt;right );</span>
<span class="lineNum">    4886 </span><span class="lineCov">        212 :         stem-&gt;positioned = true;</span>
<span class="lineNum">    4887 </span><span class="lineCov">        212 :         dsi = dsi-&gt;next;</span>
<span class="lineNum">    4888 </span>            :     }
<a name="4889"><span class="lineNum">    4889 </span><span class="lineCov">        135 : }</span></a>
<span class="lineNum">    4890 </span>            : 
<span class="lineNum">    4891 </span><span class="lineNoCov">          0 : struct glyphdata *DStemInfoToStemData( struct glyphdata *gd,DStemInfo *dsi ) {</span>
<span class="lineNum">    4892 </span>            :     int startcnt;
<span class="lineNum">    4893 </span>            :     
<span class="lineNum">    4894 </span><span class="lineNoCov">          0 :     if ( dsi == NULL )</span>
<span class="lineNum">    4895 </span><span class="lineNoCov">          0 : return( gd );</span>
<span class="lineNum">    4896 </span>            :     
<span class="lineNum">    4897 </span><span class="lineNoCov">          0 :     _DStemInfoToStemData( gd,dsi,&amp;startcnt );</span>
<span class="lineNum">    4898 </span><span class="lineNoCov">          0 :     AssignPointsToStems( gd,startcnt,NULL );</span>
<span class="lineNum">    4899 </span><span class="lineNoCov">          0 : return( gd );</span>
<a name="4900"><span class="lineNum">    4900 </span>            : }</a>
<span class="lineNum">    4901 </span>            : 
<span class="lineNum">    4902 </span><span class="lineCov">       1369 : static void _StemInfoToStemData( struct glyphdata *gd,StemInfo *si,DBounds *bounds,int is_v,int *startcnt ) {</span>
<span class="lineNum">    4903 </span>            :     struct stemdata *stem;
<span class="lineNum">    4904 </span>            :     BasePoint dir,left,right;
<span class="lineNum">    4905 </span>            :     
<span class="lineNum">    4906 </span><span class="lineCov">       1369 :     dir.x = !is_v; dir.y = is_v;</span>
<span class="lineNum">    4907 </span><span class="lineCov">       1369 :     if ( gd-&gt;stems == NULL ) {</span>
<span class="lineNum">    4908 </span><span class="lineCov">        319 :         gd-&gt;stems = calloc( 2*gd-&gt;pcnt,sizeof( struct stemdata ));</span>
<span class="lineNum">    4909 </span><span class="lineCov">        319 :         gd-&gt;stemcnt = 0;</span>
<span class="lineNum">    4910 </span>            :     }
<span class="lineNum">    4911 </span><span class="lineCov">       1369 :     *startcnt = gd-&gt;stemcnt;</span>
<span class="lineNum">    4912 </span>            : 
<span class="lineNum">    4913 </span><span class="lineCov">       5496 :     while ( si != NULL ) {</span>
<span class="lineNum">    4914 </span><span class="lineCov">       2758 :         left.x = ( is_v ) ? si-&gt;start : 0;</span>
<span class="lineNum">    4915 </span><span class="lineCov">       2758 :         left.y = ( is_v ) ? 0 : si-&gt;start + si-&gt;width;</span>
<span class="lineNum">    4916 </span><span class="lineCov">       2758 :         right.x = ( is_v ) ? si-&gt;start + si-&gt;width : 0;</span>
<span class="lineNum">    4917 </span><span class="lineCov">       2758 :         right.y = ( is_v ) ? 0 : si-&gt;start;</span>
<span class="lineNum">    4918 </span><span class="lineCov">       2758 :         stem = NewStem( gd,&amp;dir,&amp;left,&amp;right );</span>
<span class="lineNum">    4919 </span><span class="lineCov">       2758 :         stem-&gt;ghost = si-&gt;ghost;</span>
<span class="lineNum">    4920 </span><span class="lineCov">       3845 :         if (( is_v &amp;&amp; </span>
<span class="lineNum">    4921 </span><span class="lineCov">       2509 :                 left.x &gt;= bounds-&gt;minx &amp;&amp; left.x &lt; bounds-&gt;minx + dist_error_hv &amp;&amp;</span>
<span class="lineNum">    4922 </span><span class="lineCov">        423 :                 right.x &gt; bounds-&gt;maxx - dist_error_hv &amp;&amp; right.x &lt;= bounds-&gt;maxx ) ||</span>
<span class="lineNum">    4923 </span><span class="lineCov">       1671 :             ( !is_v &amp;&amp; </span>
<span class="lineNum">    4924 </span><span class="lineCov">       3920 :                 right.y &gt;= bounds-&gt;miny &amp;&amp; right.y &lt; bounds-&gt;miny + dist_error_hv &amp;&amp;</span>
<span class="lineNum">    4925 </span><span class="lineCov">        682 :                 left.y &gt; bounds-&gt;maxy - dist_error_hv &amp;&amp; left.y &lt;= bounds-&gt;maxy ))</span>
<span class="lineNum">    4926 </span><span class="lineCov">        163 :             stem-&gt;bbox = true;</span>
<span class="lineNum">    4927 </span><span class="lineCov">       2758 :         stem-&gt;positioned = true;</span>
<span class="lineNum">    4928 </span><span class="lineCov">       2758 :         si = si-&gt;next;</span>
<span class="lineNum">    4929 </span>            :     }
<a name="4930"><span class="lineNum">    4930 </span><span class="lineCov">       1369 : }</span></a>
<span class="lineNum">    4931 </span>            : 
<span class="lineNum">    4932 </span><span class="lineCov">        404 : struct glyphdata *StemInfoToStemData( struct glyphdata *gd,StemInfo *si,int is_v ) {</span>
<span class="lineNum">    4933 </span>            :     DBounds bounds;
<span class="lineNum">    4934 </span>            :     int startcnt;
<span class="lineNum">    4935 </span>            :     
<span class="lineNum">    4936 </span><span class="lineCov">        404 :     if ( si == NULL )</span>
<span class="lineNum">    4937 </span><span class="lineNoCov">          0 : return( gd );</span>
<span class="lineNum">    4938 </span>            :     
<span class="lineNum">    4939 </span><span class="lineCov">        404 :     SplineCharFindBounds( gd-&gt;sc,&amp;bounds );</span>
<span class="lineNum">    4940 </span><span class="lineCov">        404 :     _StemInfoToStemData( gd,si,&amp;bounds,is_v,&amp;startcnt );</span>
<span class="lineNum">    4941 </span>            : 
<span class="lineNum">    4942 </span><span class="lineCov">        404 :     AssignPointsToStems( gd,startcnt,&amp;bounds );</span>
<span class="lineNum">    4943 </span><span class="lineCov">        404 : return( gd );</span>
<a name="4944"><span class="lineNum">    4944 </span>            : }</a>
<span class="lineNum">    4945 </span>            : 
<span class="lineNum">    4946 </span><span class="lineCov">        875 : static int ValidConflictingStem( struct stemdata *stem1,struct stemdata *stem2 ) {</span>
<span class="lineNum">    4947 </span><span class="lineCov">        875 :     int x_dir = fabs( stem1-&gt;unit.y ) &gt; fabs( stem1-&gt;unit.x );</span>
<span class="lineNum">    4948 </span>            :     double s1, e1, s2, e2, temp;
<span class="lineNum">    4949 </span>            :     
<span class="lineNum">    4950 </span><span class="lineCov">       1750 :     s1 = (&amp;stem1-&gt;left.x)[!x_dir] - </span>
<span class="lineNum">    4951 </span><span class="lineCov">        875 :         ((&amp;stem1-&gt;left.x)[x_dir] * (&amp;stem1-&gt;unit.x)[!x_dir] )/(&amp;stem1-&gt;unit.x)[x_dir];</span>
<span class="lineNum">    4952 </span><span class="lineCov">       1750 :     e1 = (&amp;stem1-&gt;right.x)[!x_dir] - </span>
<span class="lineNum">    4953 </span><span class="lineCov">        875 :         ((&amp;stem1-&gt;right.x)[x_dir] * (&amp;stem1-&gt;unit.x)[!x_dir] )/(&amp;stem1-&gt;unit.x)[x_dir];</span>
<span class="lineNum">    4954 </span><span class="lineCov">       1750 :     s2 = (&amp;stem2-&gt;left.x)[!x_dir] - </span>
<span class="lineNum">    4955 </span><span class="lineCov">        875 :         ((&amp;stem2-&gt;left.x)[x_dir] * (&amp;stem2-&gt;unit.x)[!x_dir] )/(&amp;stem2-&gt;unit.x)[x_dir];</span>
<span class="lineNum">    4956 </span><span class="lineCov">       1750 :     e2 = (&amp;stem2-&gt;right.x)[!x_dir] - </span>
<span class="lineNum">    4957 </span><span class="lineCov">        875 :         ((&amp;stem2-&gt;right.x)[x_dir] * (&amp;stem2-&gt;unit.x)[!x_dir] )/(&amp;stem2-&gt;unit.x)[x_dir];</span>
<span class="lineNum">    4958 </span>            : 
<span class="lineNum">    4959 </span><span class="lineCov">        875 :     if ( s1 &gt; e1 ) {</span>
<span class="lineNum">    4960 </span><span class="lineCov">        472 :         temp = s1; s1 = e1; e1 = temp;</span>
<span class="lineNum">    4961 </span>            :     }
<span class="lineNum">    4962 </span><span class="lineCov">        875 :     if ( s2 &gt; e2 ) {</span>
<span class="lineNum">    4963 </span><span class="lineCov">        472 :         temp = s2; s2 = e2; e2 = temp;</span>
<span class="lineNum">    4964 </span>            :     }
<span class="lineNum">    4965 </span>            :     /* If stems don't overlap, then there is no conflict here */
<span class="lineNum">    4966 </span><span class="lineCov">        875 :     if ( s2 &gt;= e1 || s1 &gt;= e2 )</span>
<span class="lineNum">    4967 </span><span class="lineCov">          8 : return( false );</span>
<span class="lineNum">    4968 </span>            :     
<span class="lineNum">    4969 </span>            :     /* Stems which have no points assigned cannot be valid masters for    */
<span class="lineNum">    4970 </span>            :     /* other stems (however there is a notable exception for ghost hints) */
<span class="lineNum">    4971 </span><span class="lineCov">       1683 :     if (( stem1-&gt;lpcnt &gt; 0 || stem1-&gt;rpcnt &gt; 0 ) &amp;&amp; </span>
<span class="lineNum">    4972 </span><span class="lineCov">        894 :         stem2-&gt;lpcnt == 0 &amp;&amp; stem2-&gt;rpcnt == 0 &amp;&amp; !stem2-&gt;ghost )</span>
<span class="lineNum">    4973 </span><span class="lineCov">         49 : return( false );</span>
<span class="lineNum">    4974 </span>            : 
<span class="lineNum">    4975 </span>            :     /* Bounding box stems are always preferred */
<span class="lineNum">    4976 </span><span class="lineCov">        818 :     if ( stem1-&gt;bbox &amp;&amp; !stem2-&gt;bbox )</span>
<span class="lineNum">    4977 </span><span class="lineCov">        158 : return( false );</span>
<span class="lineNum">    4978 </span>            : 
<span class="lineNum">    4979 </span>            :     /* Stems associated with blue zones always preferred to any other stems */
<span class="lineNum">    4980 </span><span class="lineCov">        660 :     if ( stem1-&gt;blue &gt;=0 &amp;&amp; stem2-&gt;blue &lt; 0 )</span>
<span class="lineNum">    4981 </span><span class="lineCov">         23 : return( false );</span>
<span class="lineNum">    4982 </span>            :     /* Don't attempt to handle together stems, linked to different zones */
<span class="lineNum">    4983 </span><span class="lineCov">        637 :     if ( stem1-&gt;blue &gt;=0 &amp;&amp; stem2-&gt;blue &gt;= 0 &amp;&amp; stem1-&gt;blue != stem2-&gt;blue )</span>
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    4985 </span>            :     /* If both stems are associated with a blue zone, but one of them is for */
<span class="lineNum">    4986 </span>            :     /* a ghost hint, then that stem is preferred */
<span class="lineNum">    4987 </span><span class="lineCov">        637 :     if ( stem1-&gt;ghost &amp;&amp; !stem2-&gt;ghost )</span>
<span class="lineNum">    4988 </span><span class="lineCov">         72 : return( false );</span>
<span class="lineNum">    4989 </span>            : 
<span class="lineNum">    4990 </span><span class="lineCov">        565 : return( true );</span>
<a name="4991"><span class="lineNum">    4991 </span>            : }</a>
<span class="lineNum">    4992 </span>            : 
<span class="lineNum">    4993 </span><span class="lineCov">        479 : static int HasDependentStem( struct stemdata *master,struct stemdata *slave ) {</span>
<span class="lineNum">    4994 </span>            :     int i;
<span class="lineNum">    4995 </span>            :     struct stemdata *tstem;
<span class="lineNum">    4996 </span>            :     
<span class="lineNum">    4997 </span><span class="lineCov">        479 :     if ( slave-&gt;master != NULL &amp;&amp; master-&gt;dep_cnt &gt; 0 ) {</span>
<span class="lineNum">    4998 </span><span class="lineCov">         96 :         for ( i=0; i&lt;master-&gt;dep_cnt; i++ ) {</span>
<span class="lineNum">    4999 </span><span class="lineCov">         96 :             tstem = master-&gt;dependent[i].stem;</span>
<span class="lineNum">    5000 </span><span class="lineCov">         96 :             if ( tstem == slave || HasDependentStem( tstem,slave ))</span>
<span class="lineNum">    5001 </span><span class="lineCov">         93 : return( true );</span>
<span class="lineNum">    5002 </span>            :         }
<span class="lineNum">    5003 </span>            :     }
<span class="lineNum">    5004 </span><span class="lineCov">        386 : return( false );</span>
<a name="5005"><span class="lineNum">    5005 </span>            : }</a>
<span class="lineNum">    5006 </span>            : 
<span class="lineNum">    5007 </span><span class="lineCov">         17 : static int PreferEndDep( struct stemdata *stem,</span>
<span class="lineNum">    5008 </span>            :     struct stemdata *smaster,struct stemdata *emaster,char s_type,char e_type ) {
<span class="lineNum">    5009 </span>            :     
<span class="lineNum">    5010 </span><span class="lineCov">         17 :     int hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    5011 </span>            :     double sdist, edist;
<span class="lineNum">    5012 </span>            :     
<span class="lineNum">    5013 </span><span class="lineCov">         17 :     if ( !hv )</span>
<span class="lineNum">    5014 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    5015 </span>            :     
<span class="lineNum">    5016 </span><span class="lineCov">         17 :     if (( s_type == 'a' &amp;&amp; e_type != 'a' ) || ( s_type == 'm' &amp;&amp; e_type == 'i' ))</span>
<span class="lineNum">    5017 </span><span class="lineCov">          1 : return( false );</span>
<span class="lineNum">    5018 </span><span class="lineCov">         16 :     else if (( e_type == 'a' &amp;&amp; s_type != 'a' ) || ( e_type == 'm' &amp;&amp; s_type == 'i' ))</span>
<span class="lineNum">    5019 </span><span class="lineCov">          3 : return( true );</span>
<span class="lineNum">    5020 </span>            :     
<span class="lineNum">    5021 </span><span class="lineCov">         13 :     if ( s_type == 'm' &amp;&amp; s_type == e_type ) {</span>
<span class="lineNum">    5022 </span><span class="lineCov">         11 :         sdist = ( hv==1 ) ? </span>
<span class="lineNum">    5023 </span><span class="lineCov">         21 :             fabs( smaster-&gt;right.y - stem-&gt;right.y ) :</span>
<span class="lineNum">    5024 </span><span class="lineCov">         10 :             fabs( smaster-&gt;left.x - stem-&gt;left.x );</span>
<span class="lineNum">    5025 </span><span class="lineCov">         11 :         edist = ( hv==1 ) ? </span>
<span class="lineNum">    5026 </span><span class="lineCov">         21 :             fabs( emaster-&gt;left.y - stem-&gt;left.y ) :</span>
<span class="lineNum">    5027 </span><span class="lineCov">         10 :             fabs( emaster-&gt;right.x - stem-&gt;right.x );</span>
<span class="lineNum">    5028 </span><span class="lineCov">         11 : return( edist &lt; sdist );</span>
<span class="lineNum">    5029 </span>            :     } else
<span class="lineNum">    5030 </span><span class="lineCov">          2 : return( emaster-&gt;clen &gt; smaster-&gt;clen );</span>
<a name="5031"><span class="lineNum">    5031 </span>            : }</a>
<span class="lineNum">    5032 </span>            : 
<span class="lineNum">    5033 </span><span class="lineCov">       2221 : static void LookForMasterHVStem( struct stemdata *stem,BlueData *bd ) {</span>
<span class="lineNum">    5034 </span><span class="lineCov">       2221 :     struct stemdata *tstem, *smaster=NULL, *emaster=NULL;</span>
<span class="lineNum">    5035 </span><span class="lineCov">       2221 :     struct stembundle *bundle = stem-&gt;bundle;</span>
<span class="lineNum">    5036 </span>            :     double start, end, tstart, tend;
<span class="lineNum">    5037 </span>            :     double ssdist, sedist, esdist, eedist;
<span class="lineNum">    5038 </span>            :     double smin, smax, emin, emax, tsmin, tsmax, temin, temax;
<span class="lineNum">    5039 </span>            :     int is_x, i, link_to_s, stype, etype, allow_s, allow_e;
<span class="lineNum">    5040 </span>            : 
<span class="lineNum">    5041 </span><span class="lineCov">       2221 :     is_x = ( bundle-&gt;unit.x == 1 );</span>
<span class="lineNum">    5042 </span><span class="lineCov">       2221 :     if ( is_x ) {</span>
<span class="lineNum">    5043 </span><span class="lineCov">       1245 :         start = stem-&gt;right.y; end = stem-&gt;left.y;</span>
<span class="lineNum">    5044 </span><span class="lineCov">       1245 :         smin = start - stem-&gt;rmin - 2*dist_error_hv;</span>
<span class="lineNum">    5045 </span><span class="lineCov">       1245 :         smax = start - stem-&gt;rmax + 2*dist_error_hv;</span>
<span class="lineNum">    5046 </span><span class="lineCov">       1245 :         emin = end - stem-&gt;lmin - 2*dist_error_hv;</span>
<span class="lineNum">    5047 </span><span class="lineCov">       1245 :         emax = end - stem-&gt;lmax + 2* dist_error_hv;</span>
<span class="lineNum">    5048 </span>            :     } else {
<span class="lineNum">    5049 </span><span class="lineCov">        976 :         start = stem-&gt;left.x; end = stem-&gt;right.x;</span>
<span class="lineNum">    5050 </span><span class="lineCov">        976 :         smin = start + stem-&gt;lmax - 2*dist_error_hv;</span>
<span class="lineNum">    5051 </span><span class="lineCov">        976 :         smax = start + stem-&gt;lmin + 2*dist_error_hv;</span>
<span class="lineNum">    5052 </span><span class="lineCov">        976 :         emin = end + stem-&gt;rmax - 2*dist_error_hv;</span>
<span class="lineNum">    5053 </span><span class="lineCov">        976 :         emax = end + stem-&gt;rmin + 2*dist_error_hv;</span>
<span class="lineNum">    5054 </span>            :     }
<span class="lineNum">    5055 </span><span class="lineCov">       2221 :     start = ( is_x ) ? stem-&gt;right.y : stem-&gt;left.x;</span>
<span class="lineNum">    5056 </span><span class="lineCov">       2221 :     end = ( is_x ) ? stem-&gt;left.y : stem-&gt;right.x;</span>
<span class="lineNum">    5057 </span><span class="lineCov">       2221 :     stype = etype = '\0';</span>
<span class="lineNum">    5058 </span>            : 
<span class="lineNum">    5059 </span><span class="lineCov">       8562 :     for ( i=0; i&lt;bundle-&gt;cnt; i++ ) {</span>
<span class="lineNum">    5060 </span><span class="lineCov">       6341 :         tstem = bundle-&gt;stemlist[i];</span>
<span class="lineNum">    5061 </span><span class="lineCov">       6341 :         if ( is_x ) {</span>
<span class="lineNum">    5062 </span><span class="lineCov">       3737 :             tstart = tstem-&gt;right.y; tend = tstem-&gt;left.y;</span>
<span class="lineNum">    5063 </span><span class="lineCov">       3737 :             tsmin = tstart - tstem-&gt;rmin - 2*dist_error_hv;</span>
<span class="lineNum">    5064 </span><span class="lineCov">       3737 :             tsmax = tstart - tstem-&gt;rmax + 2*dist_error_hv;</span>
<span class="lineNum">    5065 </span><span class="lineCov">       3737 :             temin = tend - tstem-&gt;lmin - 2*dist_error_hv;</span>
<span class="lineNum">    5066 </span><span class="lineCov">       3737 :             temax = tend - tstem-&gt;lmax + 2* dist_error_hv;</span>
<span class="lineNum">    5067 </span>            :         } else {
<span class="lineNum">    5068 </span><span class="lineCov">       2604 :             tstart = tstem-&gt;left.x; tend = tstem-&gt;right.x;</span>
<span class="lineNum">    5069 </span><span class="lineCov">       2604 :             tsmin = tstart + tstem-&gt;lmax - 2*dist_error_hv;</span>
<span class="lineNum">    5070 </span><span class="lineCov">       2604 :             tsmax = tstart + tstem-&gt;lmin + 2*dist_error_hv;</span>
<span class="lineNum">    5071 </span><span class="lineCov">       2604 :             temin = tend + tstem-&gt;rmax - 2*dist_error_hv;</span>
<span class="lineNum">    5072 </span><span class="lineCov">       2604 :             temax = tend + tstem-&gt;rmin + 2*dist_error_hv;</span>
<span class="lineNum">    5073 </span>            :         }
<span class="lineNum">    5074 </span><span class="lineCov">       6341 :         tstart = ( is_x ) ? tstem-&gt;right.y : tstem-&gt;left.x;</span>
<span class="lineNum">    5075 </span><span class="lineCov">       6341 :         tend = ( is_x ) ? tstem-&gt;left.y : tstem-&gt;right.x;</span>
<span class="lineNum">    5076 </span>            : 
<span class="lineNum">    5077 </span>            :         /* In this loop we are looking if the given stem has conflicts with */
<span class="lineNum">    5078 </span>            :         /* other stems and if anyone of those conflicting stems should      */
<span class="lineNum">    5079 </span>            :         /* take precedence over it */
<span class="lineNum">    5080 </span><span class="lineCov">       7037 :         if ( stem == tstem || tend &lt; start || tstart &gt; end || </span>
<span class="lineNum">    5081 </span><span class="lineCov">       1172 :             !ValidConflictingStem( stem,tstem ) || HasDependentStem( stem,tstem ))</span>
<span class="lineNum">    5082 </span><span class="lineCov">       5958 :     continue;</span>
<span class="lineNum">    5083 </span>            :         /* Usually in case of conflicts we prefer the stem with longer active */
<span class="lineNum">    5084 </span>            :         /* zones. However a stem linked to a blue zone is always preferred to */
<span class="lineNum">    5085 </span>            :         /* a stem which is not, and ghost hints are preferred to any other    */
<span class="lineNum">    5086 </span>            :         /* stems */
<span class="lineNum">    5087 </span><span class="lineCov">        383 :         if ( stem-&gt;clen &gt; tstem-&gt;clen &amp;&amp; ValidConflictingStem( tstem,stem ))</span>
<span class="lineNum">    5088 </span><span class="lineCov">         89 :     continue;</span>
<span class="lineNum">    5089 </span>            :     
<span class="lineNum">    5090 </span><span class="lineCov">        294 :         stem-&gt;confl_cnt++;</span>
<span class="lineNum">    5091 </span>            :     
<span class="lineNum">    5092 </span>            :         /* If the master stem is for a ghost hint or both the stems are    */
<span class="lineNum">    5093 </span>            :         /* linked to the same blue zone, then we can link only to the edge */
<span class="lineNum">    5094 </span>            :         /* which fall into the blue zone */
<span class="lineNum">    5095 </span><span class="lineCov">        819 :         allow_s = ( !tstem-&gt;ghost || tstem-&gt;width == 21 ) &amp;&amp;</span>
<span class="lineNum">    5096 </span><span class="lineCov">        341 :             ( stem-&gt;blue == -1 || stem-&gt;blue != tstem-&gt;blue || bd-&gt;blues[stem-&gt;blue][0] &lt; 0 );</span>
<span class="lineNum">    5097 </span><span class="lineCov">        803 :         allow_e = ( !tstem-&gt;ghost || tstem-&gt;width == 20 ) &amp;&amp;</span>
<span class="lineNum">    5098 </span><span class="lineCov">        326 :             ( stem-&gt;blue == -1 || stem-&gt;blue != tstem-&gt;blue || bd-&gt;blues[stem-&gt;blue][0] &gt; 0 );</span>
<span class="lineNum">    5099 </span>            :         
<span class="lineNum">    5100 </span>            :         /* Assume there are two stems which have (almost) coincident left edges. */
<span class="lineNum">    5101 </span>            :         /* The hinting technique for this case is to merge all points found on   */
<span class="lineNum">    5102 </span>            :         /* those coincident edges together, position them, and then link to the  */
<span class="lineNum">    5103 </span>            :         /* opposite edges. */
<span class="lineNum">    5104 </span>            :         /* However we don't allow merging if both stems can be snapped to a blue    */
<span class="lineNum">    5105 </span>            :         /* zone, unless their edges are _exactly_ coincident, as shifting features  */
<span class="lineNum">    5106 </span>            :         /* relatively to each other instead of snapping them to the same zone would */
<span class="lineNum">    5107 </span>            :         /* obviously be wrong */
<span class="lineNum">    5108 </span><span class="lineCov">        385 :         if ( allow_s &amp;&amp; tstart &gt; smin &amp;&amp; tstart &lt; smax &amp;&amp; start &gt; tsmin &amp;&amp; start &lt; tsmax &amp;&amp;</span>
<span class="lineNum">    5109 </span><span class="lineCov">        112 :             ( stem-&gt;blue == -1 || RealNear( tstart,start ))) {</span>
<span class="lineNum">    5110 </span>            :             
<span class="lineNum">    5111 </span><span class="lineCov">        176 :             if ( smaster == NULL || stype != 'a' || smaster-&gt;clen &lt; tstem-&gt;clen ) {</span>
<span class="lineNum">    5112 </span><span class="lineCov">         88 :                 smaster = tstem;</span>
<span class="lineNum">    5113 </span><span class="lineCov">         88 :                 stype = 'a';</span>
<span class="lineNum">    5114 </span>            :             }
<span class="lineNum">    5115 </span>            :         /* The same case for right edges */
<span class="lineNum">    5116 </span><span class="lineCov">        260 :         } else if ( allow_e &amp;&amp; tend &gt; emin &amp;&amp; tend &lt; emax &amp;&amp; end &gt; temin &amp;&amp; end &lt; temax &amp;&amp;</span>
<span class="lineNum">    5117 </span><span class="lineCov">         76 :             ( stem-&gt;blue == -1 || RealNear( tend,end ))) {</span>
<span class="lineNum">    5118 </span>            : 
<span class="lineNum">    5119 </span><span class="lineCov">         98 :             if ( emaster == NULL || etype != 'a' || emaster-&gt;clen &lt; tstem-&gt;clen ) {</span>
<span class="lineNum">    5120 </span><span class="lineCov">         48 :                 emaster = tstem;</span>
<span class="lineNum">    5121 </span><span class="lineCov">         48 :                 etype = 'a';</span>
<span class="lineNum">    5122 </span>            :             }
<span class="lineNum">    5123 </span>            :             
<span class="lineNum">    5124 </span>            :         /* Nested stems. I first planned to handle them by positioning the      */
<span class="lineNum">    5125 </span>            :         /* narrower stem first, and then linking its edges to the opposed edges */
<span class="lineNum">    5126 </span>            :         /* of the nesting stem. But this works well only in those cases where   */
<span class="lineNum">    5127 </span>            :         /* maintaining the dependent stem width is not important. So now the    */
<span class="lineNum">    5128 </span>            :         /* situations where a narrower or a wider stem can be preferred         */
<span class="lineNum">    5129 </span>            :         /* (because it has longer active zones) are equally possible. In the    */
<span class="lineNum">    5130 </span>            :         /* first case I link to the master stem just one edge of the secondary  */
<span class="lineNum">    5131 </span>            :         /* stem, just like with overlapping stems */
<span class="lineNum">    5132 </span><span class="lineCov">        157 :         } else if ( tstart &gt; start &amp;&amp; tend &lt; end ) {</span>
<span class="lineNum">    5133 </span><span class="lineCov">         46 :             if ( allow_s &amp;&amp; ( smaster == NULL || stype == 'i' ||</span>
<span class="lineNum">    5134 </span><span class="lineCov">          1 :                 ( stype == 'm' &amp;&amp; smaster-&gt;clen &lt; tstem-&gt;clen ))) {</span>
<span class="lineNum">    5135 </span>            : 
<span class="lineNum">    5136 </span><span class="lineCov">         28 :                 smaster = tstem;</span>
<span class="lineNum">    5137 </span><span class="lineCov">         28 :                 stype = 'm';</span>
<span class="lineNum">    5138 </span>            :             }
<span class="lineNum">    5139 </span><span class="lineCov">         92 :             if ( allow_e &amp;&amp; ( emaster == NULL || etype == 'i' ||</span>
<span class="lineNum">    5140 </span><span class="lineNoCov">          0 :                 ( etype == 'm' &amp;&amp; emaster-&gt;clen &lt; tstem-&gt;clen ))) {</span>
<span class="lineNum">    5141 </span>            : 
<span class="lineNum">    5142 </span><span class="lineCov">         29 :                 emaster = tstem;</span>
<span class="lineNum">    5143 </span><span class="lineCov">         29 :                 etype = 'm';</span>
<span class="lineNum">    5144 </span>            :             }
<span class="lineNum">    5145 </span>            :         /* However if we have to prefer the nesting stem, we do as with      */
<span class="lineNum">    5146 </span>            :         /* overlapping stems which require interpolations, i. e. interpolate */
<span class="lineNum">    5147 </span>            :         /* one edge and link to another */
<span class="lineNum">    5148 </span><span class="lineCov">        111 :         } else if ( tstart &lt; start &amp;&amp; tend &gt; end ) {</span>
<span class="lineNum">    5149 </span><span class="lineCov">         13 :             link_to_s = ( allow_s &amp;&amp; ( start - tstart &lt; tend - end ));</span>
<span class="lineNum">    5150 </span><span class="lineCov">         26 :             if ( link_to_s &amp;&amp; ( smaster == NULL ||</span>
<span class="lineNum">    5151 </span><span class="lineNoCov">          0 :                 ( stype == 'i' &amp;&amp; smaster-&gt;clen &lt; tstem-&gt;clen ))) {</span>
<span class="lineNum">    5152 </span><span class="lineCov">          4 :                 smaster = tstem;</span>
<span class="lineNum">    5153 </span><span class="lineCov">          4 :                 stype = 'i';</span>
<span class="lineNum">    5154 </span><span class="lineCov">          9 :             } else if ( !link_to_s &amp;&amp; ( emaster == NULL ||</span>
<span class="lineNum">    5155 </span><span class="lineNoCov">          0 :                 ( etype == 'i' &amp;&amp; emaster-&gt;clen &lt; tstem-&gt;clen ))) {</span>
<span class="lineNum">    5156 </span><span class="lineCov">          9 :                 emaster = tstem;</span>
<span class="lineNum">    5157 </span><span class="lineCov">          9 :                 etype = 'i';</span>
<span class="lineNum">    5158 </span>            :             }
<span class="lineNum">    5159 </span>            :         /* Overlapping stems. Here we first check all 4 distances between */
<span class="lineNum">    5160 </span>            :         /* 4 stem edges. If the closest distance is between left or right */
<span class="lineNum">    5161 </span>            :         /* edges, then the normal technique (in TrueType) is linking them */
<span class="lineNum">    5162 </span>            :         /* with MDRP without maintaining a minimum distance. Otherwise    */
<span class="lineNum">    5163 </span>            :         /* we interpolate an edge of the &quot;slave&quot; stem between already     */
<span class="lineNum">    5164 </span>            :         /* positioned edges of the &quot;master&quot; stem, and then gridfit it     */
<span class="lineNum">    5165 </span><span class="lineCov">         98 :         } else if (( tstart &lt; start &amp;&amp; start &lt; tend &amp;&amp; tend &lt; end ) ||</span>
<span class="lineNum">    5166 </span><span class="lineCov">         50 :             ( start &lt; tstart &amp;&amp; tstart &lt; end &amp;&amp; end &lt; tend )) {</span>
<span class="lineNum">    5167 </span>            :                 
<span class="lineNum">    5168 </span><span class="lineCov">         93 :             ssdist = fabs( start - tstart );</span>
<span class="lineNum">    5169 </span><span class="lineCov">         93 :             sedist = fabs( start - tend );</span>
<span class="lineNum">    5170 </span><span class="lineCov">         93 :             esdist = fabs( end - tstart );</span>
<span class="lineNum">    5171 </span><span class="lineCov">         93 :             eedist = fabs( end - tend );</span>
<span class="lineNum">    5172 </span>            : 
<span class="lineNum">    5173 </span><span class="lineCov">        167 :             if ( allow_s &amp;&amp; ( !allow_e ||</span>
<span class="lineNum">    5174 </span><span class="lineCov">         74 :                 ( stem-&gt;width &lt; tstem-&gt;width/3 &amp;&amp; ssdist &lt; eedist ) ||</span>
<span class="lineNum">    5175 </span><span class="lineCov">         50 :                 ( ssdist &lt;= eedist &amp;&amp; ssdist &lt;= sedist &amp;&amp; ssdist &lt;= esdist )) &amp;&amp;</span>
<span class="lineNum">    5176 </span><span class="lineCov">          1 :                 ( smaster == NULL || ( stype == 'i' || </span>
<span class="lineNum">    5177 </span><span class="lineCov">          1 :                 ( stype == 'm' &amp;&amp; smaster-&gt;clen &lt; tstem-&gt;clen )))) {</span>
<span class="lineNum">    5178 </span>            : 
<span class="lineNum">    5179 </span><span class="lineCov">         46 :                 smaster = tstem;</span>
<span class="lineNum">    5180 </span><span class="lineCov">         46 :                 stype = 'm';</span>
<span class="lineNum">    5181 </span><span class="lineCov">         85 :             } else if ( allow_e &amp;&amp; ( !allow_s ||</span>
<span class="lineNum">    5182 </span><span class="lineCov">         38 :                 ( stem-&gt;width &lt; tstem-&gt;width/3 &amp;&amp; eedist &lt; ssdist ) ||</span>
<span class="lineNum">    5183 </span><span class="lineCov">         33 :                 ( eedist &lt;= ssdist &amp;&amp; eedist &lt;= sedist &amp;&amp; eedist &lt;= esdist )) &amp;&amp;</span>
<span class="lineNum">    5184 </span><span class="lineCov">          1 :                 ( emaster == NULL || ( etype == 'i' || </span>
<span class="lineNum">    5185 </span><span class="lineCov">          1 :                 ( etype == 'm' &amp;&amp; emaster-&gt;clen &lt; tstem-&gt;clen )))) {</span>
<span class="lineNum">    5186 </span>            : 
<span class="lineNum">    5187 </span><span class="lineCov">         22 :                 emaster = tstem;</span>
<span class="lineNum">    5188 </span><span class="lineCov">         22 :                 etype = 'm';</span>
<span class="lineNum">    5189 </span><span class="lineCov">         25 :             } else if ( allow_s &amp;&amp; allow_e &amp;&amp; ( smaster == NULL || </span>
<span class="lineNum">    5190 </span><span class="lineNoCov">          0 :                 ( stype == 'i' &amp;&amp; smaster-&gt;clen &lt; tstem-&gt;clen )) &amp;&amp;</span>
<span class="lineNum">    5191 </span><span class="lineCov">         12 :                 sedist &lt;= esdist &amp;&amp; sedist &lt;= ssdist &amp;&amp; sedist &lt;= eedist ) {</span>
<span class="lineNum">    5192 </span>            : 
<span class="lineNum">    5193 </span><span class="lineCov">         12 :                 smaster = tstem;</span>
<span class="lineNum">    5194 </span><span class="lineCov">         12 :                 stype = 'i';</span>
<span class="lineNum">    5195 </span><span class="lineCov">         13 :             } else if ( allow_s &amp;&amp; allow_e &amp;&amp; ( emaster == NULL || </span>
<span class="lineNum">    5196 </span><span class="lineNoCov">          0 :                 ( etype == 'i' &amp;&amp; emaster-&gt;clen &lt; tstem-&gt;clen )) &amp;&amp;</span>
<span class="lineNum">    5197 </span><span class="lineCov">         11 :                 esdist &lt;= sedist &amp;&amp; esdist &lt;= ssdist &amp;&amp; esdist &lt;= eedist ) {</span>
<span class="lineNum">    5198 </span>            : 
<span class="lineNum">    5199 </span><span class="lineCov">         11 :                 emaster = tstem;</span>
<span class="lineNum">    5200 </span><span class="lineCov">         11 :                 etype = 'i';</span>
<span class="lineNum">    5201 </span>            :             }
<span class="lineNum">    5202 </span>            :         }
<span class="lineNum">    5203 </span>            :     }
<span class="lineNum">    5204 </span><span class="lineCov">       2221 :     if ( smaster != NULL &amp;&amp; emaster != NULL ) {</span>
<span class="lineNum">    5205 </span><span class="lineCov">         17 :         if ( PreferEndDep( stem,smaster,emaster,stype,etype ))</span>
<span class="lineNum">    5206 </span><span class="lineCov">          5 :             smaster = NULL;</span>
<span class="lineNum">    5207 </span>            :         else
<span class="lineNum">    5208 </span><span class="lineCov">         12 :             emaster = NULL;</span>
<span class="lineNum">    5209 </span>            :     }
<span class="lineNum">    5210 </span>            :     
<span class="lineNum">    5211 </span><span class="lineCov">       2221 :     if ( smaster != NULL ) {</span>
<span class="lineNum">    5212 </span><span class="lineCov">        170 :         stem-&gt;master = smaster;</span>
<span class="lineNum">    5213 </span><span class="lineCov">        170 :         if ( smaster-&gt;dependent == NULL )</span>
<span class="lineNum">    5214 </span><span class="lineCov">        166 :             smaster-&gt;dependent = calloc( bundle-&gt;cnt*2,sizeof( struct dependent_stem ));</span>
<span class="lineNum">    5215 </span><span class="lineCov">        170 :         smaster-&gt;dependent[smaster-&gt;dep_cnt].stem = stem;</span>
<span class="lineNum">    5216 </span><span class="lineCov">        170 :         smaster-&gt;dependent[smaster-&gt;dep_cnt].dep_type = stype;</span>
<span class="lineNum">    5217 </span><span class="lineCov">        170 :         smaster-&gt;dependent[smaster-&gt;dep_cnt++].lbase = !is_x;</span>
<span class="lineNum">    5218 </span><span class="lineCov">       2051 :     } else if ( emaster != NULL ) {</span>
<span class="lineNum">    5219 </span><span class="lineCov">        101 :         stem-&gt;master = emaster;</span>
<span class="lineNum">    5220 </span><span class="lineCov">        101 :         if ( emaster-&gt;dependent == NULL )</span>
<span class="lineNum">    5221 </span><span class="lineCov">         98 :             emaster-&gt;dependent = calloc( bundle-&gt;cnt*2,sizeof( struct dependent_stem ));</span>
<span class="lineNum">    5222 </span><span class="lineCov">        101 :         emaster-&gt;dependent[emaster-&gt;dep_cnt  ].stem = stem;</span>
<span class="lineNum">    5223 </span><span class="lineCov">        101 :         emaster-&gt;dependent[emaster-&gt;dep_cnt  ].dep_type = etype;</span>
<span class="lineNum">    5224 </span><span class="lineCov">        101 :         emaster-&gt;dependent[emaster-&gt;dep_cnt++].lbase = is_x;</span>
<span class="lineNum">    5225 </span>            :     }
<span class="lineNum">    5226 </span><span class="lineCov">       2221 : }</span>
<span class="lineNum">    5227 </span>            : 
<span class="lineNum">    5228 </span>            : /* If a stem has been considered depending from another stem which in   */
<span class="lineNum">    5229 </span>            : /* its turn has its own &quot;master&quot;, and the first stem doesn't conflict   */
<span class="lineNum">    5230 </span>            : /* with the &quot;master&quot; of the stem it overlaps (or any other stems), then */
<span class="lineNum">    5231 </span>            : /* this dependency is unneeded and processing it in the autoinstructor  */
<span class="lineNum">    5232 </span>            : /* can even lead to undesired effects. Unfortunately we can't prevent   */
<span class="lineNum">    5233 </span>            : /* detecting such dependecies in LookForMasterHVStem(), because we      */
<a name="5234"><span class="lineNum">    5234 </span>            : /* need to know the whole stem hierarchy first. So look for undesired   */</a>
<span class="lineNum">    5235 </span>            : /* dependencies and clean them now */
<span class="lineNum">    5236 </span><span class="lineCov">       2221 : static void ClearUnneededDeps( struct stemdata *stem ) {</span>
<span class="lineNum">    5237 </span>            :     struct stemdata *master;
<span class="lineNum">    5238 </span>            :     int i, j;
<span class="lineNum">    5239 </span>            :     
<span class="lineNum">    5240 </span><span class="lineCov">       2481 :     if ( stem-&gt;confl_cnt == 1 &amp;&amp; </span>
<span class="lineNum">    5241 </span><span class="lineCov">        515 :         ( master = stem-&gt;master ) != NULL &amp;&amp; master-&gt;master != NULL ) {</span>
<span class="lineNum">    5242 </span>            :         
<span class="lineNum">    5243 </span><span class="lineNoCov">          0 :         stem-&gt;master = NULL;</span>
<span class="lineNum">    5244 </span><span class="lineNoCov">          0 :         for ( i=j=0; i&lt;master-&gt;dep_cnt; i++ ) {</span>
<span class="lineNum">    5245 </span><span class="lineNoCov">          0 :             if ( j&lt;i )</span>
<span class="lineNum">    5246 </span><span class="lineNoCov">          0 :                 memcpy( &amp;master-&gt;dependent[i-1],&amp;master-&gt;dependent[i],</span>
<span class="lineNum">    5247 </span>            :                     sizeof( struct dependent_stem ));
<span class="lineNum">    5248 </span><span class="lineNoCov">          0 :             if ( master-&gt;dependent[i].stem != stem ) j++;</span>
<span class="lineNum">    5249 </span>            :         }
<span class="lineNum">    5250 </span><span class="lineNoCov">          0 :         (master-&gt;dep_cnt)--;</span>
<span class="lineNum">    5251 </span>            :     }
<a name="5252"><span class="lineNum">    5252 </span><span class="lineCov">       2221 : }</span></a>
<span class="lineNum">    5253 </span>            : 
<span class="lineNum">    5254 </span><span class="lineCov">       1644 : static void GDBundleStems( struct glyphdata *gd, int maxtoobig, int needs_deps ) {</span>
<span class="lineNum">    5255 </span>            :     struct stemdata *stem, *tstem;
<span class="lineNum">    5256 </span>            :     int i, j, k, hv, hasl, hasr, stem_cnt;
<span class="lineNum">    5257 </span>            :     struct pointdata *lpd, *rpd;
<span class="lineNum">    5258 </span>            :     double dmove;
<span class="lineNum">    5259 </span>            :     DBounds bounds;
<span class="lineNum">    5260 </span>            :     
<span class="lineNum">    5261 </span>            :     /* Some checks for undesired stems which we couldn't do earlier  */
<span class="lineNum">    5262 </span>            :     
<span class="lineNum">    5263 </span>            :     /* First filter out HV stems which have only &quot;potential&quot; points  */
<span class="lineNum">    5264 </span>            :     /* on their left or right edge. Such stems aren't supposed to be */
<span class="lineNum">    5265 </span>            :     /* used for PS hinting, so we mark them as &quot;too big&quot; */
<span class="lineNum">    5266 </span><span class="lineCov">      12932 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    5267 </span><span class="lineCov">      11288 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    5268 </span><span class="lineCov">      11288 :         hasl = false; hasr = false;</span>
<span class="lineNum">    5269 </span>            :         
<span class="lineNum">    5270 </span><span class="lineCov">      19887 :         if ( IsUnitHV( &amp;stem-&gt;unit,true ) &amp;&amp; </span>
<span class="lineNum">    5271 </span><span class="lineCov">      14793 :             !stem-&gt;toobig &amp;&amp; !stem-&gt;ghost &amp;&amp; !stem-&gt;positioned ) {</span>
<span class="lineNum">    5272 </span><span class="lineCov">       7643 :             for ( j=0; j&lt;stem-&gt;chunk_cnt &amp;&amp; ( !hasl || !hasr ); ++j ) {</span>
<span class="lineNum">    5273 </span><span class="lineCov">       4022 :                 if ( stem-&gt;chunks[j].l!=NULL &amp;&amp; !stem-&gt;chunks[j].lpotential ) </span>
<span class="lineNum">    5274 </span><span class="lineCov">       3582 :                     hasl = true;</span>
<span class="lineNum">    5275 </span><span class="lineCov">       4022 :                 if ( stem-&gt;chunks[j].r!=NULL &amp;&amp; !stem-&gt;chunks[j].rpotential ) </span>
<span class="lineNum">    5276 </span><span class="lineCov">       3574 :                     hasr = true;</span>
<span class="lineNum">    5277 </span>            :             }
<span class="lineNum">    5278 </span><span class="lineCov">       3621 :             if ( !hasl || !hasr )</span>
<span class="lineNum">    5279 </span><span class="lineCov">        130 :                 stem-&gt;toobig = true;</span>
<span class="lineNum">    5280 </span>            :         }
<span class="lineNum">    5281 </span>            :     }
<span class="lineNum">    5282 </span>            : 
<span class="lineNum">    5283 </span>            :     /* Filter out HV stems which have both their edges controlled by */
<span class="lineNum">    5284 </span>            :     /* other, narrower HV stems */
<span class="lineNum">    5285 </span><span class="lineCov">      12932 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    5286 </span><span class="lineCov">      11288 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    5287 </span><span class="lineCov">      11288 :         hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    5288 </span>            : 
<span class="lineNum">    5289 </span><span class="lineCov">      11288 :         if ( IsUnitHV( &amp;stem-&gt;unit,true )) {</span>
<span class="lineNum">    5290 </span><span class="lineCov">       8599 :             hasl = hasr = false;</span>
<span class="lineNum">    5291 </span><span class="lineCov">      26947 :             for ( j=0; j&lt;stem-&gt;chunk_cnt; ++j ) {</span>
<span class="lineNum">    5292 </span><span class="lineCov">      19021 :                 lpd = stem-&gt;chunks[j].l;</span>
<span class="lineNum">    5293 </span><span class="lineCov">      19021 :                 rpd = stem-&gt;chunks[j].r;</span>
<span class="lineNum">    5294 </span><span class="lineCov">      19021 :                 if ( lpd != NULL ) {</span>
<span class="lineNum">    5295 </span><span class="lineCov">      16363 :                     stem_cnt = ( stem-&gt;chunks[j].lnext ) ? lpd-&gt;nextcnt : lpd-&gt;prevcnt;</span>
<span class="lineNum">    5296 </span><span class="lineCov">      36365 :                     for ( k=0; k&lt;stem_cnt; k++ ) {</span>
<span class="lineNum">    5297 </span><span class="lineCov">      44132 :                         tstem = ( stem-&gt;chunks[j].lnext ) ? </span>
<span class="lineNum">    5298 </span><span class="lineCov">      22066 :                             lpd-&gt;nextstems[k] : lpd-&gt;prevstems[k];</span>
<span class="lineNum">    5299 </span>            :                         /* Used to test tstem-&gt;toobig &lt;= stem-&gt;toobig, but got into troubles with */
<span class="lineNum">    5300 </span>            :                         /* a weird terminal stem preventing a ball terminal from being properly detected, */
<span class="lineNum">    5301 </span>            :                         /* because both the stems initially have toobig == 1. */
<span class="lineNum">    5302 </span>            :                         /* See the &quot;f&quot; from Heuristica-Italic */
<span class="lineNum">    5303 </span><span class="lineCov">      28919 :                         if ( tstem != stem &amp;&amp; </span>
<span class="lineNum">    5304 </span><span class="lineCov">      13435 :                             !tstem-&gt;toobig &amp;&amp; tstem-&gt;positioned &gt;= stem-&gt;positioned &amp;&amp;</span>
<span class="lineNum">    5305 </span><span class="lineCov">       5680 :                             tstem-&gt;width &lt; stem-&gt;width &amp;&amp; hv == IsUnitHV( &amp;tstem-&gt;unit,true )) {</span>
<span class="lineNum">    5306 </span><span class="lineCov">       2064 :                             hasl = true;</span>
<span class="lineNum">    5307 </span><span class="lineCov">       2064 :                     break;</span>
<span class="lineNum">    5308 </span>            :                         }
<span class="lineNum">    5309 </span>            :                     }
<span class="lineNum">    5310 </span>            :                 }
<span class="lineNum">    5311 </span><span class="lineCov">      19021 :                 if ( rpd != NULL ) {</span>
<span class="lineNum">    5312 </span><span class="lineCov">      16363 :                     stem_cnt = ( stem-&gt;chunks[j].rnext ) ? rpd-&gt;nextcnt : rpd-&gt;prevcnt;</span>
<span class="lineNum">    5313 </span><span class="lineCov">      36825 :                     for ( k=0; k&lt;stem_cnt; k++ ) {</span>
<span class="lineNum">    5314 </span><span class="lineCov">      45128 :                         tstem = ( stem-&gt;chunks[j].rnext ) ? </span>
<span class="lineNum">    5315 </span><span class="lineCov">      22564 :                             rpd-&gt;nextstems[k] : rpd-&gt;prevstems[k];</span>
<span class="lineNum">    5316 </span><span class="lineCov">      30013 :                         if ( tstem != stem &amp;&amp; </span>
<span class="lineNum">    5317 </span><span class="lineCov">      15039 :                             !tstem-&gt;toobig &amp;&amp; tstem-&gt;positioned &gt;= stem-&gt;positioned &amp;&amp;</span>
<span class="lineNum">    5318 </span><span class="lineCov">       6509 :                             tstem-&gt;width &lt; stem-&gt;width &amp;&amp; hv == IsUnitHV( &amp;tstem-&gt;unit,true )) {</span>
<span class="lineNum">    5319 </span><span class="lineCov">       2102 :                             hasr = true;</span>
<span class="lineNum">    5320 </span><span class="lineCov">       2102 :                     break;</span>
<span class="lineNum">    5321 </span>            :                         }
<span class="lineNum">    5322 </span>            :                     }
<span class="lineNum">    5323 </span>            :                 }
<span class="lineNum">    5324 </span><span class="lineCov">      19021 :                 if ( hasl &amp;&amp; hasr ) {</span>
<span class="lineNum">    5325 </span><span class="lineCov">        673 :                     stem-&gt;toobig = 2;</span>
<span class="lineNum">    5326 </span><span class="lineCov">        673 :             break;</span>
<span class="lineNum">    5327 </span>            :                 }
<span class="lineNum">    5328 </span>            :             }
<span class="lineNum">    5329 </span>            :         }
<span class="lineNum">    5330 </span>            :     }
<span class="lineNum">    5331 </span>            :     
<span class="lineNum">    5332 </span><span class="lineCov">       1644 :     gd-&gt;hbundle = calloc( 1,sizeof( struct stembundle ));</span>
<span class="lineNum">    5333 </span><span class="lineCov">       1644 :     gd-&gt;hbundle-&gt;stemlist = calloc( gd-&gt;stemcnt,sizeof( struct stemdata *));</span>
<span class="lineNum">    5334 </span><span class="lineCov">       1644 :     gd-&gt;hbundle-&gt;unit.x = 1; gd-&gt;hbundle-&gt;unit.y = 0;</span>
<span class="lineNum">    5335 </span><span class="lineCov">       1644 :     gd-&gt;hbundle-&gt;l_to_r.x = 0; gd-&gt;hbundle-&gt;l_to_r.y = -1;</span>
<span class="lineNum">    5336 </span>            : 
<span class="lineNum">    5337 </span><span class="lineCov">       1644 :     gd-&gt;vbundle = calloc( 1,sizeof( struct stembundle ));</span>
<span class="lineNum">    5338 </span><span class="lineCov">       1644 :     gd-&gt;vbundle-&gt;stemlist = calloc( gd-&gt;stemcnt,sizeof( struct stemdata *));</span>
<span class="lineNum">    5339 </span><span class="lineCov">       1644 :     gd-&gt;vbundle-&gt;unit.x = 0; gd-&gt;vbundle-&gt;unit.y = 1;</span>
<span class="lineNum">    5340 </span><span class="lineCov">       1644 :     gd-&gt;vbundle-&gt;l_to_r.x = 1; gd-&gt;vbundle-&gt;l_to_r.y = 0;</span>
<span class="lineNum">    5341 </span>            :     
<span class="lineNum">    5342 </span><span class="lineCov">       1644 :     if ( gd-&gt;has_slant &amp;&amp; !gd-&gt;only_hv ) {</span>
<span class="lineNum">    5343 </span><span class="lineNoCov">          0 :         SplineCharFindBounds( gd-&gt;sc,&amp;bounds );</span>
<span class="lineNum">    5344 </span>            :         
<span class="lineNum">    5345 </span><span class="lineNoCov">          0 :         gd-&gt;ibundle = calloc( 1,sizeof( struct stembundle ));</span>
<span class="lineNum">    5346 </span><span class="lineNoCov">          0 :         gd-&gt;ibundle-&gt;stemlist = calloc( gd-&gt;stemcnt,sizeof( struct stemdata *));</span>
<span class="lineNum">    5347 </span><span class="lineNoCov">          0 :         gd-&gt;ibundle-&gt;unit.x = gd-&gt;slant_unit.x; </span>
<span class="lineNum">    5348 </span><span class="lineNoCov">          0 :         gd-&gt;ibundle-&gt;unit.y = gd-&gt;slant_unit.y;</span>
<span class="lineNum">    5349 </span><span class="lineNoCov">          0 :         gd-&gt;ibundle-&gt;l_to_r.x = -gd-&gt;ibundle-&gt;unit.y; </span>
<span class="lineNum">    5350 </span><span class="lineNoCov">          0 :         gd-&gt;ibundle-&gt;l_to_r.y = gd-&gt;ibundle-&gt;unit.x;</span>
<span class="lineNum">    5351 </span>            :     }
<span class="lineNum">    5352 </span>            : 
<span class="lineNum">    5353 </span><span class="lineCov">      12932 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    5354 </span><span class="lineCov">      11288 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    5355 </span><span class="lineCov">      11288 :         if ( stem-&gt;toobig &gt; maxtoobig )</span>
<span class="lineNum">    5356 </span><span class="lineCov">       4690 :     continue;</span>
<span class="lineNum">    5357 </span><span class="lineCov">       6598 :         hv = IsUnitHV( &amp;stem-&gt;unit,true );</span>
<span class="lineNum">    5358 </span>            :         
<span class="lineNum">    5359 </span><span class="lineCov">       6598 :         if ( hv == 1 ) {</span>
<span class="lineNum">    5360 </span><span class="lineCov">       3435 :             gd-&gt;hbundle-&gt;stemlist[(gd-&gt;hbundle-&gt;cnt)++] = stem;</span>
<span class="lineNum">    5361 </span><span class="lineCov">       3435 :             stem-&gt;bundle = gd-&gt;hbundle;</span>
<span class="lineNum">    5362 </span><span class="lineCov">       3163 :         } else if ( hv == 2 ) {</span>
<span class="lineNum">    5363 </span><span class="lineCov">       2626 :             gd-&gt;vbundle-&gt;stemlist[(gd-&gt;vbundle-&gt;cnt)++] = stem;</span>
<span class="lineNum">    5364 </span><span class="lineCov">       2626 :             stem-&gt;bundle = gd-&gt;vbundle;</span>
<span class="lineNum">    5365 </span><span class="lineCov">        537 :         } else if ( gd-&gt;has_slant &amp;&amp; !gd-&gt;only_hv &amp;&amp;</span>
<span class="lineNum">    5366 </span><span class="lineNoCov">          0 :             RealNear( stem-&gt;unit.x,gd-&gt;slant_unit.x ) &amp;&amp;</span>
<span class="lineNum">    5367 </span><span class="lineNoCov">          0 :             RealNear( stem-&gt;unit.y,gd-&gt;slant_unit.y )) {</span>
<span class="lineNum">    5368 </span>            :             
<span class="lineNum">    5369 </span>            :             /* Move base point coordinates to the baseline to simplify */
<span class="lineNum">    5370 </span>            :             /* stem ordering and positioning relatively to each other  */
<span class="lineNum">    5371 </span><span class="lineNoCov">          0 :             stem-&gt;left.x -= (( stem-&gt;left.y - bounds.miny ) * stem-&gt;unit.x )/stem-&gt;unit.y;</span>
<span class="lineNum">    5372 </span><span class="lineNoCov">          0 :             stem-&gt;right.x -= (( stem-&gt;right.y - bounds.miny ) * stem-&gt;unit.x )/stem-&gt;unit.y;</span>
<span class="lineNum">    5373 </span><span class="lineNoCov">          0 :             dmove = ( stem-&gt;left.y - bounds.miny ) / stem-&gt;unit.y;</span>
<span class="lineNum">    5374 </span><span class="lineNoCov">          0 :             stem-&gt;left.y = stem-&gt;right.y = bounds.miny;</span>
<span class="lineNum">    5375 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;stem-&gt;activecnt; j++ ) {</span>
<span class="lineNum">    5376 </span><span class="lineNoCov">          0 :                 stem-&gt;active[j].start += dmove;</span>
<span class="lineNum">    5377 </span><span class="lineNoCov">          0 :                 stem-&gt;active[j].end += dmove;</span>
<span class="lineNum">    5378 </span>            :             }
<span class="lineNum">    5379 </span>            : 
<span class="lineNum">    5380 </span><span class="lineNoCov">          0 :             gd-&gt;ibundle-&gt;stemlist[(gd-&gt;ibundle-&gt;cnt)++] = stem;</span>
<span class="lineNum">    5381 </span><span class="lineNoCov">          0 :             stem-&gt;bundle = gd-&gt;ibundle;</span>
<span class="lineNum">    5382 </span><span class="lineNoCov">          0 :             stem-&gt;italic = true;</span>
<span class="lineNum">    5383 </span>            :         }
<span class="lineNum">    5384 </span>            :     }
<span class="lineNum">    5385 </span><span class="lineCov">       1644 :     qsort( gd-&gt;hbundle-&gt;stemlist,gd-&gt;hbundle-&gt;cnt,sizeof( struct stemdata *),stem_cmp );</span>
<span class="lineNum">    5386 </span><span class="lineCov">       1644 :     qsort( gd-&gt;vbundle-&gt;stemlist,gd-&gt;vbundle-&gt;cnt,sizeof( struct stemdata *),stem_cmp );</span>
<span class="lineNum">    5387 </span><span class="lineCov">       1644 :     if ( gd-&gt;has_slant &amp;&amp; !gd-&gt;only_hv )</span>
<span class="lineNum">    5388 </span><span class="lineNoCov">          0 :         qsort( gd-&gt;ibundle-&gt;stemlist,gd-&gt;ibundle-&gt;cnt,sizeof( struct stemdata *),stem_cmp );</span>
<span class="lineNum">    5389 </span>            :     
<span class="lineNum">    5390 </span><span class="lineCov">       1644 :     if ( !needs_deps )</span>
<span class="lineNum">    5391 </span><span class="lineCov">       2740 : return;</span>
<span class="lineNum">    5392 </span><span class="lineCov">       1793 :     for ( i=0; i&lt;gd-&gt;hbundle-&gt;cnt; i++ )</span>
<span class="lineNum">    5393 </span><span class="lineCov">       1245 :         LookForMasterHVStem( gd-&gt;hbundle-&gt;stemlist[i],&amp;gd-&gt;bd );</span>
<span class="lineNum">    5394 </span><span class="lineCov">       1793 :     for ( i=0; i&lt;gd-&gt;hbundle-&gt;cnt; i++ )</span>
<span class="lineNum">    5395 </span><span class="lineCov">       1245 :         ClearUnneededDeps( gd-&gt;hbundle-&gt;stemlist[i] );</span>
<span class="lineNum">    5396 </span><span class="lineCov">       1524 :     for ( i=0; i&lt;gd-&gt;vbundle-&gt;cnt; i++ )</span>
<span class="lineNum">    5397 </span><span class="lineCov">        976 :         LookForMasterHVStem( gd-&gt;vbundle-&gt;stemlist[i],&amp;gd-&gt;bd );</span>
<span class="lineNum">    5398 </span><span class="lineCov">       1524 :     for ( i=0; i&lt;gd-&gt;vbundle-&gt;cnt; i++ )</span>
<span class="lineNum">    5399 </span><span class="lineCov">        976 :         ClearUnneededDeps( gd-&gt;vbundle-&gt;stemlist[i] );</span>
<a name="5400"><span class="lineNum">    5400 </span>            : }</a>
<span class="lineNum">    5401 </span>            : 
<span class="lineNum">    5402 </span><span class="lineCov">        403 : static void AddSerifOrBall( struct glyphdata *gd,</span>
<span class="lineNum">    5403 </span>            :     struct stemdata *master,struct stemdata *slave,int lbase,int is_ball ) {
<span class="lineNum">    5404 </span>            :     
<span class="lineNum">    5405 </span>            :     struct dependent_serif *tserif;
<span class="lineNum">    5406 </span><span class="lineCov">        403 :     struct pointdata *spd, *bpd=NULL;</span>
<span class="lineNum">    5407 </span>            :     double width, min, max;
<span class="lineNum">    5408 </span>            :     int i, j, refidx, scnt, next;
<span class="lineNum">    5409 </span>            :     
<span class="lineNum">    5410 </span><span class="lineCov">        403 :     if ( lbase ) {</span>
<span class="lineNum">    5411 </span><span class="lineCov">        185 :         width = fabs(</span>
<span class="lineNum">    5412 </span><span class="lineCov">        370 :                 ( slave-&gt;right.x - master-&gt;left.x ) * master-&gt;unit.y -</span>
<span class="lineNum">    5413 </span><span class="lineCov">        185 :                 ( slave-&gt;right.y - master-&gt;left.y ) * master-&gt;unit.x );</span>
<span class="lineNum">    5414 </span><span class="lineCov">        185 :         max = width + slave-&gt;rmin + 2*dist_error_hv;</span>
<span class="lineNum">    5415 </span><span class="lineCov">        185 :         min = width + slave-&gt;rmax - 2*dist_error_hv;</span>
<span class="lineNum">    5416 </span>            :     } else {
<span class="lineNum">    5417 </span><span class="lineCov">        218 :         width = fabs(</span>
<span class="lineNum">    5418 </span><span class="lineCov">        436 :                 ( master-&gt;right.x - slave-&gt;left.x ) * master-&gt;unit.y -</span>
<span class="lineNum">    5419 </span><span class="lineCov">        218 :                 ( master-&gt;right.y - slave-&gt;left.y ) * master-&gt;unit.x );</span>
<span class="lineNum">    5420 </span><span class="lineCov">        218 :         max = width - slave-&gt;lmax + 2*dist_error_hv;</span>
<span class="lineNum">    5421 </span><span class="lineCov">        218 :         min = width - slave-&gt;lmin - 2*dist_error_hv;</span>
<span class="lineNum">    5422 </span>            :     }
<span class="lineNum">    5423 </span>            :     
<span class="lineNum">    5424 </span><span class="lineCov">        403 :     scnt = master-&gt;serif_cnt;</span>
<span class="lineNum">    5425 </span><span class="lineCov">        515 :     for ( i=0; i&lt;scnt; i++ ) {</span>
<span class="lineNum">    5426 </span><span class="lineCov">        152 :         tserif = &amp;master-&gt;serifs[i];</span>
<span class="lineNum">    5427 </span><span class="lineCov">        152 :         if ( tserif-&gt;stem == slave &amp;&amp; tserif-&gt;lbase == lbase )</span>
<span class="lineNum">    5428 </span>            :     break;
<span class="lineNum">    5429 </span><span class="lineCov">        152 :         else if ( tserif-&gt;width &gt; min &amp;&amp; tserif-&gt;width &lt; max &amp;&amp; tserif-&gt;lbase == lbase ) {</span>
<span class="lineNum">    5430 </span><span class="lineCov">        171 :             for ( j=0; j&lt;slave-&gt;chunk_cnt; j++ ) {</span>
<span class="lineNum">    5431 </span><span class="lineCov">        131 :                 spd = ( lbase ) ? slave-&gt;chunks[j].r : slave-&gt;chunks[j].l;</span>
<span class="lineNum">    5432 </span><span class="lineCov">        131 :                 next = ( lbase ) ? slave-&gt;chunks[j].rnext : slave-&gt;chunks[j].lnext;</span>
<span class="lineNum">    5433 </span><span class="lineCov">        131 :                 if ( spd != NULL &amp;&amp; IsStemAssignedToPoint( spd,tserif-&gt;stem,next ) == -1 )</span>
<span class="lineNum">    5434 </span><span class="lineCov">         18 :                     AddToStem( gd,tserif-&gt;stem,spd,NULL,next,false,false );</span>
<span class="lineNum">    5435 </span>            :             }
<span class="lineNum">    5436 </span><span class="lineCov">         40 :     break;</span>
<span class="lineNum">    5437 </span>            :         }
<span class="lineNum">    5438 </span>            :     }
<span class="lineNum">    5439 </span><span class="lineCov">        403 :     if ( i&lt;master-&gt;serif_cnt )</span>
<span class="lineNum">    5440 </span><span class="lineCov">        443 : return;</span>
<span class="lineNum">    5441 </span>            :     
<span class="lineNum">    5442 </span><span class="lineCov">        363 :     refidx = ( lbase ) ? master-&gt;leftidx : master-&gt;rightidx;</span>
<span class="lineNum">    5443 </span><span class="lineCov">        363 :     if ( refidx != -1 ) bpd = &amp;gd-&gt;points[refidx];</span>
<span class="lineNum">    5444 </span><span class="lineCov">        726 :     master-&gt;serifs = realloc(</span>
<span class="lineNum">    5445 </span><span class="lineCov">        726 :         master-&gt;serifs,( scnt+1 )*sizeof( struct dependent_serif ));</span>
<span class="lineNum">    5446 </span><span class="lineCov">        363 :     master-&gt;serifs[scnt].stem = slave;</span>
<span class="lineNum">    5447 </span><span class="lineCov">        363 :     master-&gt;serifs[scnt].width = width;</span>
<span class="lineNum">    5448 </span><span class="lineCov">        363 :     master-&gt;serifs[scnt].lbase = lbase;</span>
<span class="lineNum">    5449 </span><span class="lineCov">        363 :     master-&gt;serifs[scnt].is_ball = is_ball;</span>
<span class="lineNum">    5450 </span><span class="lineCov">        363 :     master-&gt;serif_cnt++;</span>
<span class="lineNum">    5451 </span>            :     
<span class="lineNum">    5452 </span>            :     /* Mark the dependent stem as related with a bundle, although it */
<span class="lineNum">    5453 </span>            :     /* is not listed in that bundle itself */
<span class="lineNum">    5454 </span><span class="lineCov">        363 :     slave-&gt;bundle = master-&gt;bundle;</span>
<a name="5455"><span class="lineNum">    5455 </span>            : }</a>
<span class="lineNum">    5456 </span>            : 
<span class="lineNum">    5457 </span><span class="lineCov">        944 : static int IsBall( struct glyphdata *gd,</span>
<span class="lineNum">    5458 </span>            :     struct pointdata *pd,struct stemdata *master,int lbase ) {
<span class="lineNum">    5459 </span>            :     
<span class="lineNum">    5460 </span>            :     double max, min, dot, coord;
<span class="lineNum">    5461 </span>            :     BasePoint *lbp, *rbp, *dir;
<span class="lineNum">    5462 </span>            :     Spline *test;
<span class="lineNum">    5463 </span>            :     struct pointdata *nbase, *pbase, *tpd;
<span class="lineNum">    5464 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    5465 </span>            :     int i, is_x, peak_passed;
<span class="lineNum">    5466 </span>            :     
<span class="lineNum">    5467 </span><span class="lineCov">        944 :     if ( pd == NULL || ( pd-&gt;x_extr != 1 &amp;&amp; pd-&gt;y_extr != 1 ))</span>
<span class="lineNum">    5468 </span><span class="lineCov">        865 : return( false );</span>
<span class="lineNum">    5469 </span>            : 
<span class="lineNum">    5470 </span><span class="lineCov">         79 :     is_x = ( IsUnitHV( &amp;master-&gt;unit,true ) == 1 );</span>
<span class="lineNum">    5471 </span><span class="lineCov">         79 :     lbp = ( lbase ) ? &amp;master-&gt;left : &amp;pd-&gt;base;</span>
<span class="lineNum">    5472 </span><span class="lineCov">         79 :     rbp = ( lbase ) ? &amp;pd-&gt;base : &amp;master-&gt;right;</span>
<span class="lineNum">    5473 </span><span class="lineCov">         79 :     min = ( is_x ) ? rbp-&gt;y : lbp-&gt;x;</span>
<span class="lineNum">    5474 </span><span class="lineCov">         79 :     max = ( is_x ) ? lbp-&gt;y : rbp-&gt;x;</span>
<span class="lineNum">    5475 </span>            :     
<span class="lineNum">    5476 </span><span class="lineCov">         79 :     peak_passed = false;</span>
<span class="lineNum">    5477 </span><span class="lineCov">         79 :     nbase = pbase = NULL;</span>
<span class="lineNum">    5478 </span><span class="lineCov">         79 :     test = pd-&gt;sp-&gt;next;</span>
<span class="lineNum">    5479 </span><span class="lineCov">         79 :     dir = &amp;pd-&gt;nextunit;</span>
<span class="lineNum">    5480 </span>            : 
<span class="lineNum">    5481 </span><span class="lineCov">         79 :     if ( test != NULL ) do {</span>
<span class="lineNum">    5482 </span><span class="lineCov">        309 :         tpd = &amp;gd-&gt;points[test-&gt;to-&gt;ptindex];</span>
<span class="lineNum">    5483 </span><span class="lineCov">        309 :         if ( IsStemAssignedToPoint( tpd,master,true ) != -1 ) {</span>
<span class="lineNum">    5484 </span><span class="lineCov">         48 :             nbase = tpd;</span>
<span class="lineNum">    5485 </span><span class="lineCov">         48 :     break;</span>
<span class="lineNum">    5486 </span>            :         }
<span class="lineNum">    5487 </span><span class="lineCov">        261 :         coord = ( is_x ) ? tpd-&gt;base.y : tpd-&gt;base.x;</span>
<span class="lineNum">    5488 </span><span class="lineCov">        261 :         dot = tpd-&gt;nextunit.x * dir-&gt;x + tpd-&gt;nextunit.y * dir-&gt;y;</span>
<span class="lineNum">    5489 </span><span class="lineCov">        261 :         if ( dot == 0 &amp;&amp; !peak_passed ) {</span>
<span class="lineNum">    5490 </span><span class="lineCov">         57 :             dir = &amp;tpd-&gt;nextunit;</span>
<span class="lineNum">    5491 </span><span class="lineCov">         57 :             dot = 1.0;</span>
<span class="lineNum">    5492 </span><span class="lineCov">         57 :             peak_passed = true;</span>
<span class="lineNum">    5493 </span>            :         }
<span class="lineNum">    5494 </span><span class="lineCov">        261 :         test = test-&gt;to-&gt;next;</span>
<span class="lineNum">    5495 </span><span class="lineCov">        261 :     } while ( test != NULL &amp;&amp; test != pd-&gt;sp-&gt;next &amp;&amp; dot &gt; 0 &amp;&amp;</span>
<span class="lineNum">    5496 </span><span class="lineCov">        494 :         coord &gt;= min &amp;&amp; coord &lt;= max );</span>
<span class="lineNum">    5497 </span>            : 
<span class="lineNum">    5498 </span><span class="lineCov">         79 :     peak_passed = false;</span>
<span class="lineNum">    5499 </span><span class="lineCov">         79 :     test = pd-&gt;sp-&gt;prev;</span>
<span class="lineNum">    5500 </span><span class="lineCov">         79 :     dir = &amp;pd-&gt;prevunit;</span>
<span class="lineNum">    5501 </span><span class="lineCov">         79 :     if ( test != NULL ) do {</span>
<span class="lineNum">    5502 </span><span class="lineCov">        335 :         tpd = &amp;gd-&gt;points[test-&gt;from-&gt;ptindex];</span>
<span class="lineNum">    5503 </span><span class="lineCov">        335 :         if ( IsStemAssignedToPoint( tpd,master,false ) != -1 ) {</span>
<span class="lineNum">    5504 </span><span class="lineCov">         47 :             pbase = tpd;</span>
<span class="lineNum">    5505 </span><span class="lineCov">         47 :     break;</span>
<span class="lineNum">    5506 </span>            :         }
<span class="lineNum">    5507 </span><span class="lineCov">        288 :         coord = ( is_x ) ? tpd-&gt;base.y : tpd-&gt;base.x;</span>
<span class="lineNum">    5508 </span><span class="lineCov">        288 :         dot = tpd-&gt;prevunit.x * dir-&gt;x + tpd-&gt;prevunit.y * dir-&gt;y;</span>
<span class="lineNum">    5509 </span><span class="lineCov">        288 :         if ( dot == 0 &amp;&amp; !peak_passed ) {</span>
<span class="lineNum">    5510 </span><span class="lineCov">         52 :             dir = &amp;tpd-&gt;prevunit;</span>
<span class="lineNum">    5511 </span><span class="lineCov">         52 :             dot = 1.0;</span>
<span class="lineNum">    5512 </span><span class="lineCov">         52 :             peak_passed = true;</span>
<span class="lineNum">    5513 </span>            :         }
<span class="lineNum">    5514 </span><span class="lineCov">        288 :         test = test-&gt;from-&gt;prev;</span>
<span class="lineNum">    5515 </span><span class="lineCov">        288 :     } while ( test != NULL &amp;&amp; test != pd-&gt;sp-&gt;prev &amp;&amp; dot &gt; 0 &amp;&amp;</span>
<span class="lineNum">    5516 </span><span class="lineCov">        546 :         coord &gt;= min &amp;&amp; coord &lt;= max );</span>
<span class="lineNum">    5517 </span>            : 
<span class="lineNum">    5518 </span><span class="lineCov">         79 :     if ( nbase != NULL &amp;&amp; pbase != NULL ) {</span>
<span class="lineNum">    5519 </span><span class="lineCov">         66 :         for ( i=0; i&lt;master-&gt;chunk_cnt; i++ ) {</span>
<span class="lineNum">    5520 </span><span class="lineCov">         65 :             chunk = &amp;master-&gt;chunks[i];</span>
<span class="lineNum">    5521 </span><span class="lineCov">        118 :             if (( chunk-&gt;l == nbase &amp;&amp; chunk-&gt;r == pbase ) ||</span>
<span class="lineNum">    5522 </span><span class="lineCov">         80 :                 ( chunk-&gt;l == pbase &amp;&amp; chunk-&gt;r == nbase ))</span>
<span class="lineNum">    5523 </span><span class="lineCov">         30 : return( true );</span>
<span class="lineNum">    5524 </span>            :         }
<span class="lineNum">    5525 </span>            :     }
<span class="lineNum">    5526 </span><span class="lineCov">         49 : return( false );</span>
<a name="5527"><span class="lineNum">    5527 </span>            : }</a>
<span class="lineNum">    5528 </span>            : 
<span class="lineNum">    5529 </span><span class="lineCov">        618 : static void GetSerifData( struct glyphdata *gd,struct stemdata *stem ) {</span>
<span class="lineNum">    5530 </span>            :     int i, j, is_x, stem_cnt;
<span class="lineNum">    5531 </span>            :     int snext, enext, eidx, allow_s, allow_e, s_ball, e_ball;
<span class="lineNum">    5532 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    5533 </span><span class="lineCov">        618 :     struct stemdata *tstem, *smaster=NULL, *emaster=NULL;</span>
<span class="lineNum">    5534 </span>            :     struct pointdata *spd, *epd;
<span class="lineNum">    5535 </span>            :     struct stembundle *bundle;
<span class="lineNum">    5536 </span>            :     double start, end, tstart, tend, smend, emstart;
<span class="lineNum">    5537 </span>            :     
<span class="lineNum">    5538 </span><span class="lineCov">        618 :     is_x = ( IsUnitHV( &amp;stem-&gt;unit,true ) == 1 );</span>
<span class="lineNum">    5539 </span><span class="lineCov">        618 :     bundle = ( is_x ) ? gd-&gt;hbundle : gd-&gt;vbundle;</span>
<span class="lineNum">    5540 </span><span class="lineCov">        618 :     start = ( is_x ) ? stem-&gt;right.y : stem-&gt;left.x;</span>
<span class="lineNum">    5541 </span><span class="lineCov">        618 :     end = ( is_x ) ? stem-&gt;left.y : stem-&gt;right.x;</span>
<span class="lineNum">    5542 </span>            : 
<span class="lineNum">    5543 </span><span class="lineCov">        618 :     allow_s = allow_e = true;</span>
<span class="lineNum">    5544 </span><span class="lineCov">        618 :     s_ball = e_ball = 0;</span>
<span class="lineNum">    5545 </span><span class="lineCov">       2115 :     for ( i=0; i&lt;stem-&gt;chunk_cnt &amp;&amp; ( allow_s == true || allow_e == true ); i++ ) {</span>
<span class="lineNum">    5546 </span><span class="lineCov">       1497 :         chunk = &amp;stem-&gt;chunks[i];</span>
<span class="lineNum">    5547 </span><span class="lineCov">       1497 :         spd = ( is_x ) ? chunk-&gt;r : chunk-&gt;l;</span>
<span class="lineNum">    5548 </span><span class="lineCov">       1497 :         snext = ( is_x ) ? chunk-&gt;rnext : chunk-&gt;lnext;</span>
<span class="lineNum">    5549 </span><span class="lineCov">       1497 :         epd = ( is_x ) ? chunk-&gt;l : chunk-&gt;r;</span>
<span class="lineNum">    5550 </span><span class="lineCov">       1497 :         enext = ( is_x ) ? chunk-&gt;lnext : chunk-&gt;rnext;</span>
<span class="lineNum">    5551 </span>            :         
<span class="lineNum">    5552 </span><span class="lineCov">       1497 :         if ( spd != NULL &amp;&amp; allow_e ) {</span>
<span class="lineNum">    5553 </span><span class="lineCov">        991 :             stem_cnt = ( snext ) ? spd-&gt;nextcnt : spd-&gt;prevcnt;</span>
<span class="lineNum">    5554 </span><span class="lineCov">       2588 :             for ( j=0; j&lt;stem_cnt; j++ ) {</span>
<span class="lineNum">    5555 </span><span class="lineCov">       1597 :                 tstem = ( snext ) ? spd-&gt;nextstems[j] : spd-&gt;prevstems[j];</span>
<span class="lineNum">    5556 </span><span class="lineCov">       3159 :                 if (RealNear( tstem-&gt;unit.x,stem-&gt;unit.x ) &amp;&amp; RealNear( tstem-&gt;unit.y,stem-&gt;unit.y ) &amp;&amp;</span>
<span class="lineNum">    5557 </span><span class="lineCov">       1562 :                     !tstem-&gt;toobig ) {</span>
<span class="lineNum">    5558 </span><span class="lineCov">        395 :                     chunk-&gt;is_ball = e_ball = IsBall( gd,epd,tstem,!is_x );</span>
<span class="lineNum">    5559 </span><span class="lineCov">        395 :                     if ( e_ball ) {</span>
<span class="lineNum">    5560 </span><span class="lineCov">         11 :                         chunk-&gt;ball_m = tstem;</span>
<span class="lineNum">    5561 </span><span class="lineCov">         11 :                         emaster = tstem;</span>
<span class="lineNum">    5562 </span><span class="lineCov">         11 :                         emstart = ( is_x ) ? tstem-&gt;right.y : tstem-&gt;left.x;</span>
<span class="lineNum">    5563 </span>            :                     }
<span class="lineNum">    5564 </span><span class="lineCov">        395 :                     allow_s = false;</span>
<span class="lineNum">    5565 </span>            :                 }
<span class="lineNum">    5566 </span>            :             }
<span class="lineNum">    5567 </span>            :             
<span class="lineNum">    5568 </span>            :         }
<span class="lineNum">    5569 </span><span class="lineCov">       1497 :         if ( epd != NULL &amp;&amp; allow_s ) {</span>
<span class="lineNum">    5570 </span><span class="lineCov">        958 :             stem_cnt = ( enext ) ? epd-&gt;nextcnt : epd-&gt;prevcnt;</span>
<span class="lineNum">    5571 </span><span class="lineCov">       2733 :             for ( j=0; j&lt;stem_cnt; j++ ) {</span>
<span class="lineNum">    5572 </span><span class="lineCov">       1775 :                 tstem = ( enext ) ? epd-&gt;nextstems[j] : epd-&gt;prevstems[j];</span>
<span class="lineNum">    5573 </span><span class="lineCov">       3522 :                 if (tstem-&gt;unit.x == stem-&gt;unit.x &amp;&amp; tstem-&gt;unit.y == stem-&gt;unit.y &amp;&amp;</span>
<span class="lineNum">    5574 </span><span class="lineCov">       1747 :                     !tstem-&gt;toobig ) {</span>
<span class="lineNum">    5575 </span><span class="lineCov">        549 :                     chunk-&gt;is_ball = s_ball = IsBall( gd,spd,tstem,is_x );</span>
<span class="lineNum">    5576 </span><span class="lineCov">        549 :                     if ( s_ball ) {</span>
<span class="lineNum">    5577 </span><span class="lineCov">         19 :                         chunk-&gt;ball_m = tstem;</span>
<span class="lineNum">    5578 </span><span class="lineCov">         19 :                         smaster = tstem;</span>
<span class="lineNum">    5579 </span><span class="lineCov">         19 :                         smend = ( is_x ) ? tstem-&gt;left.y : tstem-&gt;right.x;</span>
<span class="lineNum">    5580 </span>            :                     }
<span class="lineNum">    5581 </span><span class="lineCov">        549 :                     allow_e = false;</span>
<span class="lineNum">    5582 </span>            :                 }
<span class="lineNum">    5583 </span>            :             }
<span class="lineNum">    5584 </span>            :             
<span class="lineNum">    5585 </span>            :         }
<span class="lineNum">    5586 </span>            :     }
<span class="lineNum">    5587 </span>            :     
<span class="lineNum">    5588 </span><span class="lineCov">       1885 :     for ( i=0; i&lt;bundle-&gt;cnt; i++ ) {</span>
<span class="lineNum">    5589 </span><span class="lineCov">       1267 :         tstem = bundle-&gt;stemlist[i];</span>
<span class="lineNum">    5590 </span><span class="lineCov">       2534 :         if (tstem-&gt;unit.x != stem-&gt;unit.x || tstem-&gt;unit.y != stem-&gt;unit.y ||</span>
<span class="lineNum">    5591 </span><span class="lineCov">       2534 :             tstem-&gt;toobig || tstem-&gt;width &gt;= stem-&gt;width )</span>
<span class="lineNum">    5592 </span><span class="lineCov">        181 :     continue;</span>
<span class="lineNum">    5593 </span>            :             
<span class="lineNum">    5594 </span><span class="lineCov">       1086 :         tstart = ( is_x ) ? tstem-&gt;right.y : tstem-&gt;left.x;</span>
<span class="lineNum">    5595 </span><span class="lineCov">       1086 :         tend = ( is_x ) ? tstem-&gt;left.y : tstem-&gt;right.x;</span>
<span class="lineNum">    5596 </span>            : 
<span class="lineNum">    5597 </span><span class="lineCov">       1086 :         if ( tstart &gt;= start &amp;&amp; tend &lt;= end ) {</span>
<span class="lineNum">    5598 </span><span class="lineCov">        528 :             if ( allow_s &amp;&amp; tstart &gt; start ) {</span>
<span class="lineNum">    5599 </span><span class="lineCov">        841 :                 for ( j=0; j&lt;tstem-&gt;chunk_cnt &amp;&amp; smaster != tstem; j++ ) {</span>
<span class="lineNum">    5600 </span><span class="lineCov">        500 :                     if ( is_x ) {</span>
<span class="lineNum">    5601 </span><span class="lineCov">        157 :                         spd = tstem-&gt;chunks[j].l;</span>
<span class="lineNum">    5602 </span><span class="lineCov">        157 :                         snext = tstem-&gt;chunks[j].lnext;</span>
<span class="lineNum">    5603 </span><span class="lineCov">        157 :                         eidx = tstem-&gt;chunks[j].l_e_idx;</span>
<span class="lineNum">    5604 </span>            :                     } else {
<span class="lineNum">    5605 </span><span class="lineCov">        343 :                         spd = tstem-&gt;chunks[j].r;</span>
<span class="lineNum">    5606 </span><span class="lineCov">        343 :                         snext = tstem-&gt;chunks[j].rnext;</span>
<span class="lineNum">    5607 </span><span class="lineCov">        343 :                         eidx = tstem-&gt;chunks[j].r_e_idx;</span>
<span class="lineNum">    5608 </span>            :                     }
<span class="lineNum">    5609 </span><span class="lineCov">        500 :                     if ( spd != NULL &amp;&amp; ConnectsAcrossToStem( gd,spd,snext,stem,is_x,eidx ) &amp;&amp;</span>
<span class="lineNum">    5610 </span><span class="lineCov">         31 :                         ( smaster == NULL || smend - start &gt; tend - start )) {</span>
<span class="lineNum">    5611 </span><span class="lineCov">        204 :                         smaster = tstem;</span>
<span class="lineNum">    5612 </span><span class="lineCov">        204 :                         smend = tend;</span>
<span class="lineNum">    5613 </span>            :                     }
<span class="lineNum">    5614 </span>            :                 }
<span class="lineNum">    5615 </span>            :             }
<span class="lineNum">    5616 </span><span class="lineCov">        528 :             if ( allow_e &amp;&amp; tend &lt; end ) {</span>
<span class="lineNum">    5617 </span><span class="lineCov">        772 :                 for ( j=0; j&lt;tstem-&gt;chunk_cnt &amp;&amp; emaster != tstem; j++ ) {</span>
<span class="lineNum">    5618 </span><span class="lineCov">        466 :                     if ( is_x ) {</span>
<span class="lineNum">    5619 </span><span class="lineCov">        162 :                         epd = tstem-&gt;chunks[j].r;</span>
<span class="lineNum">    5620 </span><span class="lineCov">        162 :                         enext = tstem-&gt;chunks[j].rnext;</span>
<span class="lineNum">    5621 </span><span class="lineCov">        162 :                         eidx = tstem-&gt;chunks[j].r_e_idx;</span>
<span class="lineNum">    5622 </span>            :                     } else {
<span class="lineNum">    5623 </span><span class="lineCov">        304 :                         epd = tstem-&gt;chunks[j].l;</span>
<span class="lineNum">    5624 </span><span class="lineCov">        304 :                         enext = tstem-&gt;chunks[j].lnext;</span>
<span class="lineNum">    5625 </span><span class="lineCov">        304 :                         eidx = tstem-&gt;chunks[j].l_e_idx;</span>
<span class="lineNum">    5626 </span>            :                     }
<span class="lineNum">    5627 </span><span class="lineCov">        466 :                     if ( epd != NULL &amp;&amp; ConnectsAcrossToStem( gd,epd,enext,stem,!is_x,eidx ) &amp;&amp;</span>
<span class="lineNum">    5628 </span><span class="lineCov">         17 :                         ( emaster == NULL || end - emstart &gt; end - tstart )) {</span>
<span class="lineNum">    5629 </span><span class="lineCov">        191 :                         emaster = tstem;</span>
<span class="lineNum">    5630 </span><span class="lineCov">        191 :                         emstart = tstart;</span>
<span class="lineNum">    5631 </span>            :                     }
<span class="lineNum">    5632 </span>            :                 }
<span class="lineNum">    5633 </span>            :             }
<span class="lineNum">    5634 </span>            :         }
<span class="lineNum">    5635 </span>            :     }
<span class="lineNum">    5636 </span><span class="lineCov">        618 :     if ( smaster != NULL )</span>
<span class="lineNum">    5637 </span><span class="lineCov">        218 :         AddSerifOrBall( gd,smaster,stem,is_x,s_ball );</span>
<span class="lineNum">    5638 </span><span class="lineCov">        618 :     if ( emaster != NULL )</span>
<span class="lineNum">    5639 </span><span class="lineCov">        185 :         AddSerifOrBall( gd,emaster,stem,!is_x,e_ball );</span>
<a name="5640"><span class="lineNum">    5640 </span><span class="lineCov">        618 : }</span></a>
<span class="lineNum">    5641 </span>            : 
<span class="lineNum">    5642 </span><span class="lineCov">         44 : static double ActiveOverlap( struct stemdata *stem1,struct stemdata *stem2 ) {</span>
<span class="lineNum">    5643 </span><span class="lineCov">         44 :     int is_x, i, j = 0;</span>
<span class="lineNum">    5644 </span><span class="lineCov">         44 :     double base1, base2, s1, e1, s2, e2, s, e, len = 0;</span>
<span class="lineNum">    5645 </span>            :     
<span class="lineNum">    5646 </span><span class="lineCov">         44 :     is_x = ( IsUnitHV( &amp;stem1-&gt;unit,true ) == 2 );</span>
<span class="lineNum">    5647 </span><span class="lineCov">         44 :     base1 = ( &amp;stem1-&gt;left.x )[is_x];</span>
<span class="lineNum">    5648 </span><span class="lineCov">         44 :     base2 = ( &amp;stem2-&gt;left.x )[is_x];</span>
<span class="lineNum">    5649 </span>            :     
<span class="lineNum">    5650 </span><span class="lineCov">        105 :     for ( i=0; i&lt;stem1-&gt;activecnt; i++ ) {</span>
<span class="lineNum">    5651 </span><span class="lineCov">         61 :         s1 = base1 + stem1-&gt;active[i].start;</span>
<span class="lineNum">    5652 </span><span class="lineCov">         61 :         e1 = base1 + stem1-&gt;active[i].end;</span>
<span class="lineNum">    5653 </span><span class="lineCov">        118 :         for ( ; j&lt;stem2-&gt;activecnt; j++ ) {</span>
<span class="lineNum">    5654 </span><span class="lineCov">         75 :             s2 = base2 + stem2-&gt;active[j].start;</span>
<span class="lineNum">    5655 </span><span class="lineCov">         75 :             e2 = base2 + stem2-&gt;active[j].end;</span>
<span class="lineNum">    5656 </span><span class="lineCov">         75 :             if ( s2 &gt; e1 )</span>
<span class="lineNum">    5657 </span><span class="lineCov">         18 :         break;</span>
<span class="lineNum">    5658 </span>            : 
<span class="lineNum">    5659 </span><span class="lineCov">         57 :             if ( e2 &lt; s1 )</span>
<span class="lineNum">    5660 </span><span class="lineCov">         19 :         continue;</span>
<span class="lineNum">    5661 </span>            : 
<span class="lineNum">    5662 </span><span class="lineCov">         38 :             s = s2 &lt; s1 ? s1 : s2;</span>
<span class="lineNum">    5663 </span><span class="lineCov">         38 :             e = e2 &gt; e1 ? e1 : e2;</span>
<span class="lineNum">    5664 </span><span class="lineCov">         38 :             if ( e&lt;s )</span>
<span class="lineNum">    5665 </span><span class="lineNoCov">          0 :         continue;               /* Shouldn't happen */</span>
<span class="lineNum">    5666 </span><span class="lineCov">         38 :             len += e - s;</span>
<span class="lineNum">    5667 </span>            :         }
<span class="lineNum">    5668 </span>            :     }
<span class="lineNum">    5669 </span><span class="lineCov">         44 : return( len );</span>
<a name="5670"><span class="lineNum">    5670 </span>            : }</a>
<span class="lineNum">    5671 </span>            : 
<span class="lineNum">    5672 </span><span class="lineCov">         24 : static int StemPairsSimilar( struct stemdata *s1, struct stemdata *s2,</span>
<span class="lineNum">    5673 </span>            :     struct stemdata *ts1, struct stemdata *ts2 ) {
<span class="lineNum">    5674 </span>            :     
<span class="lineNum">    5675 </span><span class="lineCov">         24 :     int normal, reversed, ret = 0;</span>
<span class="lineNum">    5676 </span>            :     double olen1, olen2;
<span class="lineNum">    5677 </span>            :     
<span class="lineNum">    5678 </span>            :     /* Stem widths in the second pair should be nearly the same as */
<span class="lineNum">    5679 </span>            :     /* stem widths in the first pair */
<span class="lineNum">    5680 </span><span class="lineCov">         67 :     normal = (  ts1-&gt;width &gt;= s1-&gt;width - dist_error_hv &amp;&amp; </span>
<span class="lineNum">    5681 </span><span class="lineCov">         36 :                 ts1-&gt;width &lt;= s1-&gt;width + dist_error_hv &amp;&amp;</span>
<span class="lineNum">    5682 </span><span class="lineCov">         57 :                 ts2-&gt;width &gt;= s2-&gt;width - dist_error_hv &amp;&amp; </span>
<span class="lineNum">    5683 </span><span class="lineCov">         16 :                 ts2-&gt;width &lt;= s2-&gt;width + dist_error_hv );</span>
<span class="lineNum">    5684 </span><span class="lineCov">         71 :     reversed = (ts1-&gt;width &gt;= s2-&gt;width - dist_error_hv &amp;&amp; </span>
<span class="lineNum">    5685 </span><span class="lineCov">         42 :                 ts1-&gt;width &lt;= s2-&gt;width + dist_error_hv &amp;&amp;</span>
<span class="lineNum">    5686 </span><span class="lineCov">         61 :                 ts2-&gt;width &gt;= s1-&gt;width - dist_error_hv &amp;&amp; </span>
<span class="lineNum">    5687 </span><span class="lineCov">         18 :                 ts2-&gt;width &lt;= s1-&gt;width + dist_error_hv );</span>
<span class="lineNum">    5688 </span>            : 
<span class="lineNum">    5689 </span><span class="lineCov">         24 :     if ( !normal &amp;&amp; !reversed )</span>
<span class="lineNum">    5690 </span><span class="lineCov">          2 : return( false );</span>
<span class="lineNum">    5691 </span>            : 
<span class="lineNum">    5692 </span><span class="lineCov">         22 :     if ( normal ) {</span>
<span class="lineNum">    5693 </span><span class="lineCov">         16 :         olen1 = ActiveOverlap( s1, ts1 );</span>
<span class="lineNum">    5694 </span><span class="lineCov">         16 :         olen2 = ActiveOverlap( s2, ts2 );</span>
<span class="lineNum">    5695 </span><span class="lineCov">         53 :         ret =   olen1 &gt; s1-&gt;clen/3 &amp;&amp; olen1 &gt; ts1-&gt;clen/3 &amp;&amp;</span>
<span class="lineNum">    5696 </span><span class="lineCov">         36 :                 olen2 &gt; s2-&gt;clen/3 &amp;&amp; olen2 &gt; ts2-&gt;clen/3;</span>
<span class="lineNum">    5697 </span><span class="lineCov">          6 :     } else if ( reversed ) {</span>
<span class="lineNum">    5698 </span><span class="lineCov">          6 :         olen1 = ActiveOverlap( s1, ts2 );</span>
<span class="lineNum">    5699 </span><span class="lineCov">          6 :         olen2 = ActiveOverlap( s2, ts1 );</span>
<span class="lineNum">    5700 </span><span class="lineCov">         18 :         ret =   olen1 &gt; s1-&gt;clen/3 &amp;&amp; olen1 &gt; ts2-&gt;clen/3 &amp;&amp;</span>
<span class="lineNum">    5701 </span><span class="lineCov">         12 :                 olen2 &gt; s2-&gt;clen/3 &amp;&amp; olen2 &gt; ts1-&gt;clen/3;</span>
<span class="lineNum">    5702 </span>            :     }
<span class="lineNum">    5703 </span><span class="lineCov">         22 : return( ret );</span>
<a name="5704"><span class="lineNum">    5704 </span>            : }</a>
<span class="lineNum">    5705 </span>            : 
<span class="lineNum">    5706 </span><span class="lineCov">        548 : static void FindCounterGroups( struct glyphdata *gd,int is_v ) {</span>
<span class="lineNum">    5707 </span><span class="lineCov">        548 :     struct stembundle *bundle = is_v ? gd-&gt;vbundle : gd-&gt;hbundle;</span>
<span class="lineNum">    5708 </span>            :     struct stemdata *curm, *prevm, *cur, *prev;
<span class="lineNum">    5709 </span>            :     int i, j;
<span class="lineNum">    5710 </span>            :     double mdist, dist;
<span class="lineNum">    5711 </span>            :     
<span class="lineNum">    5712 </span><span class="lineCov">        548 :     prevm = NULL;</span>
<span class="lineNum">    5713 </span><span class="lineCov">       1524 :     for ( i=0; i&lt;bundle-&gt;cnt; i++ ) {</span>
<span class="lineNum">    5714 </span><span class="lineCov">        976 :         curm = prev = bundle-&gt;stemlist[i];</span>
<span class="lineNum">    5715 </span><span class="lineCov">        976 :         if ( curm-&gt;master != NULL )</span>
<span class="lineNum">    5716 </span><span class="lineCov">        121 :     continue;</span>
<span class="lineNum">    5717 </span><span class="lineCov">        855 :         if ( prevm == NULL || curm-&gt;prev_c_m != NULL ) {</span>
<span class="lineNum">    5718 </span><span class="lineCov">        484 :             prevm = curm;</span>
<span class="lineNum">    5719 </span><span class="lineCov">        484 :     continue;</span>
<span class="lineNum">    5720 </span>            :         }
<span class="lineNum">    5721 </span><span class="lineCov">        371 :         mdist = is_v ? curm-&gt;left.x - prevm-&gt;right.x : curm-&gt;right.y - prevm-&gt;left.y;</span>
<span class="lineNum">    5722 </span><span class="lineCov">        539 :         for ( j=i+1; j&lt;bundle-&gt;cnt; j++ ) {</span>
<span class="lineNum">    5723 </span><span class="lineCov">        168 :             cur = bundle-&gt;stemlist[j];</span>
<span class="lineNum">    5724 </span><span class="lineCov">        168 :             if ( cur-&gt;master != NULL )</span>
<span class="lineNum">    5725 </span><span class="lineCov">         36 :         continue;</span>
<span class="lineNum">    5726 </span><span class="lineCov">        132 :             if ( cur-&gt;prev_c_m != NULL ) {</span>
<span class="lineNum">    5727 </span><span class="lineCov">          3 :                 prev = cur;</span>
<span class="lineNum">    5728 </span><span class="lineCov">          3 :         continue;</span>
<span class="lineNum">    5729 </span>            :             }
<span class="lineNum">    5730 </span>            :             
<span class="lineNum">    5731 </span><span class="lineCov">        129 :             dist =  is_v ? cur-&gt;left.x - prev-&gt;right.x : cur-&gt;right.y - prev-&gt;left.y;</span>
<span class="lineNum">    5732 </span><span class="lineCov">        153 :             if ( mdist &gt; dist - dist_error_hv &amp;&amp; mdist &lt; dist + dist_error_hv &amp;&amp; </span>
<span class="lineNum">    5733 </span><span class="lineCov">         24 :                 StemPairsSimilar( prevm,curm,prev,cur )) {</span>
<span class="lineNum">    5734 </span><span class="lineCov">         13 :                 prev-&gt;next_c_m = prevm;</span>
<span class="lineNum">    5735 </span><span class="lineCov">         13 :                 cur-&gt;prev_c_m = curm;</span>
<span class="lineNum">    5736 </span>            :             }
<span class="lineNum">    5737 </span><span class="lineCov">        129 :             prev = cur;</span>
<span class="lineNum">    5738 </span>            :         }
<span class="lineNum">    5739 </span><span class="lineCov">        371 :         prevm = curm;</span>
<span class="lineNum">    5740 </span>            :     }
<span class="lineNum">    5741 </span><span class="lineCov">        548 : }</span>
<span class="lineNum">    5742 </span>            : 
<span class="lineNum">    5743 </span>            : /* Normally we use the DetectDiagonalStems flag (set via the Preferences dialog) to determine */
<span class="lineNum">    5744 </span>            : /* if diagonal stems should be generated. However, sometimes it makes sense to reduce the */
<span class="lineNum">    5745 </span>            : /* processing time, deliberately turning the diagonal stem detection off: in particular we */
<a name="5746"><span class="lineNum">    5746 </span>            : /* don't need any diagonal stems if we only want to assign points to some preexisting HV */</a>
<span class="lineNum">    5747 </span>            : /* hints. For thisreason  the only_hv argument still can be passed to this function. */
<span class="lineNum">    5748 </span><span class="lineCov">       3654 : struct glyphdata *GlyphDataInit( SplineChar *sc,int layer,double em_size,int only_hv ) {</span>
<span class="lineNum">    5749 </span>            :     struct glyphdata *gd;
<span class="lineNum">    5750 </span>            :     struct pointdata *pd;
<span class="lineNum">    5751 </span>            :     int i;
<span class="lineNum">    5752 </span>            :     SplineSet *ss;
<span class="lineNum">    5753 </span>            :     SplinePoint *sp;
<span class="lineNum">    5754 </span>            :     Monotonic *m;
<span class="lineNum">    5755 </span>            :     int cnt;
<span class="lineNum">    5756 </span>            :     double iangle;
<span class="lineNum">    5757 </span>            : 
<span class="lineNum">    5758 </span><span class="lineCov">       3654 :     if ( layer&lt;0 || layer&gt;=sc-&gt;layer_cnt )</span>
<span class="lineNum">    5759 </span><span class="lineNoCov">          0 :         return( NULL );</span>
<span class="lineNum">    5760 </span>            : 
<span class="lineNum">    5761 </span>            :     /* We only hint one layer at a time */
<span class="lineNum">    5762 </span>            :     /* We shan't try to hint references yet */
<span class="lineNum">    5763 </span><span class="lineCov">       3654 :     if ( sc-&gt;layers[layer].splines==NULL )</span>
<span class="lineNum">    5764 </span><span class="lineCov">       1691 : return( NULL );</span>
<span class="lineNum">    5765 </span>            : 
<span class="lineNum">    5766 </span><span class="lineCov">       1963 :     gd = calloc( 1,sizeof( struct glyphdata ));</span>
<span class="lineNum">    5767 </span><span class="lineCov">       1963 :     gd-&gt;only_hv = only_hv;</span>
<span class="lineNum">    5768 </span><span class="lineCov">       1963 :     gd-&gt;layer = layer;</span>
<span class="lineNum">    5769 </span>            :     
<span class="lineNum">    5770 </span><span class="lineCov">       1963 :     gd-&gt;sc = sc;</span>
<span class="lineNum">    5771 </span><span class="lineCov">       1963 :     gd-&gt;sf = sc-&gt;parent;</span>
<span class="lineNum">    5772 </span><span class="lineCov">       1963 :     gd-&gt;emsize = em_size;</span>
<span class="lineNum">    5773 </span><span class="lineCov">       1963 :     gd-&gt;order2 = ( sc-&gt;parent != NULL ) ? sc-&gt;parent-&gt;layers[layer].order2 : false;</span>
<span class="lineNum">    5774 </span><span class="lineCov">       1963 :     gd-&gt;fuzz = GetBlueFuzz( sc-&gt;parent );</span>
<span class="lineNum">    5775 </span>            :     
<span class="lineNum">    5776 </span><span class="lineCov">       1963 :     dist_error_hv = .0035*gd-&gt;emsize;</span>
<span class="lineNum">    5777 </span><span class="lineCov">       1963 :     dist_error_diag = .0065*gd-&gt;emsize;</span>
<span class="lineNum">    5778 </span><span class="lineCov">       1963 :     dist_error_curve = .022*gd-&gt;emsize;</span>
<span class="lineNum">    5779 </span>            : 
<span class="lineNum">    5780 </span><span class="lineCov">       1963 :     if ( sc-&gt;parent != NULL &amp;&amp; sc-&gt;parent-&gt;italicangle ) {</span>
<span class="lineNum">    5781 </span><span class="lineCov">        208 :         iangle = ( 90 + sc-&gt;parent-&gt;italicangle );</span>
<span class="lineNum">    5782 </span><span class="lineCov">        208 :         gd-&gt;has_slant = true;</span>
<span class="lineNum">    5783 </span><span class="lineCov">        208 :         gd-&gt;slant_unit.x = cos( iangle * ( PI/180 ));</span>
<span class="lineNum">    5784 </span><span class="lineCov">        208 :         gd-&gt;slant_unit.y = sin( iangle * ( PI/180 ));</span>
<span class="lineNum">    5785 </span>            :     } else {
<span class="lineNum">    5786 </span><span class="lineCov">       1755 :         gd-&gt;has_slant = false;</span>
<span class="lineNum">    5787 </span><span class="lineCov">       1755 :         gd-&gt;slant_unit.x = 0; gd-&gt;slant_unit.y = 1;</span>
<span class="lineNum">    5788 </span>            :     }
<span class="lineNum">    5789 </span>            : 
<span class="lineNum">    5790 </span>            :     /* SSToMContours can clean up the splinesets (remove 0 length splines) */
<span class="lineNum">    5791 </span>            :     /*  so it must be called BEFORE everything else (even though logically */
<span class="lineNum">    5792 </span>            :     /*  that doesn't make much sense). Otherwise we might have a pointer */
<span class="lineNum">    5793 </span>            :     /*  to something since freed */
<span class="lineNum">    5794 </span><span class="lineCov">       1963 :     gd-&gt;ms = SSsToMContours(sc-&gt;layers[layer].splines,over_remove);       /* second argument is meaningless here */</span>
<span class="lineNum">    5795 </span>            : 
<span class="lineNum">    5796 </span><span class="lineCov">       1963 :     gd-&gt;realcnt = gd-&gt;pcnt = SCNumberPoints( sc, layer );</span>
<span class="lineNum">    5797 </span><span class="lineCov">       1963 :     for ( i=0, ss=sc-&gt;layers[layer].splines; ss!=NULL; ss=ss-&gt;next, ++i );</span>
<span class="lineNum">    5798 </span><span class="lineCov">       1963 :     gd-&gt;ccnt = i;</span>
<span class="lineNum">    5799 </span><span class="lineCov">       1963 :     gd-&gt;contourends = malloc((i+1)*sizeof(int));</span>
<span class="lineNum">    5800 </span><span class="lineCov">       4937 :     for ( i=0, ss=sc-&gt;layers[layer].splines; ss!=NULL; ss=ss-&gt;next, ++i ) {</span>
<span class="lineNum">    5801 </span>            :         SplinePoint *last;
<span class="lineNum">    5802 </span><span class="lineCov">       2974 :         if ( ss-&gt;first-&gt;prev!=NULL )</span>
<span class="lineNum">    5803 </span><span class="lineCov">       2974 :             last = ss-&gt;first-&gt;prev-&gt;from;</span>
<span class="lineNum">    5804 </span>            :         else
<span class="lineNum">    5805 </span><span class="lineNoCov">          0 :             last = ss-&gt;last;</span>
<span class="lineNum">    5806 </span><span class="lineCov">       2974 :         if ( last-&gt;ttfindex==0xffff )</span>
<span class="lineNum">    5807 </span><span class="lineCov">        402 :             gd-&gt;contourends[i] = last-&gt;nextcpindex;</span>
<span class="lineNum">    5808 </span>            :         else
<span class="lineNum">    5809 </span><span class="lineCov">       2572 :             gd-&gt;contourends[i] = last-&gt;ttfindex;</span>
<span class="lineNum">    5810 </span>            :     }
<span class="lineNum">    5811 </span><span class="lineCov">       1963 :     gd-&gt;contourends[i] = -1;</span>
<span class="lineNum">    5812 </span>            : 
<span class="lineNum">    5813 </span>            :     /* Create temporary point numbers for the implied points. We need this */
<span class="lineNum">    5814 </span>            :     /*  for metafont if nothing else */
<span class="lineNum">    5815 </span><span class="lineCov">       4937 :     for ( ss= sc-&gt;layers[layer].splines; ss!=NULL; ss = ss-&gt;next ) {</span>
<span class="lineNum">    5816 </span><span class="lineCov">       2974 :         for ( sp = ss-&gt;first; ; ) {</span>
<span class="lineNum">    5817 </span><span class="lineCov">      39497 :             if ( sp-&gt;ttfindex &lt; gd-&gt;realcnt )</span>
<span class="lineNum">    5818 </span><span class="lineCov">      33173 :                 sp-&gt;ptindex = sp-&gt;ttfindex;</span>
<span class="lineNum">    5819 </span><span class="lineCov">       6324 :             else if ( sp-&gt;ttfindex == 0xffff )</span>
<span class="lineNum">    5820 </span><span class="lineCov">       6206 :                 sp-&gt;ptindex = gd-&gt;pcnt++;</span>
<span class="lineNum">    5821 </span><span class="lineCov">      39497 :             if ( sp-&gt;next==NULL )</span>
<span class="lineNum">    5822 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5823 </span><span class="lineCov">      39497 :             sp = sp-&gt;next-&gt;to;</span>
<span class="lineNum">    5824 </span><span class="lineCov">      39497 :             if ( sp==ss-&gt;first )</span>
<span class="lineNum">    5825 </span><span class="lineCov">       2974 :         break;</span>
<span class="lineNum">    5826 </span><span class="lineCov">      36523 :         }</span>
<span class="lineNum">    5827 </span>            :     }
<span class="lineNum">    5828 </span><span class="lineCov">       1963 :     gd-&gt;norefpcnt = gd-&gt;pcnt;</span>
<span class="lineNum">    5829 </span>            :     /* And for 0xfffe points such as those used in glyphs with order2 glyphs */
<span class="lineNum">    5830 </span>            :     /*  with references. */
<span class="lineNum">    5831 </span><span class="lineCov">       4937 :     for ( ss = sc-&gt;layers[layer].splines; ss!=NULL; ss = ss-&gt;next ) {</span>
<span class="lineNum">    5832 </span><span class="lineCov">       2974 :         for ( sp = ss-&gt;first; ; ) {</span>
<span class="lineNum">    5833 </span><span class="lineCov">      39497 :             if ( sp-&gt;ttfindex == 0xfffe )</span>
<span class="lineNum">    5834 </span><span class="lineCov">        118 :                 sp-&gt;ptindex = gd-&gt;pcnt++;</span>
<span class="lineNum">    5835 </span><span class="lineCov">      39497 :             if ( sp-&gt;next==NULL )</span>
<span class="lineNum">    5836 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5837 </span><span class="lineCov">      39497 :             sp = sp-&gt;next-&gt;to;</span>
<span class="lineNum">    5838 </span><span class="lineCov">      39497 :             if ( sp==ss-&gt;first )</span>
<span class="lineNum">    5839 </span><span class="lineCov">       2974 :         break;</span>
<span class="lineNum">    5840 </span><span class="lineCov">      36523 :         }</span>
<span class="lineNum">    5841 </span>            :     }
<span class="lineNum">    5842 </span><span class="lineCov">       1963 :     gd-&gt;pspace = malloc( gd-&gt;pcnt*sizeof( struct pointdata *));</span>
<span class="lineNum">    5843 </span>            : 
<span class="lineNum">    5844 </span>            :     /*gd-&gt;ms = SSsToMContours(sc-&gt;layers[layer].splines,over_remove);*/   /* second argument is meaningless here */
<span class="lineNum">    5845 </span><span class="lineCov">       1963 :     for ( m=gd-&gt;ms, cnt=0; m!=NULL; m=m-&gt;linked, ++cnt );</span>
<span class="lineNum">    5846 </span><span class="lineCov">       1963 :     gd-&gt;space = malloc((cnt+2)*sizeof(Monotonic*));</span>
<span class="lineNum">    5847 </span><span class="lineCov">       1963 :     gd-&gt;mcnt = cnt;</span>
<span class="lineNum">    5848 </span>            : 
<span class="lineNum">    5849 </span><span class="lineCov">       1963 :     gd-&gt;points = calloc(gd-&gt;pcnt,sizeof(struct pointdata));</span>
<span class="lineNum">    5850 </span><span class="lineCov">       4937 :     for ( ss=sc-&gt;layers[layer].splines; ss!=NULL; ss=ss-&gt;next ) if ( ss-&gt;first-&gt;prev!=NULL ) {</span>
<span class="lineNum">    5851 </span><span class="lineCov">       2974 :         for ( sp=ss-&gt;first; ; ) {</span>
<span class="lineNum">    5852 </span><span class="lineCov">      39497 :             PointInit( gd,sp,ss );</span>
<span class="lineNum">    5853 </span><span class="lineCov">      39497 :             if ( sp-&gt;next==NULL )</span>
<span class="lineNum">    5854 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    5855 </span><span class="lineCov">      39497 :             sp = sp-&gt;next-&gt;to;</span>
<span class="lineNum">    5856 </span><span class="lineCov">      39497 :             if ( sp==ss-&gt;first )</span>
<span class="lineNum">    5857 </span><span class="lineCov">       2974 :         break;</span>
<span class="lineNum">    5858 </span><span class="lineCov">      36523 :         }</span>
<span class="lineNum">    5859 </span>            :     }
<span class="lineNum">    5860 </span>            : 
<span class="lineNum">    5861 </span><span class="lineCov">      81410 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    5862 </span><span class="lineCov">      39497 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    5863 </span><span class="lineCov">      39497 :         if ( !pd-&gt;nextzero )</span>
<span class="lineNum">    5864 </span><span class="lineCov">      39328 :             pd-&gt;next_e_cnt = FindMatchingEdge(gd,pd,true,pd-&gt;nextedges);</span>
<span class="lineNum">    5865 </span><span class="lineCov">      39497 :         if ( !pd-&gt;prevzero )</span>
<span class="lineNum">    5866 </span><span class="lineCov">      39350 :             pd-&gt;prev_e_cnt = FindMatchingEdge(gd,pd,false,pd-&gt;prevedges);</span>
<span class="lineNum">    5867 </span><span class="lineCov">      39497 :         if (( pd-&gt;symetrical_h || pd-&gt;symetrical_v ) &amp;&amp; ( pd-&gt;x_corner || pd-&gt;y_corner))</span>
<span class="lineNum">    5868 </span><span class="lineNoCov">          0 :             FindMatchingEdge(gd,pd,2,&amp;pd-&gt;bothedge);</span>
<span class="lineNum">    5869 </span>            :     }
<span class="lineNum">    5870 </span>            : 
<span class="lineNum">    5871 </span><span class="lineCov">       1963 : return( gd );</span>
<a name="5872"><span class="lineNum">    5872 </span>            : }</a>
<span class="lineNum">    5873 </span>            : 
<span class="lineNum">    5874 </span><span class="lineCov">       3230 : struct glyphdata *GlyphDataBuild( SplineChar *sc,int layer, BlueData *bd,int use_existing ) {</span>
<span class="lineNum">    5875 </span>            :     struct glyphdata *gd;
<span class="lineNum">    5876 </span>            :     struct pointdata *pd;
<span class="lineNum">    5877 </span>            :     struct stemdata *stem;
<span class="lineNum">    5878 </span>            :     BasePoint dir;
<span class="lineNum">    5879 </span>            :     struct stem_chunk *chunk;
<span class="lineNum">    5880 </span>            :     int i, j, only_hv, startcnt, stemcnt, ecnt, hv, has_h, has_v;
<span class="lineNum">    5881 </span>            :     double em_size;
<span class="lineNum">    5882 </span>            :     DBounds bounds;
<span class="lineNum">    5883 </span>            :     
<span class="lineNum">    5884 </span><span class="lineCov">       3230 :     only_hv = ( !detect_diagonal_stems &amp;&amp; ( !use_existing || sc-&gt;dstem == NULL ));</span>
<span class="lineNum">    5885 </span><span class="lineCov">       3230 :     em_size = ( sc-&gt;parent != NULL ) ? sc-&gt;parent-&gt;ascent + sc-&gt;parent-&gt;descent : 1000;</span>
<span class="lineNum">    5886 </span>            : 
<span class="lineNum">    5887 </span><span class="lineCov">       3230 :     gd = GlyphDataInit( sc,layer,em_size,only_hv );</span>
<span class="lineNum">    5888 </span><span class="lineCov">       3230 :     if ( gd == NULL )</span>
<span class="lineNum">    5889 </span><span class="lineCov">       1586 : return( gd );</span>
<span class="lineNum">    5890 </span>            :     /* Get the alignment zones */
<span class="lineNum">    5891 </span><span class="lineCov">       1644 :     if ( bd == NULL )</span>
<span class="lineNum">    5892 </span><span class="lineCov">        118 :         QuickBlues( gd-&gt;sf,gd-&gt;layer,&amp;gd-&gt;bd );</span>
<span class="lineNum">    5893 </span>            :     else
<span class="lineNum">    5894 </span><span class="lineCov">       1526 :         memcpy( &amp;gd-&gt;bd,bd,sizeof( BlueData ));</span>
<span class="lineNum">    5895 </span>            : 
<span class="lineNum">    5896 </span>            :     /* There will never be more lines than there are points (counting next/prev as separate) */
<span class="lineNum">    5897 </span><span class="lineCov">       1644 :     gd-&gt;lines = malloc( 2*gd-&gt;pcnt*sizeof( struct linedata ));</span>
<span class="lineNum">    5898 </span><span class="lineCov">       1644 :     gd-&gt;linecnt = 0;</span>
<span class="lineNum">    5899 </span><span class="lineCov">      58854 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    5900 </span><span class="lineCov">      30622 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    5901 </span><span class="lineCov">      30622 :         if (( !gd-&gt;only_hv || pd-&gt;next_hor || pd-&gt;next_ver ) &amp;&amp; pd-&gt;nextline==NULL ) {</span>
<span class="lineNum">    5902 </span><span class="lineCov">      22045 :             pd-&gt;nextline = BuildLine(gd,pd,true);</span>
<span class="lineNum">    5903 </span><span class="lineCov">      22045 :             if ( pd-&gt;colinear )</span>
<span class="lineNum">    5904 </span><span class="lineCov">      12841 :                 pd-&gt;prevline = pd-&gt;nextline;</span>
<span class="lineNum">    5905 </span>            :         }
<span class="lineNum">    5906 </span><span class="lineCov">      30622 :         if (( !gd-&gt;only_hv || pd-&gt;prev_hor || pd-&gt;prev_ver ) &amp;&amp; pd-&gt;prevline==NULL ) {</span>
<span class="lineNum">    5907 </span><span class="lineCov">      15423 :             pd-&gt;prevline = BuildLine(gd,pd,false);</span>
<span class="lineNum">    5908 </span><span class="lineCov">      15423 :             if ( pd-&gt;colinear &amp;&amp; pd-&gt;nextline == NULL )</span>
<span class="lineNum">    5909 </span><span class="lineCov">      11343 :                 pd-&gt;nextline = pd-&gt;prevline;</span>
<span class="lineNum">    5910 </span>            :         }
<span class="lineNum">    5911 </span>            :     }
<span class="lineNum">    5912 </span>            :     
<span class="lineNum">    5913 </span>            :     /* There will never be more stems than there are points (counting next/prev as separate) */
<span class="lineNum">    5914 </span><span class="lineCov">       1644 :     gd-&gt;stems = calloc( 2*gd-&gt;pcnt,sizeof( struct stemdata ));</span>
<span class="lineNum">    5915 </span><span class="lineCov">       1644 :     gd-&gt;stemcnt = 0;                 /* None used so far */</span>
<span class="lineNum">    5916 </span>            : 
<span class="lineNum">    5917 </span><span class="lineCov">       1644 :     if ( use_existing ) {</span>
<span class="lineNum">    5918 </span><span class="lineCov">        548 :         SplineCharFindBounds( gd-&gt;sc,&amp;bounds );</span>
<span class="lineNum">    5919 </span><span class="lineCov">        548 :         if ( sc-&gt;vstem != NULL )</span>
<span class="lineNum">    5920 </span><span class="lineCov">        466 :             _StemInfoToStemData( gd,sc-&gt;vstem,&amp;bounds,true,&amp;startcnt );</span>
<span class="lineNum">    5921 </span><span class="lineCov">        548 :         if ( sc-&gt;hstem != NULL )</span>
<span class="lineNum">    5922 </span><span class="lineCov">        499 :             _StemInfoToStemData( gd,sc-&gt;hstem,&amp;bounds,false,&amp;startcnt );</span>
<span class="lineNum">    5923 </span><span class="lineCov">        548 :         if ( sc-&gt;dstem != NULL )</span>
<span class="lineNum">    5924 </span><span class="lineCov">        135 :             _DStemInfoToStemData( gd,sc-&gt;dstem,&amp;startcnt );</span>
<span class="lineNum">    5925 </span>            :     }
<span class="lineNum">    5926 </span>            : 
<span class="lineNum">    5927 </span><span class="lineCov">      58854 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp!=NULL ) {</span>
<span class="lineNum">    5928 </span><span class="lineCov">      30622 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    5929 </span><span class="lineCov">      30622 :         if ( pd-&gt;prev_e_cnt &gt; 0 ) {</span>
<span class="lineNum">    5930 </span><span class="lineCov">      28734 :             ecnt = BuildStem( gd,pd,false,false,use_existing,0 );</span>
<span class="lineNum">    5931 </span><span class="lineCov">      28734 :             if ( ecnt == 0 &amp;&amp; pd-&gt;prev_e_cnt &gt; 1 )</span>
<span class="lineNum">    5932 </span><span class="lineCov">         81 :                 BuildStem( gd,pd,false,false,false,1 );</span>
<span class="lineNum">    5933 </span>            :         }
<span class="lineNum">    5934 </span><span class="lineCov">      30622 :         if ( pd-&gt;next_e_cnt &gt; 0 ) {</span>
<span class="lineNum">    5935 </span><span class="lineCov">      28732 :             ecnt = BuildStem( gd,pd,true,false,use_existing,0 );</span>
<span class="lineNum">    5936 </span><span class="lineCov">      28732 :             if ( ecnt == 0 &amp;&amp; pd-&gt;next_e_cnt &gt; 1 )</span>
<span class="lineNum">    5937 </span><span class="lineCov">         84 :                 BuildStem( gd,pd,true,false,false,1 );</span>
<span class="lineNum">    5938 </span>            :         }
<span class="lineNum">    5939 </span><span class="lineCov">      30622 :         if ( pd-&gt;bothedge!=NULL ) {</span>
<span class="lineNum">    5940 </span><span class="lineNoCov">          0 :             DiagonalCornerStem( gd,pd,false );</span>
<span class="lineNum">    5941 </span>            :         }
<span class="lineNum">    5942 </span>            :         
<span class="lineNum">    5943 </span>            :         /* Snap corner extrema to preexisting hints if they have not */
<span class="lineNum">    5944 </span>            :         /* already been. This is currently done only when preparing  */
<span class="lineNum">    5945 </span>            :         /* glyph data for the autoinstructor */
<span class="lineNum">    5946 </span><span class="lineCov">      30622 :         if ( use_existing &amp;&amp; ( pd-&gt;x_corner || pd-&gt;y_corner )) {</span>
<span class="lineNum">    5947 </span><span class="lineCov">       1233 :             has_h = has_v = false;</span>
<span class="lineNum">    5948 </span><span class="lineCov">       1941 :             for ( j=0; j&lt;pd-&gt;prevcnt &amp;&amp; (( pd-&gt;x_corner &amp;&amp; !has_v ) || ( pd-&gt;y_corner &amp;&amp; !has_h )); j++ ) {</span>
<span class="lineNum">    5949 </span><span class="lineCov">        708 :                 hv = IsUnitHV( &amp;pd-&gt;prevstems[j]-&gt;unit,true );</span>
<span class="lineNum">    5950 </span><span class="lineCov">        708 :                 if ( hv == 1 ) has_h = true;</span>
<span class="lineNum">    5951 </span><span class="lineCov">        537 :                 else if ( hv == 2 ) has_v = true;</span>
<span class="lineNum">    5952 </span>            :             }
<span class="lineNum">    5953 </span><span class="lineCov">       1857 :             for ( j=0; j&lt;pd-&gt;nextcnt &amp;&amp; (( pd-&gt;x_corner &amp;&amp; !has_v ) || ( pd-&gt;y_corner &amp;&amp; !has_h )); j++ ) {</span>
<span class="lineNum">    5954 </span><span class="lineCov">        624 :                 hv = IsUnitHV( &amp;pd-&gt;nextstems[j]-&gt;unit,true );</span>
<span class="lineNum">    5955 </span><span class="lineCov">        624 :                 if ( hv == 1 ) has_h = true;</span>
<span class="lineNum">    5956 </span><span class="lineCov">        493 :                 else if ( hv == 2 ) has_v = true;</span>
<span class="lineNum">    5957 </span>            :             }
<span class="lineNum">    5958 </span><span class="lineCov">       1233 :             if ( pd-&gt;x_corner &amp;&amp; !has_v ) {</span>
<span class="lineNum">    5959 </span><span class="lineCov">        622 :                 dir.x = 0; dir.y = 1;</span>
<span class="lineNum">    5960 </span><span class="lineCov">        622 :                 HalfStemNoOpposite( gd,pd,NULL,&amp;dir,2 );</span>
<span class="lineNum">    5961 </span><span class="lineCov">        611 :             } else if ( pd-&gt;y_corner &amp;&amp; !has_h ) {</span>
<span class="lineNum">    5962 </span><span class="lineCov">        508 :                 dir.x = 1; dir.y = 0;</span>
<span class="lineNum">    5963 </span><span class="lineCov">        508 :                 HalfStemNoOpposite( gd,pd,NULL,&amp;dir,2 );</span>
<span class="lineNum">    5964 </span>            :             }
<span class="lineNum">    5965 </span>            :         }
<span class="lineNum">    5966 </span>            :     }
<span class="lineNum">    5967 </span><span class="lineCov">       1644 :     AssignLinePointsToStems( gd );</span>
<span class="lineNum">    5968 </span>            : 
<span class="lineNum">    5969 </span>            :     /* Normalize stems before calculating active zones (as otherwise */
<span class="lineNum">    5970 </span>            :     /* we don't know exact positions of stem edges */
<span class="lineNum">    5971 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i )</span>
<span class="lineNum">    5972 </span><span class="lineCov">      10651 :         NormalizeStem( gd,&amp;gd-&gt;stems[i] );</span>
<span class="lineNum">    5973 </span><span class="lineCov">       1644 :     GDNormalizeStubs( gd );</span>
<span class="lineNum">    5974 </span>            : 
<span class="lineNum">    5975 </span>            :     /* Figure out active zones at the first order (as they are needed to */
<span class="lineNum">    5976 </span>            :     /* determine which stems are undesired and they don't depend from */
<span class="lineNum">    5977 </span>            :     /* the &quot;potential&quot; state of left/right points in chunks */
<span class="lineNum">    5978 </span><span class="lineCov">       1644 :     gd-&gt;lspace = malloc(gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    5979 </span><span class="lineCov">       1644 :     gd-&gt;rspace = malloc(gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    5980 </span><span class="lineCov">       1644 :     gd-&gt;bothspace = malloc(3*gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    5981 </span><span class="lineCov">       1644 :     gd-&gt;activespace = malloc(3*gd-&gt;pcnt*sizeof(struct segment));</span>
<span class="lineNum">    5982 </span>            : #if GLYPH_DATA_DEBUG
<span class="lineNum">    5983 </span>            :     fprintf( stderr,&quot;Going to calculate stem active zones for %s\n&quot;,gd-&gt;sc-&gt;name );
<span class="lineNum">    5984 </span>            : #endif
<span class="lineNum">    5985 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i )</span>
<span class="lineNum">    5986 </span><span class="lineCov">      10651 :         FigureStemActive( gd,&amp;gd-&gt;stems[i] );</span>
<span class="lineNum">    5987 </span>            : 
<span class="lineNum">    5988 </span>            :     /* Check this before resolving stem conflicts, as otherwise we can */
<span class="lineNum">    5989 </span>            :     /* occasionally prefer a stem which should be excluded from the list */
<span class="lineNum">    5990 </span>            :     /* for some other reasons */
<span class="lineNum">    5991 </span><span class="lineCov">       1644 :     GDFindUnlikelyStems( gd );</span>
<span class="lineNum">    5992 </span>            : 
<span class="lineNum">    5993 </span>            :     /* we were cautious about assigning points to stems, go back now and see */
<span class="lineNum">    5994 </span>            :     /*  if there are any low-quality matches which remain unassigned, and if */
<span class="lineNum">    5995 </span>            :     /*  so then assign them to the stem they almost fit on. */
<span class="lineNum">    5996 </span><span class="lineCov">      12295 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    5997 </span><span class="lineCov">      10651 :         stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    5998 </span><span class="lineCov">      33531 :         for ( j=0; j&lt;stem-&gt;chunk_cnt; ++j ) {</span>
<span class="lineNum">    5999 </span><span class="lineCov">      22880 :             chunk = &amp;stem-&gt;chunks[j];</span>
<span class="lineNum">    6000 </span><span class="lineCov">      22880 :             if ( chunk-&gt;l!=NULL &amp;&amp; chunk-&gt;lpotential ) {</span>
<span class="lineNum">    6001 </span><span class="lineCov">       5334 :                 stemcnt = ( chunk-&gt;lnext ) ? chunk-&gt;l-&gt;nextcnt : chunk-&gt;l-&gt;prevcnt;</span>
<span class="lineNum">    6002 </span><span class="lineCov">       5334 :                 if ( stemcnt == 1 ) chunk-&gt;lpotential = false;</span>
<span class="lineNum">    6003 </span>            :             }
<span class="lineNum">    6004 </span><span class="lineCov">      22880 :             if ( chunk-&gt;r!=NULL &amp;&amp; chunk-&gt;rpotential ) {</span>
<span class="lineNum">    6005 </span><span class="lineCov">       5115 :                 stemcnt = ( chunk-&gt;rnext ) ? chunk-&gt;r-&gt;nextcnt : chunk-&gt;r-&gt;prevcnt;</span>
<span class="lineNum">    6006 </span><span class="lineCov">       5115 :                 if ( stemcnt == 1 ) chunk-&gt;rpotential = false;</span>
<span class="lineNum">    6007 </span>            :             }
<span class="lineNum">    6008 </span>            :         }
<span class="lineNum">    6009 </span>            :     }
<span class="lineNum">    6010 </span>            :     /* If there are multiple stems, find the one which is closest to this point */
<span class="lineNum">    6011 </span><span class="lineCov">      58854 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp != NULL ) {</span>
<span class="lineNum">    6012 </span><span class="lineCov">      30622 :         pd = &amp;gd-&gt;points[i];</span>
<span class="lineNum">    6013 </span><span class="lineCov">      30622 :         if ( pd-&gt;prevcnt &gt; 1 ) CheckPotential( gd,pd,false );</span>
<span class="lineNum">    6014 </span><span class="lineCov">      30622 :         if ( pd-&gt;nextcnt &gt; 1 ) CheckPotential( gd,pd,true );</span>
<span class="lineNum">    6015 </span>            :     }
<span class="lineNum">    6016 </span>            : 
<span class="lineNum">    6017 </span><span class="lineCov">       1644 :     if ( hint_bounding_boxes )</span>
<span class="lineNum">    6018 </span><span class="lineCov">       1644 :         CheckForBoundingBoxHints( gd );</span>
<span class="lineNum">    6019 </span><span class="lineCov">       1644 :     CheckForGhostHints( gd );</span>
<span class="lineNum">    6020 </span><span class="lineCov">       1644 :     if ( use_existing )</span>
<span class="lineNum">    6021 </span><span class="lineCov">        548 :         MarkDStemCorners( gd );</span>
<span class="lineNum">    6022 </span>            : 
<span class="lineNum">    6023 </span><span class="lineCov">       1644 :     GDBundleStems( gd,0,use_existing );</span>
<span class="lineNum">    6024 </span><span class="lineCov">       1644 :     if ( use_existing ) {</span>
<span class="lineNum">    6025 </span><span class="lineCov">       5183 :         for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    6026 </span><span class="lineCov">       4635 :             stem = &amp;gd-&gt;stems[i];</span>
<span class="lineNum">    6027 </span><span class="lineCov">       4635 :             if ( stem-&gt;toobig == 1 &amp;&amp; IsUnitHV( &amp;stem-&gt;unit,true ))</span>
<span class="lineNum">    6028 </span><span class="lineCov">        618 :                 GetSerifData( gd,stem );</span>
<span class="lineNum">    6029 </span>            :         }
<span class="lineNum">    6030 </span><span class="lineCov">        548 :         FindCounterGroups( gd,true );</span>
<span class="lineNum">    6031 </span>            :     }
<span class="lineNum">    6032 </span>            : 
<span class="lineNum">    6033 </span>            : #if GLYPH_DATA_DEBUG
<span class="lineNum">    6034 </span>            :     DumpGlyphData( gd );
<span class="lineNum">    6035 </span>            : #endif
<span class="lineNum">    6036 </span><span class="lineCov">       1644 :     free(gd-&gt;lspace);                gd-&gt;lspace = NULL;</span>
<span class="lineNum">    6037 </span><span class="lineCov">       1644 :     free(gd-&gt;rspace);                gd-&gt;rspace = NULL;</span>
<span class="lineNum">    6038 </span><span class="lineCov">       1644 :     free(gd-&gt;bothspace);     gd-&gt;bothspace = NULL;</span>
<span class="lineNum">    6039 </span><span class="lineCov">       1644 :     free(gd-&gt;activespace);   gd-&gt;activespace = NULL;</span>
<span class="lineNum">    6040 </span>            :  
<span class="lineNum">    6041 </span><span class="lineCov">       1644 : return( gd );</span>
<a name="6042"><span class="lineNum">    6042 </span>            : }</a>
<span class="lineNum">    6043 </span>            : 
<span class="lineNum">    6044 </span><span class="lineCov">       1963 : void GlyphDataFree(struct glyphdata *gd) {</span>
<span class="lineNum">    6045 </span>            :     int i;
<span class="lineNum">    6046 </span><span class="lineCov">       1963 :     if ( gd == NULL )</span>
<span class="lineNum">    6047 </span><span class="lineCov">       1963 : return;</span>
<span class="lineNum">    6048 </span>            : 
<span class="lineNum">    6049 </span><span class="lineCov">       1963 :     FreeMonotonics( gd-&gt;ms );        gd-&gt;ms = NULL;</span>
<span class="lineNum">    6050 </span><span class="lineCov">       1963 :     free( gd-&gt;space );               gd-&gt;space = NULL;</span>
<span class="lineNum">    6051 </span><span class="lineCov">       1963 :     free( gd-&gt;sspace );              gd-&gt;sspace = NULL;</span>
<span class="lineNum">    6052 </span><span class="lineCov">       1963 :     free( gd-&gt;stspace );     gd-&gt;stspace = NULL;</span>
<span class="lineNum">    6053 </span><span class="lineCov">       1963 :     free( gd-&gt;pspace );              gd-&gt;pspace = NULL;</span>
<span class="lineNum">    6054 </span>            : 
<span class="lineNum">    6055 </span>            :     /* Clean up temporary point numbers */
<span class="lineNum">    6056 </span><span class="lineCov">      81410 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) if ( gd-&gt;points[i].sp != NULL )</span>
<span class="lineNum">    6057 </span><span class="lineCov">      39497 :         gd-&gt;points[i].sp-&gt;ptindex = 0;</span>
<span class="lineNum">    6058 </span>            : 
<span class="lineNum">    6059 </span><span class="lineCov">       1963 :     if ( gd-&gt;hbundle != NULL ) {</span>
<span class="lineNum">    6060 </span><span class="lineCov">       1644 :         free( gd-&gt;hbundle-&gt;stemlist );</span>
<span class="lineNum">    6061 </span><span class="lineCov">       1644 :         free( gd-&gt;hbundle );</span>
<span class="lineNum">    6062 </span>            :     }
<span class="lineNum">    6063 </span><span class="lineCov">       1963 :     if ( gd-&gt;vbundle != NULL ) {</span>
<span class="lineNum">    6064 </span><span class="lineCov">       1644 :         free( gd-&gt;vbundle-&gt;stemlist );</span>
<span class="lineNum">    6065 </span><span class="lineCov">       1644 :         free( gd-&gt;vbundle );</span>
<span class="lineNum">    6066 </span>            :     }
<span class="lineNum">    6067 </span><span class="lineCov">       1963 :     if ( gd-&gt;ibundle != NULL ) {</span>
<span class="lineNum">    6068 </span><span class="lineNoCov">          0 :         free( gd-&gt;ibundle-&gt;stemlist );</span>
<span class="lineNum">    6069 </span><span class="lineNoCov">          0 :         free( gd-&gt;ibundle );</span>
<span class="lineNum">    6070 </span>            :     }
<span class="lineNum">    6071 </span>            :     
<span class="lineNum">    6072 </span><span class="lineCov">      10772 :     for ( i=0; i&lt;gd-&gt;linecnt; ++i )</span>
<span class="lineNum">    6073 </span><span class="lineCov">       8809 :         free( gd-&gt;lines[i].points );</span>
<span class="lineNum">    6074 </span><span class="lineCov">      13966 :     for ( i=0; i&lt;gd-&gt;stemcnt; ++i ) {</span>
<span class="lineNum">    6075 </span><span class="lineCov">      12003 :         free( gd-&gt;stems[i].chunks );</span>
<span class="lineNum">    6076 </span><span class="lineCov">      12003 :         free( gd-&gt;stems[i].dependent );</span>
<span class="lineNum">    6077 </span><span class="lineCov">      12003 :         free( gd-&gt;stems[i].serifs );</span>
<span class="lineNum">    6078 </span><span class="lineCov">      12003 :         free( gd-&gt;stems[i].active );</span>
<span class="lineNum">    6079 </span>            :     }
<span class="lineNum">    6080 </span><span class="lineCov">      81410 :     for ( i=0; i&lt;gd-&gt;pcnt; ++i ) {</span>
<span class="lineNum">    6081 </span><span class="lineCov">      79447 :         free( gd-&gt;points[i].nextstems );</span>
<span class="lineNum">    6082 </span><span class="lineCov">      79447 :         free( gd-&gt;points[i].next_is_l );</span>
<span class="lineNum">    6083 </span><span class="lineCov">      79447 :         free( gd-&gt;points[i].prevstems );</span>
<span class="lineNum">    6084 </span><span class="lineCov">      79447 :         free( gd-&gt;points[i].prev_is_l );</span>
<span class="lineNum">    6085 </span>            :     }
<span class="lineNum">    6086 </span><span class="lineCov">       1963 :     free( gd-&gt;lines );</span>
<span class="lineNum">    6087 </span><span class="lineCov">       1963 :     free( gd-&gt;stems );</span>
<span class="lineNum">    6088 </span><span class="lineCov">       1963 :     free( gd-&gt;contourends );</span>
<span class="lineNum">    6089 </span><span class="lineCov">       1963 :     free( gd-&gt;points );</span>
<span class="lineNum">    6090 </span><span class="lineCov">       1963 :     free( gd );</span>
<span class="lineNum">    6091 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
