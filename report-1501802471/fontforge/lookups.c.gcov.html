<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd) - fontforge/lookups.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">fontforge</a> - lookups.c<span style="font-size: 80%;"> (source / <a href="lookups.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd)</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">632</td>
            <td class="headerCovTableEntry">2956</td>
            <td class="headerCovTableEntryLo">21.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-08-04</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">39</td>
            <td class="headerCovTableEntry">121</td>
            <td class="headerCovTableEntryLo">32.2 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- coding: utf-8 -*- */</a>
<span class="lineNum">       2 </span>            : /* Copyright (C) 2007-2012 by George Williams */
<span class="lineNum">       3 </span>            : /*
<span class="lineNum">       4 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       5 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            :  * Redistributions of source code must retain the above copyright notice, this
<span class="lineNum">       8 </span>            :  * list of conditions and the following disclaimer.
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            :  * Redistributions in binary form must reproduce the above copyright notice,
<span class="lineNum">      11 </span>            :  * this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      12 </span>            :  * and/or other materials provided with the distribution.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            :  * The name of the author may not be used to endorse or promote products
<span class="lineNum">      15 </span>            :  * derived from this software without specific prior written permission.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
<span class="lineNum">      18 </span>            :  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
<span class="lineNum">      19 </span>            :  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
<span class="lineNum">      20 </span>            :  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      21 </span>            :  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      22 </span>            :  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
<span class="lineNum">      23 </span>            :  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
<span class="lineNum">      24 </span>            :  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
<span class="lineNum">      25 </span>            :  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
<span class="lineNum">      26 </span>            :  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      27 </span>            :  */
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;lookups.h&quot;
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &quot;fontforgevw.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;fvfonts.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;macenc.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;splinesaveafm.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;splineutil.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;tottfgpos.h&quot;
<span class="lineNum">      37 </span>            : #include &lt;chardata.h&gt;
<span class="lineNum">      38 </span>            : #include &lt;utype.h&gt;
<span class="lineNum">      39 </span>            : #include &lt;ustring.h&gt;
<span class="lineNum">      40 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      41 </span>            : #include &lt;locale.h&gt;
<span class="lineNum">      42 </span>            : #include &lt;stdlib.h&gt;
<span class="lineNum">      43 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">      44 </span>            : #include &quot;ttf.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;xvasprintf.h&quot;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : struct opentype_feature_friendlynames friendlies[] = {
<span class="lineNum">      48 </span>            :     { CHR('a','a','l','t'),     &quot;aalt&quot;, N_(&quot;Access All Alternates&quot;),        gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">      49 </span>            :     { CHR('a','b','v','f'),     &quot;abvf&quot;, N_(&quot;Above Base Forms&quot;),             gsub_single_mask },
<span class="lineNum">      50 </span>            :     { CHR('a','b','v','m'),     &quot;abvm&quot;, N_(&quot;Above Base Mark&quot;),              gpos_mark2base_mask|gpos_mark2ligature_mask },
<span class="lineNum">      51 </span>            :     { CHR('a','b','v','s'),     &quot;abvs&quot;, N_(&quot;Above Base Substitutions&quot;),     gsub_ligature_mask },
<span class="lineNum">      52 </span>            :     { CHR('a','f','r','c'),     &quot;afrc&quot;, N_(&quot;Vertical Fractions&quot;),   gsub_ligature_mask },
<span class="lineNum">      53 </span>            :     { CHR('a','k','h','n'),     &quot;akhn&quot;, N_(&quot;Akhand&quot;),                       gsub_ligature_mask },
<span class="lineNum">      54 </span>            :     { CHR('a','l','i','g'),     &quot;alig&quot;, N_(&quot;Ancient Ligatures&quot;),    gsub_ligature_mask },
<span class="lineNum">      55 </span>            :     { CHR('b','l','w','f'),     &quot;blwf&quot;, N_(&quot;Below Base Forms&quot;),             gsub_ligature_mask },
<span class="lineNum">      56 </span>            :     { CHR('b','l','w','m'),     &quot;blwm&quot;, N_(&quot;Below Base Mark&quot;),              gpos_mark2base_mask|gpos_mark2ligature_mask },
<span class="lineNum">      57 </span>            :     { CHR('b','l','w','s'),     &quot;blws&quot;, N_(&quot;Below Base Substitutions&quot;),     gsub_ligature_mask },
<span class="lineNum">      58 </span>            :     { CHR('c','2','p','c'),     &quot;c2pc&quot;, N_(&quot;Capitals to Petite Capitals&quot;),  gsub_single_mask },
<span class="lineNum">      59 </span>            :     { CHR('c','2','s','c'),     &quot;c2sc&quot;, N_(&quot;Capitals to Small Capitals&quot;),   gsub_single_mask },
<span class="lineNum">      60 </span>            :     { CHR('c','a','l','t'),     &quot;calt&quot;, N_(&quot;Contextual Alternates&quot;),        gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">      61 </span>            :     { CHR('c','a','s','e'),     &quot;case&quot;, N_(&quot;Case-Sensitive Forms&quot;), gsub_single_mask|gpos_single_mask },
<span class="lineNum">      62 </span>            :     { CHR('c','c','m','p'),     &quot;ccmp&quot;, N_(&quot;Glyph Composition/Decomposition&quot;),      gsub_multiple_mask|gsub_ligature_mask },
<span class="lineNum">      63 </span>            :     { CHR('c','f','a','r'),     &quot;cfar&quot;, N_(&quot;Conjunct Form After Ro&quot;),       gsub_single_mask },
<span class="lineNum">      64 </span>            :     { CHR('c','j','c','t'),     &quot;cjct&quot;, N_(&quot;Conjunct Forms&quot;),               gsub_ligature_mask },
<span class="lineNum">      65 </span>            :     { CHR('c','l','i','g'),     &quot;clig&quot;, N_(&quot;Contextual Ligatures&quot;), gsub_reversecchain_mask },
<span class="lineNum">      66 </span>            :     { CHR('c','p','c','t'),     &quot;cpct&quot;, N_(&quot;Centered CJK Punctuation&quot;),     gpos_single_mask },
<span class="lineNum">      67 </span>            :     { CHR('c','p','s','p'),     &quot;cpsp&quot;, N_(&quot;Capital Spacing&quot;),              gpos_single_mask },
<span class="lineNum">      68 </span>            :     { CHR('c','s','w','h'),     &quot;cswh&quot;, N_(&quot;Contextual Swash&quot;),             gsub_reversecchain_mask },
<span class="lineNum">      69 </span>            :     { CHR('c','u','r','s'),     &quot;curs&quot;, N_(&quot;Cursive Attachment&quot;),   gpos_cursive_mask },
<span class="lineNum">      70 </span>            :     { CHR('c','v','0','0'),     &quot;cv00&quot;, N_(&quot;Character Variants 00&quot;),        gsub_single_mask },
<span class="lineNum">      71 </span>            :     { CHR('c','v','0','1'),     &quot;cv01&quot;, N_(&quot;Character Variants 01&quot;),        gsub_single_mask },
<span class="lineNum">      72 </span>            :     { CHR('c','v','0','2'),     &quot;cv02&quot;, N_(&quot;Character Variants 02&quot;),        gsub_single_mask },
<span class="lineNum">      73 </span>            :     { CHR('c','v','0','3'),     &quot;cv03&quot;, N_(&quot;Character Variants 03&quot;),        gsub_single_mask },
<span class="lineNum">      74 </span>            :     { CHR('c','v','0','4'),     &quot;cv04&quot;, N_(&quot;Character Variants 04&quot;),        gsub_single_mask },
<span class="lineNum">      75 </span>            :     { CHR('c','v','0','5'),     &quot;cv05&quot;, N_(&quot;Character Variants 05&quot;),        gsub_single_mask },
<span class="lineNum">      76 </span>            :     { CHR('c','v','0','6'),     &quot;cv06&quot;, N_(&quot;Character Variants 06&quot;),        gsub_single_mask },
<span class="lineNum">      77 </span>            :     { CHR('c','v','0','7'),     &quot;cv07&quot;, N_(&quot;Character Variants 07&quot;),        gsub_single_mask },
<span class="lineNum">      78 </span>            :     { CHR('c','v','0','8'),     &quot;cv08&quot;, N_(&quot;Character Variants 08&quot;),        gsub_single_mask },
<span class="lineNum">      79 </span>            :     { CHR('c','v','0','9'),     &quot;cv09&quot;, N_(&quot;Character Variants 09&quot;),        gsub_single_mask },
<span class="lineNum">      80 </span>            :     { CHR('c','v','1','0'),     &quot;cv10&quot;, N_(&quot;Character Variants 10&quot;),        gsub_single_mask },
<span class="lineNum">      81 </span>            :     { CHR('c','v','9','9'),     &quot;cv99&quot;, N_(&quot;Character Variants 99&quot;),        gsub_single_mask },
<span class="lineNum">      82 </span>            :     { CHR('d','c','a','p'),     &quot;dcap&quot;, N_(&quot;Drop Caps&quot;),            gsub_single_mask },
<span class="lineNum">      83 </span>            :     { CHR('d','i','s','t'),     &quot;dist&quot;, N_(&quot;Distance&quot;),                     gpos_pair_mask },
<span class="lineNum">      84 </span>            :     { CHR('d','l','i','g'),     &quot;dlig&quot;, N_(&quot;Discretionary Ligatures&quot;),      gsub_ligature_mask },
<span class="lineNum">      85 </span>            :     { CHR('d','n','o','m'),     &quot;dnom&quot;, N_(&quot;Denominators&quot;),         gsub_single_mask },
<span class="lineNum">      86 </span>            :     { CHR('d','p','n','g'),     &quot;dpng&quot;, N_(&quot;Dipthongs (Obsolete)&quot;), gsub_ligature_mask },
<span class="lineNum">      87 </span>            :     { CHR('d','t','l','s'),     &quot;dtls&quot;, N_(&quot;Dotless Forms&quot;),                gsub_single_mask },
<span class="lineNum">      88 </span>            :     { CHR('e','x','p','t'),     &quot;expt&quot;, N_(&quot;Expert Forms&quot;),         gsub_single_mask },
<span class="lineNum">      89 </span>            :     { CHR('f','a','l','t'),     &quot;falt&quot;, N_(&quot;Final Glyph On Line&quot;),  gsub_alternate_mask },
<span class="lineNum">      90 </span>            :     { CHR('f','i','n','2'),     &quot;fin2&quot;, N_(&quot;Terminal Forms #2&quot;),    gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">      91 </span>            :     { CHR('f','i','n','3'),     &quot;fin3&quot;, N_(&quot;Terminal Forms #3&quot;),    gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">      92 </span>            :     { CHR('f','i','n','a'),     &quot;fina&quot;, N_(&quot;Terminal Forms&quot;),               gsub_single_mask },
<span class="lineNum">      93 </span>            :     { CHR('f','l','a','c'),     &quot;flac&quot;, N_(&quot;Flattened Accents over Capitals&quot;),      gsub_single_mask|gsub_ligature_mask },
<span class="lineNum">      94 </span>            :     { CHR('f','r','a','c'),     &quot;frac&quot;, N_(&quot;Diagonal Fractions&quot;),   gsub_single_mask|gsub_ligature_mask },
<span class="lineNum">      95 </span>            :     { CHR('f','w','i','d'),     &quot;fwid&quot;, N_(&quot;Full Widths&quot;),          gsub_single_mask|gpos_single_mask },
<span class="lineNum">      96 </span>            :     { CHR('h','a','l','f'),     &quot;half&quot;, N_(&quot;Half Forms&quot;),           gsub_ligature_mask },
<span class="lineNum">      97 </span>            :     { CHR('h','a','l','n'),     &quot;haln&quot;, N_(&quot;Halant Forms&quot;),         gsub_ligature_mask },
<span class="lineNum">      98 </span>            :     { CHR('h','a','l','t'),     &quot;halt&quot;, N_(&quot;Alternative Half Widths&quot;),      gpos_single_mask },
<span class="lineNum">      99 </span>            :     { CHR('h','i','s','t'),     &quot;hist&quot;, N_(&quot;Historical Forms&quot;),             gsub_single_mask },
<span class="lineNum">     100 </span>            :     { CHR('h','k','n','a'),     &quot;hkna&quot;, N_(&quot;Horizontal Kana Alternatives&quot;), gsub_single_mask },
<span class="lineNum">     101 </span>            :     { CHR('h','l','i','g'),     &quot;hlig&quot;, N_(&quot;Historic Ligatures&quot;),   gsub_ligature_mask },
<span class="lineNum">     102 </span>            :     { CHR('h','n','g','l'),     &quot;hngl&quot;, N_(&quot;Hanja to Hangul&quot;),              gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     103 </span>            :     { CHR('h','o','j','o'),     &quot;hojo&quot;, N_(&quot;Hojo (JIS X 0212-1990) Kanji Forms&quot;),   gsub_single_mask },
<span class="lineNum">     104 </span>            :     { CHR('h','w','i','d'),     &quot;hwid&quot;, N_(&quot;Half Widths&quot;),          gsub_single_mask|gpos_single_mask },
<span class="lineNum">     105 </span>            :     { CHR('i','n','i','t'),     &quot;init&quot;, N_(&quot;Initial Forms&quot;),                gsub_single_mask },
<span class="lineNum">     106 </span>            :     { CHR('i','s','o','l'),     &quot;isol&quot;, N_(&quot;Isolated Forms&quot;),               gsub_single_mask },
<span class="lineNum">     107 </span>            :     { CHR('i','t','a','l'),     &quot;ital&quot;, N_(&quot;Italics&quot;),                      gsub_single_mask },
<span class="lineNum">     108 </span>            :     { CHR('j','a','l','t'),     &quot;jalt&quot;, N_(&quot;Justification Alternatives&quot;),   gsub_alternate_mask },
<span class="lineNum">     109 </span>            :     { CHR('j','a','j','p'),     &quot;jajp&quot;, N_(&quot;Japanese Forms (Obsolete)&quot;),    gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     110 </span>            :     { CHR('j','p','0','4'),     &quot;jp04&quot;, N_(&quot;JIS2004 Forms&quot;),                gsub_single_mask },
<span class="lineNum">     111 </span>            :     { CHR('j','p','7','8'),     &quot;jp78&quot;, N_(&quot;JIS78 Forms&quot;),          gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     112 </span>            :     { CHR('j','p','8','3'),     &quot;jp83&quot;, N_(&quot;JIS83 Forms&quot;),          gsub_single_mask },
<span class="lineNum">     113 </span>            :     { CHR('j','p','9','0'),     &quot;jp90&quot;, N_(&quot;JIS90 Forms&quot;),          gsub_single_mask },
<span class="lineNum">     114 </span>            :     { CHR('k','e','r','n'),     &quot;kern&quot;, N_(&quot;Horizontal Kerning&quot;),   gpos_pair_mask|gpos_context_mask|gpos_contextchain_mask|kern_statemachine_mask },
<span class="lineNum">     115 </span>            :     { CHR('l','f','b','d'),     &quot;lfbd&quot;, N_(&quot;Left Bounds&quot;),          gpos_single_mask },
<span class="lineNum">     116 </span>            :     { CHR('l','i','g','a'),     &quot;liga&quot;, N_(&quot;Standard Ligatures&quot;),   gsub_ligature_mask },
<span class="lineNum">     117 </span>            :     { CHR('l','j','m','o'),     &quot;ljmo&quot;, N_(&quot;Leading Jamo Forms&quot;),   gsub_ligature_mask },
<span class="lineNum">     118 </span>            :     { CHR('l','n','u','m'),     &quot;lnum&quot;, N_(&quot;Lining Figures&quot;),               gsub_single_mask },
<span class="lineNum">     119 </span>            :     { CHR('l','o','c','l'),     &quot;locl&quot;, N_(&quot;Localized Forms&quot;),              gsub_single_mask },
<span class="lineNum">     120 </span>            :     { CHR('m','a','r','k'),     &quot;mark&quot;, N_(&quot;Mark Positioning&quot;),             gpos_mark2base_mask|gpos_mark2ligature_mask },
<span class="lineNum">     121 </span>            :     { CHR('m','e','d','2'),     &quot;med2&quot;, N_(&quot;Medial Forms 2&quot;),               gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">     122 </span>            :     { CHR('m','e','d','i'),     &quot;medi&quot;, N_(&quot;Medial Forms&quot;),         gsub_single_mask },
<span class="lineNum">     123 </span>            :     { CHR('m','g','r','k'),     &quot;mgrk&quot;, N_(&quot;Mathematical Greek&quot;),   gsub_single_mask },
<span class="lineNum">     124 </span>            :     { CHR('m','k','m','k'),     &quot;mkmk&quot;, N_(&quot;Mark to Mark&quot;),         gpos_mark2mark_mask },
<span class="lineNum">     125 </span>            :     { CHR('m','s','e','t'),     &quot;mset&quot;, N_(&quot;Mark Positioning via Substitution&quot;),    gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">     126 </span>            :     { CHR('n','a','l','t'),     &quot;nalt&quot;, N_(&quot;Alternate Annotation Forms&quot;),   gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     127 </span>            :     { CHR('n','l','c','k'),     &quot;nlck&quot;, N_(&quot;NLC Kanji Forms&quot;),              gsub_single_mask },
<span class="lineNum">     128 </span>            :     { CHR('n','u','k','t'),     &quot;nukt&quot;, N_(&quot;Nukta Forms&quot;),          gsub_ligature_mask },
<span class="lineNum">     129 </span>            :     { CHR('n','u','m','r'),     &quot;numr&quot;, N_(&quot;Numerators&quot;),           gsub_single_mask },
<span class="lineNum">     130 </span>            :     { CHR('o','n','u','m'),     &quot;onum&quot;, N_(&quot;Oldstyle Figures&quot;),             gsub_single_mask },
<span class="lineNum">     131 </span>            :     { CHR('o','p','b','d'),     &quot;opbd&quot;, N_(&quot;Optical Bounds&quot;),               gpos_single_mask },
<span class="lineNum">     132 </span>            :     { CHR('o','r','d','n'),     &quot;ordn&quot;, N_(&quot;Ordinals&quot;),                     gsub_ligature_mask|gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">     133 </span>            :     { CHR('o','r','n','m'),     &quot;ornm&quot;, N_(&quot;Ornaments&quot;),            gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     134 </span>            :     { CHR('p','a','l','t'),     &quot;palt&quot;, N_(&quot;Proportional Alternate Metrics&quot;),       gpos_single_mask },
<span class="lineNum">     135 </span>            :     { CHR('p','c','a','p'),     &quot;pcap&quot;, N_(&quot;Lowercase to Petite Capitals&quot;), gsub_single_mask },
<span class="lineNum">     136 </span>            :     { CHR('p','k','n','a'),     &quot;pkna&quot;, N_(&quot;Proportional Kana&quot;),    gpos_single_mask },
<span class="lineNum">     137 </span>            :     { CHR('p','n','u','m'),     &quot;pnum&quot;, N_(&quot;Proportional Numbers&quot;), gsub_single_mask },
<span class="lineNum">     138 </span>            :     { CHR('p','r','e','f'),     &quot;pref&quot;, N_(&quot;Pre Base Forms&quot;),               gsub_ligature_mask },
<span class="lineNum">     139 </span>            :     { CHR('p','r','e','s'),     &quot;pres&quot;, N_(&quot;Pre Base Substitutions&quot;),       gsub_ligature_mask|gsub_context_mask|gsub_contextchain_mask|morx_context_mask },
<span class="lineNum">     140 </span>            :     { CHR('p','s','t','f'),     &quot;pstf&quot;, N_(&quot;Post Base Forms&quot;),              gsub_ligature_mask },
<span class="lineNum">     141 </span>            :     { CHR('p','s','t','s'),     &quot;psts&quot;, N_(&quot;Post Base Substitutions&quot;),      gsub_ligature_mask },
<span class="lineNum">     142 </span>            :     { CHR('p','w','i','d'),     &quot;pwid&quot;, N_(&quot;Proportional Width&quot;),   gsub_single_mask },
<span class="lineNum">     143 </span>            :     { CHR('q','w','i','d'),     &quot;qwid&quot;, N_(&quot;Quarter Widths&quot;),               gsub_single_mask|gpos_single_mask },
<span class="lineNum">     144 </span>            :     { CHR('r','a','n','d'),     &quot;rand&quot;, N_(&quot;Randomize&quot;),            gsub_alternate_mask },
<span class="lineNum">     145 </span>            :     { CHR('r','k','r','f'),     &quot;rkrf&quot;, N_(&quot;Rakar Forms&quot;),          gsub_ligature_mask },
<span class="lineNum">     146 </span>            :     { CHR('r','l','i','g'),     &quot;rlig&quot;, N_(&quot;Required Ligatures&quot;),   gsub_ligature_mask },
<span class="lineNum">     147 </span>            :     { CHR('r','p','h','f'),     &quot;rphf&quot;, N_(&quot;Reph Form&quot;),            gsub_ligature_mask },
<span class="lineNum">     148 </span>            :     { CHR('r','t','b','d'),     &quot;rtbd&quot;, N_(&quot;Right Bounds&quot;),         gpos_single_mask },
<span class="lineNum">     149 </span>            :     { CHR('r','t','l','a'),     &quot;rtla&quot;, N_(&quot;Right to Left Alternates&quot;),     gsub_single_mask },
<span class="lineNum">     150 </span>            :     { CHR('r','t','l','m'),     &quot;rtlm&quot;, N_(&quot;Right to Left mirrored forms&quot;), gsub_single_mask },
<span class="lineNum">     151 </span>            :     { CHR('r','u','b','y'),     &quot;ruby&quot;, N_(&quot;Ruby Notational Forms&quot;),        gsub_single_mask },
<span class="lineNum">     152 </span>            :     { CHR('s','a','l','t'),     &quot;salt&quot;, N_(&quot;Stylistic Alternatives&quot;),       gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     153 </span>            :     { CHR('s','i','n','f'),     &quot;sinf&quot;, N_(&quot;Scientific Inferiors&quot;), gsub_single_mask },
<span class="lineNum">     154 </span>            :     { CHR('s','m','c','p'),     &quot;smcp&quot;, N_(&quot;Lowercase to Small Capitals&quot;),  gsub_single_mask },
<span class="lineNum">     155 </span>            :     { CHR('s','m','p','l'),     &quot;smpl&quot;, N_(&quot;Simplified Forms&quot;),             gsub_single_mask },
<span class="lineNum">     156 </span>            :     { CHR('s','s','0','1'),     &quot;ss01&quot;, N_(&quot;Style Set 1&quot;),          gsub_single_mask },
<span class="lineNum">     157 </span>            :     { CHR('s','s','0','2'),     &quot;ss02&quot;, N_(&quot;Style Set 2&quot;),          gsub_single_mask },
<span class="lineNum">     158 </span>            :     { CHR('s','s','0','3'),     &quot;ss03&quot;, N_(&quot;Style Set 3&quot;),          gsub_single_mask },
<span class="lineNum">     159 </span>            :     { CHR('s','s','0','4'),     &quot;ss04&quot;, N_(&quot;Style Set 4&quot;),          gsub_single_mask },
<span class="lineNum">     160 </span>            :     { CHR('s','s','0','5'),     &quot;ss05&quot;, N_(&quot;Style Set 5&quot;),          gsub_single_mask },
<span class="lineNum">     161 </span>            :     { CHR('s','s','0','6'),     &quot;ss06&quot;, N_(&quot;Style Set 6&quot;),          gsub_single_mask },
<span class="lineNum">     162 </span>            :     { CHR('s','s','0','7'),     &quot;ss07&quot;, N_(&quot;Style Set 7&quot;),          gsub_single_mask },
<span class="lineNum">     163 </span>            :     { CHR('s','s','0','8'),     &quot;ss08&quot;, N_(&quot;Style Set 8&quot;),          gsub_single_mask },
<span class="lineNum">     164 </span>            :     { CHR('s','s','0','9'),     &quot;ss09&quot;, N_(&quot;Style Set 9&quot;),          gsub_single_mask },
<span class="lineNum">     165 </span>            :     { CHR('s','s','1','0'),     &quot;ss10&quot;, N_(&quot;Style Set 10&quot;),         gsub_single_mask },
<span class="lineNum">     166 </span>            :     { CHR('s','s','1','1'),     &quot;ss11&quot;, N_(&quot;Style Set 11&quot;),         gsub_single_mask },
<span class="lineNum">     167 </span>            :     { CHR('s','s','1','2'),     &quot;ss12&quot;, N_(&quot;Style Set 12&quot;),         gsub_single_mask },
<span class="lineNum">     168 </span>            :     { CHR('s','s','1','3'),     &quot;ss13&quot;, N_(&quot;Style Set 13&quot;),         gsub_single_mask },
<span class="lineNum">     169 </span>            :     { CHR('s','s','1','4'),     &quot;ss14&quot;, N_(&quot;Style Set 14&quot;),         gsub_single_mask },
<span class="lineNum">     170 </span>            :     { CHR('s','s','1','5'),     &quot;ss15&quot;, N_(&quot;Style Set 15&quot;),         gsub_single_mask },
<span class="lineNum">     171 </span>            :     { CHR('s','s','1','6'),     &quot;ss16&quot;, N_(&quot;Style Set 16&quot;),         gsub_single_mask },
<span class="lineNum">     172 </span>            :     { CHR('s','s','1','7'),     &quot;ss17&quot;, N_(&quot;Style Set 17&quot;),         gsub_single_mask },
<span class="lineNum">     173 </span>            :     { CHR('s','s','1','8'),     &quot;ss18&quot;, N_(&quot;Style Set 18&quot;),         gsub_single_mask },
<span class="lineNum">     174 </span>            :     { CHR('s','s','1','9'),     &quot;ss19&quot;, N_(&quot;Style Set 19&quot;),         gsub_single_mask },
<span class="lineNum">     175 </span>            :     { CHR('s','s','2','0'),     &quot;ss20&quot;, N_(&quot;Style Set 20&quot;),         gsub_single_mask },
<span class="lineNum">     176 </span>            :     { CHR('s','s','t','y'),     &quot;ssty&quot;, N_(&quot;Script Style&quot;),         gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     177 </span>            :     { CHR('s','u','b','s'),     &quot;subs&quot;, N_(&quot;Subscript&quot;),            gsub_single_mask },
<span class="lineNum">     178 </span>            :     { CHR('s','u','p','s'),     &quot;sups&quot;, N_(&quot;Superscript&quot;),          gsub_single_mask },
<span class="lineNum">     179 </span>            :     { CHR('s','w','s','h'),     &quot;swsh&quot;, N_(&quot;Swash&quot;),                        gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     180 </span>            :     { CHR('t','i','t','l'),     &quot;titl&quot;, N_(&quot;Titling&quot;),                      gsub_single_mask },
<span class="lineNum">     181 </span>            :     { CHR('t','j','m','o'),     &quot;tjmo&quot;, N_(&quot;Trailing Jamo Forms&quot;),  gsub_ligature_mask },
<span class="lineNum">     182 </span>            :     { CHR('t','n','a','m'),     &quot;tnam&quot;, N_(&quot;Traditional Name Forms&quot;),       gsub_single_mask },
<span class="lineNum">     183 </span>            :     { CHR('t','n','u','m'),     &quot;tnum&quot;, N_(&quot;Tabular Numbers&quot;),              gsub_single_mask },
<span class="lineNum">     184 </span>            :     { CHR('t','r','a','d'),     &quot;trad&quot;, N_(&quot;Traditional Forms&quot;),    gsub_single_mask|gsub_alternate_mask },
<span class="lineNum">     185 </span>            :     { CHR('t','w','i','d'),     &quot;twid&quot;, N_(&quot;Third Widths&quot;),         gsub_single_mask|gpos_single_mask },
<span class="lineNum">     186 </span>            :     { CHR('u','n','i','c'),     &quot;unic&quot;, N_(&quot;Unicase&quot;),                      gsub_single_mask },
<span class="lineNum">     187 </span>            :     { CHR('v','a','l','t'),     &quot;valt&quot;, N_(&quot;Alternate Vertical Metrics&quot;),   gpos_single_mask },
<span class="lineNum">     188 </span>            :     { CHR('v','a','t','u'),     &quot;vatu&quot;, N_(&quot;Vattu Variants&quot;),               gsub_ligature_mask },
<span class="lineNum">     189 </span>            :     { CHR('v','e','r','t'),     &quot;vert&quot;, N_(&quot;Vertical Alternates (obs)&quot;),    gsub_single_mask },
<span class="lineNum">     190 </span>            :     { CHR('v','h','a','l'),     &quot;vhal&quot;, N_(&quot;Alternate Vertical Half Metrics&quot;),      gpos_single_mask },
<span class="lineNum">     191 </span>            :     { CHR('v','j','m','o'),     &quot;vjmo&quot;, N_(&quot;Vowel Jamo Forms&quot;),             gsub_ligature_mask },
<span class="lineNum">     192 </span>            :     { CHR('v','k','n','a'),     &quot;vkna&quot;, N_(&quot;Vertical Kana Alternates&quot;),     gsub_single_mask },
<span class="lineNum">     193 </span>            :     { CHR('v','k','r','n'),     &quot;vkrn&quot;, N_(&quot;Vertical Kerning&quot;),             gpos_pair_mask|gpos_context_mask|gpos_contextchain_mask|kern_statemachine_mask },
<span class="lineNum">     194 </span>            :     { CHR('v','p','a','l'),     &quot;vpal&quot;, N_(&quot;Proportional Alternate Vertical Metrics&quot;),      gpos_single_mask },
<span class="lineNum">     195 </span>            :     { CHR('v','r','t','2'),     &quot;vrt2&quot;, N_(&quot;Vertical Rotation &amp; Alternates&quot;),   gsub_single_mask },
<span class="lineNum">     196 </span>            :     { CHR('z','e','r','o'),     &quot;zero&quot;, N_(&quot;Slashed Zero&quot;),         gsub_single_mask },
<span class="lineNum">     197 </span>            : /* This is my hack for setting the &quot;Required feature&quot; field of a script */
<span class="lineNum">     198 </span>            :     { CHR(' ','R','Q','D'),     &quot; RQD&quot;, N_(&quot;Required feature&quot;),             gsub_single_mask|gsub_multiple_mask|gsub_alternate_mask|gsub_ligature_mask|gsub_context_mask|gsub_contextchain_mask|gsub_reversecchain_mask|morx_context_mask|gpos_single_mask|gpos_pair_mask|gpos_cursive_mask|gpos_mark2base_mask|gpos_mark2ligature_mask|gpos_mark2mark_mask|gpos_context_mask|gpos_contextchain_mask },
<span class="lineNum">     199 </span>            :     OPENTYPE_FEATURE_FRIENDLYNAMES_EMPTY
<a name="200"><span class="lineNum">     200 </span>            : };</a>
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span><span class="lineCov">         46 : static int uint32_cmp(const void *_ui1, const void *_ui2) {</span>
<span class="lineNum">     203 </span><span class="lineCov">         46 :     if ( *(uint32 *) _ui1 &gt; *(uint32 *)_ui2 )</span>
<span class="lineNum">     204 </span><span class="lineCov">         18 : return( 1 );</span>
<span class="lineNum">     205 </span><span class="lineCov">         28 :     if ( *(uint32 *) _ui1 &lt; *(uint32 *)_ui2 )</span>
<span class="lineNum">     206 </span><span class="lineCov">         28 : return( -1 );</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="209"><span class="lineNum">     209 </span>            : }</a>
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineCov">         17 : static int lang_cmp(const void *_ui1, const void *_ui2) {</span>
<span class="lineNum">     212 </span>            :     /* The default language is magic, and should come first in the list even */
<span class="lineNum">     213 </span>            :     /*  if that is not true alphabetical order */
<span class="lineNum">     214 </span><span class="lineCov">         17 :     if ( *(uint32 *) _ui1 == DEFAULT_LANG )</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 : return( -1 );</span>
<span class="lineNum">     216 </span><span class="lineCov">         17 :     if ( *(uint32 *) _ui2 == DEFAULT_LANG )</span>
<span class="lineNum">     217 </span><span class="lineCov">         13 : return( 1 );</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineCov">          4 :     if ( *(uint32 *) _ui1 &gt; *(uint32 *)_ui2 )</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 : return( 1 );</span>
<span class="lineNum">     221 </span><span class="lineCov">          4 :     if ( *(uint32 *) _ui1 &lt; *(uint32 *)_ui2 )</span>
<span class="lineNum">     222 </span><span class="lineCov">          4 : return( -1 );</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="225"><span class="lineNum">     225 </span>            : }</a>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 : FeatureScriptLangList *FindFeatureTagInFeatureScriptList(uint32 tag, FeatureScriptLangList *fl) {</span>
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     while ( fl!=NULL ) {</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :         if ( fl-&gt;featuretag==tag )</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : return( fl );</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         fl = fl-&gt;next;</span>
<span class="lineNum">     233 </span>            :     }
<span class="lineNum">     234 </span><span class="lineNoCov">          0 : return( NULL );</span>
<a name="235"><span class="lineNum">     235 </span>            : }</a>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineCov">         71 : int FeatureTagInFeatureScriptList(uint32 tag, FeatureScriptLangList *fl) {</span>
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineCov">        179 :     while ( fl!=NULL ) {</span>
<span class="lineNum">     240 </span><span class="lineCov">         71 :         if ( fl-&gt;featuretag==tag )</span>
<span class="lineNum">     241 </span><span class="lineCov">         34 : return( true );</span>
<span class="lineNum">     242 </span><span class="lineCov">         37 :         fl = fl-&gt;next;</span>
<span class="lineNum">     243 </span>            :     }
<span class="lineNum">     244 </span><span class="lineCov">         37 : return( false );</span>
<a name="245"><span class="lineNum">     245 </span>            : }</a>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineNoCov">          0 : int ScriptInFeatureScriptList(uint32 script, FeatureScriptLangList *fl) {</span>
<span class="lineNum">     248 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     if ( fl==NULL )             /* No features bound to lookup? (nested?) don't restrict by script */</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :     while ( fl!=NULL ) {</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :         for ( sl=fl-&gt;scripts; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :             if ( sl-&gt;script == script )</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     257 </span>            :         }
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         fl = fl-&gt;next;</span>
<span class="lineNum">     259 </span>            :     }
<span class="lineNum">     260 </span><span class="lineNoCov">          0 : return( false );</span>
<a name="261"><span class="lineNum">     261 </span>            : }</a>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineCov">      12920 : int FeatureScriptTagInFeatureScriptList(uint32 feature, uint32 script, FeatureScriptLangList *fl) {</span>
<span class="lineNum">     264 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineCov">      28593 :     while ( fl!=NULL ) {</span>
<span class="lineNum">     267 </span><span class="lineCov">      12920 :         if ( fl-&gt;featuretag == feature ) {</span>
<span class="lineNum">     268 </span><span class="lineCov">      15671 :             for ( sl=fl-&gt;scripts; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">     269 </span><span class="lineCov">      12919 :                 if ( sl-&gt;script == script )</span>
<span class="lineNum">     270 </span><span class="lineCov">      10167 : return( true );</span>
<span class="lineNum">     271 </span>            :             }
<span class="lineNum">     272 </span>            :         }
<span class="lineNum">     273 </span><span class="lineCov">       2753 :         fl = fl-&gt;next;</span>
<span class="lineNum">     274 </span>            :     }
<span class="lineNum">     275 </span><span class="lineCov">       2753 : return( false );</span>
<a name="276"><span class="lineNum">     276 </span>            : }</a>
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span><span class="lineCov">        828 : int DefaultLangTagInOneScriptList(struct scriptlanglist *sl) {</span>
<span class="lineNum">     279 </span>            :     int l;
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineCov">        924 :     for ( l=0; l&lt;sl-&gt;lang_cnt; ++l ) {</span>
<span class="lineNum">     282 </span><span class="lineCov">        900 :         uint32 lang = l&lt;MAX_LANG ? sl-&gt;langs[l] : sl-&gt;morelangs[l-MAX_LANG];</span>
<span class="lineNum">     283 </span><span class="lineCov">        900 :         if ( lang==DEFAULT_LANG )</span>
<span class="lineNum">     284 </span><span class="lineCov">        804 : return( true );</span>
<span class="lineNum">     285 </span>            :     }
<span class="lineNum">     286 </span><span class="lineCov">         24 : return( false );</span>
<a name="287"><span class="lineNum">     287 </span>            : }</a>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineCov">        333 : struct scriptlanglist *DefaultLangTagInScriptList(struct scriptlanglist *sl, int DFLT_ok) {</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">        690 :     while ( sl!=NULL ) {</span>
<span class="lineNum">     292 </span><span class="lineCov">        333 :         if ( DFLT_ok || sl-&gt;script!=DEFAULT_SCRIPT ) {</span>
<span class="lineNum">     293 </span><span class="lineCov">        321 :             if ( DefaultLangTagInOneScriptList(sl))</span>
<span class="lineNum">     294 </span><span class="lineCov">        309 : return( sl );</span>
<span class="lineNum">     295 </span>            :         }
<span class="lineNum">     296 </span><span class="lineCov">         24 :         sl = sl-&gt;next;</span>
<span class="lineNum">     297 </span>            :     }
<span class="lineNum">     298 </span><span class="lineCov">         24 : return( NULL );</span>
<a name="299"><span class="lineNum">     299 </span>            : }</a>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineCov">         32 : uint32 *SFScriptsInLookups(SplineFont *sf,int gpos) {</span>
<span class="lineNum">     302 </span>            :     /* Presumes that either SFFindUnusedLookups or SFFindClearUnusedLookupBits */
<span class="lineNum">     303 </span>            :     /*  has been called first */
<span class="lineNum">     304 </span>            :     /* Since MS will sometimes ignore a script if it isn't found in both */
<span class="lineNum">     305 </span>            :     /*  GPOS and GSUB we want to return the same script list no matter */
<span class="lineNum">     306 </span>            :     /*  what the setting of gpos ... so we totally ignore that argument */
<span class="lineNum">     307 </span>            :     /*  and always look at both sets of lookups */
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : /* Sergey Malkin from MicroSoft tells me:
<span class="lineNum">     310 </span>            :     Each shaping engine in Uniscribe can decide on its requirements for
<span class="lineNum">     311 </span>            :     layout tables - some of them require both GSUB and GPOS, in some cases
<span class="lineNum">     312 </span>            :     any table present is enough, or it can work without any table.
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :     Sometimes, purpose of the check is to determine if font is supporting
<span class="lineNum">     315 </span>            :     particular script - if required tables are not there font is just
<span class="lineNum">     316 </span>            :     rejected by this shaping engine. Sometimes, shaping engine can not just
<span class="lineNum">     317 </span>            :     reject the font because there are fonts using older shaping technologies
<span class="lineNum">     318 </span>            :     we still have to support, so it uses some logic when to fallback to
<span class="lineNum">     319 </span>            :     legacy layout code.
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     In your case this is Hebrew, where both tables are required to use
<span class="lineNum">     322 </span>            :     OpenType processing. Arabic requires both tables too, Latin requires
<span class="lineNum">     323 </span>            :     GSUB to execute GPOS. But in general, if you have both tables you should
<span class="lineNum">     324 </span>            :     be safe with any script to get fully featured OpenType shaping.
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : In other words, if we have a Hebrew font with just GPOS features they won't work,
<span class="lineNum">     327 </span>            : and MS will not use the font at all. We must add a GSUB table. In the unlikely
<span class="lineNum">     328 </span>            : event that we had a hebrew font with only GSUB it would not work either.
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : So if we want our lookups to have a chance of executing under Uniscribe we
<span class="lineNum">     331 </span>            : better make sure that both tables have the same script set.
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : (Sergey says we could optimize a little: A Latin GSUB table will run without
<span class="lineNum">     334 </span>            : a GPOS, but he says the GPOS won't work without a GSUB.)
<span class="lineNum">     335 </span>            : */
<span class="lineNum">     336 </span><span class="lineCov">         32 :     int cnt=0, tot=0, i;</span>
<span class="lineNum">     337 </span><span class="lineCov">         32 :     uint32 *scripts = NULL;</span>
<span class="lineNum">     338 </span>            :     OTLookup *test;
<span class="lineNum">     339 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">     340 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :     /* So here always give scripts for both (see comment above) no */
<span class="lineNum">     343 </span>            :     /*  matter what they asked for */
<span class="lineNum">     344 </span><span class="lineCov">         96 :     for ( gpos=0; gpos&lt;2; ++gpos ) {</span>
<span class="lineNum">     345 </span><span class="lineCov">        402 :         for ( test = gpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     346 </span><span class="lineCov">        338 :             if ( test-&gt;unused )</span>
<span class="lineNum">     347 </span><span class="lineCov">          8 :         continue;</span>
<span class="lineNum">     348 </span><span class="lineCov">        610 :             for ( fl=test-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">     349 </span><span class="lineCov">        280 :                 if ( fl-&gt;ismac )</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     351 </span><span class="lineCov">        822 :                 for ( sl=fl-&gt;scripts ; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">     352 </span><span class="lineCov">       1060 :                     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     353 </span><span class="lineCov">       1000 :                         if ( sl-&gt;script==scripts[i] )</span>
<span class="lineNum">     354 </span><span class="lineCov">        482 :                     break;</span>
<span class="lineNum">     355 </span>            :                     }
<span class="lineNum">     356 </span><span class="lineCov">        542 :                     if ( i==cnt ) {</span>
<span class="lineNum">     357 </span><span class="lineCov">         60 :                         if ( cnt&gt;=tot )</span>
<span class="lineNum">     358 </span><span class="lineCov">         26 :                             scripts = realloc(scripts,(tot+=10)*sizeof(uint32));</span>
<span class="lineNum">     359 </span><span class="lineCov">         60 :                         scripts[cnt++] = sl-&gt;script;</span>
<span class="lineNum">     360 </span>            :                     }
<span class="lineNum">     361 </span>            :                 }
<span class="lineNum">     362 </span>            :             }
<span class="lineNum">     363 </span>            :         }
<span class="lineNum">     364 </span>            :     }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">         32 :     if ( cnt==0 )</span>
<span class="lineNum">     367 </span><span class="lineCov">          6 : return( NULL );</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :     /* We want our scripts in alphabetic order */
<span class="lineNum">     370 </span><span class="lineCov">         26 :     qsort(scripts,cnt,sizeof(uint32),uint32_cmp);</span>
<span class="lineNum">     371 </span>            :     /* add a 0 entry to mark the end of the list */
<span class="lineNum">     372 </span><span class="lineCov">         26 :     if ( cnt&gt;=tot )</span>
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :         scripts = realloc(scripts,(tot+1)*sizeof(uint32));</span>
<span class="lineNum">     374 </span><span class="lineCov">         26 :     scripts[cnt] = 0;</span>
<span class="lineNum">     375 </span><span class="lineCov">         26 : return( scripts );</span>
<a name="376"><span class="lineNum">     376 </span>            : }</a>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineCov">         60 : uint32 *SFLangsInScript(SplineFont *sf,int gpos,uint32 script) {</span>
<span class="lineNum">     379 </span>            :     /* However, the language lists (I think) are distinct */
<span class="lineNum">     380 </span>            :     /* But giving a value of -1 for gpos will give us the set of languages in */
<span class="lineNum">     381 </span>            :     /*  both tables (for this script) */
<span class="lineNum">     382 </span><span class="lineCov">         60 :     int cnt=0, tot=0, i, g, l;</span>
<span class="lineNum">     383 </span><span class="lineCov">         60 :     uint32 *langs = NULL;</span>
<span class="lineNum">     384 </span>            :     OTLookup *test;
<span class="lineNum">     385 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">     386 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineCov">        180 :     for ( g=0; g&lt;2; ++g ) {</span>
<span class="lineNum">     389 </span><span class="lineCov">        120 :         if (( gpos==0 &amp;&amp; g==1 ) || ( gpos==1 &amp;&amp; g==0 ))</span>
<span class="lineNum">     390 </span><span class="lineCov">         60 :     continue;</span>
<span class="lineNum">     391 </span><span class="lineCov">        491 :         for ( test = g ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     392 </span><span class="lineCov">        431 :             if ( test-&gt;unused )</span>
<span class="lineNum">     393 </span><span class="lineCov">          3 :         continue;</span>
<span class="lineNum">     394 </span><span class="lineCov">        785 :             for ( fl=test-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">     395 </span><span class="lineCov">       1136 :                 for ( sl=fl-&gt;scripts ; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">     396 </span><span class="lineCov">        779 :                     if ( sl-&gt;script==script ) {</span>
<span class="lineNum">     397 </span><span class="lineCov">        713 :                         for ( l=0; l&lt;sl-&gt;lang_cnt; ++l ) {</span>
<span class="lineNum">     398 </span>            :                             uint32 lang;
<span class="lineNum">     399 </span><span class="lineCov">        442 :                             if ( l&lt;MAX_LANG )</span>
<span class="lineNum">     400 </span><span class="lineCov">        442 :                                 lang = sl-&gt;langs[l];</span>
<span class="lineNum">     401 </span>            :                             else
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :                                 lang = sl-&gt;morelangs[l-MAX_LANG];</span>
<span class="lineNum">     403 </span><span class="lineCov">        681 :                             for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     404 </span><span class="lineCov">        618 :                                 if ( lang==langs[i] )</span>
<span class="lineNum">     405 </span><span class="lineCov">        379 :                             break;</span>
<span class="lineNum">     406 </span>            :                             }
<span class="lineNum">     407 </span><span class="lineCov">        442 :                             if ( i==cnt ) {</span>
<span class="lineNum">     408 </span><span class="lineCov">         63 :                                 if ( cnt&gt;=tot )</span>
<span class="lineNum">     409 </span><span class="lineCov">         50 :                                     langs = realloc(langs,(tot+=10)*sizeof(uint32));</span>
<span class="lineNum">     410 </span><span class="lineCov">         63 :                                 langs[cnt++] = lang;</span>
<span class="lineNum">     411 </span>            :                             }
<span class="lineNum">     412 </span>            :                         }
<span class="lineNum">     413 </span>            :                     }
<span class="lineNum">     414 </span>            :                 }
<span class="lineNum">     415 </span>            :             }
<span class="lineNum">     416 </span>            :         }
<span class="lineNum">     417 </span>            :     }
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineCov">         60 :     if ( cnt==0 ) {</span>
<span class="lineNum">     420 </span>            :         /* We add dummy script entries. Because Uniscribe will refuse to */
<span class="lineNum">     421 </span>            :         /*  process some scripts if they don't have an entry in both GPOS */
<span class="lineNum">     422 </span>            :         /*  an GSUB. So if a script appears in either table, force it to */
<span class="lineNum">     423 </span>            :         /*  appear in both. That means we can get scripts with no lookups */
<span class="lineNum">     424 </span>            :         /*  and hence no languages. It seems that Uniscribe doesn't like */
<span class="lineNum">     425 </span>            :         /*  that either. So give each such script a dummy default language */
<span class="lineNum">     426 </span>            :         /*  entry. This is what VOLT does */
<span class="lineNum">     427 </span><span class="lineCov">         10 :         langs = calloc(2,sizeof(uint32));</span>
<span class="lineNum">     428 </span><span class="lineCov">         10 :         langs[0] = DEFAULT_LANG;</span>
<span class="lineNum">     429 </span><span class="lineCov">         10 : return( langs );</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :     /* We want our languages in alphabetic order */
<span class="lineNum">     433 </span><span class="lineCov">         50 :     qsort(langs,cnt,sizeof(uint32),lang_cmp);</span>
<span class="lineNum">     434 </span>            :     /* add a 0 entry to mark the end of the list */
<span class="lineNum">     435 </span><span class="lineCov">         50 :     if ( cnt&gt;=tot )</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :         langs = realloc(langs,(tot+1)*sizeof(uint32));</span>
<span class="lineNum">     437 </span><span class="lineCov">         50 :     langs[cnt] = 0;</span>
<span class="lineNum">     438 </span><span class="lineCov">         50 : return( langs );</span>
<a name="439"><span class="lineNum">     439 </span>            : }</a>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">         73 : uint32 *SFFeaturesInScriptLang(SplineFont *sf,int gpos,uint32 script,uint32 lang) {</span>
<span class="lineNum">     442 </span><span class="lineCov">         73 :     int cnt=0, tot=0, i, l, isg;</span>
<span class="lineNum">     443 </span><span class="lineCov">         73 :     uint32 *features = NULL;</span>
<span class="lineNum">     444 </span>            :     OTLookup *test;
<span class="lineNum">     445 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">     446 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     447 </span>            :     /* gpos==0 =&gt; GSUB, gpos==1 =&gt; GPOS, gpos==-1 =&gt; both, gpos==-2 =&gt; Both &amp; morx &amp; kern */
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineCov">         73 :     if ( sf-&gt;cidmaster ) sf=sf-&gt;cidmaster;</span>
<span class="lineNum">     450 </span><span class="lineCov">        219 :     for ( isg = 0; isg&lt;2; ++isg ) {</span>
<span class="lineNum">     451 </span><span class="lineCov">        146 :         if ( gpos&gt;=0 &amp;&amp; isg!=gpos )</span>
<span class="lineNum">     452 </span><span class="lineCov">         73 :     continue;</span>
<span class="lineNum">     453 </span><span class="lineCov">        766 :         for ( test = isg ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     454 </span><span class="lineCov">        693 :             if ( test-&gt;unused )</span>
<span class="lineNum">     455 </span><span class="lineCov">          3 :         continue;</span>
<span class="lineNum">     456 </span><span class="lineCov">       1266 :             for ( fl=test-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">     457 </span><span class="lineCov">        576 :                 if ( fl-&gt;ismac &amp;&amp; gpos!=-2 )</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     459 </span><span class="lineCov">        576 :                 if ( script==0xffffffff ) {</span>
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :                     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                         if ( fl-&gt;featuretag==features[i] )</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">     463 </span>            :                     }
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :                     if ( i==cnt ) {</span>
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :                         if ( cnt&gt;=tot )</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :                             features = realloc(features,(tot+=10)*sizeof(uint32));</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :                         features[cnt++] = fl-&gt;featuretag;</span>
<span class="lineNum">     468 </span>            :                     }
<span class="lineNum">     469 </span><span class="lineCov">       1874 :                 } else for ( sl=fl-&gt;scripts ; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">     470 </span><span class="lineCov">       1298 :                     if ( sl-&gt;script==script ) {</span>
<span class="lineNum">     471 </span><span class="lineCov">        458 :                         int matched = false;</span>
<span class="lineNum">     472 </span><span class="lineCov">        458 :                         if ( fl-&gt;ismac &amp;&amp; gpos==-2 )</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                             matched = true;</span>
<span class="lineNum">     474 </span><span class="lineCov">        709 :                         else for ( l=0; l&lt;sl-&gt;lang_cnt; ++l ) {</span>
<span class="lineNum">     475 </span>            :                             uint32 testlang;
<span class="lineNum">     476 </span><span class="lineCov">        693 :                             if ( l&lt;MAX_LANG )</span>
<span class="lineNum">     477 </span><span class="lineCov">        693 :                                 testlang = sl-&gt;langs[l];</span>
<span class="lineNum">     478 </span>            :                             else
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                                 testlang = sl-&gt;morelangs[l-MAX_LANG];</span>
<span class="lineNum">     480 </span><span class="lineCov">        693 :                             if ( testlang==lang ) {</span>
<span class="lineNum">     481 </span><span class="lineCov">        442 :                                 matched = true;</span>
<span class="lineNum">     482 </span><span class="lineCov">        442 :                         break;</span>
<span class="lineNum">     483 </span>            :                             }
<span class="lineNum">     484 </span>            :                         }
<span class="lineNum">     485 </span><span class="lineCov">        458 :                         if ( matched ) {</span>
<span class="lineNum">     486 </span><span class="lineCov">       1516 :                             for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     487 </span><span class="lineCov">       1252 :                                 if ( fl-&gt;featuretag==features[i] )</span>
<span class="lineNum">     488 </span><span class="lineCov">        178 :                             break;</span>
<span class="lineNum">     489 </span>            :                             }
<span class="lineNum">     490 </span><span class="lineCov">        442 :                             if ( i==cnt ) {</span>
<span class="lineNum">     491 </span><span class="lineCov">        264 :                                 if ( cnt&gt;=tot )</span>
<span class="lineNum">     492 </span><span class="lineCov">         74 :                                     features = realloc(features,(tot+=10)*sizeof(uint32));</span>
<span class="lineNum">     493 </span><span class="lineCov">        264 :                                 features[cnt++] = fl-&gt;featuretag;</span>
<span class="lineNum">     494 </span>            :                             }
<span class="lineNum">     495 </span>            :                         }
<span class="lineNum">     496 </span>            :                     }
<span class="lineNum">     497 </span>            :                 }
<span class="lineNum">     498 </span>            :             }
<span class="lineNum">     499 </span>            :         }
<span class="lineNum">     500 </span>            :     }
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineCov">         73 :     if ( sf-&gt;design_size!=0 &amp;&amp; gpos ) {</span>
<span class="lineNum">     503 </span>            :         /* The 'size' feature is like no other. It has no lookups and so */
<span class="lineNum">     504 </span>            :         /*  we will never find it in the normal course of events. If the */
<span class="lineNum">     505 </span>            :         /*  user has specified a design size, then every script/lang combo */
<span class="lineNum">     506 </span>            :         /*  gets a 'size' feature which contains no lookups but feature */
<span class="lineNum">     507 </span>            :         /*  params */
<span class="lineNum">     508 </span><span class="lineCov">          1 :         if ( cnt&gt;=tot )</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :             features = realloc(features,(tot+=2)*sizeof(uint32));</span>
<span class="lineNum">     510 </span><span class="lineCov">          1 :         features[cnt++] = CHR('s','i','z','e');</span>
<span class="lineNum">     511 </span>            :     }
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineCov">         73 :     if ( cnt==0 )</span>
<span class="lineNum">     514 </span><span class="lineCov">         10 : return( calloc(1,sizeof(uint32)) );</span>
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :     /* We don't care if our features are in alphabetical order here */
<span class="lineNum">     517 </span>            :     /*  all that matters is whether the complete list of features is */
<span class="lineNum">     518 </span>            :     /*  ordering here would be irrelevant */
<span class="lineNum">     519 </span>            :     /* qsort(features,cnt,sizeof(uint32),uint32_cmp); */
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :     /* add a 0 entry to mark the end of the list */
<span class="lineNum">     522 </span><span class="lineCov">         63 :     if ( cnt&gt;=tot )</span>
<span class="lineNum">     523 </span><span class="lineCov">          2 :         features = realloc(features,(tot+1)*sizeof(uint32));</span>
<span class="lineNum">     524 </span><span class="lineCov">         63 :     features[cnt] = 0;</span>
<span class="lineNum">     525 </span><span class="lineCov">         63 : return( features );</span>
<a name="526"><span class="lineNum">     526 </span>            : }</a>
<span class="lineNum">     527 </span>            : 
<span class="lineNum">     528 </span><span class="lineCov">        265 : OTLookup **SFLookupsInScriptLangFeature(SplineFont *sf,int gpos,uint32 script,uint32 lang, uint32 feature) {</span>
<span class="lineNum">     529 </span><span class="lineCov">        265 :     int cnt=0, tot=0, l;</span>
<span class="lineNum">     530 </span><span class="lineCov">        265 :     OTLookup **lookups = NULL;</span>
<span class="lineNum">     531 </span>            :     OTLookup *test;
<span class="lineNum">     532 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">     533 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span><span class="lineCov">       5877 :     for ( test = gpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     536 </span><span class="lineCov">       5612 :         if ( test-&gt;unused )</span>
<span class="lineNum">     537 </span><span class="lineCov">         16 :     continue;</span>
<span class="lineNum">     538 </span><span class="lineCov">       9716 :         for ( fl=test-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">     539 </span><span class="lineCov">       4562 :             if ( fl-&gt;featuretag==feature ) {</span>
<span class="lineNum">     540 </span><span class="lineCov">       1016 :                 for ( sl=fl-&gt;scripts ; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">     541 </span><span class="lineCov">        936 :                     if ( sl-&gt;script==script ) {</span>
<span class="lineNum">     542 </span><span class="lineCov">        695 :                         for ( l=0; l&lt;sl-&gt;lang_cnt; ++l ) {</span>
<span class="lineNum">     543 </span>            :                             uint32 testlang;
<span class="lineNum">     544 </span><span class="lineCov">        685 :                             if ( l&lt;MAX_LANG )</span>
<span class="lineNum">     545 </span><span class="lineCov">        685 :                                 testlang = sl-&gt;langs[l];</span>
<span class="lineNum">     546 </span>            :                             else
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :                                 testlang = sl-&gt;morelangs[l-MAX_LANG];</span>
<span class="lineNum">     548 </span><span class="lineCov">        685 :                             if ( testlang==lang ) {</span>
<span class="lineNum">     549 </span><span class="lineCov">        442 :                                 if ( cnt&gt;=tot )</span>
<span class="lineNum">     550 </span><span class="lineCov">        264 :                                     lookups = realloc(lookups,(tot+=10)*sizeof(OTLookup *));</span>
<span class="lineNum">     551 </span><span class="lineCov">        442 :                                 lookups[cnt++] = test;</span>
<span class="lineNum">     552 </span><span class="lineCov">        442 :         goto found;</span>
<span class="lineNum">     553 </span>            :                             }
<span class="lineNum">     554 </span>            :                         }
<span class="lineNum">     555 </span>            :                     }
<span class="lineNum">     556 </span>            :                 }
<span class="lineNum">     557 </span>            :             }
<span class="lineNum">     558 </span>            :         }
<span class="lineNum">     559 </span>            :         found:;
<span class="lineNum">     560 </span>            :     }
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineCov">        265 :     if ( cnt==0 )</span>
<span class="lineNum">     563 </span><span class="lineCov">          1 : return( NULL );</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :     /* lookup order is irrelevant here. might as well leave it in invocation order */
<span class="lineNum">     566 </span>            :     /* add a 0 entry to mark the end of the list */
<span class="lineNum">     567 </span><span class="lineCov">        264 :     if ( cnt&gt;=tot )</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :         lookups = realloc(lookups,(tot+1)*sizeof(OTLookup *));</span>
<span class="lineNum">     569 </span><span class="lineCov">        264 :     lookups[cnt] = 0;</span>
<span class="lineNum">     570 </span><span class="lineCov">        264 : return( lookups );</span>
<a name="571"><span class="lineNum">     571 </span>            : }</a>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineCov">       2286 : static int LigaturesFirstComponentGID(SplineFont *sf,char *components) {</span>
<span class="lineNum">     574 </span>            :     int gid, ch;
<span class="lineNum">     575 </span>            :     char *pt;
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineCov">       2286 :     for ( pt = components; *pt!='\0' &amp;&amp; *pt!=' '; ++pt );</span>
<span class="lineNum">     578 </span><span class="lineCov">       2286 :     ch = *pt; *pt = '\0';</span>
<span class="lineNum">     579 </span><span class="lineCov">       2286 :     gid = SFFindExistingSlot(sf,-1,components);</span>
<span class="lineNum">     580 </span><span class="lineCov">       2286 :     *pt = ch;</span>
<span class="lineNum">     581 </span><span class="lineCov">       2286 : return( gid );</span>
<a name="582"><span class="lineNum">     582 </span>            : }</a>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov">       5690 : static int PSTValid(SplineFont *sf,PST *pst) {</span>
<span class="lineNum">     585 </span>            :     char *start, *pt, ch;
<span class="lineNum">     586 </span>            :     int ret;
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineCov">       5690 :     switch ( pst-&gt;type ) {</span>
<span class="lineNum">     589 </span>            :       case pst_position:
<span class="lineNum">     590 </span><span class="lineCov">          6 : return( true );</span>
<span class="lineNum">     591 </span>            :       case pst_pair:
<span class="lineNum">     592 </span><span class="lineCov">          3 : return( SCWorthOutputting(SFGetChar(sf,-1,pst-&gt;u.pair.paired)) );</span>
<span class="lineNum">     593 </span>            :       case pst_substitution: case pst_alternate: case pst_multiple:
<span class="lineNum">     594 </span>            :       case pst_ligature:
<span class="lineNum">     595 </span><span class="lineCov">      23150 :         for ( start = pst-&gt;u.mult.components; *start ; ) {</span>
<span class="lineNum">     596 </span><span class="lineCov">      11942 :             for ( pt=start; *pt &amp;&amp; *pt!=' '; ++pt );</span>
<span class="lineNum">     597 </span><span class="lineCov">      11942 :             ch = *pt; *pt = '\0';</span>
<span class="lineNum">     598 </span><span class="lineCov">      11942 :             ret = SCWorthOutputting(SFGetChar(sf,-1,start));</span>
<span class="lineNum">     599 </span><span class="lineCov">      11942 :             if ( !ret ) {</span>
<span class="lineNum">     600 </span><span class="lineCov">        154 :                 LogError(_(&quot;Lookup subtable contains unused glyph %s making the whole subtable invalid&quot;), start);</span>
<span class="lineNum">     601 </span><span class="lineCov">        154 :                 *pt = ch;</span>
<span class="lineNum">     602 </span><span class="lineCov">        154 : return( false );</span>
<span class="lineNum">     603 </span>            :             }
<span class="lineNum">     604 </span><span class="lineCov">      11788 :             *pt = ch;</span>
<span class="lineNum">     605 </span><span class="lineCov">      11788 :             if ( ch==0 )</span>
<span class="lineNum">     606 </span><span class="lineCov">       5527 :                 start = pt;</span>
<span class="lineNum">     607 </span>            :             else
<span class="lineNum">     608 </span><span class="lineCov">       6261 :                 start = pt+1;</span>
<span class="lineNum">     609 </span>            :         }
<span class="lineNum">     610 </span>            :       default:
<span class="lineNum">     611 </span><span class="lineCov">       5527 :       break;</span>
<span class="lineNum">     612 </span>            :     }
<span class="lineNum">     613 </span><span class="lineCov">       5527 : return( true );</span>
<a name="614"><span class="lineNum">     614 </span>            : }</a>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">        118 : SplineChar **SFGlyphsWithPSTinSubtable(SplineFont *sf,struct lookup_subtable *subtable) {</span>
<span class="lineNum">     617 </span><span class="lineCov">        118 :     uint8 *used = calloc(sf-&gt;glyphcnt,sizeof(uint8));</span>
<span class="lineNum">     618 </span>            :     SplineChar **glyphs, *sc;
<span class="lineNum">     619 </span>            :     int i, k, gid, cnt;
<span class="lineNum">     620 </span>            :     KernPair *kp;
<span class="lineNum">     621 </span>            :     PST *pst;
<span class="lineNum">     622 </span><span class="lineCov">        118 :     int ispair = subtable-&gt;lookup-&gt;lookup_type == gpos_pair;</span>
<span class="lineNum">     623 </span><span class="lineCov">        118 :     int isliga = subtable-&gt;lookup-&gt;lookup_type == gsub_ligature;</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineCov">     875830 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( SCWorthOutputting(sc = sf-&gt;glyphs[i]) ) {</span>
<span class="lineNum">     626 </span><span class="lineCov">      98731 :         if ( ispair ) {</span>
<span class="lineNum">     627 </span><span class="lineCov">      24645 :             for ( k=0; k&lt;2; ++k ) {</span>
<span class="lineNum">     628 </span><span class="lineCov">      16862 :                 for ( kp= k ? sc-&gt;kerns : sc-&gt;vkerns; kp!=NULL ; kp=kp-&gt;next ) {</span>
<span class="lineNum">     629 </span><span class="lineCov">        559 :                     if ( !SCWorthOutputting(kp-&gt;sc))</span>
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     631 </span><span class="lineCov">        559 :                     if ( kp-&gt;subtable == subtable ) {</span>
<span class="lineNum">     632 </span><span class="lineCov">        380 :                         used[i] = true;</span>
<span class="lineNum">     633 </span><span class="lineCov">        380 :     goto continue_;</span>
<span class="lineNum">     634 </span>            :                     }
<span class="lineNum">     635 </span>            :                 }
<span class="lineNum">     636 </span>            :             }
<span class="lineNum">     637 </span>            :         }
<span class="lineNum">     638 </span><span class="lineCov">     177217 :         for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">     639 </span><span class="lineCov">      79307 :             if ( pst-&gt;subtable == subtable &amp;&amp; PSTValid(sf,pst)) {</span>
<span class="lineNum">     640 </span><span class="lineCov">       2727 :                 if ( !isliga ) {</span>
<span class="lineNum">     641 </span><span class="lineCov">        441 :                     used[i] = true;</span>
<span class="lineNum">     642 </span><span class="lineCov">        441 :     goto continue_;</span>
<span class="lineNum">     643 </span>            :                 } else {
<span class="lineNum">     644 </span><span class="lineCov">       2286 :                     gid = LigaturesFirstComponentGID(sf,pst-&gt;u.lig.components);</span>
<span class="lineNum">     645 </span><span class="lineCov">       2286 :                     pst-&gt;u.lig.lig = sc;</span>
<span class="lineNum">     646 </span><span class="lineCov">       2286 :                     if ( gid!=-1 )</span>
<span class="lineNum">     647 </span><span class="lineCov">       2286 :                         used[gid] = true;</span>
<span class="lineNum">     648 </span>            :                     /* can't continue here. ffi might be &quot;f+f+i&quot; and &quot;ff+i&quot; */
<span class="lineNum">     649 </span>            :                     /*  and we need to mark both &quot;f&quot; and &quot;ff&quot; as used */
<span class="lineNum">     650 </span>            :                 }
<span class="lineNum">     651 </span>            :             }
<span class="lineNum">     652 </span>            :         }
<span class="lineNum">     653 </span>            :     continue_: ;
<span class="lineNum">     654 </span>            :     }
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span><span class="lineCov">     875830 :     for ( i=cnt=0 ; i&lt;sf-&gt;glyphcnt; ++i )</span>
<span class="lineNum">     657 </span><span class="lineCov">     875712 :         if ( used[i] )</span>
<span class="lineNum">     658 </span><span class="lineCov">       1534 :             ++cnt;</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineCov">        118 :     if ( cnt==0 ) {</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :         free(used);</span>
<span class="lineNum">     662 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     663 </span>            :     }
<span class="lineNum">     664 </span><span class="lineCov">        118 :     glyphs = malloc((cnt+1)*sizeof(SplineChar *));</span>
<span class="lineNum">     665 </span><span class="lineCov">     875830 :     for ( i=cnt=0 ; i&lt;sf-&gt;glyphcnt; ++i ) {</span>
<span class="lineNum">     666 </span><span class="lineCov">     875712 :         if ( used[i] )</span>
<span class="lineNum">     667 </span><span class="lineCov">       1534 :             glyphs[cnt++] = sf-&gt;glyphs[i];</span>
<span class="lineNum">     668 </span>            :     }
<span class="lineNum">     669 </span><span class="lineCov">        118 :     glyphs[cnt] = NULL;</span>
<span class="lineNum">     670 </span><span class="lineCov">        118 :     free(used);</span>
<span class="lineNum">     671 </span><span class="lineCov">        118 : return( glyphs );</span>
<a name="672"><span class="lineNum">     672 </span>            : }</a>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span><span class="lineNoCov">          0 : SplineChar **SFGlyphsWithLigatureinLookup(SplineFont *sf,struct lookup_subtable *subtable) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :     uint8 *used = calloc(sf-&gt;glyphcnt,sizeof(uint8));</span>
<span class="lineNum">     676 </span>            :     SplineChar **glyphs, *sc;
<span class="lineNum">     677 </span>            :     int i, cnt;
<span class="lineNum">     678 </span>            :     PST *pst;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( SCWorthOutputting(sc = sf-&gt;glyphs[i]) ) {</span>
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :         for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :             if ( pst-&gt;subtable == subtable ) {</span>
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :                 used[i] = true;</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :     goto continue_;</span>
<span class="lineNum">     685 </span>            :             }
<span class="lineNum">     686 </span>            :         }
<span class="lineNum">     687 </span>            :     continue_: ;
<span class="lineNum">     688 </span>            :     }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :     for ( i=cnt=0 ; i&lt;sf-&gt;glyphcnt; ++i )</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :         if ( used[i] )</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :             ++cnt;</span>
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :     if ( cnt==0 ) {</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :         free(used);</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     697 </span>            :     }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :     glyphs = malloc((cnt+1)*sizeof(SplineChar *));</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :     for ( i=cnt=0 ; i&lt;sf-&gt;glyphcnt; ++i ) {</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :         if ( used[i] )</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :             glyphs[cnt++] = sf-&gt;glyphs[i];</span>
<span class="lineNum">     703 </span>            :     }
<span class="lineNum">     704 </span><span class="lineNoCov">          0 :     glyphs[cnt] = NULL;</span>
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :     free(used);</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 : return( glyphs );</span>
<a name="707"><span class="lineNum">     707 </span>            : }</a>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineNoCov">          0 : static void TickLookupKids(OTLookup *otl) {</span>
<span class="lineNum">     710 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">     711 </span>            :     int i,j;
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :     for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :         if ( sub-&gt;fpst!=NULL ) {</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;sub-&gt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     716 </span><span class="lineNoCov">          0 :                 struct fpst_rule *rule = &amp;sub-&gt;fpst-&gt;rules[i];</span>
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :                 for ( j=0; j&lt;rule-&gt;lookup_cnt; ++j ) {</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                     if ( rule-&gt;lookups[j].lookup!=NULL )</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                         rule-&gt;lookups[j].lookup-&gt;in_gpos = true;</span>
<span class="lineNum">     720 </span>            :                 }
<span class="lineNum">     721 </span>            :             }
<span class="lineNum">     722 </span>            :         }
<span class="lineNum">     723 </span>            :     }
<a name="724"><span class="lineNum">     724 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">         24 : void SFFindUnusedLookups(SplineFont *sf) {</span>
<span class="lineNum">     727 </span>            :     OTLookup *test;
<span class="lineNum">     728 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">     729 </span>            :     int gpos;
<span class="lineNum">     730 </span>            :     AnchorClass *ac;
<span class="lineNum">     731 </span>            :     AnchorPoint *ap;
<span class="lineNum">     732 </span>            :     SplineChar *sc;
<span class="lineNum">     733 </span>            :     KernPair *kp;
<span class="lineNum">     734 </span>            :     PST *pst;
<span class="lineNum">     735 </span>            :     int i,k,gid,isv;
<span class="lineNum">     736 </span><span class="lineCov">         24 :     SplineFont *_sf = sf;</span>
<span class="lineNum">     737 </span>            :     Justify *jscripts;
<span class="lineNum">     738 </span>            :     struct jstf_lang *jlangs;
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">         24 :     if ( _sf-&gt;cidmaster ) _sf = _sf-&gt;cidmaster;</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span>            :     /* Some things are obvious. If a subtable consists of a kernclass or some */
<span class="lineNum">     743 </span>            :     /*  such, then obviously it is used. But more distributed info takes more */
<span class="lineNum">     744 </span>            :     /*  work. So mark anything easy as used, and anything difficult as unused */
<span class="lineNum">     745 </span>            :     /* We'll work on the difficult things later */
<span class="lineNum">     746 </span><span class="lineCov">         72 :     for ( gpos=0; gpos&lt;2; ++gpos ) {</span>
<span class="lineNum">     747 </span><span class="lineCov">        239 :         for ( test = gpos ? _sf-&gt;gpos_lookups : _sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     748 </span><span class="lineCov">        390 :             for ( sub = test-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">     749 </span><span class="lineCov">        199 :                 if ( sub-&gt;kc!=NULL || sub-&gt;fpst!=NULL || sub-&gt;sm!=NULL ) {</span>
<span class="lineNum">     750 </span><span class="lineCov">         28 :                     sub-&gt;unused = false;</span>
<span class="lineNum">     751 </span><span class="lineCov">         28 :             continue;</span>
<span class="lineNum">     752 </span>            :                 }
<span class="lineNum">     753 </span><span class="lineCov">        171 :                 sub-&gt;unused = true;</span>
<span class="lineNum">     754 </span>            :                 /* We'll turn the following bit back on if there turns out */
<span class="lineNum">     755 </span>            :                 /*  to be an anchor class attached to it -- that is subtly */
<span class="lineNum">     756 </span>            :                 /*  different than being unused -- unused will be set if all */
<span class="lineNum">     757 </span>            :                 /*  acs are unused, this bit will be on if there are unused */
<span class="lineNum">     758 </span>            :                 /*  classes that still refer to us. */
<span class="lineNum">     759 </span><span class="lineCov">        171 :                 sub-&gt;anchor_classes = false;</span>
<span class="lineNum">     760 </span>            :             }
<span class="lineNum">     761 </span>            :         }
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :     /* To be useful an anchor class must have both at least one base and one mark */
<span class="lineNum">     765 </span>            :     /*  (for cursive anchors that means at least one entry and at least one exit) */
<span class="lineNum">     766 </span>            :     /* Start by assuming the worst */
<span class="lineNum">     767 </span><span class="lineCov">         53 :     for ( ac = _sf-&gt;anchor; ac!=NULL; ac=ac-&gt;next )</span>
<span class="lineNum">     768 </span><span class="lineCov">         29 :         ac-&gt;has_mark = ac-&gt;has_base = false;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span>            :     /* Ok, for each glyph, look at all lookups (or anchor classes) it affects */
<span class="lineNum">     771 </span>            :     /*  and mark the appropriate parts of them as used */
<span class="lineNum">     772 </span><span class="lineCov">         24 :     k = 0;</span>
<span class="lineNum">     773 </span>            :     do {
<span class="lineNum">     774 </span><span class="lineCov">         27 :         sf = _sf-&gt;subfontcnt==0 ? _sf : _sf-&gt;subfonts[k];</span>
<span class="lineNum">     775 </span><span class="lineCov">     154508 :         for ( gid=0; gid&lt;sf-&gt;glyphcnt; ++gid ) if ( SCWorthOutputting(sc = sf-&gt;glyphs[gid]) ) {</span>
<span class="lineNum">     776 </span><span class="lineCov">      18071 :             for ( ap=sc-&gt;anchor; ap!=NULL; ap=ap-&gt;next ) {</span>
<span class="lineNum">     777 </span><span class="lineCov">       2389 :                 switch ( ap-&gt;type ) {</span>
<span class="lineNum">     778 </span>            :                   case at_mark: case at_centry:
<span class="lineNum">     779 </span><span class="lineCov">        463 :                     ap-&gt;anchor-&gt;has_mark = true;</span>
<span class="lineNum">     780 </span><span class="lineCov">        463 :                   break;</span>
<span class="lineNum">     781 </span>            :                   case at_basechar: case at_baselig: case at_basemark:
<span class="lineNum">     782 </span>            :                   case at_cexit:
<span class="lineNum">     783 </span><span class="lineCov">       1926 :                     ap-&gt;anchor-&gt;has_base = true;</span>
<span class="lineNum">     784 </span><span class="lineCov">       1926 :                   break;</span>
<span class="lineNum">     785 </span>            :                   default:
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">     787 </span>            :                 }
<span class="lineNum">     788 </span>            :             }
<span class="lineNum">     789 </span><span class="lineCov">      47046 :             for ( isv=0; isv&lt;2; ++isv ) {</span>
<span class="lineNum">     790 </span><span class="lineCov">      35557 :                 for ( kp= isv ? sc-&gt;kerns : sc-&gt;vkerns ; kp!=NULL; kp=kp-&gt;next ) {</span>
<span class="lineNum">     791 </span><span class="lineCov">       4193 :                     if ( SCWorthOutputting(kp-&gt;sc))</span>
<span class="lineNum">     792 </span><span class="lineCov">       4193 :                         kp-&gt;subtable-&gt;unused = false;</span>
<span class="lineNum">     793 </span>            :                 }
<span class="lineNum">     794 </span>            :             }
<span class="lineNum">     795 </span><span class="lineCov">      19213 :             for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">     796 </span><span class="lineCov">       3531 :                 if ( pst-&gt;subtable==NULL )</span>
<span class="lineNum">     797 </span><span class="lineCov">        643 :             continue;</span>
<span class="lineNum">     798 </span><span class="lineCov">       2888 :                 if ( !PSTValid(sf,pst))</span>
<span class="lineNum">     799 </span><span class="lineCov">         79 :             continue;</span>
<span class="lineNum">     800 </span><span class="lineCov">       2809 :                 pst-&gt;subtable-&gt;unused = false;</span>
<span class="lineNum">     801 </span>            :             }
<span class="lineNum">     802 </span>            :         }
<span class="lineNum">     803 </span><span class="lineCov">         27 :         ++k;</span>
<span class="lineNum">     804 </span><span class="lineCov">         27 :     } while ( k&lt;_sf-&gt;subfontcnt );</span>
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :     /* Finally for any anchor class that has both a mark and a base then it is */
<span class="lineNum">     807 </span>            :     /*  used, and its lookup is also used */
<span class="lineNum">     808 </span>            :     /* Also, even if unused, as long as the anchor class exists we must keep */
<span class="lineNum">     809 </span>            :     /*  the subtable around */
<span class="lineNum">     810 </span><span class="lineCov">         53 :     for ( ac = _sf-&gt;anchor; ac!=NULL; ac=ac-&gt;next ) {</span>
<span class="lineNum">     811 </span><span class="lineCov">         29 :         if ( ac-&gt;subtable==NULL )</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">     813 </span><span class="lineCov">         29 :         ac-&gt;subtable-&gt;anchor_classes = true;</span>
<span class="lineNum">     814 </span><span class="lineCov">         29 :         if ( ac-&gt;has_mark &amp;&amp; ac-&gt;has_base )</span>
<span class="lineNum">     815 </span><span class="lineCov">         27 :             ac-&gt;subtable-&gt;unused = false;</span>
<span class="lineNum">     816 </span>            :     }
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span>            :     /* Now for each lookup, a lookup is unused if ALL subtables are unused */
<span class="lineNum">     819 </span><span class="lineCov">         72 :     for ( gpos=0; gpos&lt;2; ++gpos ) {</span>
<span class="lineNum">     820 </span><span class="lineCov">        239 :         for ( test = gpos ? _sf-&gt;gpos_lookups : _sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     821 </span><span class="lineCov">        191 :             test-&gt;unused = test-&gt;empty = true;</span>
<span class="lineNum">     822 </span><span class="lineCov">        223 :             for ( sub=test-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">     823 </span><span class="lineCov">        191 :                 if ( !sub-&gt;unused )</span>
<span class="lineNum">     824 </span><span class="lineCov">        186 :                     test-&gt;unused = false;</span>
<span class="lineNum">     825 </span><span class="lineCov">        191 :                 if ( !sub-&gt;unused &amp;&amp; !sub-&gt;anchor_classes ) {</span>
<span class="lineNum">     826 </span><span class="lineCov">        159 :                     test-&gt;empty = false;</span>
<span class="lineNum">     827 </span><span class="lineCov">        159 :             break;</span>
<span class="lineNum">     828 </span>            :                 }
<span class="lineNum">     829 </span>            :             }
<span class="lineNum">     830 </span>            :         }
<span class="lineNum">     831 </span>            :     }
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :     /* I store JSTF max lookups in the gpos list because they have the same */
<span class="lineNum">     834 </span>            :     /*  format. But now I need to tease them out and learn which lookups are */
<span class="lineNum">     835 </span>            :     /*  used in GPOS and which in JSTF (and conceivably which get duplicated */
<span class="lineNum">     836 </span>            :     /*  and placed in both) */
<span class="lineNum">     837 </span><span class="lineCov">         77 :     for ( test = sf-&gt;gpos_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     838 </span><span class="lineCov">         53 :         test-&gt;only_jstf = test-&gt;in_jstf = test-&gt;in_gpos = false;</span>
<span class="lineNum">     839 </span><span class="lineCov">         53 :         if ( test-&gt;features!=NULL )</span>
<span class="lineNum">     840 </span><span class="lineCov">         51 :             test-&gt;in_gpos = true;</span>
<span class="lineNum">     841 </span>            :     }
<span class="lineNum">     842 </span><span class="lineCov">         24 :     for ( jscripts = sf-&gt;justify; jscripts!=NULL; jscripts=jscripts-&gt;next ) {</span>
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :         for ( jlangs=jscripts-&gt;langs; jlangs!=NULL; jlangs=jlangs-&gt;next ) {</span>
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;jlangs-&gt;cnt; ++i ) {</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                 struct jstf_prio *prio = &amp;jlangs-&gt;prios[i];</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                 if ( prio-&gt;enableShrink!=NULL )</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                     for ( k=0; prio-&gt;enableShrink[k]!=NULL; ++k )</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :                         prio-&gt;enableShrink[k]-&gt;in_gpos = true;</span>
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :                 if ( prio-&gt;disableShrink!=NULL )</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :                     for ( k=0; prio-&gt;disableShrink[k]!=NULL; ++k )</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :                         prio-&gt;disableShrink[k]-&gt;in_gpos = true;</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :                 if ( prio-&gt;enableExtend!=NULL )</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :                     for ( k=0; prio-&gt;enableExtend[k]!=NULL; ++k )</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :                         prio-&gt;enableExtend[k]-&gt;in_gpos = true;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                 if ( prio-&gt;disableExtend!=NULL )</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :                     for ( k=0; prio-&gt;disableExtend[k]!=NULL; ++k )</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :                         prio-&gt;disableExtend[k]-&gt;in_gpos = true;</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                 if ( prio-&gt;maxShrink!=NULL )</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :                     for ( k=0; prio-&gt;maxShrink[k]!=NULL; ++k )</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :                         prio-&gt;maxShrink[k]-&gt;in_jstf = true;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                 if ( prio-&gt;maxExtend!=NULL )</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :                     for ( k=0; prio-&gt;maxExtend[k]!=NULL; ++k )</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :                         prio-&gt;maxExtend[k]-&gt;in_jstf = true;</span>
<span class="lineNum">     864 </span>            :             }
<span class="lineNum">     865 </span>            :         }
<span class="lineNum">     866 </span>            :     }
<span class="lineNum">     867 </span><span class="lineCov">         77 :     for ( test = sf-&gt;gpos_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     868 </span><span class="lineCov">         53 :         if ( test-&gt;in_gpos &amp;&amp; (test-&gt;lookup_type==gpos_context || test-&gt;lookup_type==gpos_contextchain))</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :             TickLookupKids(test);</span>
<span class="lineNum">     870 </span>            :     }
<span class="lineNum">     871 </span><span class="lineCov">         77 :     for ( test = sf-&gt;gpos_lookups; test!=NULL; test = test-&gt;next )</span>
<span class="lineNum">     872 </span><span class="lineCov">         53 :         test-&gt;only_jstf = test-&gt;in_jstf &amp;&amp; !test-&gt;in_gpos;</span>
<a name="873"><span class="lineNum">     873 </span><span class="lineCov">         24 : }</span></a>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 : void SFFindClearUnusedLookupBits(SplineFont *sf) {</span>
<span class="lineNum">     876 </span>            :     OTLookup *test;
<span class="lineNum">     877 </span>            :     int gpos;
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     for ( gpos=0; gpos&lt;2; ++gpos ) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :         for ( test = gpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; test!=NULL; test = test-&gt;next ) {</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :             test-&gt;unused = false;</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :             test-&gt;empty = false;</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :             test-&gt;def_lang_checked = false;</span>
<span class="lineNum">     884 </span>            :         }
<span class="lineNum">     885 </span>            :     }
<a name="886"><span class="lineNum">     886 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span><span class="lineNoCov">          0 : static void SFRemoveAnchorPointsOfAC(SplineFont *sf,AnchorClass *ac) {</span>
<span class="lineNum">     889 </span>            :     int gid;
<span class="lineNum">     890 </span>            :     SplineChar *sc;
<span class="lineNum">     891 </span>            :     AnchorPoint *ap, *prev, *next;
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :     for ( gid=0; gid&lt;sf-&gt;glyphcnt; ++gid ) if ( (sc = sf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         for ( prev=NULL, ap=sc-&gt;anchor; ap!=NULL; ap=next ) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :             next = ap-&gt;next;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :             if ( ap-&gt;anchor!=ac )</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :                 prev = ap;</span>
<span class="lineNum">     898 </span>            :             else {
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :                 if ( prev==NULL )</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :                     sc-&gt;anchor = next;</span>
<span class="lineNum">     901 </span>            :                 else
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                     prev-&gt;next = next;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                 ap-&gt;next = NULL;</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                 AnchorPointsFree(ap);</span>
<span class="lineNum">     905 </span>            :             }
<span class="lineNum">     906 </span>            :         }
<span class="lineNum">     907 </span>            :     }
<a name="908"><span class="lineNum">     908 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span><span class="lineNoCov">          0 : static OTLookup **RemoveFromList(OTLookup **list, OTLookup *dying) {</span>
<span class="lineNum">     911 </span>            :     int i,j;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     if ( list==NULL )</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :     for ( i=0; list[i]!=NULL; ++i ) {</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :         if ( list[i]==dying ) {</span>
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :             for ( j=i+1; ; ++j ) {</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                 list[j-1] = list[j];</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :                 if ( list[j]==NULL )</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">     922 </span>            :         }
<span class="lineNum">     923 </span>            :     }
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     if ( list[0]==NULL ) {</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :         free(list);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span><span class="lineNoCov">          0 : return( list );</span>
<a name="929"><span class="lineNum">     929 </span>            : }</a>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">          1 : static void RemoveJSTFReferences(SplineFont *sf,OTLookup *dying) {</span>
<span class="lineNum">     932 </span>            :     Justify *jscript;
<span class="lineNum">     933 </span>            :     struct jstf_lang *jlang;
<span class="lineNum">     934 </span>            :     int i;
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span><span class="lineCov">          1 :     for ( jscript = sf-&gt;justify; jscript!=NULL; jscript=jscript-&gt;next ) {</span>
<span class="lineNum">     937 </span><span class="lineNoCov">          0 :         for ( jlang=jscript-&gt;langs; jlang!=NULL; jlang=jlang-&gt;next ) {</span>
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;jlang-&gt;cnt; ++i ) {</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :                 struct jstf_prio *prio = &amp;jlang-&gt;prios[i];</span>
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :                 prio-&gt;enableShrink = RemoveFromList(prio-&gt;enableShrink,dying);</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :                 prio-&gt;disableShrink = RemoveFromList(prio-&gt;disableShrink,dying);</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :                 prio-&gt;enableExtend = RemoveFromList(prio-&gt;enableExtend,dying);</span>
<span class="lineNum">     943 </span><span class="lineNoCov">          0 :                 prio-&gt;disableExtend = RemoveFromList(prio-&gt;disableExtend,dying);</span>
<span class="lineNum">     944 </span><span class="lineNoCov">          0 :                 prio-&gt;maxShrink = RemoveFromList(prio-&gt;maxShrink,dying);</span>
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :                 prio-&gt;maxExtend = RemoveFromList(prio-&gt;maxExtend,dying);</span>
<span class="lineNum">     946 </span>            :             }
<span class="lineNum">     947 </span>            :         }
<span class="lineNum">     948 </span>            :     }
<a name="949"><span class="lineNum">     949 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineCov">          1 : static void RemoveNestedReferences(SplineFont *sf,int isgpos) {</span>
<span class="lineNum">     952 </span>            :     OTLookup *otl;
<span class="lineNum">     953 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">     954 </span>            :     int i,j,k;
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span><span class="lineCov">          3 :     for ( otl = isgpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; otl!=NULL; otl = otl-&gt;next ) {</span>
<span class="lineNum">     957 </span><span class="lineCov">          2 :         if ( otl-&gt;lookup_type==morx_context ) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :             for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                 ASM *sm = sub-&gt;sm;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :                 if ( sm-&gt;type==asm_context ) {</span>
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                     for ( i=0; i&lt;sm-&gt;state_cnt*sm-&gt;class_cnt; ++i ) {</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                         struct asm_state *state = &amp;sm-&gt;state[i];</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                         if ( state-&gt;u.context.mark_lookup == otl )</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                             state-&gt;u.context.mark_lookup = NULL;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                         if ( state-&gt;u.context.cur_lookup == otl )</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :                             state-&gt;u.context.cur_lookup = NULL;</span>
<span class="lineNum">     967 </span>            :                     }
<span class="lineNum">     968 </span>            :                 }
<span class="lineNum">     969 </span>            :             }
<span class="lineNum">     970 </span>            :         /* Reverse chaining tables do not reference lookups. The match pattern*/
<span class="lineNum">     971 </span>            :         /*  is a (exactly one) coverage table, and each glyph in that table   */
<span class="lineNum">     972 </span>            :         /*  as an inline replacement. There is no lookup to do the replacement*/
<span class="lineNum">     973 </span>            :         /* (so we ignore it here) */
<span class="lineNum">     974 </span><span class="lineCov">          4 :         } else if ( otl-&gt;lookup_type==gsub_context || otl-&gt;lookup_type==gsub_contextchain ||</span>
<span class="lineNum">     975 </span><span class="lineCov">          4 :                 otl-&gt;lookup_type==gpos_context || otl-&gt;lookup_type==gpos_contextchain ) {</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :             for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :                 FPST *fpst = sub-&gt;fpst;</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :                 for ( i=0; i&lt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :                     for ( j=0; j&lt;fpst-&gt;rules[i].lookup_cnt; ++j ) {</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :                         if ( fpst-&gt;rules[i].lookups[j].lookup == otl ) {</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :                             for ( k=j+1; k&lt;fpst-&gt;rules[i].lookup_cnt; ++k )</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :                                 fpst-&gt;rules[i].lookups[k-1] = fpst-&gt;rules[i].lookups[k];</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :                             --fpst-&gt;rules[i].lookup_cnt;</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :                             --j;</span>
<span class="lineNum">     985 </span>            :                         }
<span class="lineNum">     986 </span>            :                     }
<span class="lineNum">     987 </span>            :                 }
<span class="lineNum">     988 </span>            :             }
<span class="lineNum">     989 </span>            :         }
<span class="lineNum">     990 </span>            :     }
<a name="991"><span class="lineNum">     991 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineNoCov">          0 : void SFRemoveUnusedLookupSubTables(SplineFont *sf,</span>
<span class="lineNum">     994 </span>            :         int remove_incomplete_anchorclasses,
<span class="lineNum">     995 </span>            :         int remove_unused_lookups) {
<span class="lineNum">     996 </span>            :     int gpos;
<span class="lineNum">     997 </span>            :     struct lookup_subtable *sub, *subnext, *prev;
<span class="lineNum">     998 </span>            :     AnchorClass *ac, *acprev, *acnext;
<span class="lineNum">     999 </span>            :     OTLookup *otl, *otlprev, *otlnext;
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :     /* Presumes someone has called SFFindUnusedLookups first */
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     if ( remove_incomplete_anchorclasses ) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :         for ( acprev=NULL, ac=sf-&gt;anchor; ac!=NULL; ac=acnext ) {</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :             acnext = ac-&gt;next;</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :             if ( ac-&gt;has_mark &amp;&amp; ac-&gt;has_base )</span>
<span class="lineNum">    1007 </span><span class="lineNoCov">          0 :                 acprev = ac;</span>
<span class="lineNum">    1008 </span>            :             else {
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :                 SFRemoveAnchorPointsOfAC(sf,ac);</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :                 ac-&gt;next = NULL;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                 AnchorClassesFree(ac);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                 if ( acprev==NULL )</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                     sf-&gt;anchor = acnext;</span>
<span class="lineNum">    1014 </span>            :                 else
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                     acprev = acnext;</span>
<span class="lineNum">    1016 </span>            :             }
<span class="lineNum">    1017 </span>            :         }
<span class="lineNum">    1018 </span>            :     }
<span class="lineNum">    1019 </span>            : 
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     for ( gpos=0; gpos&lt;2; ++gpos ) {</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :         for ( otl = gpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; otl!=NULL; otl = otlnext ) {</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :             otlnext = otl-&gt;next;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :             if ( remove_unused_lookups &amp;&amp; (otl-&gt;empty ||</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                     (otl-&gt;unused &amp;&amp; remove_incomplete_anchorclasses)) ) {</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :                 if ( otlprev!=NULL )</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :                     otlprev-&gt;next = otlnext;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                 else if ( gpos )</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :                     sf-&gt;gpos_lookups = otlnext;</span>
<span class="lineNum">    1029 </span>            :                 else
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                     sf-&gt;gsub_lookups = otlnext;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                 RemoveNestedReferences(sf,gpos);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :                 OTLookupFree(otl);</span>
<span class="lineNum">    1033 </span>            :             } else {
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                 for ( prev=NULL, sub=otl-&gt;subtables; sub!=NULL; sub=subnext ) {</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                     subnext = sub-&gt;next;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                     if ( sub-&gt;unused &amp;&amp;</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :                             (!sub-&gt;anchor_classes ||</span>
<span class="lineNum">    1038 </span>            :                               remove_incomplete_anchorclasses )) {
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                         if ( prev==NULL )</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :                             otl-&gt;subtables = subnext;</span>
<span class="lineNum">    1041 </span>            :                         else
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :                             prev-&gt;next = subnext;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                         free(sub-&gt;subtable_name);</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :                         chunkfree(sub,sizeof(*sub));</span>
<span class="lineNum">    1045 </span>            :                     } else
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                         prev = sub;</span>
<span class="lineNum">    1047 </span>            :                 }
<span class="lineNum">    1048 </span>            :             }
<span class="lineNum">    1049 </span>            :         }
<span class="lineNum">    1050 </span>            :     }
<a name="1051"><span class="lineNum">    1051 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span><span class="lineCov">          2 : void SFRemoveLookupSubTable(SplineFont *sf,struct lookup_subtable *sub, int remove_acs) {</span>
<span class="lineNum">    1054 </span><span class="lineCov">          2 :     OTLookup *otl = sub-&gt;lookup;</span>
<span class="lineNum">    1055 </span>            :     struct lookup_subtable *subprev, *subtest;
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span><span class="lineCov">          2 :     if ( sf-&gt;cidmaster!=NULL ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineCov">          2 :     if ( sub-&gt;sm!=NULL ) {</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :         ASM *prev = NULL, *test;</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :         for ( test=sf-&gt;sm; test!=NULL &amp;&amp; test!=sub-&gt;sm; prev=test, test=test-&gt;next );</span>
<span class="lineNum">    1062 </span><span class="lineNoCov">          0 :         if ( prev==NULL )</span>
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :             sf-&gt;sm = sub-&gt;sm-&gt;next;</span>
<span class="lineNum">    1064 </span>            :         else
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :             prev-&gt;next = sub-&gt;sm-&gt;next;</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :         sub-&gt;sm-&gt;next = NULL;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :         ASMFree(sub-&gt;sm);</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :         sub-&gt;sm = NULL;</span>
<span class="lineNum">    1069 </span><span class="lineCov">          2 :     } else if ( sub-&gt;fpst!=NULL ) {</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :         FPST *prev = NULL, *test;</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :         for ( test=sf-&gt;possub; test!=NULL &amp;&amp; test!=sub-&gt;fpst; prev=test, test=test-&gt;next );</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :         if ( prev==NULL )</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :             sf-&gt;possub = sub-&gt;fpst-&gt;next;</span>
<span class="lineNum">    1074 </span>            :         else
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :             prev-&gt;next = sub-&gt;fpst-&gt;next;</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :         sub-&gt;fpst-&gt;next = NULL;</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :         FPSTFree(sub-&gt;fpst);</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :         sub-&gt;fpst = NULL;</span>
<span class="lineNum">    1079 </span><span class="lineCov">          2 :     } else if ( sub-&gt;kc!=NULL ) {</span>
<span class="lineNum">    1080 </span><span class="lineCov">          1 :         KernClass *prev = NULL, *test;</span>
<span class="lineNum">    1081 </span><span class="lineCov">          1 :         for ( test=sf-&gt;kerns; test!=NULL &amp;&amp; test!=sub-&gt;kc; prev=test, test=test-&gt;next );</span>
<span class="lineNum">    1082 </span><span class="lineCov">          1 :         if ( test!=NULL ) {</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :             if ( prev==NULL )</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :                 sf-&gt;kerns = sub-&gt;kc-&gt;next;</span>
<span class="lineNum">    1085 </span>            :             else
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :                 prev-&gt;next = sub-&gt;kc-&gt;next;</span>
<span class="lineNum">    1087 </span>            :         } else {
<span class="lineNum">    1088 </span><span class="lineCov">          1 :             for ( prev=NULL,test=sf-&gt;vkerns; test!=NULL &amp;&amp; test!=sub-&gt;kc; prev=test, test=test-&gt;next );</span>
<span class="lineNum">    1089 </span><span class="lineCov">          1 :             if ( prev==NULL )</span>
<span class="lineNum">    1090 </span><span class="lineCov">          1 :                 sf-&gt;vkerns = sub-&gt;kc-&gt;next;</span>
<span class="lineNum">    1091 </span>            :             else
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :                 prev-&gt;next = sub-&gt;kc-&gt;next;</span>
<span class="lineNum">    1093 </span>            :         }
<span class="lineNum">    1094 </span><span class="lineCov">          1 :         sub-&gt;kc-&gt;next = NULL;</span>
<span class="lineNum">    1095 </span><span class="lineCov">          1 :         KernClassListFree(sub-&gt;kc);</span>
<span class="lineNum">    1096 </span><span class="lineCov">          1 :         sub-&gt;kc = NULL;</span>
<span class="lineNum">    1097 </span><span class="lineCov">          2 :     } else if ( otl-&gt;lookup_type==gpos_cursive || otl-&gt;lookup_type==gpos_mark2base ||</span>
<span class="lineNum">    1098 </span><span class="lineCov">          2 :             otl-&gt;lookup_type==gpos_mark2ligature || otl-&gt;lookup_type==gpos_mark2mark ) {</span>
<span class="lineNum">    1099 </span>            :         AnchorClass *ac, *acnext;
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :         for ( ac=sf-&gt;anchor; ac!=NULL; ac=acnext ) {</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :             acnext = ac-&gt;next;</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :             if ( ac-&gt;subtable==sub ) {</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :                 if ( remove_acs )</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                     SFRemoveAnchorClass(sf,ac);</span>
<span class="lineNum">    1105 </span>            :                 else
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                     ac-&gt;subtable = NULL;</span>
<span class="lineNum">    1107 </span>            :             }
<span class="lineNum">    1108 </span>            :         }
<span class="lineNum">    1109 </span>            :     } else {
<span class="lineNum">    1110 </span>            :         int i,k,v;
<span class="lineNum">    1111 </span>            :         SplineChar *sc;
<span class="lineNum">    1112 </span>            :         SplineFont *_sf;
<span class="lineNum">    1113 </span>            :         PST *pst, *prev, *next;
<span class="lineNum">    1114 </span>            :         KernPair *kp, *kpprev, *kpnext;
<span class="lineNum">    1115 </span><span class="lineCov">          1 :         k=0;</span>
<span class="lineNum">    1116 </span>            :         do {
<span class="lineNum">    1117 </span><span class="lineCov">          1 :             _sf = sf-&gt;subfontcnt==0 ? sf : sf-&gt;subfonts[k];</span>
<span class="lineNum">    1118 </span><span class="lineCov">         53 :             for ( i=0; i&lt;_sf-&gt;glyphcnt; ++i ) if ( (sc=_sf-&gt;glyphs[i])!=NULL ) {</span>
<span class="lineNum">    1119 </span><span class="lineCov">         79 :                 for ( pst=sc-&gt;possub, prev=NULL ; pst!=NULL; pst=next ) {</span>
<span class="lineNum">    1120 </span><span class="lineCov">         27 :                     next = pst-&gt;next;</span>
<span class="lineNum">    1121 </span><span class="lineCov">         27 :                     if ( pst-&gt;subtable==sub ) {</span>
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :                         if ( prev==NULL )</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                             sc-&gt;possub = next;</span>
<span class="lineNum">    1124 </span>            :                         else
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :                             prev-&gt;next = next;</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :                         pst-&gt;next = NULL;</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :                         PSTFree(pst);</span>
<span class="lineNum">    1128 </span>            :                     } else
<span class="lineNum">    1129 </span><span class="lineCov">         27 :                         prev = pst;</span>
<span class="lineNum">    1130 </span>            :                 }
<span class="lineNum">    1131 </span><span class="lineCov">        156 :                 for ( v=0; v&lt;2; ++v ) {</span>
<span class="lineNum">    1132 </span><span class="lineCov">        108 :                     for ( kp=v ? sc-&gt;vkerns : sc-&gt;kerns, kpprev=NULL ; kp!=NULL; kp=kpnext ) {</span>
<span class="lineNum">    1133 </span><span class="lineCov">          4 :                         kpnext = kp-&gt;next;</span>
<span class="lineNum">    1134 </span><span class="lineCov">          4 :                         if ( kp-&gt;subtable==sub ) {</span>
<span class="lineNum">    1135 </span><span class="lineCov">          2 :                             if ( kpprev!=NULL )</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :                                 kpprev-&gt;next = kpnext;</span>
<span class="lineNum">    1137 </span><span class="lineCov">          2 :                             else if ( v )</span>
<span class="lineNum">    1138 </span><span class="lineCov">          2 :                                 sc-&gt;vkerns = kpnext;</span>
<span class="lineNum">    1139 </span>            :                             else
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :                                 sc-&gt;kerns = kpnext;</span>
<span class="lineNum">    1141 </span><span class="lineCov">          2 :                             kp-&gt;next = NULL;</span>
<span class="lineNum">    1142 </span><span class="lineCov">          2 :                             KernPairsFree(kp);</span>
<span class="lineNum">    1143 </span>            :                         } else
<span class="lineNum">    1144 </span><span class="lineCov">          2 :                             kpprev = kp;</span>
<span class="lineNum">    1145 </span>            :                     }
<span class="lineNum">    1146 </span>            :                 }
<span class="lineNum">    1147 </span>            :             }
<span class="lineNum">    1148 </span><span class="lineCov">          1 :             ++k;</span>
<span class="lineNum">    1149 </span><span class="lineCov">          1 :         } while ( k&lt;sf-&gt;subfontcnt );</span>
<span class="lineNum">    1150 </span>            :     }
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineCov">          2 :     subprev = NULL;</span>
<span class="lineNum">    1153 </span><span class="lineCov">          2 :     for ( subtest = otl-&gt;subtables; subtest!=NULL &amp;&amp; subtest!=sub; subprev = subtest, subtest=subtest-&gt;next );</span>
<span class="lineNum">    1154 </span><span class="lineCov">          2 :     if ( subprev==NULL )</span>
<span class="lineNum">    1155 </span><span class="lineCov">          2 :         otl-&gt;subtables = sub-&gt;next;</span>
<span class="lineNum">    1156 </span>            :     else
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :         subprev-&gt;next = sub-&gt;next;</span>
<span class="lineNum">    1158 </span><span class="lineCov">          2 :     free(sub-&gt;subtable_name);</span>
<span class="lineNum">    1159 </span><span class="lineCov">          2 :     free(sub-&gt;suffix);</span>
<span class="lineNum">    1160 </span><span class="lineCov">          2 :     chunkfree(sub,sizeof(struct lookup_subtable));</span>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">          2 : }</span></a>
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span><span class="lineCov">          1 : void SFRemoveLookup(SplineFont *sf,OTLookup *otl,int remove_acs) {</span>
<span class="lineNum">    1164 </span>            :     OTLookup *test, *prev;
<span class="lineNum">    1165 </span>            :     int isgpos;
<span class="lineNum">    1166 </span>            :     struct lookup_subtable *sub, *subnext;
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">          1 :     if ( sf-&gt;cidmaster ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">          3 :     for ( sub = otl-&gt;subtables; sub!=NULL; sub=subnext ) {</span>
<span class="lineNum">    1171 </span><span class="lineCov">          2 :         subnext = sub-&gt;next;</span>
<span class="lineNum">    1172 </span><span class="lineCov">          2 :         SFRemoveLookupSubTable(sf,sub,remove_acs);</span>
<span class="lineNum">    1173 </span>            :     }
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineCov">          1 :     for ( prev=NULL, test=sf-&gt;gpos_lookups; test!=NULL &amp;&amp; test!=otl; prev=test, test=test-&gt;next );</span>
<span class="lineNum">    1176 </span><span class="lineCov">          1 :     if ( test==NULL ) {</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :         isgpos = false;</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :         for ( prev=NULL, test=sf-&gt;gsub_lookups; test!=NULL &amp;&amp; test!=otl; prev=test, test=test-&gt;next );</span>
<span class="lineNum">    1179 </span>            :     } else
<span class="lineNum">    1180 </span><span class="lineCov">          1 :         isgpos = true;</span>
<span class="lineNum">    1181 </span><span class="lineCov">          1 :     if ( prev!=NULL )</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :         prev-&gt;next = otl-&gt;next;</span>
<span class="lineNum">    1183 </span><span class="lineCov">          1 :     else if ( isgpos )</span>
<span class="lineNum">    1184 </span><span class="lineCov">          1 :         sf-&gt;gpos_lookups = otl-&gt;next;</span>
<span class="lineNum">    1185 </span>            :     else
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :         sf-&gt;gsub_lookups = otl-&gt;next;</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineCov">          1 :     RemoveNestedReferences(sf,isgpos);</span>
<span class="lineNum">    1189 </span><span class="lineCov">          1 :     RemoveJSTFReferences(sf,otl);</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineCov">          1 :     otl-&gt;next = NULL;</span>
<span class="lineNum">    1192 </span><span class="lineCov">          1 :     OTLookupFree(otl);</span>
<a name="1193"><span class="lineNum">    1193 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span><span class="lineCov">        118 : struct lookup_subtable *SFFindLookupSubtable(SplineFont *sf,char *name) {</span>
<span class="lineNum">    1196 </span>            :     int isgpos;
<span class="lineNum">    1197 </span>            :     OTLookup *otl;
<span class="lineNum">    1198 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span><span class="lineCov">        118 :     if ( sf-&gt;cidmaster ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineCov">        118 :     if ( name==NULL )</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span><span class="lineCov">        232 :     for ( isgpos=0; isgpos&lt;2; ++isgpos ) {</span>
<span class="lineNum">    1206 </span><span class="lineCov">        388 :         for ( otl = isgpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups ; otl!=NULL; otl=otl-&gt;next ) {</span>
<span class="lineNum">    1207 </span><span class="lineCov">        430 :             for ( sub = otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    1208 </span><span class="lineCov">        274 :                 if ( strcmp(name,sub-&gt;subtable_name)==0 )</span>
<span class="lineNum">    1209 </span><span class="lineCov">        118 : return( sub );</span>
<span class="lineNum">    1210 </span>            :             }
<span class="lineNum">    1211 </span>            :         }
<span class="lineNum">    1212 </span>            :     }
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 : return( NULL );</span>
<a name="1214"><span class="lineNum">    1214 </span>            : }</a>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span><span class="lineCov">        118 : struct lookup_subtable *SFFindLookupSubtableAndFreeName(SplineFont *sf,char *name) {</span>
<span class="lineNum">    1217 </span><span class="lineCov">        118 :     struct lookup_subtable *sub = SFFindLookupSubtable(sf,name);</span>
<span class="lineNum">    1218 </span><span class="lineCov">        118 :     free(name);</span>
<span class="lineNum">    1219 </span><span class="lineCov">        118 : return( sub );</span>
<a name="1220"><span class="lineNum">    1220 </span>            : }</a>
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 : OTLookup *SFFindLookup(SplineFont *sf,char *name) {</span>
<span class="lineNum">    1223 </span>            :     int isgpos;
<span class="lineNum">    1224 </span>            :     OTLookup *otl;
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     if ( sf-&gt;cidmaster ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :     if ( name==NULL )</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :     for ( isgpos=0; isgpos&lt;2; ++isgpos ) {</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         for ( otl = isgpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups ; otl!=NULL; otl=otl-&gt;next ) {</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :             if ( strcmp(name,otl-&gt;lookup_name)==0 )</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 : return( otl );</span>
<span class="lineNum">    1235 </span>            :         }
<span class="lineNum">    1236 </span>            :     }
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 : return( NULL );</span>
<a name="1238"><span class="lineNum">    1238 </span>            : }</a>
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span><span class="lineCov">        906 : void FListAppendScriptLang(FeatureScriptLangList *fl,uint32 script_tag,uint32 lang_tag) {</span>
<span class="lineNum">    1241 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">    1242 </span>            :     int l;
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineCov">        906 :     for ( sl = fl-&gt;scripts; sl!=NULL &amp;&amp; sl-&gt;script!=script_tag; sl=sl-&gt;next );</span>
<span class="lineNum">    1245 </span><span class="lineCov">        906 :     if ( sl==NULL ) {</span>
<span class="lineNum">    1246 </span><span class="lineCov">        554 :         sl = chunkalloc(sizeof(struct scriptlanglist));</span>
<span class="lineNum">    1247 </span><span class="lineCov">        554 :         sl-&gt;script = script_tag;</span>
<span class="lineNum">    1248 </span><span class="lineCov">        554 :         sl-&gt;next = fl-&gt;scripts;</span>
<span class="lineNum">    1249 </span><span class="lineCov">        554 :         fl-&gt;scripts = sl;</span>
<span class="lineNum">    1250 </span>            :     }
<span class="lineNum">    1251 </span><span class="lineCov">        906 :     for ( l=0; l&lt;MAX_LANG &amp;&amp; l&lt;sl-&gt;lang_cnt &amp;&amp; sl-&gt;langs[l]!=lang_tag; ++l );</span>
<span class="lineNum">    1252 </span><span class="lineCov">        906 :     if ( l&gt;=MAX_LANG &amp;&amp; l&lt;sl-&gt;lang_cnt ) {</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :         while ( l&lt;sl-&gt;lang_cnt &amp;&amp; sl-&gt;morelangs[l-MAX_LANG]!=lang_tag )</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :             ++l;</span>
<span class="lineNum">    1255 </span>            :     }
<span class="lineNum">    1256 </span><span class="lineCov">        906 :     if ( l&gt;=sl-&gt;lang_cnt ) {</span>
<span class="lineNum">    1257 </span><span class="lineCov">        810 :         if ( l&lt;MAX_LANG )</span>
<span class="lineNum">    1258 </span><span class="lineCov">        810 :             sl-&gt;langs[l] = lang_tag;</span>
<span class="lineNum">    1259 </span>            :         else {
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :             if ( l%MAX_LANG == 0 )</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :                 sl-&gt;morelangs = realloc(sl-&gt;morelangs,l*sizeof(uint32));</span>
<span class="lineNum">    1262 </span>            :                 /* We've just allocated MAX_LANG-1 more than we need */
<span class="lineNum">    1263 </span>            :                 /*  so we don't do quite some many allocations */
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :             sl-&gt;morelangs[l-MAX_LANG] = lang_tag;</span>
<span class="lineNum">    1265 </span>            :         }
<span class="lineNum">    1266 </span><span class="lineCov">        810 :         ++sl-&gt;lang_cnt;</span>
<span class="lineNum">    1267 </span>            :     }
<a name="1268"><span class="lineNum">    1268 </span><span class="lineCov">        906 : }</span></a>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineCov">         90 : void FListsAppendScriptLang(FeatureScriptLangList *fl,uint32 script_tag,uint32 lang_tag) {</span>
<span class="lineNum">    1271 </span><span class="lineCov">        272 :     while ( fl!=NULL ) {</span>
<span class="lineNum">    1272 </span><span class="lineCov">         92 :         FListAppendScriptLang(fl,script_tag,lang_tag);</span>
<span class="lineNum">    1273 </span><span class="lineCov">         92 :         fl=fl-&gt;next;</span>
<span class="lineNum">    1274 </span>            :     }
<a name="1275"><span class="lineNum">    1275 </span><span class="lineCov">         90 : }</span></a>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineCov">         95 : char *SuffixFromTags(FeatureScriptLangList *fl) {</span>
<span class="lineNum">    1278 </span>            :     static struct { uint32 tag; const char *suffix; } tags2suffix[] = {
<span class="lineNum">    1279 </span>            :         { CHR('v','r','t','2'), &quot;vert&quot; },     /* Will check for vrt2 later */
<span class="lineNum">    1280 </span>            :         { CHR('o','n','u','m'), &quot;oldstyle&quot; },
<span class="lineNum">    1281 </span>            :         { CHR('s','u','p','s'), &quot;superior&quot; },
<span class="lineNum">    1282 </span>            :         { CHR('s','u','b','s'), &quot;inferior&quot; },
<span class="lineNum">    1283 </span>            :         { CHR('s','w','s','h'), &quot;swash&quot; },
<span class="lineNum">    1284 </span>            :         { CHR('f','w','i','d'), &quot;full&quot; },
<span class="lineNum">    1285 </span>            :         { CHR('h','w','i','d'), &quot;hw&quot; },
<span class="lineNum">    1286 </span>            :         { 0, NULL }
<span class="lineNum">    1287 </span>            :     };
<span class="lineNum">    1288 </span>            :     int i;
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span><span class="lineCov">        234 :     while ( fl!=NULL ) {</span>
<span class="lineNum">    1291 </span><span class="lineCov">        390 :         for ( i=0; tags2suffix[i].tag!=0; ++i )</span>
<span class="lineNum">    1292 </span><span class="lineCov">        346 :             if ( tags2suffix[i].tag==fl-&gt;featuretag )</span>
<span class="lineNum">    1293 </span><span class="lineCov">         14 : return( copy( tags2suffix[i].suffix ));</span>
<span class="lineNum">    1294 </span><span class="lineCov">         44 :         fl = fl-&gt;next;</span>
<span class="lineNum">    1295 </span>            :     }
<span class="lineNum">    1296 </span><span class="lineCov">         81 : return( NULL );</span>
<span class="lineNum">    1297 </span>            : }
<span class="lineNum">    1298 </span>            : 
<span class="lineNum">    1299 </span>            : const char *lookup_type_names[2][10] = {
<span class="lineNum">    1300 </span>            :     {   N_(&quot;Undefined substitution&quot;), N_(&quot;Single Substitution&quot;), N_(&quot;Multiple Substitution&quot;),
<span class="lineNum">    1301 </span>            :         N_(&quot;Alternate Substitution&quot;), N_(&quot;Ligature Substitution&quot;), N_(&quot;Contextual Substitution&quot;),
<span class="lineNum">    1302 </span>            :         N_(&quot;Contextual Chaining Substitution&quot;), N_(&quot;Extension&quot;),
<span class="lineNum">    1303 </span>            :         N_(&quot;Reverse Contextual Chaining Substitution&quot;)
<span class="lineNum">    1304 </span>            :     },
<span class="lineNum">    1305 </span>            :     {   N_(&quot;Undefined positioning&quot;), N_(&quot;Single Positioning&quot;), N_(&quot;Pairwise Positioning (kerning)&quot;),
<span class="lineNum">    1306 </span>            :         N_(&quot;Cursive attachment&quot;), N_(&quot;Mark to base attachment&quot;),
<span class="lineNum">    1307 </span>            :         N_(&quot;Mark to Ligature attachment&quot;), N_(&quot;Mark to Mark attachment&quot;),
<span class="lineNum">    1308 </span>            :         N_(&quot;Contextual Positioning&quot;), N_(&quot;Contextual Chaining Positioning&quot;),
<span class="lineNum">    1309 </span>            :         N_(&quot;Extension&quot;)
<span class="lineNum">    1310 </span>            :     }
<span class="lineNum">    1311 </span>            : };
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : /* This is a non-ui based copy of a similar list in lookupui.c */
<span class="lineNum">    1314 </span>            : static struct {
<span class="lineNum">    1315 </span>            :     const char *text;
<span class="lineNum">    1316 </span>            :     uint32 tag;
<span class="lineNum">    1317 </span>            : } localscripts[] = {
<span class="lineNum">    1318 </span>            : /* GT: See the long comment at &quot;Property|New&quot; */
<span class="lineNum">    1319 </span>            : /* GT: The msgstr should contain a translation of &quot;Arabic&quot;, ignore &quot;Script|&quot; */
<span class="lineNum">    1320 </span>            :     { N_(&quot;Script|Arabic&quot;), CHR('a','r','a','b') },
<span class="lineNum">    1321 </span>            :     { N_(&quot;Script|Aramaic&quot;), CHR('a','r','a','m') },
<span class="lineNum">    1322 </span>            :     { N_(&quot;Script|Armenian&quot;), CHR('a','r','m','n') },
<span class="lineNum">    1323 </span>            :     { N_(&quot;Script|Avestan&quot;), CHR('a','v','e','s') },
<span class="lineNum">    1324 </span>            :     { N_(&quot;Script|Balinese&quot;), CHR('b','a','l','i') },
<span class="lineNum">    1325 </span>            :     { N_(&quot;Script|Batak&quot;), CHR('b','a','t','k') },
<span class="lineNum">    1326 </span>            :     { N_(&quot;Script|Bengali&quot;), CHR('b','e','n','g') },
<span class="lineNum">    1327 </span>            :     { N_(&quot;Script|Bengali2&quot;), CHR('b','n','g','2') },
<span class="lineNum">    1328 </span>            :     { N_(&quot;Bliss Symbolics&quot;), CHR('b','l','i','s') },
<span class="lineNum">    1329 </span>            :     { N_(&quot;Bopomofo&quot;), CHR('b','o','p','o') },
<span class="lineNum">    1330 </span>            :     { NU_(&quot;Brāhmī&quot;), CHR('b','r','a','h') },
<span class="lineNum">    1331 </span>            :     { N_(&quot;Braille&quot;), CHR('b','r','a','i') },
<span class="lineNum">    1332 </span>            :     { N_(&quot;Script|Buginese&quot;), CHR('b','u','g','i') },
<span class="lineNum">    1333 </span>            :     { N_(&quot;Script|Buhid&quot;), CHR('b','u','h','d') },
<span class="lineNum">    1334 </span>            :     { N_(&quot;Byzantine Music&quot;), CHR('b','y','z','m') },
<span class="lineNum">    1335 </span>            :     { N_(&quot;Canadian Syllabics&quot;), CHR('c','a','n','s') },
<span class="lineNum">    1336 </span>            :     { N_(&quot;Carian&quot;), CHR('c','a','r','i') },
<span class="lineNum">    1337 </span>            :     { N_(&quot;Cherokee&quot;), CHR('c','h','a','m') },
<span class="lineNum">    1338 </span>            :     { N_(&quot;Script|Cham&quot;), CHR('c','h','a','m') },
<span class="lineNum">    1339 </span>            :     { N_(&quot;Script|Cherokee&quot;), CHR('c','h','e','r') },
<span class="lineNum">    1340 </span>            :     { N_(&quot;Cirth&quot;), CHR('c','i','r','t') },
<span class="lineNum">    1341 </span>            :     { N_(&quot;CJK Ideographic&quot;), CHR('h','a','n','i') },
<span class="lineNum">    1342 </span>            :     { N_(&quot;Script|Coptic&quot;), CHR('c','o','p','t') },
<span class="lineNum">    1343 </span>            :     { N_(&quot;Cypro-Minoan&quot;), CHR('c','p','r','t') },
<span class="lineNum">    1344 </span>            :     { N_(&quot;Cypriot syllabary&quot;), CHR('c','p','m','n') },
<span class="lineNum">    1345 </span>            :     { N_(&quot;Cyrillic&quot;), CHR('c','y','r','l') },
<span class="lineNum">    1346 </span>            :     { N_(&quot;Script|Default&quot;), CHR('D','F','L','T') },
<span class="lineNum">    1347 </span>            :     { N_(&quot;Deseret (Mormon)&quot;), CHR('d','s','r','t') },
<span class="lineNum">    1348 </span>            :     { N_(&quot;Devanagari&quot;), CHR('d','e','v','a') },
<span class="lineNum">    1349 </span>            :     { N_(&quot;Devanagari2&quot;), CHR('d','e','v','2') },
<span class="lineNum">    1350 </span>            : /*  { N_(&quot;Egyptian demotic&quot;), CHR('e','g','y','d') }, */
<span class="lineNum">    1351 </span>            : /*  { N_(&quot;Egyptian hieratic&quot;), CHR('e','g','y','h') }, */
<span class="lineNum">    1352 </span>            : /* GT: Someone asked if FontForge actually was prepared generate hieroglyph output */
<span class="lineNum">    1353 </span>            : /* GT: because of this string. No. But OpenType and Unicode have placeholders for */
<span class="lineNum">    1354 </span>            : /* GT: dealing with these scripts against the day someone wants to use them. So */
<span class="lineNum">    1355 </span>            : /* GT: FontForge must be prepared to deal with those placeholders if nothing else. */
<span class="lineNum">    1356 </span>            : /*  { N_(&quot;Egyptian hieroglyphs&quot;), CHR('e','g','y','p') }, */
<span class="lineNum">    1357 </span>            :     { N_(&quot;Script|Ethiopic&quot;), CHR('e','t','h','i') },
<span class="lineNum">    1358 </span>            :     { N_(&quot;Script|Georgian&quot;), CHR('g','e','o','r') },
<span class="lineNum">    1359 </span>            :     { N_(&quot;Glagolitic&quot;), CHR('g','l','a','g') },
<span class="lineNum">    1360 </span>            :     { N_(&quot;Gothic&quot;), CHR('g','o','t','h') },
<span class="lineNum">    1361 </span>            :     { N_(&quot;Script|Greek&quot;), CHR('g','r','e','k') },
<span class="lineNum">    1362 </span>            :     { N_(&quot;Script|Gujarati&quot;), CHR('g','u','j','r') },
<span class="lineNum">    1363 </span>            :     { N_(&quot;Script|Gujarati2&quot;), CHR('g','j','r','2') },
<span class="lineNum">    1364 </span>            :     { N_(&quot;Gurmukhi&quot;), CHR('g','u','r','u') },
<span class="lineNum">    1365 </span>            :     { N_(&quot;Gurmukhi2&quot;), CHR('g','u','r','2') },
<span class="lineNum">    1366 </span>            :     { N_(&quot;Hangul Jamo&quot;), CHR('j','a','m','o') },
<span class="lineNum">    1367 </span>            :     { N_(&quot;Hangul&quot;), CHR('h','a','n','g') },
<span class="lineNum">    1368 </span>            :     { NU_(&quot;Script|Hanunóo&quot;), CHR('h','a','n','o') },
<span class="lineNum">    1369 </span>            :     { N_(&quot;Script|Hebrew&quot;), CHR('h','e','b','r') },
<span class="lineNum">    1370 </span>            : /*  { N_(&quot;Pahawh Hmong&quot;), CHR('h','m','n','g') },*/
<span class="lineNum">    1371 </span>            : /*  { N_(&quot;Indus (Harappan)&quot;), CHR('i','n','d','s') },*/
<span class="lineNum">    1372 </span>            :     { N_(&quot;Script|Javanese&quot;), CHR('j','a','v','a') },
<span class="lineNum">    1373 </span>            :     { N_(&quot;Kayah Li&quot;), CHR('k','a','l','i') },
<span class="lineNum">    1374 </span>            :     { N_(&quot;Hiragana &amp; Katakana&quot;), CHR('k','a','n','a') },
<span class="lineNum">    1375 </span>            :     { NU_(&quot;Kharoṣṭhī&quot;), CHR('k','h','a','r') },
<span class="lineNum">    1376 </span>            :     { N_(&quot;Script|Kannada&quot;), CHR('k','n','d','a') },
<span class="lineNum">    1377 </span>            :     { N_(&quot;Script|Kannada2&quot;), CHR('k','n','d','2') },
<span class="lineNum">    1378 </span>            :     { N_(&quot;Script|Khmer&quot;), CHR('k','h','m','r') },
<span class="lineNum">    1379 </span>            :     { N_(&quot;Script|Kharosthi&quot;), CHR('k','h','a','r') },
<span class="lineNum">    1380 </span>            :     { N_(&quot;Script|Lao&quot;) , CHR('l','a','o',' ') },
<span class="lineNum">    1381 </span>            :     { N_(&quot;Script|Latin&quot;), CHR('l','a','t','n') },
<span class="lineNum">    1382 </span>            :     { NU_(&quot;Lepcha (Róng)&quot;), CHR('l','e','p','c') },
<span class="lineNum">    1383 </span>            :     { N_(&quot;Script|Limbu&quot;), CHR('l','i','m','b') },     /* Not in ISO 15924 !!!!!, just guessing */
<span class="lineNum">    1384 </span>            :     { N_(&quot;Linear A&quot;), CHR('l','i','n','a') },
<span class="lineNum">    1385 </span>            :     { N_(&quot;Linear B&quot;), CHR('l','i','n','b') },
<span class="lineNum">    1386 </span>            :     { N_(&quot;Lycian&quot;), CHR('l','y','c','i') },
<span class="lineNum">    1387 </span>            :     { N_(&quot;Lydian&quot;), CHR('l','y','d','i') },
<span class="lineNum">    1388 </span>            :     { N_(&quot;Script|Mandaean&quot;), CHR('m','a','n','d') },
<span class="lineNum">    1389 </span>            : /*  { N_(&quot;Mayan hieroglyphs&quot;), CHR('m','a','y','a') },*/
<span class="lineNum">    1390 </span>            :     { NU_(&quot;Script|Malayālam&quot;), CHR('m','l','y','m') },
<span class="lineNum">    1391 </span>            :     { NU_(&quot;Script|Malayālam2&quot;), CHR('m','l','m','2') },
<span class="lineNum">    1392 </span>            :     { NU_(&quot;Mathematical Alphanumeric Symbols&quot;), CHR('m','a','t','h') },
<span class="lineNum">    1393 </span>            :     { N_(&quot;Script|Mongolian&quot;), CHR('m','o','n','g') },
<span class="lineNum">    1394 </span>            :     { N_(&quot;Musical&quot;), CHR('m','u','s','c') },
<span class="lineNum">    1395 </span>            :     { N_(&quot;Script|Myanmar&quot;), CHR('m','y','m','r') },
<span class="lineNum">    1396 </span>            :     { N_(&quot;New Tai Lue&quot;), CHR('t','a','l','u') },
<span class="lineNum">    1397 </span>            :     { N_(&quot;N'Ko&quot;), CHR('n','k','o',' ') },
<span class="lineNum">    1398 </span>            :     { N_(&quot;Ogham&quot;), CHR('o','g','a','m') },
<span class="lineNum">    1399 </span>            :     { N_(&quot;Ol Chiki&quot;), CHR('o','l','c','k') },
<span class="lineNum">    1400 </span>            :     { N_(&quot;Old Italic (Etruscan, Oscan, etc.)&quot;), CHR('i','t','a','l') },
<span class="lineNum">    1401 </span>            :     { N_(&quot;Script|Old Permic&quot;), CHR('p','e','r','m') },
<span class="lineNum">    1402 </span>            :     { N_(&quot;Old Persian cuneiform&quot;), CHR('x','p','e','o') },
<span class="lineNum">    1403 </span>            :     { N_(&quot;Script|Oriya&quot;), CHR('o','r','y','a') },
<span class="lineNum">    1404 </span>            :     { N_(&quot;Script|Oriya2&quot;), CHR('o','r','y','2') },
<span class="lineNum">    1405 </span>            :     { N_(&quot;Osmanya&quot;), CHR('o','s','m','a') },
<span class="lineNum">    1406 </span>            :     { N_(&quot;Script|Pahlavi&quot;), CHR('p','a','l','v') },
<span class="lineNum">    1407 </span>            :     { N_(&quot;Script|Phags-pa&quot;), CHR('p','h','a','g') },
<span class="lineNum">    1408 </span>            :     { N_(&quot;Script|Phoenician&quot;), CHR('p','h','n','x') },
<span class="lineNum">    1409 </span>            :     { N_(&quot;Phaistos&quot;), CHR('p','h','s','t') },
<span class="lineNum">    1410 </span>            :     { N_(&quot;Pollard Phonetic&quot;), CHR('p','l','r','d') },
<span class="lineNum">    1411 </span>            :     { N_(&quot;Rejang&quot;), CHR('r','j','n','g') },
<span class="lineNum">    1412 </span>            :     { N_(&quot;Rongorongo&quot;), CHR('r','o','r','o') },
<span class="lineNum">    1413 </span>            :     { N_(&quot;Runic&quot;), CHR('r','u','n','r') },
<span class="lineNum">    1414 </span>            :     { N_(&quot;Saurashtra&quot;), CHR('s','a','u','r') },
<span class="lineNum">    1415 </span>            :     { N_(&quot;Shavian&quot;), CHR('s','h','a','w') },
<span class="lineNum">    1416 </span>            :     { N_(&quot;Script|Sinhala&quot;), CHR('s','i','n','h') },
<span class="lineNum">    1417 </span>            :     { N_(&quot;Script|Sumero-Akkadian Cuneiform&quot;), CHR('x','s','u','x') },
<span class="lineNum">    1418 </span>            :     { N_(&quot;Script|Sundanese&quot;), CHR('s','u','n','d') },
<span class="lineNum">    1419 </span>            :     { N_(&quot;Script|Syloti Nagri&quot;), CHR('s','y','l','o') },
<span class="lineNum">    1420 </span>            :     { N_(&quot;Script|Syriac&quot;), CHR('s','y','r','c') },
<span class="lineNum">    1421 </span>            :     { N_(&quot;Script|Tagalog&quot;), CHR('t','g','l','g') },
<span class="lineNum">    1422 </span>            :     { N_(&quot;Script|Tagbanwa&quot;), CHR('t','a','g','b') },
<span class="lineNum">    1423 </span>            :     { N_(&quot;Tai Le&quot;), CHR('t','a','l','e') },   /* Not in ISO 15924 !!!!!, just guessing */
<span class="lineNum">    1424 </span>            :     { N_(&quot;Tai Lu&quot;), CHR('t','a','l','a') },   /* Not in ISO 15924 !!!!!, just guessing */
<span class="lineNum">    1425 </span>            :     { N_(&quot;Script|Tamil&quot;), CHR('t','a','m','l') },
<span class="lineNum">    1426 </span>            :     { N_(&quot;Script|Tamil2&quot;), CHR('t','m','l','2') },
<span class="lineNum">    1427 </span>            :     { N_(&quot;Script|Telugu&quot;), CHR('t','e','l','u') },
<span class="lineNum">    1428 </span>            :     { N_(&quot;Script|Telugu2&quot;), CHR('t','e','l','2') },
<span class="lineNum">    1429 </span>            :     { N_(&quot;Tengwar&quot;), CHR('t','e','n','g') },
<span class="lineNum">    1430 </span>            :     { N_(&quot;Thaana&quot;), CHR('t','h','a','a') },
<span class="lineNum">    1431 </span>            :     { N_(&quot;Script|Thai&quot;), CHR('t','h','a','i') },
<span class="lineNum">    1432 </span>            :     { N_(&quot;Script|Tibetan&quot;), CHR('t','i','b','t') },
<span class="lineNum">    1433 </span>            :     { N_(&quot;Tifinagh (Berber)&quot;), CHR('t','f','n','g') },
<span class="lineNum">    1434 </span>            :     { N_(&quot;Script|Ugaritic&quot;), CHR('u','g','r','t') },  /* Not in ISO 15924 !!!!!, just guessing */
<span class="lineNum">    1435 </span>            :     { N_(&quot;Script|Vai&quot;), CHR('v','a','i',' ') },
<span class="lineNum">    1436 </span>            : /*  { N_(&quot;Visible Speech&quot;), CHR('v','i','s','p') },*/
<span class="lineNum">    1437 </span>            :     { N_(&quot;Cuneiform, Ugaritic&quot;), CHR('x','u','g','a') },
<span class="lineNum">    1438 </span>            :     { N_(&quot;Script|Yi&quot;)  , CHR('y','i',' ',' ') },
<span class="lineNum">    1439 </span>            : /*  { N_(&quot;Private Use Script 1&quot;), CHR('q','a','a','a') },*/
<span class="lineNum">    1440 </span>            : /*  { N_(&quot;Private Use Script 2&quot;), CHR('q','a','a','b') },*/
<span class="lineNum">    1441 </span>            : /*  { N_(&quot;Undetermined Script&quot;), CHR('z','y','y','y') },*/
<span class="lineNum">    1442 </span>            : /*  { N_(&quot;Uncoded Script&quot;), CHR('z','z','z','z') },*/
<span class="lineNum">    1443 </span>            :     { NULL, 0 }
<a name="1444"><span class="lineNum">    1444 </span>            : };</a>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineCov">        716 : void LookupInit(void) {</span>
<span class="lineNum">    1447 </span>            :     static int done = false;
<span class="lineNum">    1448 </span>            :     int i, j;
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span><span class="lineCov">        716 :     if ( done )</span>
<span class="lineNum">    1451 </span><span class="lineCov">       1417 : return;</span>
<span class="lineNum">    1452 </span><span class="lineCov">         15 :     done = true;</span>
<span class="lineNum">    1453 </span><span class="lineCov">         45 :     for ( j=0; j&lt;2; ++j ) {</span>
<span class="lineNum">    1454 </span><span class="lineCov">        330 :         for ( i=0; i&lt;10; ++i )</span>
<span class="lineNum">    1455 </span><span class="lineCov">        300 :             if ( lookup_type_names[j][i]!=NULL )</span>
<span class="lineNum">    1456 </span><span class="lineCov">        285 :                 lookup_type_names[j][i] = S_((char *) lookup_type_names[j][i]);</span>
<span class="lineNum">    1457 </span>            :     }
<span class="lineNum">    1458 </span><span class="lineCov">       1635 :     for ( i=0; localscripts[i].text!=NULL; ++i )</span>
<span class="lineNum">    1459 </span><span class="lineCov">       1620 :         localscripts[i].text = S_(localscripts[i].text);</span>
<span class="lineNum">    1460 </span><span class="lineCov">       2265 :     for ( i=0; friendlies[i].friendlyname!=NULL; ++i )</span>
<span class="lineNum">    1461 </span><span class="lineCov">       2250 :         friendlies[i].friendlyname = S_(friendlies[i].friendlyname);</span>
<a name="1462"><span class="lineNum">    1462 </span>            : }</a>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineCov">        337 : char *TagFullName(SplineFont *sf,uint32 tag, int ismac, int onlyifknown) {</span>
<span class="lineNum">    1465 </span><span class="lineCov">        337 :     char ubuf[200], *end = ubuf+sizeof(ubuf), *setname;</span>
<span class="lineNum">    1466 </span>            :     int k;
<span class="lineNum">    1467 </span>            : 
<span class="lineNum">    1468 </span><span class="lineCov">        337 :     if ( ismac==-1 )</span>
<span class="lineNum">    1469 </span>            :         /* Guess */
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :         ismac = (tag&gt;&gt;24)&lt;' ' || (tag&gt;&gt;24)&gt;0x7e;</span>
<span class="lineNum">    1471 </span>            : 
<span class="lineNum">    1472 </span><span class="lineCov">        337 :     if ( ismac ) {</span>
<span class="lineNum">    1473 </span><span class="lineCov">          2 :         sprintf( ubuf, &quot;&lt;%d,%d&gt; &quot;, (int) (tag&gt;&gt;16),(int) (tag&amp;0xffff) );</span>
<span class="lineNum">    1474 </span><span class="lineCov">          2 :         if ( (setname = PickNameFromMacName(FindMacSettingName(sf,tag&gt;&gt;16,tag&amp;0xffff)))!=NULL ) {</span>
<span class="lineNum">    1475 </span><span class="lineCov">          2 :             strcat( ubuf, setname );</span>
<span class="lineNum">    1476 </span><span class="lineCov">          2 :             free( setname );</span>
<span class="lineNum">    1477 </span>            :         }
<span class="lineNum">    1478 </span>            :     } else {
<span class="lineNum">    1479 </span><span class="lineCov">        335 :         uint32 stag = tag;</span>
<span class="lineNum">    1480 </span><span class="lineCov">        335 :         if ( tag==CHR('n','u','t','f') )        /* early name that was standardize later as... */</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :             stag = CHR('a','f','r','c');        /*  Stood for nut fractions. &quot;nut&quot; meaning &quot;fits in an en&quot; in old typography-speak =&gt; vertical fractions rather than diagonal ones */</span>
<span class="lineNum">    1482 </span><span class="lineCov">        335 :         if ( tag==REQUIRED_FEATURE ) {</span>
<span class="lineNum">    1483 </span><span class="lineCov">          4 :             strcpy(ubuf,_(&quot;Required Feature&quot;));</span>
<span class="lineNum">    1484 </span>            :         } else {
<span class="lineNum">    1485 </span><span class="lineCov">        331 :             LookupInit();</span>
<span class="lineNum">    1486 </span><span class="lineCov">      19609 :             for ( k=0; friendlies[k].tag!=0; ++k ) {</span>
<span class="lineNum">    1487 </span><span class="lineCov">      19601 :                 if ( friendlies[k].tag == stag )</span>
<span class="lineNum">    1488 </span><span class="lineCov">        323 :             break;</span>
<span class="lineNum">    1489 </span>            :             }
<span class="lineNum">    1490 </span><span class="lineCov">        331 :             ubuf[0] = '\'';</span>
<span class="lineNum">    1491 </span><span class="lineCov">        331 :             ubuf[1] = tag&gt;&gt;24;</span>
<span class="lineNum">    1492 </span><span class="lineCov">        331 :             ubuf[2] = (tag&gt;&gt;16)&amp;0xff;</span>
<span class="lineNum">    1493 </span><span class="lineCov">        331 :             ubuf[3] = (tag&gt;&gt;8)&amp;0xff;</span>
<span class="lineNum">    1494 </span><span class="lineCov">        331 :             ubuf[4] = tag&amp;0xff;</span>
<span class="lineNum">    1495 </span><span class="lineCov">        331 :             ubuf[5] = '\'';</span>
<span class="lineNum">    1496 </span><span class="lineCov">        331 :             ubuf[6] = ' ';</span>
<span class="lineNum">    1497 </span><span class="lineCov">        331 :             if ( friendlies[k].tag!=0 )</span>
<span class="lineNum">    1498 </span><span class="lineCov">        323 :                 strncpy(ubuf+7, (char *) friendlies[k].friendlyname,end-ubuf-7);</span>
<span class="lineNum">    1499 </span><span class="lineCov">          8 :             else if ( onlyifknown )</span>
<span class="lineNum">    1500 </span><span class="lineCov">          8 : return( NULL );</span>
<span class="lineNum">    1501 </span>            :             else
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :                 ubuf[7]='\0';</span>
<span class="lineNum">    1503 </span>            :         }
<span class="lineNum">    1504 </span>            :     }
<span class="lineNum">    1505 </span><span class="lineCov">        329 : return( copy( ubuf ));</span>
<span class="lineNum">    1506 </span>            : }
<a name="1507"><span class="lineNum">    1507 </span>            : </a>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineCov">        383 : void NameOTLookup(OTLookup *otl,SplineFont *sf) {</span>
<span class="lineNum">    1510 </span><span class="lineCov">        383 :     char *userfriendly = NULL, *script;</span>
<span class="lineNum">    1511 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">    1512 </span>            :     char *lookuptype;
<span class="lineNum">    1513 </span>            :     const char *format;
<span class="lineNum">    1514 </span>            :     struct lookup_subtable *subtable;
<span class="lineNum">    1515 </span>            :     int k;
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span><span class="lineCov">        383 :     LookupInit();</span>
<span class="lineNum">    1518 </span>            : 
<span class="lineNum">    1519 </span><span class="lineCov">        383 :     if ( otl-&gt;lookup_name==NULL ) {</span>
<span class="lineNum">    1520 </span><span class="lineCov">        512 :         for ( k=0; k&lt;2; ++k ) {</span>
<span class="lineNum">    1521 </span><span class="lineCov">        491 :             for ( fl=otl-&gt;features; fl!=NULL ; fl=fl-&gt;next ) {</span>
<span class="lineNum">    1522 </span>            :                 /* look first for a feature attached to a default language */
<span class="lineNum">    1523 </span><span class="lineCov">        361 :                 if ( k==1 || DefaultLangTagInScriptList(fl-&gt;scripts,false)!=NULL ) {</span>
<span class="lineNum">    1524 </span><span class="lineCov">        337 :                     userfriendly = TagFullName(sf,fl-&gt;featuretag, fl-&gt;ismac, true);</span>
<span class="lineNum">    1525 </span><span class="lineCov">        337 :                     if ( userfriendly!=NULL )</span>
<span class="lineNum">    1526 </span><span class="lineCov">        329 :             break;</span>
<span class="lineNum">    1527 </span>            :                 }
<span class="lineNum">    1528 </span>            :             }
<span class="lineNum">    1529 </span><span class="lineCov">        459 :             if ( userfriendly!=NULL )</span>
<span class="lineNum">    1530 </span><span class="lineCov">        329 :         break;</span>
<span class="lineNum">    1531 </span>            :         }
<span class="lineNum">    1532 </span><span class="lineCov">        382 :         if ( userfriendly==NULL ) {</span>
<span class="lineNum">    1533 </span><span class="lineCov">         53 :             if ( (otl-&gt;lookup_type&amp;0xff)&gt;= 0xf0 )</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :                 lookuptype = _(&quot;State Machine&quot;);</span>
<span class="lineNum">    1535 </span><span class="lineCov">         53 :             else if ( (otl-&gt;lookup_type&gt;&gt;8)&lt;2 &amp;&amp; (otl-&gt;lookup_type&amp;0xff)&lt;10 )</span>
<span class="lineNum">    1536 </span><span class="lineCov">         53 :                 lookuptype = _(lookup_type_names[otl-&gt;lookup_type&gt;&gt;8][otl-&gt;lookup_type&amp;0xff]);</span>
<span class="lineNum">    1537 </span>            :             else
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :                 lookuptype = S_(&quot;LookupType|Unknown&quot;);</span>
<span class="lineNum">    1539 </span><span class="lineCov">         53 :             for ( fl=otl-&gt;features; fl!=NULL &amp;&amp; !fl-&gt;ismac; fl=fl-&gt;next );</span>
<span class="lineNum">    1540 </span><span class="lineCov">         53 :             if ( fl==NULL )</span>
<span class="lineNum">    1541 </span><span class="lineCov">         53 :                 userfriendly = copy(lookuptype);</span>
<span class="lineNum">    1542 </span>            :             else {
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :                 userfriendly = malloc( strlen(lookuptype) + 10);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :                 sprintf( userfriendly, &quot;%s '%c%c%c%c'&quot;, lookuptype,</span>
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :                     fl-&gt;featuretag&gt;&gt;24,</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :                     fl-&gt;featuretag&gt;&gt;16,</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :                     fl-&gt;featuretag&gt;&gt;8 ,</span>
<span class="lineNum">    1548 </span>            :                     fl-&gt;featuretag );
<span class="lineNum">    1549 </span>            :             }
<span class="lineNum">    1550 </span>            :         }
<span class="lineNum">    1551 </span><span class="lineCov">        382 :         script = NULL;</span>
<span class="lineNum">    1552 </span><span class="lineCov">        382 :         if ( fl==NULL ) fl = otl-&gt;features;</span>
<span class="lineNum">    1553 </span><span class="lineCov">        382 :         if ( fl!=NULL &amp;&amp; fl-&gt;scripts!=NULL ) {</span>
<span class="lineNum">    1554 </span>            :             char buf[8];
<span class="lineNum">    1555 </span>            :             int j;
<span class="lineNum">    1556 </span>            :             struct scriptlanglist *sl, *found, *found2;
<span class="lineNum">    1557 </span><span class="lineCov">        333 :             uint32 script_tag = fl-&gt;scripts-&gt;script;</span>
<span class="lineNum">    1558 </span><span class="lineCov">        333 :             found = found2 = NULL;</span>
<span class="lineNum">    1559 </span><span class="lineCov">        666 :             for ( sl = fl-&gt;scripts; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">    1560 </span><span class="lineCov">        519 :                 if ( sl-&gt;script == DEFAULT_SCRIPT )</span>
<span class="lineNum">    1561 </span>            :                     /* Ignore it */;
<span class="lineNum">    1562 </span><span class="lineCov">        507 :                 else if ( DefaultLangTagInOneScriptList(sl)) {</span>
<span class="lineNum">    1563 </span><span class="lineCov">        495 :                     if ( found==NULL )</span>
<span class="lineNum">    1564 </span><span class="lineCov">        309 :                         found = sl;</span>
<span class="lineNum">    1565 </span>            :                     else {
<span class="lineNum">    1566 </span><span class="lineCov">        186 :                         found = found2 = NULL;</span>
<span class="lineNum">    1567 </span><span class="lineCov">        186 :             break;</span>
<span class="lineNum">    1568 </span>            :                     }
<span class="lineNum">    1569 </span><span class="lineCov">         12 :                 } else if ( found2 == NULL )</span>
<span class="lineNum">    1570 </span><span class="lineCov">         12 :                     found2 = sl;</span>
<span class="lineNum">    1571 </span>            :                 else
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :                     found2 = (struct scriptlanglist *) -1;</span>
<span class="lineNum">    1573 </span>            :             }
<span class="lineNum">    1574 </span><span class="lineCov">        333 :             if ( found==NULL &amp;&amp; found2!=NULL &amp;&amp; found2 != (struct scriptlanglist *) -1 )</span>
<span class="lineNum">    1575 </span><span class="lineCov">         12 :                 found = found2;</span>
<span class="lineNum">    1576 </span><span class="lineCov">        333 :             if ( found!=NULL ) {</span>
<span class="lineNum">    1577 </span><span class="lineCov">        135 :                 script_tag = found-&gt;script;</span>
<span class="lineNum">    1578 </span><span class="lineCov">        135 :                 for ( j=0; localscripts[j].text!=NULL &amp;&amp; script_tag!=localscripts[j].tag; ++j );</span>
<span class="lineNum">    1579 </span><span class="lineCov">        135 :                 if ( localscripts[j].text!=NULL )</span>
<span class="lineNum">    1580 </span><span class="lineCov">        135 :                     script = copy( S_((char *) localscripts[j].text) );</span>
<span class="lineNum">    1581 </span>            :                 else {
<span class="lineNum">    1582 </span><span class="lineNoCov">          0 :                     buf[0] = '\'';</span>
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :                     buf[1] = fl-&gt;scripts-&gt;script&gt;&gt;24;</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :                     buf[2] = (fl-&gt;scripts-&gt;script&gt;&gt;16)&amp;0xff;</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :                     buf[3] = (fl-&gt;scripts-&gt;script&gt;&gt;8)&amp;0xff;</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :                     buf[4] = fl-&gt;scripts-&gt;script&amp;0xff;</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :                     buf[5] = '\'';</span>
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :                     buf[6] = 0;</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :                     script = copy(buf);</span>
<span class="lineNum">    1590 </span>            :                 }
<span class="lineNum">    1591 </span>            :             }
<span class="lineNum">    1592 </span>            :         }
<span class="lineNum">    1593 </span><span class="lineCov">        382 :         if ( script!=NULL ) {</span>
<span class="lineNum">    1594 </span>            : /* GT: This string is used to generate a name for each OpenType lookup. */
<span class="lineNum">    1595 </span>            : /* GT: The %s will be filled with the user friendly name of the feature used to invoke the lookup */
<span class="lineNum">    1596 </span>            : /* GT: The second %s (if present) is the script */
<span class="lineNum">    1597 </span>            : /* GT: While the %d is the index into the lookup list and is used to disambiguate it */
<span class="lineNum">    1598 </span>            : /* GT: In case that is needed */
<span class="lineNum">    1599 </span><span class="lineCov">        135 :             format = _(&quot;%s in %s lookup %d&quot;);</span>
<span class="lineNum">    1600 </span><span class="lineCov">        135 :             otl-&gt;lookup_name = malloc( strlen(userfriendly)+strlen(format)+strlen(script)+10 );</span>
<span class="lineNum">    1601 </span><span class="lineCov">        135 :             sprintf( otl-&gt;lookup_name, format, userfriendly, script, otl-&gt;lookup_index );</span>
<span class="lineNum">    1602 </span>            :         } else {
<span class="lineNum">    1603 </span><span class="lineCov">        247 :             format = _(&quot;%s lookup %d&quot;);</span>
<span class="lineNum">    1604 </span><span class="lineCov">        247 :             otl-&gt;lookup_name = malloc( strlen(userfriendly)+strlen(format)+10 );</span>
<span class="lineNum">    1605 </span><span class="lineCov">        247 :             sprintf( otl-&gt;lookup_name, format, userfriendly, otl-&gt;lookup_index );</span>
<span class="lineNum">    1606 </span>            :         }
<span class="lineNum">    1607 </span><span class="lineCov">        382 :         free(script);</span>
<span class="lineNum">    1608 </span><span class="lineCov">        382 :         free(userfriendly);</span>
<span class="lineNum">    1609 </span>            :     }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineCov">        383 :     if ( otl-&gt;subtables==NULL )</span>
<span class="lineNum">    1612 </span>            :         /* IError( _(&quot;Lookup with no subtables&quot;))*/;
<span class="lineNum">    1613 </span>            :     else {
<span class="lineNum">    1614 </span><span class="lineCov">        383 :         int cnt = 0;</span>
<span class="lineNum">    1615 </span><span class="lineCov">        781 :         for ( subtable = otl-&gt;subtables; subtable!=NULL; subtable=subtable-&gt;next, ++cnt )</span>
<span class="lineNum">    1616 </span><span class="lineCov">        398 :                 if ( subtable-&gt;subtable_name==NULL ) {</span>
<span class="lineNum">    1617 </span><span class="lineCov">        397 :             if ( subtable==otl-&gt;subtables &amp;&amp; subtable-&gt;next==NULL )</span>
<span class="lineNum">    1618 </span>            : /* GT: This string is used to generate a name for an OpenType lookup subtable. */
<span class="lineNum">    1619 </span>            : /* GT:  %s is the lookup name */
<span class="lineNum">    1620 </span><span class="lineCov">        371 :                 format = _(&quot;%s subtable&quot;);</span>
<span class="lineNum">    1621 </span><span class="lineCov">         26 :             else if ( subtable-&gt;per_glyph_pst_or_kern )</span>
<span class="lineNum">    1622 </span>            : /* GT: This string is used to generate a name for an OpenType lookup subtable. */
<span class="lineNum">    1623 </span>            : /* GT:  %s is the lookup name, %d is the index of the subtable in the lookup */
<span class="lineNum">    1624 </span><span class="lineCov">         10 :                 format = _(&quot;%s per glyph data %d&quot;);</span>
<span class="lineNum">    1625 </span><span class="lineCov">         16 :             else if ( subtable-&gt;kc!=NULL )</span>
<span class="lineNum">    1626 </span><span class="lineCov">         16 :                 format = _(&quot;%s kerning class %d&quot;);</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :             else if ( subtable-&gt;fpst!=NULL )</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :                 format = _(&quot;%s contextual %d&quot;);</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :             else if ( subtable-&gt;anchor_classes )</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :                 format = _(&quot;%s anchor %d&quot;);</span>
<span class="lineNum">    1631 </span>            :             else {
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :                 IError(&quot;Subtable status not filled in for %dth subtable of %s&quot;, cnt, otl-&gt;lookup_name );</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :                 format = &quot;%s !!!!!!!! %d&quot;;</span>
<span class="lineNum">    1634 </span>            :             }
<span class="lineNum">    1635 </span><span class="lineCov">        397 :             subtable-&gt;subtable_name = malloc( strlen(otl-&gt;lookup_name)+strlen(format)+10 );</span>
<span class="lineNum">    1636 </span><span class="lineCov">        397 :             sprintf( subtable-&gt;subtable_name, format, otl-&gt;lookup_name, cnt );</span>
<span class="lineNum">    1637 </span>            :         }
<span class="lineNum">    1638 </span>            :     }
<span class="lineNum">    1639 </span><span class="lineCov">        383 :     if ( otl-&gt;lookup_type==gsub_ligature ) {</span>
<span class="lineNum">    1640 </span><span class="lineCov">        235 :         for ( fl=otl-&gt;features; fl!=NULL; fl=fl-&gt;next )</span>
<span class="lineNum">    1641 </span><span class="lineCov">        114 :             if ( fl-&gt;featuretag==CHR('l','i','g','a') || fl-&gt;featuretag==CHR('r','l','i','g'))</span>
<span class="lineNum">    1642 </span><span class="lineCov">         58 :                 otl-&gt;store_in_afm = true;</span>
<span class="lineNum">    1643 </span>            :     }
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span><span class="lineCov">        383 :     if ( otl-&gt;lookup_type==gsub_single )</span>
<span class="lineNum">    1646 </span><span class="lineCov">        190 :         for ( subtable = otl-&gt;subtables; subtable!=NULL; subtable=subtable-&gt;next )</span>
<span class="lineNum">    1647 </span><span class="lineCov">         95 :             subtable-&gt;suffix = SuffixFromTags(otl-&gt;features);</span>
<a name="1648"><span class="lineNum">    1648 </span><span class="lineCov">        383 : }</span></a>
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineCov">        462 : static void LangOrder(struct scriptlanglist *sl) {</span>
<span class="lineNum">    1651 </span>            :     int i,j;
<span class="lineNum">    1652 </span>            :     uint32 lang, lang2;
<span class="lineNum">    1653 </span>            : 
<span class="lineNum">    1654 </span><span class="lineCov">       1180 :     for ( i=0; i&lt;sl-&gt;lang_cnt; ++i ) {</span>
<span class="lineNum">    1655 </span><span class="lineCov">        718 :         lang = i&lt;MAX_LANG ? sl-&gt;langs[i] : sl-&gt;morelangs[i-MAX_LANG];</span>
<span class="lineNum">    1656 </span><span class="lineCov">       1064 :         for ( j=i+1; j&lt;sl-&gt;lang_cnt; ++j ) {</span>
<span class="lineNum">    1657 </span><span class="lineCov">        346 :             lang2 = j&lt;MAX_LANG ? sl-&gt;langs[j] : sl-&gt;morelangs[j-MAX_LANG];</span>
<span class="lineNum">    1658 </span><span class="lineCov">        346 :             if ( lang&gt;lang2 ) {</span>
<span class="lineNum">    1659 </span><span class="lineCov">        256 :                 if ( i&lt;MAX_LANG )</span>
<span class="lineNum">    1660 </span><span class="lineCov">        256 :                     sl-&gt;langs[i] = lang2;</span>
<span class="lineNum">    1661 </span>            :                 else
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :                     sl-&gt;morelangs[i-MAX_LANG] = lang2;</span>
<span class="lineNum">    1663 </span><span class="lineCov">        256 :                 if ( j&lt;MAX_LANG )</span>
<span class="lineNum">    1664 </span><span class="lineCov">        256 :                     sl-&gt;langs[j] = lang;</span>
<span class="lineNum">    1665 </span>            :                 else
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :                     sl-&gt;morelangs[j-MAX_LANG] = lang;</span>
<span class="lineNum">    1667 </span><span class="lineCov">        256 :                 lang = lang2;</span>
<span class="lineNum">    1668 </span>            :             }
<span class="lineNum">    1669 </span>            :         }
<span class="lineNum">    1670 </span>            :     }
<a name="1671"><span class="lineNum">    1671 </span><span class="lineCov">        462 : }</span></a>
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineCov">        219 : static struct scriptlanglist *SLOrder(struct scriptlanglist *sl) {</span>
<span class="lineNum">    1674 </span>            :     int i,j, cnt;
<span class="lineNum">    1675 </span><span class="lineCov">        219 :     struct scriptlanglist *sl2, *space[30], **allocked=NULL, **test = space;</span>
<span class="lineNum">    1676 </span>            : 
<span class="lineNum">    1677 </span><span class="lineCov">        681 :     for ( sl2=sl, cnt=0; sl2!=NULL; sl2=sl2-&gt;next, ++cnt )</span>
<span class="lineNum">    1678 </span><span class="lineCov">        462 :         LangOrder(sl2);</span>
<span class="lineNum">    1679 </span><span class="lineCov">        219 :     if ( cnt&lt;=1 )</span>
<span class="lineNum">    1680 </span><span class="lineCov">         76 : return( sl );</span>
<span class="lineNum">    1681 </span><span class="lineCov">        143 :     if ( cnt&gt;30 )</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :         test = allocked = malloc(cnt*sizeof(struct scriptlanglist *));</span>
<span class="lineNum">    1683 </span><span class="lineCov">        529 :     for ( sl2=sl, cnt=0; sl2!=NULL; sl2=sl2-&gt;next, ++cnt )</span>
<span class="lineNum">    1684 </span><span class="lineCov">        386 :         test[cnt] = sl2;</span>
<span class="lineNum">    1685 </span><span class="lineCov">        486 :     for ( i=0; i&lt;cnt; ++i ) for ( j=i+1; j&lt;cnt; ++j ) {</span>
<span class="lineNum">    1686 </span><span class="lineCov">        343 :         if ( test[i]-&gt;script &gt; test[j]-&gt;script ) {</span>
<span class="lineNum">    1687 </span>            :             struct scriptlanglist *temp;
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :             temp = test[i];</span>
<span class="lineNum">    1689 </span><span class="lineNoCov">          0 :             test[i] = test[j];</span>
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :             test[j] = temp;</span>
<span class="lineNum">    1691 </span>            :         }
<span class="lineNum">    1692 </span>            :     }
<span class="lineNum">    1693 </span><span class="lineCov">        143 :     sl = test[0];</span>
<span class="lineNum">    1694 </span><span class="lineCov">        386 :     for ( i=1; i&lt;cnt; ++i )</span>
<span class="lineNum">    1695 </span><span class="lineCov">        243 :         test[i-1]-&gt;next = test[i];</span>
<span class="lineNum">    1696 </span><span class="lineCov">        143 :     test[i-1]-&gt;next = NULL;</span>
<span class="lineNum">    1697 </span><span class="lineCov">        143 :     free( allocked );</span>
<span class="lineNum">    1698 </span><span class="lineCov">        143 : return( sl );</span>
<a name="1699"><span class="lineNum">    1699 </span>            : }</a>
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span><span class="lineCov">        252 : FeatureScriptLangList *FLOrder(FeatureScriptLangList *fl) {</span>
<span class="lineNum">    1702 </span>            :     int i,j, cnt;
<span class="lineNum">    1703 </span><span class="lineCov">        252 :     FeatureScriptLangList *fl2, *space[30], **allocked=NULL, **test = space;</span>
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineCov">        471 :     for ( fl2=fl, cnt=0; fl2!=NULL; fl2=fl2-&gt;next, ++cnt )</span>
<span class="lineNum">    1706 </span><span class="lineCov">        219 :         fl2-&gt;scripts = SLOrder(fl2-&gt;scripts);</span>
<span class="lineNum">    1707 </span><span class="lineCov">        252 :     if ( cnt&lt;=1 )</span>
<span class="lineNum">    1708 </span><span class="lineCov">        251 : return( fl );</span>
<span class="lineNum">    1709 </span><span class="lineCov">          1 :     if ( cnt&gt;30 )</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :         test = allocked = malloc(cnt*sizeof(FeatureScriptLangList *));</span>
<span class="lineNum">    1711 </span><span class="lineCov">          3 :     for ( fl2=fl, cnt=0; fl2!=NULL; fl2=fl2-&gt;next, ++cnt )</span>
<span class="lineNum">    1712 </span><span class="lineCov">          2 :         test[cnt] = fl2;</span>
<span class="lineNum">    1713 </span><span class="lineCov">          2 :     for ( i=0; i&lt;cnt; ++i ) for ( j=i+1; j&lt;cnt; ++j ) {</span>
<span class="lineNum">    1714 </span><span class="lineCov">          1 :         if ( test[i]-&gt;featuretag &gt; test[j]-&gt;featuretag ) {</span>
<span class="lineNum">    1715 </span>            :             FeatureScriptLangList *temp;
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :             temp = test[i];</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :             test[i] = test[j];</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :             test[j] = temp;</span>
<span class="lineNum">    1719 </span>            :         }
<span class="lineNum">    1720 </span>            :     }
<span class="lineNum">    1721 </span><span class="lineCov">          1 :     fl = test[0];</span>
<span class="lineNum">    1722 </span><span class="lineCov">          2 :     for ( i=1; i&lt;cnt; ++i )</span>
<span class="lineNum">    1723 </span><span class="lineCov">          1 :         test[i-1]-&gt;next = test[i];</span>
<span class="lineNum">    1724 </span><span class="lineCov">          1 :     test[i-1]-&gt;next = NULL;</span>
<span class="lineNum">    1725 </span><span class="lineCov">          1 :     free( allocked );</span>
<span class="lineNum">    1726 </span><span class="lineCov">          1 : return( fl );</span>
<a name="1727"><span class="lineNum">    1727 </span>            : }</a>
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span><span class="lineCov">         10 : struct scriptlanglist *SLCopy(struct scriptlanglist *sl) {</span>
<span class="lineNum">    1730 </span>            :     struct scriptlanglist *newsl;
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span><span class="lineCov">         10 :     newsl = chunkalloc(sizeof(struct scriptlanglist));</span>
<span class="lineNum">    1733 </span><span class="lineCov">         10 :     *newsl = *sl;</span>
<span class="lineNum">    1734 </span><span class="lineCov">         10 :     newsl-&gt;next = NULL;</span>
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span><span class="lineCov">         10 :     if ( sl-&gt;lang_cnt&gt;MAX_LANG ) {</span>
<span class="lineNum">    1737 </span><span class="lineNoCov">          0 :         newsl-&gt;morelangs = malloc((newsl-&gt;lang_cnt-MAX_LANG)*sizeof(uint32));</span>
<span class="lineNum">    1738 </span><span class="lineNoCov">          0 :         memcpy(newsl-&gt;morelangs,sl-&gt;morelangs,(newsl-&gt;lang_cnt-MAX_LANG)*sizeof(uint32));</span>
<span class="lineNum">    1739 </span>            :     }
<span class="lineNum">    1740 </span><span class="lineCov">         10 : return( newsl );</span>
<a name="1741"><span class="lineNum">    1741 </span>            : }</a>
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span><span class="lineCov">          4 : struct scriptlanglist *SListCopy(struct scriptlanglist *sl) {</span>
<span class="lineNum">    1744 </span><span class="lineCov">          4 :     struct scriptlanglist *head=NULL, *last=NULL, *cur;</span>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span><span class="lineCov">         14 :     for ( ; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">    1747 </span><span class="lineCov">         10 :         cur = SLCopy(sl);</span>
<span class="lineNum">    1748 </span><span class="lineCov">         10 :         if ( head==NULL )</span>
<span class="lineNum">    1749 </span><span class="lineCov">          4 :             head = cur;</span>
<span class="lineNum">    1750 </span>            :         else
<span class="lineNum">    1751 </span><span class="lineCov">          6 :             last-&gt;next = cur;</span>
<span class="lineNum">    1752 </span><span class="lineCov">         10 :         last = cur;</span>
<span class="lineNum">    1753 </span>            :     }
<span class="lineNum">    1754 </span><span class="lineCov">          4 : return( head );</span>
<a name="1755"><span class="lineNum">    1755 </span>            : }</a>
<span class="lineNum">    1756 </span>            : 
<span class="lineNum">    1757 </span><span class="lineCov">          4 : FeatureScriptLangList *FeatureListCopy(FeatureScriptLangList *fl) {</span>
<span class="lineNum">    1758 </span>            :     FeatureScriptLangList *newfl;
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span><span class="lineCov">          4 :     if ( fl==NULL )</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineCov">          4 :     newfl = chunkalloc(sizeof(FeatureScriptLangList));</span>
<span class="lineNum">    1764 </span><span class="lineCov">          4 :     *newfl = *fl;</span>
<span class="lineNum">    1765 </span><span class="lineCov">          4 :     newfl-&gt;next = NULL;</span>
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineCov">          4 :     newfl-&gt;scripts = SListCopy(fl-&gt;scripts);</span>
<span class="lineNum">    1768 </span><span class="lineCov">          4 : return( newfl );</span>
<a name="1769"><span class="lineNum">    1769 </span>            : }</a>
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 : static void LangMerge(struct scriptlanglist *into, struct scriptlanglist *from) {</span>
<span class="lineNum">    1772 </span>            :     int i,j;
<span class="lineNum">    1773 </span>            :     uint32 flang, tlang;
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :     for ( i=0 ; i&lt;from-&gt;lang_cnt; ++i ) {</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :         flang = i&lt;MAX_LANG ? from-&gt;langs[i] : from-&gt;morelangs[i-MAX_LANG];</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :         for ( j=0; j&lt;into-&gt;lang_cnt; ++j ) {</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 :             tlang = j&lt;MAX_LANG ? into-&gt;langs[j] : into-&gt;morelangs[j-MAX_LANG];</span>
<span class="lineNum">    1779 </span><span class="lineNoCov">          0 :             if ( tlang==flang )</span>
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1781 </span>            :         }
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :         if ( j==into-&gt;lang_cnt ) {</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :             if ( into-&gt;lang_cnt&lt;MAX_LANG )</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :                 into-&gt;langs[into-&gt;lang_cnt++] = flang;</span>
<span class="lineNum">    1785 </span>            :             else {
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :                 into-&gt;morelangs = realloc(into-&gt;morelangs,(into-&gt;lang_cnt+1-MAX_LANG)*sizeof(uint32));</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :                 into-&gt;morelangs[into-&gt;lang_cnt++-MAX_LANG] = flang;</span>
<span class="lineNum">    1788 </span>            :             }
<span class="lineNum">    1789 </span>            :         }
<span class="lineNum">    1790 </span>            :     }
<a name="1791"><span class="lineNum">    1791 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 : void SLMerge(FeatureScriptLangList *into, struct scriptlanglist *fsl) {</span>
<span class="lineNum">    1794 </span>            :     struct scriptlanglist *isl;
<span class="lineNum">    1795 </span>            : 
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :     for ( ; fsl!=NULL; fsl = fsl-&gt;next ) {</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :         for ( isl=into-&gt;scripts; isl!=NULL; isl=isl-&gt;next ) {</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :             if ( fsl-&gt;script==isl-&gt;script )</span>
<span class="lineNum">    1799 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1800 </span>            :         }
<span class="lineNum">    1801 </span><span class="lineNoCov">          0 :         if ( isl!=NULL )</span>
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :             LangMerge(isl,fsl);</span>
<span class="lineNum">    1803 </span>            :         else {
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :             isl = SLCopy(fsl);</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :             isl-&gt;next = into-&gt;scripts;</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :             into-&gt;scripts = isl;</span>
<span class="lineNum">    1807 </span>            :         }
<span class="lineNum">    1808 </span>            :     }
<a name="1809"><span class="lineNum">    1809 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1810 </span>            : 
<span class="lineNum">    1811 </span><span class="lineNoCov">          0 : void FLMerge(OTLookup *into, OTLookup *from) {</span>
<span class="lineNum">    1812 </span>            :     /* Merge the feature list from &quot;from&quot; into &quot;into&quot; */
<span class="lineNum">    1813 </span>            :     FeatureScriptLangList *ifl, *ffl;
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            :     /* first check for common featuretags and merge the scripts of each */
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :     for ( ffl = from-&gt;features; ffl!=NULL; ffl = ffl-&gt;next ) {</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :         for ( ifl=into-&gt;features; ifl!=NULL; ifl=ifl-&gt;next ) {</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :             if ( ffl-&gt;featuretag==ifl-&gt;featuretag )</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1820 </span>            :         }
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :         if ( ifl!=NULL )</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :             SLMerge(ffl,ifl-&gt;scripts);</span>
<span class="lineNum">    1823 </span>            :         else {
<span class="lineNum">    1824 </span><span class="lineNoCov">          0 :             ifl = FeatureListCopy(ffl);</span>
<span class="lineNum">    1825 </span><span class="lineNoCov">          0 :             ifl-&gt;next = into-&gt;features;</span>
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :             into-&gt;features = ifl;</span>
<span class="lineNum">    1827 </span>            :         }
<span class="lineNum">    1828 </span>            :     }
<span class="lineNum">    1829 </span><span class="lineNoCov">          0 :     into-&gt;features = FLOrder(into-&gt;features);</span>
<a name="1830"><span class="lineNum">    1830 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1831 </span>            : 
<span class="lineNum">    1832 </span><span class="lineNoCov">          0 : void SFSubTablesMerge(SplineFont *_sf,struct lookup_subtable *subfirst,</span>
<span class="lineNum">    1833 </span>            :         struct lookup_subtable *subsecond) {
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 :     uint16 lookup_type = subfirst-&gt;lookup-&gt;lookup_type;</span>
<span class="lineNum">    1835 </span>            :     int gid,k,isv;
<span class="lineNum">    1836 </span>            :     SplineChar *sc;
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :     SplineFont *sf = _sf;</span>
<span class="lineNum">    1838 </span>            :     PST *pst, *fpst, *spst, *pstprev, *pstnext;
<span class="lineNum">    1839 </span>            :     KernPair *fkp, *skp, *kpprev, *kpnext;
<span class="lineNum">    1840 </span>            :     AnchorClass *ac;
<span class="lineNum">    1841 </span>            : 
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :     if ( lookup_type != subsecond-&gt;lookup-&gt;lookup_type ) {</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :         IError(&quot;Attempt to merge lookup subtables with mismatch types&quot;);</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    1845 </span>            :     }
<span class="lineNum">    1846 </span><span class="lineNoCov">          0 :     if ( lookup_type != gsub_single &amp;&amp;</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :             lookup_type != gsub_multiple &amp;&amp;</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :             lookup_type != gsub_alternate &amp;&amp;</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :             lookup_type != gsub_ligature &amp;&amp;</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :             lookup_type != gpos_single &amp;&amp;</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :             lookup_type != gpos_pair &amp;&amp;</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :             lookup_type != gpos_cursive &amp;&amp;</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :             lookup_type != gpos_mark2base &amp;&amp;</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :             lookup_type != gpos_mark2ligature &amp;&amp;</span>
<span class="lineNum">    1855 </span>            :             lookup_type != gpos_mark2mark ) {
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :         IError(&quot;Attempt to merge lookup subtables with bad types&quot;);</span>
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :     } else if ( subfirst-&gt;kc!=NULL || subsecond-&gt;kc != NULL ) {</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :         IError(&quot;Attempt to merge lookup subtables with kerning classes&quot;);</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    1861 </span>            :     }
<span class="lineNum">    1862 </span>            : 
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :     if ( lookup_type==gpos_cursive || lookup_type==gpos_mark2base ||</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :             lookup_type==gpos_mark2ligature || lookup_type==gpos_mark2mark ) {</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :         for ( ac = sf-&gt;anchor; ac!=NULL ; ac=ac-&gt;next )</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :             if ( ac-&gt;subtable == subsecond )</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :                 ac-&gt;subtable = subfirst;</span>
<span class="lineNum">    1868 </span>            :     } else {
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :         k=0;</span>
<span class="lineNum">    1870 </span>            :         do {
<span class="lineNum">    1871 </span><span class="lineNoCov">          0 :             sf = _sf-&gt;subfontcnt==0 ? _sf : _sf-&gt;subfonts[k];</span>
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :             for ( gid=0; gid&lt;sf-&gt;glyphcnt; ++gid ) if ( (sc=sf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :                 if ( lookup_type==gsub_single || lookup_type==gsub_multiple ||</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :                         lookup_type==gsub_alternate || lookup_type==gpos_single ) {</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :                     fpst = spst = NULL;</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :                     for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :                         if ( pst-&gt;subtable == subfirst ) {</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :                             fpst = pst;</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :                             if ( spst!=NULL )</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :                         } else if ( pst-&gt;subtable == subsecond ) {</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :                             spst = pst;</span>
<span class="lineNum">    1883 </span><span class="lineNoCov">          0 :                             if ( fpst!=NULL )</span>
<span class="lineNum">    1884 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    1885 </span>            :                         }
<span class="lineNum">    1886 </span>            :                     }
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :                     if ( fpst==NULL &amp;&amp; spst!=NULL )</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :                         spst-&gt;subtable = subfirst;</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :                     else if ( spst!=NULL ) {</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;The glyph, %s, contains a %s from %s and one from %s.\nThe one from %s will be removed.\n&quot;),</span>
<span class="lineNum">    1891 </span>            :                                 sc-&gt;name,
<span class="lineNum">    1892 </span>            :                                 lookup_type==gpos_single ? _(&quot;positioning&quot;) : _(&quot;substitution&quot;),
<span class="lineNum">    1893 </span>            :                                 subfirst-&gt;subtable_name, subsecond-&gt;subtable_name,
<span class="lineNum">    1894 </span>            :                                 subsecond-&gt;subtable_name );
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :                         pstprev = NULL;</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :                         for ( pst=sc-&gt;possub; pst!=NULL &amp;&amp; pst!=spst; pstprev=pst, pst=pst-&gt;next );</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :                         if ( pstprev==NULL )</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :                             sc-&gt;possub = spst-&gt;next;</span>
<span class="lineNum">    1899 </span>            :                         else
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :                             pstprev = spst-&gt;next;</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :                         spst-&gt;next = NULL;</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :                         PSTFree(spst);</span>
<span class="lineNum">    1903 </span>            :                     }
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                 } else if ( lookup_type==gsub_ligature || lookup_type==gpos_pair ) {</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :                     pstprev = NULL;</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :                     for ( spst=sc-&gt;possub; spst!=NULL ; spst = pstnext ) {</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :                         pstnext = spst-&gt;next;</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                         if ( spst-&gt;subtable == subsecond ) {</span>
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :                             for ( fpst=sc-&gt;possub; fpst!=NULL; fpst=fpst-&gt;next ) {</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :                                 if ( fpst-&gt;subtable == subfirst &amp;&amp;</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :                                         strcmp(fpst-&gt;u.lig.components,spst-&gt;u.lig.components)==0 )</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :                             break;</span>
<span class="lineNum">    1913 </span>            :                             }
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :                             if ( fpst==NULL )</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :                                 spst-&gt;subtable = subfirst;</span>
<span class="lineNum">    1916 </span>            :                             else {
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :                                 LogError(_(&quot;The glyph, %s, contains the same %s from %s and from %s.\nThe one from %s will be removed.\n&quot;),</span>
<span class="lineNum">    1918 </span>            :                                         sc-&gt;name,
<span class="lineNum">    1919 </span>            :                                         lookup_type==gsub_ligature ? _(&quot;ligature&quot;) : _(&quot;kern pair&quot;),
<span class="lineNum">    1920 </span>            :                                         subfirst-&gt;subtable_name, subsecond-&gt;subtable_name,
<span class="lineNum">    1921 </span>            :                                         subsecond-&gt;subtable_name );
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :                                 if ( pstprev==NULL )</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :                                     sc-&gt;possub = pstnext;</span>
<span class="lineNum">    1924 </span>            :                                 else
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :                                     pstprev-&gt;next = pstnext;</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :                                 spst-&gt;next = NULL;</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :                                 PSTFree(spst);</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :                                 spst = pstprev;</span>
<span class="lineNum">    1929 </span>            :                             }
<span class="lineNum">    1930 </span>            :                         }
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :                         pstprev = spst;</span>
<span class="lineNum">    1932 </span>            :                     }
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :                     for ( isv=0; isv&lt;2; ++isv ) {</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :                         kpprev = NULL;</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :                         for ( skp=isv ? sc-&gt;vkerns : sc-&gt;kerns; skp!=NULL ; skp = kpnext ) {</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :                             kpnext = skp-&gt;next;</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :                             if ( skp-&gt;subtable == subsecond ) {</span>
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :                                 for ( fkp=isv ? sc-&gt;vkerns : sc-&gt;kerns; fkp!=NULL; fkp=fkp-&gt;next ) {</span>
<span class="lineNum">    1939 </span><span class="lineNoCov">          0 :                                     if ( fkp-&gt;subtable == subfirst &amp;&amp; fkp-&gt;sc==skp-&gt;sc )</span>
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    1941 </span>            :                                 }
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :                                 if ( fkp==NULL )</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :                                     skp-&gt;subtable = subfirst;</span>
<span class="lineNum">    1944 </span>            :                                 else {
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :                                     LogError(_(&quot;The glyph, %s, contains the same kern pair from %s and from %s.\nThe one from %s will be removed.\n&quot;),</span>
<span class="lineNum">    1946 </span>            :                                             sc-&gt;name,
<span class="lineNum">    1947 </span>            :                                             subfirst-&gt;subtable_name, subsecond-&gt;subtable_name,
<span class="lineNum">    1948 </span>            :                                             subsecond-&gt;subtable_name );
<span class="lineNum">    1949 </span><span class="lineNoCov">          0 :                                     if ( kpprev!=NULL )</span>
<span class="lineNum">    1950 </span><span class="lineNoCov">          0 :                                         kpprev-&gt;next = kpnext;</span>
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :                                     else if ( isv )</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :                                         sc-&gt;vkerns = kpnext;</span>
<span class="lineNum">    1953 </span>            :                                     else
<span class="lineNum">    1954 </span><span class="lineNoCov">          0 :                                         sc-&gt;kerns = kpnext;</span>
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :                                     skp-&gt;next = NULL;</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :                                     KernPairsFree(skp);</span>
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :                                     skp = kpprev;</span>
<span class="lineNum">    1958 </span>            :                                 }
<span class="lineNum">    1959 </span>            :                             }
<span class="lineNum">    1960 </span><span class="lineNoCov">          0 :                             kpprev = skp;</span>
<span class="lineNum">    1961 </span>            :                         }
<span class="lineNum">    1962 </span>            :                     }
<span class="lineNum">    1963 </span>            :                 }
<span class="lineNum">    1964 </span>            :             }
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :             ++k;</span>
<span class="lineNum">    1966 </span><span class="lineNoCov">          0 :         } while ( k&lt;_sf-&gt;subfontcnt );</span>
<span class="lineNum">    1967 </span>            :     }
<span class="lineNum">    1968 </span>            : }
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span>            : /* ************************************************************************** */
<span class="lineNum">    1971 </span>            : /* ******************************* copy lookup ****************************** */
<a name="1972"><span class="lineNum">    1972 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">    1973 </span>            : 
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 : static char **ClassCopy(int class_cnt,char **classes) {</span>
<span class="lineNum">    1975 </span>            :     char **newclasses;
<span class="lineNum">    1976 </span>            :     int i;
<span class="lineNum">    1977 </span>            : 
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :     if ( classes==NULL || class_cnt==0 )</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     newclasses = malloc(class_cnt*sizeof(char *));</span>
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;class_cnt; ++i )</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :         newclasses[i] = copy(classes[i]);</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 : return( newclasses );</span>
<span class="lineNum">    1984 </span>            : }
<span class="lineNum">    1985 </span>            : 
<a name="1986"><span class="lineNum">    1986 </span>            : static OTLookup *_OTLookupCopyInto(struct sfmergecontext *mc,</a>
<span class="lineNum">    1987 </span>            :         OTLookup *from_otl, OTLookup *before, int do_contents);
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 : static OTLookup *OTLookupCopyNested(struct sfmergecontext *mc,</span>
<span class="lineNum">    1989 </span>            :         OTLookup *from_otl) {
<span class="lineNum">    1990 </span>            :     char *newname;
<span class="lineNum">    1991 </span>            :     OTLookup *to_nested_otl;
<span class="lineNum">    1992 </span>            :     int l;
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :     if ( from_otl==NULL )</span>
<span class="lineNum">    1995 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :     for ( l=0; l&lt;mc-&gt;lcnt; ++l ) {</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :         if ( mc-&gt;lks[l].from == from_otl )</span>
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 : return( mc-&gt;lks[l].to );</span>
<span class="lineNum">    2000 </span>            :     }
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :     newname = strconcat(mc-&gt;prefix,from_otl-&gt;lookup_name);</span>
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :     to_nested_otl = SFFindLookup(mc-&gt;sf_to,newname);</span>
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :     free(newname);</span>
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :     if ( to_nested_otl==NULL )</span>
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :         to_nested_otl = _OTLookupCopyInto(mc, from_otl, (OTLookup *) -1, true );</span>
<span class="lineNum">    2007 </span><span class="lineNoCov">          0 : return( to_nested_otl );</span>
<a name="2008"><span class="lineNum">    2008 </span>            : }</a>
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span><span class="lineNoCov">          0 : static KernClass *SF_AddKernClass(struct sfmergecontext *mc,KernClass *kc,</span>
<span class="lineNum">    2011 </span>            :         struct lookup_subtable *sub ) {
<span class="lineNum">    2012 </span>            :     KernClass *newkc;
<span class="lineNum">    2013 </span>            : 
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :     newkc = chunkalloc(sizeof(KernClass));</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :     *newkc = *kc;</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     newkc-&gt;subtable = sub;</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :     if ( sub-&gt;vertical_kerning ) {</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :         newkc-&gt;next = mc-&gt;sf_to-&gt;vkerns;</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :         mc-&gt;sf_to-&gt;vkerns = newkc;</span>
<span class="lineNum">    2020 </span>            :     } else {
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :         newkc-&gt;next = mc-&gt;sf_to-&gt;kerns;</span>
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :         mc-&gt;sf_to-&gt;kerns = newkc;</span>
<span class="lineNum">    2023 </span>            :     }
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :     newkc-&gt;firsts = ClassCopy(newkc-&gt;first_cnt,newkc-&gt;firsts);</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :     newkc-&gt;seconds = ClassCopy(newkc-&gt;second_cnt,newkc-&gt;seconds);</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :     newkc-&gt;offsets = malloc(newkc-&gt;first_cnt*newkc-&gt;second_cnt*sizeof(int16));</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :     memcpy(newkc-&gt;offsets,kc-&gt;offsets,newkc-&gt;first_cnt*newkc-&gt;second_cnt*sizeof(int16));</span>
<span class="lineNum">    2029 </span>            :     // We support group kerning as well.
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :     if (newkc-&gt;firsts_names) newkc-&gt;firsts_names = ClassCopy(newkc-&gt;first_cnt,newkc-&gt;firsts_names);</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :     if (newkc-&gt;seconds_names) newkc-&gt;seconds_names = ClassCopy(newkc-&gt;second_cnt,newkc-&gt;seconds_names);</span>
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :     if (newkc-&gt;firsts_flags) {</span>
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :       newkc-&gt;firsts_flags = malloc(newkc-&gt;first_cnt*sizeof(int));</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :       memcpy(newkc-&gt;firsts_flags,kc-&gt;firsts_flags,newkc-&gt;first_cnt*sizeof(int));</span>
<span class="lineNum">    2035 </span>            :     }
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :     if (newkc-&gt;seconds_flags) {</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :       newkc-&gt;seconds_flags = malloc(newkc-&gt;second_cnt*sizeof(int));</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :       memcpy(newkc-&gt;seconds_flags,kc-&gt;seconds_flags,newkc-&gt;second_cnt*sizeof(int));</span>
<span class="lineNum">    2039 </span>            :     }
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :     if (newkc-&gt;offsets_flags) {</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :       newkc-&gt;offsets_flags = malloc(newkc-&gt;first_cnt*newkc-&gt;second_cnt*sizeof(int));</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :       memcpy(newkc-&gt;offsets_flags,kc-&gt;offsets_flags,newkc-&gt;first_cnt*newkc-&gt;second_cnt*sizeof(int));</span>
<span class="lineNum">    2043 </span>            :     }
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 : return( newkc );</span>
<a name="2045"><span class="lineNum">    2045 </span>            : }</a>
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 : static FPST *SF_AddFPST(struct sfmergecontext *mc,FPST *fpst,</span>
<span class="lineNum">    2048 </span>            :         struct lookup_subtable *sub ) {
<span class="lineNum">    2049 </span>            :     FPST *newfpst;
<span class="lineNum">    2050 </span>            :     int i, k;
<span class="lineNum">    2051 </span>            : 
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :     newfpst = chunkalloc(sizeof(FPST));</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :     *newfpst = *fpst;</span>
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :     newfpst-&gt;subtable = sub;</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :     newfpst-&gt;next = mc-&gt;sf_to-&gt;possub;</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :     mc-&gt;sf_to-&gt;possub = newfpst;</span>
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span><span class="lineNoCov">          0 :     newfpst-&gt;nclass = ClassCopy(newfpst-&gt;nccnt,newfpst-&gt;nclass);</span>
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :     newfpst-&gt;bclass = ClassCopy(newfpst-&gt;bccnt,newfpst-&gt;bclass);</span>
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :     newfpst-&gt;fclass = ClassCopy(newfpst-&gt;fccnt,newfpst-&gt;fclass);</span>
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :     newfpst-&gt;nclassnames = ClassCopy(newfpst-&gt;nccnt,newfpst-&gt;nclassnames);</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :     newfpst-&gt;bclassnames = ClassCopy(newfpst-&gt;bccnt,newfpst-&gt;bclassnames);</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 :     newfpst-&gt;fclassnames = ClassCopy(newfpst-&gt;fccnt,newfpst-&gt;fclassnames);</span>
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :     newfpst-&gt;rules = malloc(newfpst-&gt;rule_cnt*sizeof(struct fpst_rule));</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :     memcpy(newfpst-&gt;rules,fpst-&gt;rules,newfpst-&gt;rule_cnt*sizeof(struct fpst_rule));</span>
<span class="lineNum">    2068 </span>            : 
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;newfpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">    2070 </span><span class="lineNoCov">          0 :         struct fpst_rule *r = &amp;newfpst-&gt;rules[i], *oldr = &amp;fpst-&gt;rules[i];</span>
<span class="lineNum">    2071 </span>            : 
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :         r-&gt;lookups = malloc(r-&gt;lookup_cnt*sizeof(struct seqlookup));</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :         memcpy(r-&gt;lookups,oldr-&gt;lookups,r-&gt;lookup_cnt*sizeof(struct seqlookup));</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :         for ( k=0; k&lt;r-&gt;lookup_cnt; ++k ) {</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :             r-&gt;lookups[k].lookup = OTLookupCopyNested(mc,</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :                 r-&gt;lookups[k].lookup);</span>
<span class="lineNum">    2077 </span>            :         }
<span class="lineNum">    2078 </span>            : 
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :         switch ( newfpst-&gt;format ) {</span>
<span class="lineNum">    2080 </span>            :           case pst_glyphs:
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :             r-&gt;u.glyph.names = copy( r-&gt;u.glyph.names );</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :             r-&gt;u.glyph.back = copy( r-&gt;u.glyph.back );</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :             r-&gt;u.glyph.fore = copy( r-&gt;u.glyph.fore );</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2085 </span>            :           case pst_class:
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :             r-&gt;u.class.nclasses = malloc( r-&gt;u.class.ncnt*sizeof(uint16));</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :             memcpy(r-&gt;u.class.nclasses,oldr-&gt;u.class.nclasses, r-&gt;u.class.ncnt*sizeof(uint16));</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :             r-&gt;u.class.bclasses = malloc( r-&gt;u.class.bcnt*sizeof(uint16));</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :             memcpy(r-&gt;u.class.bclasses,oldr-&gt;u.class.bclasses, r-&gt;u.class.bcnt*sizeof(uint16));</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :             r-&gt;u.class.fclasses = malloc( r-&gt;u.class.fcnt*sizeof(uint16));</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :             memcpy(r-&gt;u.class.fclasses,oldr-&gt;u.class.fclasses, r-&gt;u.class.fcnt*sizeof(uint16));</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2093 </span>            :           case pst_coverage:
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :             r-&gt;u.coverage.ncovers = ClassCopy( r-&gt;u.coverage.ncnt, r-&gt;u.coverage.ncovers );</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :             r-&gt;u.coverage.bcovers = ClassCopy( r-&gt;u.coverage.bcnt, r-&gt;u.coverage.bcovers );</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :             r-&gt;u.coverage.fcovers = ClassCopy( r-&gt;u.coverage.fcnt, r-&gt;u.coverage.fcovers );</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2098 </span>            :           case pst_reversecoverage:
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :             r-&gt;u.rcoverage.ncovers = ClassCopy( r-&gt;u.rcoverage.always1, r-&gt;u.rcoverage.ncovers );</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :             r-&gt;u.rcoverage.bcovers = ClassCopy( r-&gt;u.rcoverage.bcnt, r-&gt;u.rcoverage.bcovers );</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :             r-&gt;u.rcoverage.fcovers = ClassCopy( r-&gt;u.rcoverage.fcnt, r-&gt;u.rcoverage.fcovers );</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :             r-&gt;u.rcoverage.replacements = copy( r-&gt;u.rcoverage.replacements );</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2104 </span>            :           default:
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2106 </span>            :         }
<span class="lineNum">    2107 </span>            :     }
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 : return( newfpst );</span>
<a name="2109"><span class="lineNum">    2109 </span>            : }</a>
<span class="lineNum">    2110 </span>            : 
<span class="lineNum">    2111 </span><span class="lineNoCov">          0 : static ASM *SF_AddASM(struct sfmergecontext *mc,ASM *sm, struct lookup_subtable *sub ) {</span>
<span class="lineNum">    2112 </span>            :     ASM *newsm;
<span class="lineNum">    2113 </span>            :     int i;
<span class="lineNum">    2114 </span>            : 
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :     newsm = chunkalloc(sizeof(ASM));</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :     *newsm = *sm;</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :     newsm-&gt;subtable = sub;</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :     newsm-&gt;next = mc-&gt;sf_to-&gt;sm;</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :     mc-&gt;sf_to-&gt;sm = newsm;</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :     mc-&gt;sf_to-&gt;changed = true;</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :     newsm-&gt;classes = ClassCopy(newsm-&gt;class_cnt, newsm-&gt;classes);</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :     newsm-&gt;state = malloc(newsm-&gt;class_cnt*newsm-&gt;state_cnt*sizeof(struct asm_state));</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :     memcpy(newsm-&gt;state,sm-&gt;state,</span>
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :             newsm-&gt;class_cnt*newsm-&gt;state_cnt*sizeof(struct asm_state));</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     if ( newsm-&gt;type == asm_kern ) {</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :         for ( i=newsm-&gt;class_cnt*newsm-&gt;state_cnt-1; i&gt;=0; --i ) {</span>
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :             newsm-&gt;state[i].u.kern.kerns = malloc(newsm-&gt;state[i].u.kern.kcnt*sizeof(int16));</span>
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :             memcpy(newsm-&gt;state[i].u.kern.kerns,sm-&gt;state[i].u.kern.kerns,newsm-&gt;state[i].u.kern.kcnt*sizeof(int16));</span>
<span class="lineNum">    2129 </span>            :         }
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :     } else if ( newsm-&gt;type == asm_insert ) {</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;newsm-&gt;class_cnt*newsm-&gt;state_cnt; ++i ) {</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :             struct asm_state *this = &amp;newsm-&gt;state[i];</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :             this-&gt;u.insert.mark_ins = copy(this-&gt;u.insert.mark_ins);</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :             this-&gt;u.insert.cur_ins = copy(this-&gt;u.insert.cur_ins);</span>
<span class="lineNum">    2135 </span>            :         }
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :     } else if ( newsm-&gt;type == asm_context ) {</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;newsm-&gt;class_cnt*newsm-&gt;state_cnt; ++i ) {</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :             newsm-&gt;state[i].u.context.mark_lookup = OTLookupCopyNested(mc,</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :                     newsm-&gt;state[i].u.context.mark_lookup);</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :             newsm-&gt;state[i].u.context.cur_lookup = OTLookupCopyNested(mc,</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                     newsm-&gt;state[i].u.context.cur_lookup);</span>
<span class="lineNum">    2142 </span>            :         }
<span class="lineNum">    2143 </span>            :     }
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 : return( newsm );</span>
<a name="2145"><span class="lineNum">    2145 </span>            : }</a>
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 : static SplineChar *SCFindOrMake(SplineFont *into,SplineChar *fromsc) {</span>
<span class="lineNum">    2148 </span>            :     int to_index;
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :     if ( into-&gt;cidmaster==NULL &amp;&amp; into-&gt;fv!=NULL ) {</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :         to_index = SFFindSlot(into,into-&gt;fv-&gt;map,fromsc-&gt;unicodeenc,fromsc-&gt;name);</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :         if ( to_index==-1 )</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 : return( SFMakeChar(into,into-&gt;fv-&gt;map,to_index));</span>
<span class="lineNum">    2155 </span>            :     }
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 : return( SFGetChar(into,fromsc-&gt;unicodeenc,fromsc-&gt;name));</span>
<a name="2157"><span class="lineNum">    2157 </span>            : }</a>
<span class="lineNum">    2158 </span>            : 
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 : static void SF_SCAddAP(SplineChar *tosc,AnchorPoint *ap, AnchorClass *newac) {</span>
<span class="lineNum">    2160 </span>            :     AnchorPoint *newap;
<span class="lineNum">    2161 </span>            : 
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :     newap = chunkalloc(sizeof(AnchorPoint));</span>
<span class="lineNum">    2163 </span><span class="lineNoCov">          0 :     *newap = *ap;</span>
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :     newap-&gt;anchor = newac;</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :     newap-&gt;next = tosc-&gt;anchor;</span>
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 :     tosc-&gt;anchor = newap;</span>
<a name="2167"><span class="lineNum">    2167 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2168 </span>            : 
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 : static void SF_AddAnchorClasses(struct sfmergecontext *mc,</span>
<span class="lineNum">    2170 </span>            :         struct lookup_subtable *from_sub, struct lookup_subtable *sub ) {
<span class="lineNum">    2171 </span>            :     AnchorClass *ac, *nac;
<span class="lineNum">    2172 </span>            :     int k, gid;
<span class="lineNum">    2173 </span>            :     SplineFont *fsf;
<span class="lineNum">    2174 </span>            :     AnchorPoint *ap;
<span class="lineNum">    2175 </span>            :     SplineChar *fsc, *tsc;
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :     for ( ac=mc-&gt;sf_from-&gt;anchor; ac!=NULL; ac=ac-&gt;next ) if ( ac-&gt;subtable==from_sub ) {</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :         nac = chunkalloc(sizeof(AnchorClass));</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :         *nac = *ac;</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :         nac-&gt;subtable = sub;</span>
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :         nac-&gt;name = strconcat(mc-&gt;prefix,nac-&gt;name);</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :         nac-&gt;next = mc-&gt;sf_to-&gt;anchor;</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :         mc-&gt;sf_to-&gt;anchor = nac;</span>
<span class="lineNum">    2184 </span>            : 
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :         k=0;</span>
<span class="lineNum">    2186 </span>            :         do {
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :             fsf = mc-&gt;sf_from-&gt;subfontcnt==0 ? mc-&gt;sf_from : mc-&gt;sf_from-&gt;subfonts[k];</span>
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :             for ( gid = 0; gid&lt;fsf-&gt;glyphcnt; ++gid ) if ( (fsc = fsf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :                 for ( ap=fsc-&gt;anchor; ap!=NULL; ap=ap-&gt;next ) {</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :                     if ( ap-&gt;anchor==ac ) {</span>
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :                         tsc = SCFindOrMake(mc-&gt;sf_to,fsc);</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :                         if ( tsc==NULL )</span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :                         SF_SCAddAP(tsc,ap,nac);</span>
<span class="lineNum">    2195 </span>            :                     }
<span class="lineNum">    2196 </span>            :                 }
<span class="lineNum">    2197 </span>            :             }
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :             ++k;</span>
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :         } while ( k&lt;mc-&gt;sf_from-&gt;subfontcnt );</span>
<span class="lineNum">    2200 </span>            :     }
<a name="2201"><span class="lineNum">    2201 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 : static int SF_SCAddPST(SplineChar *tosc,PST *pst,struct lookup_subtable *sub) {</span>
<span class="lineNum">    2204 </span>            :     PST *newpst;
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :     newpst = chunkalloc(sizeof(PST));</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :     *newpst = *pst;</span>
<span class="lineNum">    2208 </span><span class="lineNoCov">          0 :     newpst-&gt;subtable = sub;</span>
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     newpst-&gt;next = tosc-&gt;possub;</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :     tosc-&gt;possub = newpst;</span>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :     switch( newpst-&gt;type ) {</span>
<span class="lineNum">    2213 </span>            :       case pst_pair:
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :         newpst-&gt;u.pair.paired = copy(pst-&gt;u.pair.paired);</span>
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :         newpst-&gt;u.pair.vr = chunkalloc(sizeof(struct vr [2]));</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :         memcpy(newpst-&gt;u.pair.vr,pst-&gt;u.pair.vr,sizeof(struct vr [2]));</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2218 </span>            :       case pst_ligature:
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :         newpst-&gt;u.lig.lig = tosc;</span>
<span class="lineNum">    2220 </span>            :         /* Fall through */
<span class="lineNum">    2221 </span>            :       case pst_substitution:
<span class="lineNum">    2222 </span>            :       case pst_alternate:
<span class="lineNum">    2223 </span>            :       case pst_multiple:
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :         newpst-&gt;u.subs.variant = copy(pst-&gt;u.subs.variant);</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2226 </span>            :       default:
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2228 </span>            :     }
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 : return( true );</span>
<a name="2230"><span class="lineNum">    2230 </span>            : }</a>
<span class="lineNum">    2231 </span>            : 
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 : static int SF_SCAddKP(SplineChar *tosc,KernPair *kp,struct lookup_subtable *sub,</span>
<span class="lineNum">    2233 </span>            :         int isvkern, SplineFont *to_sf ) {
<span class="lineNum">    2234 </span>            :     SplineChar *tosecond;
<span class="lineNum">    2235 </span>            :     KernPair *newkp;
<span class="lineNum">    2236 </span>            : 
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :     tosecond = SFGetChar(to_sf,kp-&gt;sc-&gt;unicodeenc,kp-&gt;sc-&gt;name);</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :     if ( tosecond==NULL )</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :     newkp = chunkalloc(sizeof(KernPair));</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :     *newkp = *kp;</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :     newkp-&gt;subtable = sub;</span>
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :     newkp-&gt;sc = tosecond;</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :     if ( isvkern ) {</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :         newkp-&gt;next = tosc-&gt;vkerns;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :         tosc-&gt;vkerns = newkp;</span>
<span class="lineNum">    2248 </span>            :     } else {
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :         newkp-&gt;next = tosc-&gt;kerns;</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :         tosc-&gt;kerns = newkp;</span>
<span class="lineNum">    2251 </span>            :     }
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 : return(true);</span>
<a name="2253"><span class="lineNum">    2253 </span>            : }</a>
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 : static void SF_AddPSTKern(struct sfmergecontext *mc,struct lookup_subtable *from_sub, struct lookup_subtable *sub) {</span>
<span class="lineNum">    2256 </span>            :     int k, gid, isv;
<span class="lineNum">    2257 </span>            :     SplineFont *fsf;
<span class="lineNum">    2258 </span>            :     SplineChar *fsc, *tsc;
<span class="lineNum">    2259 </span>            :     PST *pst;
<span class="lineNum">    2260 </span>            :     KernPair *kp;
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :     int iskern = sub-&gt;lookup-&gt;lookup_type==gpos_pair;</span>
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :     k=0;</span>
<span class="lineNum">    2264 </span>            :     do {
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :         fsf = mc-&gt;sf_from-&gt;subfontcnt==0 ? mc-&gt;sf_from : mc-&gt;sf_from-&gt;subfonts[k];</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :         for ( gid = 0; gid&lt;fsf-&gt;glyphcnt; ++gid ) if ( (fsc = fsf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :             tsc = (SplineChar *) -1;</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :             for ( pst = fsc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :                 if ( pst-&gt;subtable==from_sub ) {</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :                     if ( tsc==(SplineChar *) -1 ) {</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :                         tsc = SCFindOrMake(mc-&gt;sf_to,fsc);</span>
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :                         if ( tsc==NULL )</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2274 </span>            :                     }
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :                     SF_SCAddPST(tsc,pst,sub);</span>
<span class="lineNum">    2276 </span>            :                 }
<span class="lineNum">    2277 </span>            :             }
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :             if ( tsc!=NULL &amp;&amp; iskern ) {</span>
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :                 for ( isv=0; isv&lt;2 &amp;&amp; tsc!=NULL; ++isv ) {</span>
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :                     for ( kp= isv ? fsc-&gt;vkerns : fsc-&gt;kerns; kp!=NULL; kp=kp-&gt;next ) {</span>
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :                         if ( kp-&gt;subtable==sub ) {</span>
<span class="lineNum">    2282 </span>            :                             /* Kerning data tend to be individualistic. Only copy if */
<span class="lineNum">    2283 </span>            :                             /*  glyphs exist */
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :                             if ( tsc==(SplineChar *) -1 ) {</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :                                 tsc = SFGetChar(mc-&gt;sf_to,fsc-&gt;unicodeenc,fsc-&gt;name);</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :                                 if ( tsc==NULL )</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2288 </span>            :                             }
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :                             SF_SCAddKP(tsc,kp,sub,isv,mc-&gt;sf_to);</span>
<span class="lineNum">    2290 </span>            :                         }
<span class="lineNum">    2291 </span>            :                     }
<span class="lineNum">    2292 </span>            :                 }
<span class="lineNum">    2293 </span>            :             }
<span class="lineNum">    2294 </span>            :         }
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :         ++k;</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :     } while ( k&lt;mc-&gt;sf_from-&gt;subfontcnt );</span>
<a name="2297"><span class="lineNum">    2297 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span><span class="lineCov">         22 : int _FeatureOrderId( int isgpos,uint32 tag ) {</span>
<span class="lineNum">    2300 </span>            :     /* This is the order in which features should be executed */
<span class="lineNum">    2301 </span>            : 
<span class="lineNum">    2302 </span><span class="lineCov">         22 :     if ( !isgpos ) switch ( tag ) {</span>
<span class="lineNum">    2303 </span>            : /* GSUB ordering */
<span class="lineNum">    2304 </span>            :       case CHR('c','c','m','p'):        /* Must be first? */
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 : return( -2 );</span>
<span class="lineNum">    2306 </span>            :       case CHR('l','o','c','l'):        /* Language dependent letter forms (serbian uses some different glyphs than russian) */
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 : return( -1 );</span>
<span class="lineNum">    2308 </span>            :       case CHR('i','s','o','l'):
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2310 </span>            :       case CHR('j','a','l','t'):                /* must come after 'isol' */
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 : return( 1 );</span>
<span class="lineNum">    2312 </span>            :       case CHR('f','i','n','a'):
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 : return( 2 );</span>
<span class="lineNum">    2314 </span>            :       case CHR('f','i','n','2'):
<span class="lineNum">    2315 </span>            :       case CHR('f','a','l','t'):                /* must come after 'fina' */
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 : return( 3 );</span>
<span class="lineNum">    2317 </span>            :       case CHR('f','i','n','3'):
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 : return( 4 );</span>
<span class="lineNum">    2319 </span>            :       case CHR('m','e','d','i'):
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 : return( 5 );</span>
<span class="lineNum">    2321 </span>            :       case CHR('m','e','d','2'):
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 : return( 6 );</span>
<span class="lineNum">    2323 </span>            :       case CHR('i','n','i','t'):
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 : return( 7 );</span>
<span class="lineNum">    2325 </span>            : 
<span class="lineNum">    2326 </span>            :       case CHR('r','t','l','a'):
<span class="lineNum">    2327 </span><span class="lineNoCov">          0 : return( 100 );</span>
<span class="lineNum">    2328 </span>            :       case CHR('s','m','c','p'): case CHR('c','2','s','c'):
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 : return( 200 );</span>
<span class="lineNum">    2330 </span>            : 
<span class="lineNum">    2331 </span>            :       case CHR('r','l','i','g'):
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 : return( 300 );</span>
<span class="lineNum">    2333 </span>            :       case CHR('c','a','l','t'):
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 : return( 301 );</span>
<span class="lineNum">    2335 </span>            :       case CHR('l','i','g','a'):
<span class="lineNum">    2336 </span><span class="lineCov">          9 : return( 302 );</span>
<span class="lineNum">    2337 </span>            :       case CHR('d','l','i','g'): case CHR('h','l','i','g'):
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 : return( 303 );</span>
<span class="lineNum">    2339 </span>            :       case CHR('c','s','w','h'):
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 : return( 304 );</span>
<span class="lineNum">    2341 </span>            :       case CHR('m','s','e','t'):
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 : return( 305 );</span>
<span class="lineNum">    2343 </span>            : 
<span class="lineNum">    2344 </span>            :       case CHR('f','r','a','c'):
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 : return( 306 );</span>
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span>            : /* Indic processing */
<span class="lineNum">    2348 </span>            :       case CHR('n','u','k','t'):
<span class="lineNum">    2349 </span>            :       case CHR('p','r','e','f'):
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 : return( 301 );</span>
<span class="lineNum">    2351 </span>            :       case CHR('a','k','h','n'):
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 : return( 302 );</span>
<span class="lineNum">    2353 </span>            :       case CHR('r','p','h','f'):
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 : return( 303 );</span>
<span class="lineNum">    2355 </span>            :       case CHR('b','l','w','f'):
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 : return( 304 );</span>
<span class="lineNum">    2357 </span>            :       case CHR('h','a','l','f'):
<span class="lineNum">    2358 </span>            :       case CHR('a','b','v','f'):
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 : return( 305 );</span>
<span class="lineNum">    2360 </span>            :       case CHR('p','s','t','f'):
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 : return( 306 );</span>
<span class="lineNum">    2362 </span>            :       case CHR('v','a','t','u'):
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 : return( 307 );</span>
<span class="lineNum">    2364 </span>            : 
<span class="lineNum">    2365 </span>            :       case CHR('p','r','e','s'):
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 : return( 310 );</span>
<span class="lineNum">    2367 </span>            :       case CHR('b','l','w','s'):
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 : return( 311 );</span>
<span class="lineNum">    2369 </span>            :       case CHR('a','b','v','s'):
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 : return( 312 );</span>
<span class="lineNum">    2371 </span>            :       case CHR('p','s','t','s'):
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 : return( 313 );</span>
<span class="lineNum">    2373 </span>            :       case CHR('c','l','i','g'):
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 : return( 314 );</span>
<span class="lineNum">    2375 </span>            : 
<span class="lineNum">    2376 </span>            :       case CHR('h','a','l','n'):
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 : return( 320 );</span>
<span class="lineNum">    2378 </span>            : /* end indic ordering */
<span class="lineNum">    2379 </span>            : 
<span class="lineNum">    2380 </span>            :       case CHR('a','f','r','c'):
<span class="lineNum">    2381 </span>            :       case CHR('l','j','m','o'):
<span class="lineNum">    2382 </span>            :       case CHR('v','j','m','o'):
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 : return( 350 );</span>
<span class="lineNum">    2384 </span>            :       case CHR('v','r','t','2'): case CHR('v','e','r','t'):
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 : return( 1010 );         /* Documented to come last */</span>
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span>            : /* Unknown things come after everything but vert/vrt2 */
<span class="lineNum">    2388 </span>            :       default:
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 : return( 1000 );</span>
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span><span class="lineCov">         13 :     } else switch ( tag ) {</span>
<span class="lineNum">    2392 </span>            : /* GPOS ordering */
<span class="lineNum">    2393 </span>            :       case CHR('c','u','r','s'):
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2395 </span>            :       case CHR('d','i','s','t'):
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 : return( 100 );</span>
<span class="lineNum">    2397 </span>            :       case CHR('b','l','w','m'):
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 : return( 201 );</span>
<span class="lineNum">    2399 </span>            :       case CHR('a','b','v','m'):
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 : return( 202 );</span>
<span class="lineNum">    2401 </span>            :       case CHR('k','e','r','n'):
<span class="lineNum">    2402 </span><span class="lineCov">         11 : return( 300 );</span>
<span class="lineNum">    2403 </span>            :       case CHR('m','a','r','k'):
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 : return( 400 );</span>
<span class="lineNum">    2405 </span>            :       case CHR('m','k','m','k'):
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 : return( 500 );</span>
<span class="lineNum">    2407 </span>            : /* Unknown things come after everything  */
<span class="lineNum">    2408 </span>            :       default:
<span class="lineNum">    2409 </span><span class="lineCov">          2 : return( 1000 );</span>
<span class="lineNum">    2410 </span>            :     }
<a name="2411"><span class="lineNum">    2411 </span>            : }</a>
<span class="lineNum">    2412 </span>            : 
<span class="lineNum">    2413 </span><span class="lineCov">         22 : int FeatureOrderId( int isgpos,FeatureScriptLangList *fl ) {</span>
<span class="lineNum">    2414 </span><span class="lineCov">         22 :     int pos = 9999, temp;</span>
<span class="lineNum">    2415 </span>            : 
<span class="lineNum">    2416 </span><span class="lineCov">         22 :     if ( fl==NULL )</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span><span class="lineCov">         66 :     while ( fl!=NULL ) {</span>
<span class="lineNum">    2420 </span><span class="lineCov">         22 :         temp = _FeatureOrderId(isgpos,fl-&gt;featuretag );</span>
<span class="lineNum">    2421 </span><span class="lineCov">         22 :         if ( temp&lt;pos ) pos = temp;</span>
<span class="lineNum">    2422 </span><span class="lineCov">         22 :         fl = fl-&gt;next;</span>
<span class="lineNum">    2423 </span>            :     }
<span class="lineNum">    2424 </span><span class="lineCov">         22 : return( pos );</span>
<a name="2425"><span class="lineNum">    2425 </span>            : }</a>
<span class="lineNum">    2426 </span>            : 
<span class="lineNum">    2427 </span><span class="lineCov">         15 : void SortInsertLookup(SplineFont *sf, OTLookup *newotl) {</span>
<span class="lineNum">    2428 </span><span class="lineCov">         15 :     int isgpos = newotl-&gt;lookup_type&gt;=gpos_start;</span>
<span class="lineNum">    2429 </span>            :     int pos;
<span class="lineNum">    2430 </span>            :     OTLookup *prev, *otl;
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span><span class="lineCov">         15 :     pos = FeatureOrderId(isgpos,newotl-&gt;features);</span>
<span class="lineNum">    2433 </span><span class="lineCov">         30 :     for ( prev=NULL, otl= isgpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups ;</span>
<span class="lineNum">    2434 </span><span class="lineCov">          7 :             otl!=NULL &amp;&amp; FeatureOrderId(isgpos,newotl-&gt;features)&lt;pos;</span>
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :             prev = otl, otl=otl-&gt;next );</span>
<span class="lineNum">    2436 </span><span class="lineCov">         15 :     newotl-&gt;next = otl;</span>
<span class="lineNum">    2437 </span><span class="lineCov">         15 :     if ( prev!=NULL )</span>
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :         prev-&gt;next = newotl;</span>
<span class="lineNum">    2439 </span><span class="lineCov">         15 :     else if ( isgpos )</span>
<span class="lineNum">    2440 </span><span class="lineCov">          8 :         sf-&gt;gpos_lookups = newotl;</span>
<span class="lineNum">    2441 </span>            :     else
<span class="lineNum">    2442 </span><span class="lineCov">          7 :         sf-&gt;gsub_lookups = newotl;</span>
<span class="lineNum">    2443 </span><span class="lineCov">         15 : }</span>
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            : /* Before may be:
<span class="lineNum">    2446 </span>            :     * A lookup in into_sf, in which case insert new lookup before it
<span class="lineNum">    2447 </span>            :     * NULL               , in which case insert new lookup at end
<span class="lineNum">    2448 </span>            :     * -1                 , in which case insert new lookup at start
<a name="2449"><span class="lineNum">    2449 </span>            :     * -2                 , try to guess a good position</a>
<span class="lineNum">    2450 </span>            : */
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 : static void OrderNewLookup(SplineFont *into_sf,OTLookup *otl,OTLookup *before) {</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :     int isgpos = otl-&gt;lookup_type&gt;=gpos_start;</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :     OTLookup **head = isgpos ? &amp;into_sf-&gt;gpos_lookups : &amp;into_sf-&gt;gsub_lookups;</span>
<span class="lineNum">    2454 </span>            :     OTLookup *prev;
<span class="lineNum">    2455 </span>            : 
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :     if ( before == (OTLookup *) -2 )</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :         SortInsertLookup(into_sf,otl);</span>
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :     else if ( before == (OTLookup *) -1 || *head==NULL || *head==before ) {</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :         otl-&gt;next = *head;</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :         *head = otl;</span>
<span class="lineNum">    2461 </span>            :     } else {
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :         for ( prev= *head; prev-&gt;next!=NULL &amp;&amp; prev-&gt;next!=before ; prev=prev-&gt;next );</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :         otl-&gt;next = prev-&gt;next;</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :         prev-&gt;next = otl;</span>
<span class="lineNum">    2465 </span>            :     }
<a name="2466"><span class="lineNum">    2466 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2467 </span>            : 
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 : static OTLookup *_OTLookupCopyInto(struct sfmergecontext *mc,</span>
<span class="lineNum">    2469 </span>            :         OTLookup *from_otl, OTLookup *before, int do_contents) {
<span class="lineNum">    2470 </span>            :     OTLookup *otl;
<span class="lineNum">    2471 </span>            :     struct lookup_subtable *sub, *last, *from_sub;
<span class="lineNum">    2472 </span>            :     int scnt, l;
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span><span class="lineNoCov">          0 :     for ( l=0; l&lt;mc-&gt;lcnt; ++l ) {</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :         if ( mc-&gt;lks[l].from == from_otl ) {</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :             if ( mc-&gt;lks[l].old )</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 : return( mc-&gt;lks[l].to );</span>
<span class="lineNum">    2478 </span>            :             else
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    2480 </span>            :         }
<span class="lineNum">    2481 </span>            :     }
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :     if ( l&gt;=mc-&gt;lmax )</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :         mc-&gt;lks = realloc(mc-&gt;lks,(mc-&gt;lmax += 20)*sizeof(struct lookup_cvt));</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :     mc-&gt;sf_to-&gt;changed = true;</span>
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :     if ( l&gt;=mc-&gt;lcnt ) {</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :         otl = chunkalloc(sizeof(OTLookup));</span>
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :         *otl = *from_otl;</span>
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :         memset(&amp;mc-&gt;lks[l],0,sizeof(mc-&gt;lks[l]));</span>
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :         mc-&gt;lks[l].from = from_otl; mc-&gt;lks[l].to = otl; ++mc-&gt;lcnt;</span>
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :         otl-&gt;lookup_name = strconcat(mc-&gt;prefix,from_otl-&gt;lookup_name);</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :         otl-&gt;features = FeatureListCopy(from_otl-&gt;features);</span>
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :         otl-&gt;next = NULL; otl-&gt;subtables = NULL;</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :         OrderNewLookup(mc-&gt;sf_to,otl,before);</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :         if ( !do_contents )</span>
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :             FIOTLookupCopyInto(mc-&gt;sf_to,mc-&gt;sf_from, from_otl, otl, 0, before);</span>
<span class="lineNum">    2498 </span>            :     } else
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :         otl = mc-&gt;lks[l].to;</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :     if ( !do_contents )</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 : return( otl );</span>
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :     last = NULL;</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :     scnt = 0;</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :     for ( from_sub = from_otl-&gt;subtables; from_sub!=NULL; from_sub=from_sub-&gt;next ) {</span>
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :         sub = chunkalloc(sizeof(struct lookup_subtable));</span>
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :         *sub = *from_sub;</span>
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :         sub-&gt;lookup = otl;</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :         sub-&gt;subtable_name = strconcat(mc-&gt;prefix,from_sub-&gt;subtable_name);</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :         sub-&gt;suffix = copy(sub-&gt;suffix);</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :         if ( last==NULL )</span>
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :             otl-&gt;subtables = sub;</span>
<span class="lineNum">    2513 </span>            :         else
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :             last-&gt;next = sub;</span>
<span class="lineNum">    2515 </span><span class="lineNoCov">          0 :         last = sub;</span>
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :         if ( from_sub-&gt;kc!=NULL )</span>
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :             sub-&gt;kc = SF_AddKernClass(mc, from_sub-&gt;kc, sub);</span>
<span class="lineNum">    2518 </span><span class="lineNoCov">          0 :         else if ( from_sub-&gt;fpst!=NULL )</span>
<span class="lineNum">    2519 </span><span class="lineNoCov">          0 :             sub-&gt;fpst = SF_AddFPST(mc, from_sub-&gt;fpst, sub);</span>
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :         else if ( from_sub-&gt;sm!=NULL )</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :             sub-&gt;sm = SF_AddASM(mc, from_sub-&gt;sm, sub);</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :         else if ( from_sub-&gt;anchor_classes )</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :             SF_AddAnchorClasses(mc, from_sub, sub);</span>
<span class="lineNum">    2524 </span>            :         else
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :             SF_AddPSTKern(mc, from_sub, sub);</span>
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :         ++scnt;</span>
<span class="lineNum">    2527 </span>            :     }
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :     FIOTLookupCopyInto(mc-&gt;sf_to,mc-&gt;sf_from, from_otl, otl, scnt, before);</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 : return( otl );</span>
<a name="2530"><span class="lineNum">    2530 </span>            : }</a>
<span class="lineNum">    2531 </span>            : 
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 : static int NeedsPrefix(SplineFont *into_sf,SplineFont *from_sf, OTLookup **list) {</span>
<span class="lineNum">    2533 </span>            :     struct lookup_subtable *from_sub;
<span class="lineNum">    2534 </span>            :     int i,j,k;
<span class="lineNum">    2535 </span>            :     OTLookup *sublist[2];
<span class="lineNum">    2536 </span>            : 
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :     sublist[1] = NULL;</span>
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :     if ( list==NULL || list[0]==NULL )</span>
<span class="lineNum">    2540 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :     for ( k=0; list[k]!=NULL; ++k ) {</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :         OTLookup *from_otl = list[k];</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :         if ( SFFindLookup(into_sf,from_otl-&gt;lookup_name)!=NULL )</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :         for ( from_sub = from_otl-&gt;subtables; from_sub!=NULL; from_sub=from_sub-&gt;next ) {</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :             if ( from_sub-&gt;fpst!=NULL ) {</span>
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :                 for ( i=0; i&lt;from_sub-&gt;fpst-&gt;rule_cnt; ++i ) {</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :                     struct fpst_rule *r = &amp;from_sub-&gt;fpst-&gt;rules[i];</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :                     for ( j=0; j&lt;r-&gt;lookup_cnt; ++j ) {</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :                         sublist[0] = r-&gt;lookups[j].lookup;</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :                         if ( NeedsPrefix(into_sf,from_sf, sublist))</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    2553 </span>            :                     }
<span class="lineNum">    2554 </span>            :                 }
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :             } else if ( from_sub-&gt;sm!=NULL &amp;&amp; from_sub-&gt;sm-&gt;type==asm_context ) {</span>
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :                 for ( i=0; i&lt;from_sub-&gt;sm-&gt;class_cnt*from_sub-&gt;sm-&gt;state_cnt; ++i ) {</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :                     sublist[0] = from_sub-&gt;sm-&gt;state[i].u.context.mark_lookup;</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :                     if ( NeedsPrefix(into_sf,from_sf,sublist))</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :                     sublist[0] = from_sub-&gt;sm-&gt;state[i].u.context.cur_lookup;</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :                     if ( NeedsPrefix(into_sf,from_sf,sublist))</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    2563 </span>            :                 }
<span class="lineNum">    2564 </span>            :             }
<span class="lineNum">    2565 </span>            :         }
<span class="lineNum">    2566 </span>            :     }
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 : return( false );</span>
<a name="2568"><span class="lineNum">    2568 </span>            : }</a>
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 : OTLookup *OTLookupCopyInto(SplineFont *into_sf,SplineFont *from_sf, OTLookup *from_otl) {</span>
<span class="lineNum">    2571 </span>            :     OTLookup *newotl, *list[2];
<span class="lineNum">    2572 </span>            :     struct sfmergecontext mc;
<span class="lineNum">    2573 </span>            : 
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :     memset(&amp;mc,0,sizeof(mc));</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :     mc.sf_from = from_sf; mc.sf_to = into_sf;</span>
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :     list[0] = from_otl; list[1] = NULL;</span>
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :     mc.prefix = NeedsPrefix(into_sf,from_sf,list)</span>
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :             ? strconcat(from_sf-&gt;fontname,&quot;-&quot;) : copy(&quot;&quot;);</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :     newotl = _OTLookupCopyInto(&amp;mc,from_otl,(OTLookup *) -2,true);</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :     free(mc.lks);</span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :     free(mc.prefix);</span>
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 : return( newotl );</span>
<a name="2584"><span class="lineNum">    2584 </span>            : }</a>
<span class="lineNum">    2585 </span>            : 
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 : void OTLookupsCopyInto(SplineFont *into_sf,SplineFont *from_sf,</span>
<span class="lineNum">    2587 </span>            :         OTLookup **list, OTLookup *before) {
<span class="lineNum">    2588 </span>            :     int i, do_contents;
<span class="lineNum">    2589 </span>            :     struct sfmergecontext mc;
<span class="lineNum">    2590 </span>            : 
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :     memset(&amp;mc,0,sizeof(mc));</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :     mc.sf_from = from_sf; mc.sf_to = into_sf;</span>
<span class="lineNum">    2593 </span>            : 
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :     mc.prefix = NeedsPrefix(into_sf,from_sf,list)</span>
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :             ? strconcat(from_sf-&gt;fontname,&quot;-&quot;) : copy(&quot;&quot;);</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :     for ( i=0; list[i]!=NULL; ++i );</span>
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :     mc.lks = malloc((mc.lmax=i+5)*sizeof(struct lookup_cvt));</span>
<span class="lineNum">    2598 </span>            :     /* First create all the lookups and position them in the right order */
<span class="lineNum">    2599 </span>            :     /*  then create subtables (which may in turn create some new lookups */
<span class="lineNum">    2600 </span>            :     /*  for contextual lookups which invoke other lookups, don't care how */
<span class="lineNum">    2601 </span>            :     /*  those nested lookups are ordered) */
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :     for ( do_contents=0; do_contents&lt;2; ++do_contents )</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :         for ( i=0; list[i]!=NULL; ++i )</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :             (void) _OTLookupCopyInto(&amp;mc,list[i],before,do_contents);</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :     free(mc.lks);</span>
<span class="lineNum">    2606 </span><span class="lineNoCov">          0 :     free(mc.prefix);</span>
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2608 </span>            : 
<span class="lineNum">    2609 </span>            : /* ************************************************************************** */
<span class="lineNum">    2610 </span>            : /* ****************************** Apply lookups ***************************** */
<span class="lineNum">    2611 </span>            : /* ************************************************************************** */
<span class="lineNum">    2612 </span>            : 
<span class="lineNum">    2613 </span>            : struct lookup_data {
<span class="lineNum">    2614 </span>            :     struct opentype_str *str;
<span class="lineNum">    2615 </span>            :     int cnt, max;
<span class="lineNum">    2616 </span>            : 
<span class="lineNum">    2617 </span>            :     uint32 script;
<span class="lineNum">    2618 </span>            :     SplineFont *sf;
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span>            :     struct lookup_subtable *lig_owner;
<span class="lineNum">    2621 </span>            :     int lcnt, lmax;
<span class="lineNum">    2622 </span>            :     SplineChar ***ligs;         /* For each ligature we have an array of SplineChars that are its components preceded by the ligature glyph itself */
<span class="lineNum">    2623 </span>            :                                 /*  NULL terminated */
<span class="lineNum">    2624 </span>            :     int pixelsize;
<span class="lineNum">    2625 </span>            :     double scale;
<span class="lineNum">    2626 </span>            : };
<span class="lineNum">    2627 </span>            : 
<a name="2628"><span class="lineNum">    2628 </span>            : static int ApplyLookupAtPos(uint32 tag, OTLookup *otl,struct lookup_data *data,int pos);</a>
<span class="lineNum">    2629 </span>            : 
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 : static int GlyphNameInClass(const char *name,const char *class) {</span>
<span class="lineNum">    2631 </span>            :     const char *pt;
<span class="lineNum">    2632 </span><span class="lineNoCov">          0 :     int len = strlen(name);</span>
<span class="lineNum">    2633 </span>            : 
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :     for (pt = class; pt &amp;&amp; (pt=strstr(pt,name))!=NULL; pt += len) {</span>
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 :         if ( (pt==class || pt[-1]==' ') &amp;&amp; (pt[len]=='\0' || pt[len]==' '))</span>
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    2637 </span>            :     }
<span class="lineNum">    2638 </span>            : 
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    2640 </span>            : }
<span class="lineNum">    2641 </span>            : 
<span class="lineNum">    2642 </span>            : /* ************************************************************************** */
<span class="lineNum">    2643 </span>            : /* ************************ Apply Apple State Machines ********************** */
<a name="2644"><span class="lineNum">    2644 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">    2645 </span>            : 
<span class="lineNum">    2646 </span><span class="lineNoCov">          0 : static void ApplyMacIndicRearrangement(struct lookup_data *data,int verb,</span>
<span class="lineNum">    2647 </span>            :         int first_pos,int last_pos) {
<span class="lineNum">    2648 </span>            :     struct opentype_str temp, temp2, temp3, temp4;
<span class="lineNum">    2649 </span>            :     int i;
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :     if ( first_pos==-1 || last_pos==-1 || last_pos &lt;= first_pos )</span>
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    2653 </span><span class="lineNoCov">          0 :     switch ( verb ) {</span>
<span class="lineNum">    2654 </span>            :       case 1: /* Ax =&gt; xA */
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :         for ( i= first_pos; i&lt;last_pos; ++i )</span>
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i+1];</span>
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2659 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2660 </span>            :       case 2: /* xD =&gt; Dx */
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[last_pos];</span>
<span class="lineNum">    2662 </span><span class="lineNoCov">          0 :         for ( i= last_pos; i&gt;first_pos; --i )</span>
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i-1];</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp;</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2666 </span>            :       case 3: /* AxD =&gt; DxA */
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[last_pos];</span>
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = data-&gt;str[first_pos];</span>
<span class="lineNum">    2669 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp;</span>
<span class="lineNum">    2670 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2671 </span>            :       case 4: /* ABx =&gt; xAB */
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2673 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :         for ( i= first_pos; i&lt;last_pos-1; ++i )</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i+21];</span>
<span class="lineNum">    2676 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp;</span>
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp2;</span>
<span class="lineNum">    2678 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2679 </span>            :       case 5: /* ABx =&gt; xBA */
<span class="lineNum">    2680 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2681 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :         for ( i= first_pos; i&lt;last_pos-1; ++i )</span>
<span class="lineNum">    2683 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i+21];</span>
<span class="lineNum">    2684 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp2;</span>
<span class="lineNum">    2685 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2686 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2687 </span>            :       case 6: /* xCD =&gt; CDx */
<span class="lineNum">    2688 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[last_pos];</span>
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2690 </span><span class="lineNoCov">          0 :         for ( i= last_pos; i&gt;first_pos+1; --i )</span>
<span class="lineNum">    2691 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i-2];</span>
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp;</span>
<span class="lineNum">    2693 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp2;</span>
<span class="lineNum">    2694 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2695 </span>            :       case 7: /* xCD =&gt; DCx */
<span class="lineNum">    2696 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[last_pos];</span>
<span class="lineNum">    2697 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :         for ( i= last_pos; i&gt;first_pos+1; --i )</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i-2];</span>
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp2;</span>
<span class="lineNum">    2701 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp;</span>
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2703 </span>            :       case 8: /* AxCD =&gt; CDxA */
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2706 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :         for ( i= last_pos-1; i&gt;first_pos; --i )</span>
<span class="lineNum">    2708 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i-1];</span>
<span class="lineNum">    2709 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp2;</span>
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp3;</span>
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2713 </span>            :       case 9: /* AxCD =&gt; DCxA */
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :         for ( i= last_pos-1; i&gt;first_pos; --i )</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i-1];</span>
<span class="lineNum">    2719 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp3;</span>
<span class="lineNum">    2720 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp2;</span>
<span class="lineNum">    2721 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2722 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2723 </span>            :       case 10: /* ABxD =&gt; DxAB */
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :         for ( i= first_pos+1; i&lt;last_pos; ++i )</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i+1];</span>
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp3;</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp;</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp2;</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2733 </span>            :       case 11: /* ABxD =&gt; DxBA */
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2737 </span><span class="lineNoCov">          0 :         for ( i= first_pos+1; i&lt;last_pos; ++i )</span>
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 :             data-&gt;str[i] = data-&gt;str[i+1];</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp3;</span>
<span class="lineNum">    2740 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp2;</span>
<span class="lineNum">    2741 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2742 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2743 </span>            :       case 12: /* ABxCD =&gt; CDxAB */
<span class="lineNum">    2744 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2745 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2746 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :         temp4 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2748 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp2;</span>
<span class="lineNum">    2749 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp;</span>
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp4;</span>
<span class="lineNum">    2751 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp3;</span>
<span class="lineNum">    2752 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2753 </span>            :       case 13: /* ABxCD =&gt; CDxBA */
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 :         temp4 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2758 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp2;</span>
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp4;</span>
<span class="lineNum">    2761 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp3;</span>
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2763 </span>            :       case 14: /* ABxCD =&gt; DCxAB */
<span class="lineNum">    2764 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :         temp4 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp2;</span>
<span class="lineNum">    2769 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp;</span>
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp3;</span>
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp4;</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2773 </span>            :       case 15: /* ABxCD =&gt; DCxBA */
<span class="lineNum">    2774 </span><span class="lineNoCov">          0 :         temp = data-&gt;str[first_pos];</span>
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :         temp2 = data-&gt;str[first_pos+1];</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :         temp3 = data-&gt;str[last_pos-1];</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :         temp4 = data-&gt;str[last_pos];</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos] = temp;</span>
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :         data-&gt;str[last_pos-1] = temp2;</span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos+1] = temp3;</span>
<span class="lineNum">    2781 </span><span class="lineNoCov">          0 :         data-&gt;str[first_pos] = temp4;</span>
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2783 </span>            :       default:
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2785 </span>            :     }
<a name="2786"><span class="lineNum">    2786 </span>            : }</a>
<span class="lineNum">    2787 </span>            : 
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 : static int ApplyMacInsert(struct lookup_data *data,int ipos,int cnt,</span>
<span class="lineNum">    2789 </span>            :         char *glyphnames, int orig_index) {
<span class="lineNum">    2790 </span>            :     SplineChar *inserts[32];
<span class="lineNum">    2791 </span>            :     char *start, *pt;
<span class="lineNum">    2792 </span>            :     int i, ch;
<span class="lineNum">    2793 </span>            : 
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 :     if ( cnt==0 || glyphnames==NULL || ipos == -1 )</span>
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2796 </span>            : 
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :     for ( i=0, start = glyphnames; i&lt;cnt; ) {</span>
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :         while ( *start==' ' ) ++start;</span>
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :         if ( *start=='\0' )</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :         for ( pt = start; *pt!=' ' &amp;&amp; *pt!='\0'; ++pt );</span>
<span class="lineNum">    2802 </span><span class="lineNoCov">          0 :         ch = *pt; *pt = '\0';</span>
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :         inserts[i] = SFGetChar(data-&gt;sf,-1,start);</span>
<span class="lineNum">    2804 </span><span class="lineNoCov">          0 :         *pt = ch;</span>
<span class="lineNum">    2805 </span><span class="lineNoCov">          0 :         if ( inserts[i]!=NULL )</span>
<span class="lineNum">    2806 </span><span class="lineNoCov">          0 :             ++i;</span>
<span class="lineNum">    2807 </span>            :     }
<span class="lineNum">    2808 </span><span class="lineNoCov">          0 :     cnt = i;</span>
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :     if ( i==0 )</span>
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :     for ( i= data-&gt;cnt; i&gt;=ipos; --i )</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :         data-&gt;str[i+cnt] = data-&gt;str[i];</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :     memset(data-&gt;str+ipos,0,cnt*sizeof(struct opentype_str));</span>
<span class="lineNum">    2814 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    2815 </span><span class="lineNoCov">          0 :         data-&gt;str[ipos+i].sc = inserts[i];</span>
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :         data-&gt;str[ipos+i].orig_index = orig_index;</span>
<span class="lineNum">    2817 </span>            :     }
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 : return( cnt );</span>
<a name="2819"><span class="lineNum">    2819 </span>            : }</a>
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 : static void ApplyAppleStateMachine(OTLookup *otl,struct lookup_data *data) {</span>
<span class="lineNum">    2822 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    2823 </span>            :     int state, class, pos, mark_pos, markend_pos, i;
<span class="lineNum">    2824 </span>            :     ASM *sm;
<span class="lineNum">    2825 </span>            :     int cnt_cur, cnt_mark;
<span class="lineNum">    2826 </span>            :     struct asm_state *entry;
<span class="lineNum">    2827 </span>            :     int kern_stack[8], kcnt;            /* Kerning state machines handle at most 8 glyphs */
<span class="lineNum">    2828 </span>            :     /* Flaws: Line processing has not been done yet, so we are never in the */
<span class="lineNum">    2829 </span>            :     /*  start of line state and we never get an end of line token. We never */
<span class="lineNum">    2830 </span>            :     /*  get deleted tokens either, those glyphs are just gone */
<span class="lineNum">    2831 </span>            :     /* Class 0: End of text */
<span class="lineNum">    2832 </span>            :     /* Class 1: Glyph not in any classes */
<span class="lineNum">    2833 </span>            :     /* Class 2: Deleted (we never see) */
<span class="lineNum">    2834 </span>            :     /* Class 3: End of line (we never see) */
<span class="lineNum">    2835 </span>            : 
<span class="lineNum">    2836 </span>            :     /* Mac doesn't have the concept of subtables, but a user could create one */
<span class="lineNum">    2837 </span>            :     /*  it will get flattened out into its own &quot;lookup&quot; when written to a file*/
<span class="lineNum">    2838 </span>            :     /*  So if there are multiple subtables, just process them all */
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :     for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :         sm = sub-&gt;sm;</span>
<span class="lineNum">    2841 </span>            : 
<span class="lineNum">    2842 </span><span class="lineNoCov">          0 :         state = 0;</span>
<span class="lineNum">    2843 </span><span class="lineNoCov">          0 :         mark_pos = markend_pos = -1;</span>
<span class="lineNum">    2844 </span><span class="lineNoCov">          0 :         for ( pos = 0; pos&lt;=data-&gt;cnt; ) {</span>
<span class="lineNum">    2845 </span><span class="lineNoCov">          0 :             if ( pos==data-&gt;cnt )</span>
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 :                 class = 0;</span>
<span class="lineNum">    2847 </span>            :             else {
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 :                 for ( class = sm-&gt;class_cnt-1; class&gt;3; --class )</span>
<span class="lineNum">    2849 </span><span class="lineNoCov">          0 :                     if ( GlyphNameInClass(data-&gt;str[i].sc-&gt;name,sm-&gt;classes[class]) )</span>
<span class="lineNum">    2850 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 :                 if ( class==3 )</span>
<span class="lineNum">    2852 </span><span class="lineNoCov">          0 :                     class = 1;          /* Glyph not in any class */;</span>
<span class="lineNum">    2853 </span>            :             }
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :             entry = &amp;sm-&gt;state[state*sm-&gt;class_cnt+class];</span>
<span class="lineNum">    2855 </span><span class="lineNoCov">          0 :             switch ( otl-&gt;lookup_type ) {</span>
<span class="lineNum">    2856 </span>            :               case morx_context:
<span class="lineNum">    2857 </span><span class="lineNoCov">          0 :                 if ( entry-&gt;u.context.cur_lookup!=NULL )</span>
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :                     ApplyLookupAtPos(0,entry-&gt;u.context.cur_lookup,data,pos);</span>
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 :                 if ( entry-&gt;u.context.mark_lookup!=NULL &amp;&amp; mark_pos!=-1 ) {</span>
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :                     ApplyLookupAtPos(0,entry-&gt;u.context.mark_lookup,data,mark_pos);</span>
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :                     mark_pos = -1;</span>
<span class="lineNum">    2862 </span>            :                 }
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2864 </span>            :               case morx_indic:
<span class="lineNum">    2865 </span><span class="lineNoCov">          0 :                 if ( entry-&gt;flags &amp; 0x2000 )</span>
<span class="lineNum">    2866 </span><span class="lineNoCov">          0 :                     markend_pos = pos;</span>
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :                 if ( (entry-&gt;flags&amp;0xf)!=0 ) {</span>
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :                     ApplyMacIndicRearrangement(data,entry-&gt;flags&amp;0xf,mark_pos,markend_pos);</span>
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :                     mark_pos = markend_pos = -1;</span>
<span class="lineNum">    2870 </span>            :                 }
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2872 </span>            :               case morx_insert:
<span class="lineNum">    2873 </span>            :                 /* I live in total ignorance of what I should do if the glyph */
<span class="lineNum">    2874 </span>            :                 /*  &quot;is Kashida like&quot;... so I ignore those flags. */
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :                 cnt_cur = (entry-&gt;flags&gt;&gt;5)&amp;0x1f;</span>
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :                 cnt_mark = (entry-&gt;flags&amp;0x1f);</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :                 if ( data-&gt;cnt + cnt_cur + cnt_mark &gt;= data-&gt;max )</span>
<span class="lineNum">    2878 </span><span class="lineNoCov">          0 :                     data-&gt;str = realloc(data-&gt;str,(data-&gt;max = data-&gt;cnt + cnt_cur + cnt_mark +20)*sizeof(struct opentype_str));</span>
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :                 if ( cnt_cur!=0 )</span>
<span class="lineNum">    2880 </span><span class="lineNoCov">          0 :                     cnt_cur = ApplyMacInsert(data,(entry-&gt;flags&amp; 0x0800)? pos : pos+1,</span>
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :                             cnt_cur,entry-&gt;u.insert.cur_ins,data-&gt;str[pos].orig_index);</span>
<span class="lineNum">    2882 </span><span class="lineNoCov">          0 :                 if ( cnt_mark!=0 &amp;&amp; mark_pos!=-1 ) {</span>
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 :                     cnt_mark = ApplyMacInsert(data,(entry-&gt;flags&amp; 0x0800)? mark_pos : mark_pos+1,</span>
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :                             cnt_mark,entry-&gt;u.insert.mark_ins,data-&gt;str[mark_pos].orig_index);</span>
<span class="lineNum">    2885 </span><span class="lineNoCov">          0 :                     mark_pos = -1;</span>
<span class="lineNum">    2886 </span>            :                 } else
<span class="lineNum">    2887 </span><span class="lineNoCov">          0 :                     cnt_mark = 0;</span>
<span class="lineNum">    2888 </span><span class="lineNoCov">          0 :                 pos += cnt_cur+cnt_mark;</span>
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2890 </span>            :               case kern_statemachine:
<span class="lineNum">    2891 </span><span class="lineNoCov">          0 :                 if ( entry-&gt;u.kern.kcnt!=0 ) {</span>
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :                     for ( i=0; i&lt;kcnt &amp;&amp; i&lt;entry-&gt;u.kern.kcnt; ++i )</span>
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :                         data-&gt;str[kern_stack[i]].vr.h_adv_off +=</span>
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 :                                 entry-&gt;u.kern.kerns[i];</span>
<span class="lineNum">    2895 </span><span class="lineNoCov">          0 :                     kcnt = 0;</span>
<span class="lineNum">    2896 </span>            :                 }
<span class="lineNum">    2897 </span><span class="lineNoCov">          0 :                 if ( entry-&gt;flags &amp; 0x8000 ) {</span>
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :                     for ( i=6; i&gt;=0; --i )</span>
<span class="lineNum">    2899 </span><span class="lineNoCov">          0 :                         kern_stack[i+1] = kern_stack[i];</span>
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :                     kern_stack[0] = pos;</span>
<span class="lineNum">    2901 </span><span class="lineNoCov">          0 :                     if ( ++kcnt&gt;8 ) kcnt = 8;</span>
<span class="lineNum">    2902 </span>            :                 }
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2904 </span>            :               default:
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    2906 </span>            :             }
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :             if ( entry-&gt;flags &amp; 0x8000 )</span>
<span class="lineNum">    2908 </span><span class="lineNoCov">          0 :                 mark_pos = pos;         /* The docs do not state whether this happens before or after substitutions are applied at the mark */</span>
<span class="lineNum">    2909 </span>            :                                         /* after is more useful. So assume that */
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 :             if ( !(entry-&gt;flags &amp; 0x4000) )</span>
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :                 ++pos;</span>
<span class="lineNum">    2912 </span><span class="lineNoCov">          0 :             state = entry-&gt;next_state;</span>
<span class="lineNum">    2913 </span>            :         }
<span class="lineNum">    2914 </span>            :     }
<span class="lineNum">    2915 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2916 </span>            : 
<span class="lineNum">    2917 </span>            : /* ************************************************************************** */
<span class="lineNum">    2918 </span>            : /* ************************* Apply OpenType Lookups ************************* */
<a name="2919"><span class="lineNum">    2919 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">    2920 </span>            : 
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 : static void LigatureFree(struct lookup_data *data) {</span>
<span class="lineNum">    2922 </span>            :     int i;
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span><span class="lineNoCov">          0 :     if ( data-&gt;ligs==NULL )</span>
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :     for ( i=0; data-&gt;ligs[i]!=NULL; ++i )</span>
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 :         free(data-&gt;ligs[i]);</span>
<a name="2928"><span class="lineNum">    2928 </span>            : }</a>
<span class="lineNum">    2929 </span>            : 
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 : static void LigatureSearch(struct lookup_subtable *sub, struct lookup_data *data) {</span>
<span class="lineNum">    2931 </span><span class="lineNoCov">          0 :     SplineFont *sf = data-&gt;sf;</span>
<span class="lineNum">    2932 </span>            :     int gid, ccnt, cnt, ch, err;
<span class="lineNum">    2933 </span>            :     SplineChar *sc;
<span class="lineNum">    2934 </span>            :     PST *pst;
<span class="lineNum">    2935 </span>            :     char *pt, *start;
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :     LigatureFree(data);</span>
<span class="lineNum">    2938 </span><span class="lineNoCov">          0 :     cnt = 0;</span>
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :     for ( gid=0; gid&lt;sf-&gt;glyphcnt; ++gid ) if ( (sc=sf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :         for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) if ( pst-&gt;subtable==sub ) {</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :             for ( pt = pst-&gt;u.lig.components, ccnt=0; *pt; ++pt )</span>
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :                 if ( *pt==' ' )</span>
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :                     ++ccnt;</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :             if ( cnt&gt;=data-&gt;lmax )</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :                 data-&gt;ligs = realloc(data-&gt;ligs,(data-&gt;lmax+=100)*sizeof(SplineChar **));</span>
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :             data-&gt;ligs[cnt] = malloc((ccnt+3)*sizeof(SplineChar *));</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :             data-&gt;ligs[cnt][0] = sc;</span>
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :             ccnt = 1;</span>
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :             err = 0;</span>
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :             for ( pt = pst-&gt;u.lig.components; *pt; ) {</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :                 while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :                 if ( *pt=='\0' )</span>
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2954 </span><span class="lineNoCov">          0 :                 for ( start=pt; *pt!='\0' &amp;&amp; *pt!=' '; ++pt );</span>
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :                 ch = *pt; *pt = '\0';</span>
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :                 data-&gt;ligs[cnt][ccnt++] = SFGetChar(sf,-1,start);</span>
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :                 *pt = ch;</span>
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :                 if ( data-&gt;ligs[cnt][ccnt-1]==NULL )</span>
<span class="lineNum">    2959 </span><span class="lineNoCov">          0 :                     err = 1;</span>
<span class="lineNum">    2960 </span>            :             }
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :             if ( !err )</span>
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :                 data-&gt;ligs[cnt++][ccnt] = NULL;</span>
<span class="lineNum">    2963 </span>            :         }
<span class="lineNum">    2964 </span>            :     }
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :     if ( cnt&gt;=data-&gt;lmax )</span>
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :         data-&gt;ligs = realloc(data-&gt;ligs,(data-&gt;lmax+=1)*sizeof(SplineChar **));</span>
<span class="lineNum">    2967 </span><span class="lineNoCov">          0 :     data-&gt;ligs[cnt] = NULL;</span>
<span class="lineNum">    2968 </span><span class="lineNoCov">          0 :     data-&gt;lcnt = cnt;</span>
<a name="2969"><span class="lineNum">    2969 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span><span class="lineNoCov">          0 : static int skipglyphs(int lookup_flags, struct lookup_data *data, int pos) {</span>
<span class="lineNum">    2972 </span>            :     int mc, glyph_class, ms;
<span class="lineNum">    2973 </span>            :     /* The lookup flags tell us what glyphs to ignore. Skip over anything we */
<span class="lineNum">    2974 </span>            :     /*  should ignore */
<span class="lineNum">    2975 </span>            : 
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :     if ( lookup_flags==0 )</span>
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 : return( pos );</span>
<span class="lineNum">    2978 </span><span class="lineNoCov">          0 :     mc = (lookup_flags&gt;&gt;8);</span>
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :     if ( mc&lt;0 || mc&gt;=data-&gt;sf-&gt;mark_class_cnt )</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :         mc = 0;</span>
<span class="lineNum">    2981 </span><span class="lineNoCov">          0 :     ms = lookup_flags&gt;&gt;16;</span>
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :     if ( !(lookup_flags&amp;pst_usemarkfilteringset) || ms&gt;=data-&gt;sf-&gt;mark_set_cnt )</span>
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :         ms = -1;</span>
<span class="lineNum">    2984 </span><span class="lineNoCov">          0 :     while ( pos&lt;data-&gt;cnt ) {</span>
<span class="lineNum">    2985 </span><span class="lineNoCov">          0 :         glyph_class = gdefclass(data-&gt;str[pos].sc);</span>
<span class="lineNum">    2986 </span>            :         /* 1=&gt;base, 2=&gt;ligature, 3=&gt;mark, 4=&gt;component?, 0=&gt;.notdef */
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :         if ( (glyph_class==1 &amp;&amp; (lookup_flags&amp;pst_ignorebaseglyphs)) ||</span>
<span class="lineNum">    2988 </span><span class="lineNoCov">          0 :                 (glyph_class==2 &amp;&amp; (lookup_flags&amp;pst_ignoreligatures)) ||</span>
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :                 (glyph_class==3 &amp;&amp; (lookup_flags&amp;pst_ignorecombiningmarks)) ||</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :                 (glyph_class==3 &amp;&amp; mc!=0 &amp;&amp;</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :                         !GlyphNameInClass(data-&gt;str[pos].sc-&gt;name,data-&gt;sf-&gt;mark_classes[mc])) ||</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :                 (ms&gt;=0 &amp;&amp;</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :                         !GlyphNameInClass(data-&gt;str[pos].sc-&gt;name,data-&gt;sf-&gt;mark_sets[ms])) ) {</span>
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :             ++pos;</span>
<span class="lineNum">    2995 </span>            :         } else
<span class="lineNum">    2996 </span>            :     break;
<span class="lineNum">    2997 </span>            :     }
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 : return( pos );</span>
<a name="2999"><span class="lineNum">    2999 </span>            : }</a>
<span class="lineNum">    3000 </span>            : 
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 : static int bskipmarkglyphs(int lookup_flags, struct lookup_data *data, int pos) {</span>
<span class="lineNum">    3002 </span>            :     int mc, glyph_class, ms;
<span class="lineNum">    3003 </span>            :     /* The lookup flags tell us what glyphs to ignore. Skip over anything we */
<span class="lineNum">    3004 </span>            :     /*  should ignore. Here we skip backward */
<span class="lineNum">    3005 </span>            : 
<span class="lineNum">    3006 </span><span class="lineNoCov">          0 :     mc = (lookup_flags&gt;&gt;8);</span>
<span class="lineNum">    3007 </span><span class="lineNoCov">          0 :     if ( mc&lt;0 || mc&gt;=data-&gt;sf-&gt;mark_class_cnt )</span>
<span class="lineNum">    3008 </span><span class="lineNoCov">          0 :         mc = 0;</span>
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :     ms = lookup_flags&gt;&gt;16;</span>
<span class="lineNum">    3010 </span><span class="lineNoCov">          0 :     if ( !(lookup_flags&amp;pst_usemarkfilteringset) || ms&gt;=data-&gt;sf-&gt;mark_set_cnt )</span>
<span class="lineNum">    3011 </span><span class="lineNoCov">          0 :         ms = -1;</span>
<span class="lineNum">    3012 </span><span class="lineNoCov">          0 :     while ( pos&gt;=0 ) {</span>
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :         glyph_class = gdefclass(data-&gt;str[pos].sc);</span>
<span class="lineNum">    3014 </span>            :         /* 1=&gt;base, 2=&gt;ligature, 3=&gt;mark, 4=&gt;component?, 0=&gt;.notdef */
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :         if ( glyph_class==3 )</span>
<span class="lineNum">    3016 </span><span class="lineNoCov">          0 :             --pos;</span>
<span class="lineNum">    3017 </span><span class="lineNoCov">          0 :         else if ( (glyph_class==1 &amp;&amp; (lookup_flags&amp;pst_ignorebaseglyphs)) ||</span>
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 :                 (glyph_class==2 &amp;&amp; (lookup_flags&amp;pst_ignoreligatures)) ||</span>
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :                 (glyph_class==3 &amp;&amp; (lookup_flags&amp;pst_ignorecombiningmarks)) ||</span>
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :                 (glyph_class==3 &amp;&amp; mc!=0 &amp;&amp;</span>
<span class="lineNum">    3021 </span><span class="lineNoCov">          0 :                         !GlyphNameInClass(data-&gt;str[pos].sc-&gt;name,data-&gt;sf-&gt;mark_classes[mc])) ||</span>
<span class="lineNum">    3022 </span><span class="lineNoCov">          0 :                 (ms&gt;=0 &amp;&amp;</span>
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :                         !GlyphNameInClass(data-&gt;str[pos].sc-&gt;name,data-&gt;sf-&gt;mark_sets[ms])) ) {</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :             --pos;</span>
<span class="lineNum">    3025 </span>            :         } else
<span class="lineNum">    3026 </span>            :     break;
<span class="lineNum">    3027 </span>            :     }
<span class="lineNum">    3028 </span><span class="lineNoCov">          0 : return( pos );</span>
<a name="3029"><span class="lineNum">    3029 </span>            : }</a>
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span><span class="lineNoCov">          0 : static int bskipglyphs(int lookup_flags, struct lookup_data *data, int pos) {</span>
<span class="lineNum">    3032 </span>            :     int mc, glyph_class, ms;
<span class="lineNum">    3033 </span>            :     /* The lookup flags tell us what glyphs to ignore. Skip over anything we */
<span class="lineNum">    3034 </span>            :     /*  should ignore. Here we skip backward */
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineNoCov">          0 :     if ( lookup_flags==0 )</span>
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 : return( pos );</span>
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :     mc = (lookup_flags&gt;&gt;8);</span>
<span class="lineNum">    3039 </span><span class="lineNoCov">          0 :     if ( mc&lt;0 || mc&gt;=data-&gt;sf-&gt;mark_class_cnt )</span>
<span class="lineNum">    3040 </span><span class="lineNoCov">          0 :         mc = 0;</span>
<span class="lineNum">    3041 </span><span class="lineNoCov">          0 :     ms = lookup_flags&gt;&gt;16;</span>
<span class="lineNum">    3042 </span><span class="lineNoCov">          0 :     if ( !(lookup_flags&amp;pst_usemarkfilteringset) || ms&gt;=data-&gt;sf-&gt;mark_set_cnt )</span>
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :         ms = -1;</span>
<span class="lineNum">    3044 </span><span class="lineNoCov">          0 :     while ( pos&gt;=0 ) {</span>
<span class="lineNum">    3045 </span><span class="lineNoCov">          0 :         glyph_class = gdefclass(data-&gt;str[pos].sc);</span>
<span class="lineNum">    3046 </span>            :         /* 1=&gt;base, 2=&gt;ligature, 3=&gt;mark, 4=&gt;component?, 0=&gt;.notdef */
<span class="lineNum">    3047 </span><span class="lineNoCov">          0 :         if ( (glyph_class==1 &amp;&amp; (lookup_flags&amp;pst_ignorebaseglyphs)) ||</span>
<span class="lineNum">    3048 </span><span class="lineNoCov">          0 :                 (glyph_class==2 &amp;&amp; (lookup_flags&amp;pst_ignoreligatures)) ||</span>
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :                 (glyph_class==3 &amp;&amp; (lookup_flags&amp;pst_ignorecombiningmarks)) ||</span>
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :                 (glyph_class==3 &amp;&amp; mc!=0 &amp;&amp;</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :                         !GlyphNameInClass(data-&gt;str[pos].sc-&gt;name,data-&gt;sf-&gt;mark_classes[mc])) ||</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :                 (ms&gt;=0 &amp;&amp;</span>
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :                         !GlyphNameInClass(data-&gt;str[pos].sc-&gt;name,data-&gt;sf-&gt;mark_sets[ms])) ) {</span>
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :             --pos;</span>
<span class="lineNum">    3055 </span>            :         } else
<span class="lineNum">    3056 </span>            :     break;
<span class="lineNum">    3057 </span>            :     }
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 : return( pos );</span>
<a name="3059"><span class="lineNum">    3059 </span>            : }</a>
<span class="lineNum">    3060 </span>            : 
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 : static int ContextualMatch(struct lookup_subtable *sub,struct lookup_data *data,</span>
<span class="lineNum">    3062 </span>            :         int pos, struct fpst_rule **_rule) {
<span class="lineNum">    3063 </span>            :     int i, cpos, retpos, r;
<span class="lineNum">    3064 </span><span class="lineNoCov">          0 :     FPST *fpst = sub-&gt;fpst;</span>
<span class="lineNum">    3065 </span><span class="lineNoCov">          0 :     int lookup_flags = sub-&gt;lookup-&gt;lookup_flags;</span>
<span class="lineNum">    3066 </span>            :     const char *pt;
<span class="lineNum">    3067 </span>            : 
<span class="lineNum">    3068 </span>            :     /* If we should skip the current glyph then don't try for a match here */
<span class="lineNum">    3069 </span><span class="lineNoCov">          0 :     cpos = skipglyphs(lookup_flags,data,pos);</span>
<span class="lineNum">    3070 </span><span class="lineNoCov">          0 :     if ( cpos!=pos )</span>
<span class="lineNum">    3071 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span><span class="lineNoCov">          0 :     for ( r=0; r&lt;fpst-&gt;rule_cnt; ++r ) {</span>
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :         struct fpst_rule *rule = &amp;fpst-&gt;rules[r];</span>
<span class="lineNum">    3075 </span><span class="lineNoCov">          0 :         for ( i=pos; i&lt;data-&gt;cnt; ++i )</span>
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :             data-&gt;str[i].context_pos = -1;</span>
<span class="lineNum">    3077 </span>            : 
<span class="lineNum">    3078 </span>            : /* Handle backtrack (backtrace in the rule is stored in reverse textual order) */
<span class="lineNum">    3079 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type == pst_chainpos || fpst-&gt;type == pst_chainsub ) {</span>
<span class="lineNum">    3080 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format==pst_glyphs ) {</span>
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :                 pt = rule-&gt;u.glyph.back;</span>
<span class="lineNum">    3082 </span><span class="lineNoCov">          0 :                 for ( i=bskipglyphs(lookup_flags,data,pos-1), cpos=0; i&gt;=0; i = bskipglyphs(lookup_flags,data,i-1)) {</span>
<span class="lineNum">    3083 </span><span class="lineNoCov">          0 :                     const char *name = data-&gt;str[i].sc-&gt;name;</span>
<span class="lineNum">    3084 </span><span class="lineNoCov">          0 :                     int len = strlen( name );</span>
<span class="lineNum">    3085 </span><span class="lineNoCov">          0 :                     if ( strncmp(name,pt,len)!=0 || (pt[len]!='\0' &amp;&amp; pt[len]!=' '))</span>
<span class="lineNum">    3086 </span>            :                 break;
<span class="lineNum">    3087 </span><span class="lineNoCov">          0 :                     pt += len;</span>
<span class="lineNum">    3088 </span><span class="lineNoCov">          0 :                     while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    3089 </span>            :                 }
<span class="lineNum">    3090 </span><span class="lineNoCov">          0 :                 if ( *pt!='\0' )</span>
<span class="lineNum">    3091 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 :             } else if ( fpst-&gt;format==pst_class ) {</span>
<span class="lineNum">    3093 </span><span class="lineNoCov">          0 :                 for ( i=bskipglyphs(lookup_flags,data,pos-1), cpos=0; i&gt;=0 &amp;&amp; cpos&lt;rule-&gt;u.class.bcnt; i = bskipglyphs(lookup_flags,data,i-1)) {</span>
<span class="lineNum">    3094 </span><span class="lineNoCov">          0 :                     if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,fpst-&gt;bclass[rule-&gt;u.class.bclasses[cpos]]) )</span>
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3096 </span><span class="lineNoCov">          0 :                     ++cpos;</span>
<span class="lineNum">    3097 </span>            :                 }
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :                 if ( cpos!=rule-&gt;u.class.bcnt )</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3100 </span><span class="lineNoCov">          0 :             } else if ( fpst-&gt;format==pst_coverage ) {</span>
<span class="lineNum">    3101 </span><span class="lineNoCov">          0 :                 for ( i=bskipglyphs(lookup_flags,data,pos-1), cpos=0; i&gt;=0 &amp;&amp; cpos&lt;rule-&gt;u.coverage.bcnt; i = bskipglyphs(lookup_flags,data,i-1)) {</span>
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :                     if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,rule-&gt;u.coverage.bcovers[cpos]) )</span>
<span class="lineNum">    3103 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3104 </span><span class="lineNoCov">          0 :                     ++cpos;</span>
<span class="lineNum">    3105 </span>            :                 }
<span class="lineNum">    3106 </span><span class="lineNoCov">          0 :                 if ( cpos&lt;rule-&gt;u.coverage.bcnt )</span>
<span class="lineNum">    3107 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3108 </span>            :             }
<span class="lineNum">    3109 </span>            :         }
<span class="lineNum">    3110 </span>            : /* Handle Match */
<span class="lineNum">    3111 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;format==pst_glyphs ) {</span>
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :             pt = rule-&gt;u.glyph.names;</span>
<span class="lineNum">    3113 </span><span class="lineNoCov">          0 :             for ( i=pos, cpos=0; i&lt;data-&gt;cnt &amp;&amp; *pt!='\0'; i = skipglyphs(lookup_flags,data,i+1)) {</span>
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :                 const char *name = data-&gt;str[i].sc-&gt;name;</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :                 int len = strlen( name );</span>
<span class="lineNum">    3116 </span><span class="lineNoCov">          0 :                 if ( strncmp(name,pt,len)!=0 || (pt[len]!='\0' &amp;&amp; pt[len]!=' '))</span>
<span class="lineNum">    3117 </span>            :             break;
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :                 data-&gt;str[i].context_pos = cpos++;</span>
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :                 pt += len;</span>
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :                 while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    3121 </span>            :             }
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :             if ( *pt!='\0' )</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :         } else if ( fpst-&gt;format==pst_class ) {</span>
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :             for ( i=pos, cpos=0; i&lt;data-&gt;cnt &amp;&amp; cpos&lt;rule-&gt;u.class.ncnt; i = skipglyphs(lookup_flags,data,i+1)) {</span>
<span class="lineNum">    3126 </span><span class="lineNoCov">          0 :                 int class = rule-&gt;u.class.nclasses[cpos];</span>
<span class="lineNum">    3127 </span><span class="lineNoCov">          0 :                 if ( class!=0 ) {</span>
<span class="lineNum">    3128 </span><span class="lineNoCov">          0 :                     if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,fpst-&gt;nclass[class]) )</span>
<span class="lineNum">    3129 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3130 </span>            :                 } else {
<span class="lineNum">    3131 </span>            :                     int c;
<span class="lineNum">    3132 </span>            :                     /* Ok, to match class 0 we must fail to match all other classes */
<span class="lineNum">    3133 </span><span class="lineNoCov">          0 :                     for ( c=1; c&lt;fpst-&gt;nccnt; ++c )</span>
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :                         if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,fpst-&gt;nclass[c]) )</span>
<span class="lineNum">    3135 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :                     if ( c!=fpst-&gt;nccnt )</span>
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :             break;              /* It matched another class =&gt; not in class 0 */</span>
<span class="lineNum">    3138 </span>            :                 }
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :                 data-&gt;str[i].context_pos = cpos++;</span>
<span class="lineNum">    3140 </span>            :             }
<span class="lineNum">    3141 </span><span class="lineNoCov">          0 :             if ( cpos&lt;rule-&gt;u.class.ncnt )</span>
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3143 </span><span class="lineNoCov">          0 :         } else if ( fpst-&gt;format==pst_coverage ) {</span>
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 :             for ( i=pos, cpos=0; i&lt;data-&gt;cnt &amp;&amp; cpos&lt;rule-&gt;u.coverage.ncnt; i = skipglyphs(lookup_flags,data,i+1)) {</span>
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :                 if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,rule-&gt;u.coverage.ncovers[cpos]) )</span>
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 :                 data-&gt;str[i].context_pos = cpos++;</span>
<span class="lineNum">    3148 </span>            :             }
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :             if ( cpos&lt;rule-&gt;u.coverage.ncnt )</span>
<span class="lineNum">    3150 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3151 </span>            :         } else
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 : return( 0 );            /* Not ready to deal with reverse chainging */</span>
<span class="lineNum">    3153 </span>            : 
<span class="lineNum">    3154 </span><span class="lineNoCov">          0 :         retpos = i;</span>
<span class="lineNum">    3155 </span>            : /* Handle lookahead */
<span class="lineNum">    3156 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type == pst_chainpos || fpst-&gt;type == pst_chainsub ) {</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format==pst_glyphs ) {</span>
<span class="lineNum">    3158 </span><span class="lineNoCov">          0 :                 pt = rule-&gt;u.glyph.fore;</span>
<span class="lineNum">    3159 </span><span class="lineNoCov">          0 :                 for ( i=retpos; i&lt;data-&gt;cnt &amp;&amp; *pt!='\0'; i = skipglyphs(lookup_flags,data,i+1)) {</span>
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :                     const char *name = data-&gt;str[i].sc-&gt;name;</span>
<span class="lineNum">    3161 </span><span class="lineNoCov">          0 :                     int len = strlen( name );</span>
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :                     if ( strncmp(name,pt,len)!=0 || (pt[len]!='\0' &amp;&amp; pt[len]!=' '))</span>
<span class="lineNum">    3163 </span>            :                 break;
<span class="lineNum">    3164 </span><span class="lineNoCov">          0 :                     pt += len;</span>
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :                     while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    3166 </span>            :                 }
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :                 if ( *pt!='\0' )</span>
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :             } else if ( fpst-&gt;format==pst_class ) {</span>
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :                 for ( i=retpos, cpos=0; i&lt;data-&gt;cnt &amp;&amp; cpos&lt;rule-&gt;u.class.fcnt; i = skipglyphs(lookup_flags,data,i+1)) {</span>
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 :                     if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,fpst-&gt;fclass[rule-&gt;u.class.fclasses[cpos]]) )</span>
<span class="lineNum">    3172 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :                     cpos++;</span>
<span class="lineNum">    3174 </span>            :                 }
<span class="lineNum">    3175 </span><span class="lineNoCov">          0 :                 if ( cpos&lt;rule-&gt;u.class.fcnt )</span>
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3177 </span><span class="lineNoCov">          0 :             } else if ( fpst-&gt;format==pst_coverage ) {</span>
<span class="lineNum">    3178 </span><span class="lineNoCov">          0 :                 for ( i=retpos, cpos=0; i&lt;data-&gt;cnt &amp;&amp; cpos&lt;rule-&gt;u.coverage.fcnt; i = skipglyphs(lookup_flags,data,i+1)) {</span>
<span class="lineNum">    3179 </span><span class="lineNoCov">          0 :                     if ( !GlyphNameInClass(data-&gt;str[i].sc-&gt;name,rule-&gt;u.coverage.fcovers[cpos]) )</span>
<span class="lineNum">    3180 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    3181 </span><span class="lineNoCov">          0 :                     cpos++;</span>
<span class="lineNum">    3182 </span>            :                 }
<span class="lineNum">    3183 </span><span class="lineNoCov">          0 :                 if ( cpos&lt;rule-&gt;u.coverage.fcnt )</span>
<span class="lineNum">    3184 </span><span class="lineNoCov">          0 :     continue;           /* didn't match */</span>
<span class="lineNum">    3185 </span>            :             }
<span class="lineNum">    3186 </span>            :         }
<span class="lineNum">    3187 </span><span class="lineNoCov">          0 :         *_rule = rule;</span>
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 : return( retpos );</span>
<span class="lineNum">    3189 </span>            :     }
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="3191"><span class="lineNum">    3191 </span>            : }</a>
<span class="lineNum">    3192 </span>            : 
<span class="lineNum">    3193 </span><span class="lineNoCov">          0 : static int ApplySingleSubsAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3194 </span>            :     PST *pst;
<span class="lineNum">    3195 </span>            :     SplineChar *sc;
<span class="lineNum">    3196 </span>            : 
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 :     for ( pst=data-&gt;str[pos].sc-&gt;possub; pst!=NULL &amp;&amp; pst-&gt;subtable!=sub; pst=pst-&gt;next );</span>
<span class="lineNum">    3198 </span><span class="lineNoCov">          0 :     if ( pst==NULL )</span>
<span class="lineNum">    3199 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3200 </span>            : 
<span class="lineNum">    3201 </span><span class="lineNoCov">          0 :     sc = SFGetChar(data-&gt;sf,-1,pst-&gt;u.subs.variant);</span>
<span class="lineNum">    3202 </span><span class="lineNoCov">          0 :     if ( sc!=NULL ) {</span>
<span class="lineNum">    3203 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].sc = sc;</span>
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :     } else if ( strcmp(pst-&gt;u.subs.variant,MAC_DELETED_GLYPH_NAME)==0 ) {</span>
<span class="lineNum">    3206 </span>            :         /* Under AAT we delete the glyph. But OpenType doesn't have that concept */
<span class="lineNum">    3207 </span>            :         int i;
<span class="lineNum">    3208 </span><span class="lineNoCov">          0 :         for ( i=pos+1; i&lt;data-&gt;cnt; ++i )</span>
<span class="lineNum">    3209 </span><span class="lineNoCov">          0 :             data-&gt;str[pos-1] = data-&gt;str[pos];</span>
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 :         --data-&gt;cnt;</span>
<span class="lineNum">    3211 </span><span class="lineNoCov">          0 : return( pos );</span>
<span class="lineNum">    3212 </span>            :     } else {
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3214 </span>            :     }
<a name="3215"><span class="lineNum">    3215 </span>            : }</a>
<span class="lineNum">    3216 </span>            : 
<span class="lineNum">    3217 </span><span class="lineNoCov">          0 : static int ApplyMultSubsAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3218 </span>            :     PST *pst;
<span class="lineNum">    3219 </span>            :     SplineChar *sc;
<span class="lineNum">    3220 </span>            :     char *start, *pt;
<span class="lineNum">    3221 </span>            :     int mcnt, ch, i;
<span class="lineNum">    3222 </span>            :     SplineChar *mults[20];
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :     for ( pst=data-&gt;str[pos].sc-&gt;possub; pst!=NULL &amp;&amp; pst-&gt;subtable!=sub; pst=pst-&gt;next );</span>
<span class="lineNum">    3225 </span><span class="lineNoCov">          0 :     if ( pst==NULL )</span>
<span class="lineNum">    3226 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3227 </span>            : 
<span class="lineNum">    3228 </span><span class="lineNoCov">          0 :     mcnt = 0;</span>
<span class="lineNum">    3229 </span><span class="lineNoCov">          0 :     for ( start = pst-&gt;u.alt.components; *start==' '; ++start);</span>
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :     for ( ; *start; ) {</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :         for ( pt=start; *pt!='\0' &amp;&amp; *pt!=' '; ++pt );</span>
<span class="lineNum">    3232 </span><span class="lineNoCov">          0 :         ch = *pt; *pt = '\0';</span>
<span class="lineNum">    3233 </span><span class="lineNoCov">          0 :         sc = SFGetChar(data-&gt;sf,-1,start);</span>
<span class="lineNum">    3234 </span><span class="lineNoCov">          0 :         *pt = ch;</span>
<span class="lineNum">    3235 </span><span class="lineNoCov">          0 :         if ( sc==NULL )</span>
<span class="lineNum">    3236 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3237 </span><span class="lineNoCov">          0 :         if ( mcnt&lt;20 ) mults[mcnt++] = sc;</span>
<span class="lineNum">    3238 </span><span class="lineNoCov">          0 :         while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    3239 </span><span class="lineNoCov">          0 :         start = pt;</span>
<span class="lineNum">    3240 </span>            :     }
<span class="lineNum">    3241 </span>            : 
<span class="lineNum">    3242 </span><span class="lineNoCov">          0 :     if ( mcnt==0 ) {</span>
<span class="lineNum">    3243 </span>            :         /* Is this legal? that is can we remove a glyph with an empty multiple? */
<span class="lineNum">    3244 </span><span class="lineNoCov">          0 :         for ( i=pos+1; i&lt;data-&gt;cnt; ++i )</span>
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :             data-&gt;str[i-1] = data-&gt;str[i];</span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :         --data-&gt;cnt;</span>
<span class="lineNum">    3247 </span><span class="lineNoCov">          0 : return( pos );</span>
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :     } else if ( mcnt==1 ) {</span>
<span class="lineNum">    3249 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].sc = mults[0];</span>
<span class="lineNum">    3250 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<span class="lineNum">    3251 </span>            :     } else {
<span class="lineNum">    3252 </span><span class="lineNoCov">          0 :         if ( data-&gt;cnt+mcnt-1 &gt;= data-&gt;max )</span>
<span class="lineNum">    3253 </span><span class="lineNoCov">          0 :             data-&gt;str = realloc(data-&gt;str,(data-&gt;max+=mcnt) * sizeof( struct opentype_str ));</span>
<span class="lineNum">    3254 </span><span class="lineNoCov">          0 :         for ( i=data-&gt;cnt-1; i&gt;pos; --i )</span>
<span class="lineNum">    3255 </span><span class="lineNoCov">          0 :             data-&gt;str[i+mcnt-1] = data-&gt;str[i];</span>
<span class="lineNum">    3256 </span><span class="lineNoCov">          0 :         memset(data-&gt;str+pos,0,mcnt*sizeof(struct opentype_str));</span>
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;mcnt; ++i ) {</span>
<span class="lineNum">    3258 </span><span class="lineNoCov">          0 :             data-&gt;str[pos+i].sc = mults[i];</span>
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :             data-&gt;str[pos+i].orig_index = data-&gt;str[pos].orig_index;</span>
<span class="lineNum">    3260 </span>            :         }
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :         data-&gt;cnt += (mcnt-1);</span>
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 : return( pos+mcnt );</span>
<span class="lineNum">    3263 </span>            :     }
<a name="3264"><span class="lineNum">    3264 </span>            : }</a>
<span class="lineNum">    3265 </span>            : 
<span class="lineNum">    3266 </span><span class="lineNoCov">          0 : static int ApplyAltSubsAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3267 </span>            :     PST *pst;
<span class="lineNum">    3268 </span>            :     SplineChar *sc;
<span class="lineNum">    3269 </span>            :     char *start, *pt, ch;
<span class="lineNum">    3270 </span>            : 
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 :     for ( pst=data-&gt;str[pos].sc-&gt;possub; pst!=NULL &amp;&amp; pst-&gt;subtable!=sub; pst=pst-&gt;next );</span>
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :     if ( pst==NULL )</span>
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3274 </span>            : 
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :     for ( start = pst-&gt;u.alt.components; *start==' '; ++start);</span>
<span class="lineNum">    3276 </span><span class="lineNoCov">          0 :     for ( ; *start; ) {</span>
<span class="lineNum">    3277 </span><span class="lineNoCov">          0 :         for ( pt=start; *pt!='\0' &amp;&amp; *pt!=' '; ++pt );</span>
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :         ch = *pt; *pt = '\0';</span>
<span class="lineNum">    3279 </span><span class="lineNoCov">          0 :         sc = SFGetChar(data-&gt;sf,-1,start);</span>
<span class="lineNum">    3280 </span><span class="lineNoCov">          0 :         *pt = ch;</span>
<span class="lineNum">    3281 </span><span class="lineNoCov">          0 :         if ( sc!=NULL ) {</span>
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :             data-&gt;str[pos].sc = sc;</span>
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<span class="lineNum">    3284 </span>            :         }
<span class="lineNum">    3285 </span><span class="lineNoCov">          0 :         while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 :         start = pt;</span>
<span class="lineNum">    3287 </span>            :     }
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="3289"><span class="lineNum">    3289 </span>            : }</a>
<span class="lineNum">    3290 </span>            : 
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 : static int ApplyLigatureSubsAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3292 </span>            :     int i,k, lpos, npos;
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :     int lookup_flags = sub-&gt;lookup-&gt;lookup_flags;</span>
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :     int match_found = -1, match_len=0;</span>
<span class="lineNum">    3295 </span>            : 
<span class="lineNum">    3296 </span><span class="lineNoCov">          0 :     if ( data-&gt;lig_owner!=sub )</span>
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 :         LigatureSearch(sub,data);</span>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;data-&gt;lcnt; ++i ) {</span>
<span class="lineNum">    3299 </span><span class="lineNoCov">          0 :         if ( data-&gt;ligs[i][1]==data-&gt;str[pos].sc ) {</span>
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 :             lpos = 0;</span>
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 :             npos = pos+1;</span>
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 :             for ( k=2; data-&gt;ligs[i][k]!=NULL; ++k ) {</span>
<span class="lineNum">    3303 </span><span class="lineNoCov">          0 :                 npos = skipglyphs(lookup_flags,data,npos);</span>
<span class="lineNum">    3304 </span><span class="lineNoCov">          0 :                 if ( npos&gt;=data-&gt;cnt || data-&gt;str[npos].sc != data-&gt;ligs[i][k] )</span>
<span class="lineNum">    3305 </span>            :             break;
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :                 ++npos;</span>
<span class="lineNum">    3307 </span>            :             }
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :             if ( data-&gt;ligs[i][k]==NULL ) {</span>
<span class="lineNum">    3309 </span><span class="lineNoCov">          0 :                 if ( match_found==-1 || k&gt;match_len ) {</span>
<span class="lineNum">    3310 </span><span class="lineNoCov">          0 :                     match_found = i;</span>
<span class="lineNum">    3311 </span><span class="lineNoCov">          0 :                     match_len = k;</span>
<span class="lineNum">    3312 </span>            :                 }
<span class="lineNum">    3313 </span>            :             }
<span class="lineNum">    3314 </span>            :         }
<span class="lineNum">    3315 </span>            :     }
<span class="lineNum">    3316 </span><span class="lineNoCov">          0 :     if ( match_found!=-1 ) {</span>
<span class="lineNum">    3317 </span>            :         /* Matched. Remove the component glyphs, and note which component */
<span class="lineNum">    3318 </span>            :         /*  any intervening marks should be attached to */
<span class="lineNum">    3319 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].sc = data-&gt;ligs[match_found][0];</span>
<span class="lineNum">    3320 </span><span class="lineNoCov">          0 :         npos = pos+1;</span>
<span class="lineNum">    3321 </span><span class="lineNoCov">          0 :         for ( k=2; data-&gt;ligs[match_found][k]!=NULL; ++k ) {</span>
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :             lpos = skipglyphs(lookup_flags,data,npos);</span>
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :             for ( ; npos&lt;lpos; ++npos )</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :                 data-&gt;str[npos].lig_pos = k-2;</span>
<span class="lineNum">    3325 </span>            :             /* Remove this glyph (copy the final NUL too) */
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :             for ( ++lpos; lpos&lt;=data-&gt;cnt; ++lpos )</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :                 data-&gt;str[lpos-1] = data-&gt;str[lpos];</span>
<span class="lineNum">    3328 </span><span class="lineNoCov">          0 :             --data-&gt;cnt;</span>
<span class="lineNum">    3329 </span>            :         }
<span class="lineNum">    3330 </span>            :         /* Any marks after the last component (which should be attached */
<span class="lineNum">    3331 </span>            :         /*  to it) will not have been tagged, so do that now */
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :         lpos = skipglyphs(lookup_flags,data,npos);</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :         for ( ; npos&lt;lpos; ++npos )</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :             data-&gt;str[npos].lig_pos = k-2;</span>
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<span class="lineNum">    3336 </span>            :     }
<span class="lineNum">    3337 </span>            : 
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="3339"><span class="lineNum">    3339 </span>            : }</a>
<span class="lineNum">    3340 </span>            : 
<span class="lineNum">    3341 </span><span class="lineNoCov">          0 : static int ApplyContextual(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3342 </span>            :     /* On this level there is no difference between GPOS/GSUB contextuals */
<span class="lineNum">    3343 </span>            :     /*  If the contextual matches, then we apply the lookups, otherwise we */
<span class="lineNum">    3344 </span>            :     /*  don't. Now the lookups will be different, but we don't care here */
<span class="lineNum">    3345 </span>            :     struct fpst_rule *rule;
<span class="lineNum">    3346 </span>            :     int retpos, i,j;
<span class="lineNum">    3347 </span>            : 
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :     retpos = ContextualMatch(sub,data,pos,&amp;rule);</span>
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :     if ( retpos==0 )</span>
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3351 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;rule-&gt;lookup_cnt; ++i ) {</span>
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :         for ( j=pos; j&lt;data-&gt;cnt; ++j ) {</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :             if ( data-&gt;str[j].context_pos == rule-&gt;lookups[i].seq ) {</span>
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :                 ApplyLookupAtPos(0,rule-&gt;lookups[i].lookup,data,j);</span>
<span class="lineNum">    3355 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3356 </span>            :             }
<span class="lineNum">    3357 </span>            :         }
<span class="lineNum">    3358 </span>            :     }
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 : return( retpos );</span>
<a name="3360"><span class="lineNum">    3360 </span>            : }</a>
<span class="lineNum">    3361 </span>            : 
<span class="lineNum">    3362 </span><span class="lineNoCov">          0 : static int FigureDeviceTable(DeviceTable *dt,int pixelsize) {</span>
<span class="lineNum">    3363 </span>            : 
<span class="lineNum">    3364 </span><span class="lineNoCov">          0 :     if ( dt==NULL || dt-&gt;corrections==NULL || pixelsize&lt;dt-&gt;first_pixel_size ||</span>
<span class="lineNum">    3365 </span><span class="lineNoCov">          0 :             pixelsize&gt;dt-&gt;last_pixel_size )</span>
<span class="lineNum">    3366 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3367 </span>            : 
<span class="lineNum">    3368 </span><span class="lineNoCov">          0 : return( dt-&gt;corrections[pixelsize - dt-&gt;last_pixel_size] );</span>
<a name="3369"><span class="lineNum">    3369 </span>            : }</a>
<span class="lineNum">    3370 </span>            : 
<span class="lineNum">    3371 </span><span class="lineNoCov">          0 : static int ApplySinglePosAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3372 </span>            :     PST *pst;
<span class="lineNum">    3373 </span>            : 
<span class="lineNum">    3374 </span><span class="lineNoCov">          0 :     for ( pst=data-&gt;str[pos].sc-&gt;possub; pst!=NULL &amp;&amp; pst-&gt;subtable!=sub; pst=pst-&gt;next );</span>
<span class="lineNum">    3375 </span><span class="lineNoCov">          0 :     if ( pst==NULL )</span>
<span class="lineNum">    3376 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3377 </span>            : 
<span class="lineNum">    3378 </span><span class="lineNoCov">          0 :     data-&gt;str[pos].vr.xoff += rint( pst-&gt;u.pos.xoff * data-&gt;scale );</span>
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :     data-&gt;str[pos].vr.yoff += rint( pst-&gt;u.pos.yoff * data-&gt;scale );</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :     data-&gt;str[pos].vr.h_adv_off += rint( pst-&gt;u.pos.h_adv_off * data-&gt;scale );</span>
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :     data-&gt;str[pos].vr.v_adv_off += rint( pst-&gt;u.pos.v_adv_off * data-&gt;scale );</span>
<span class="lineNum">    3382 </span><span class="lineNoCov">          0 :     if ( pst-&gt;u.pos.adjust!=NULL ) {</span>
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.xoff += FigureDeviceTable(&amp;pst-&gt;u.pos.adjust-&gt;xadjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3384 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.yoff += FigureDeviceTable(&amp;pst-&gt;u.pos.adjust-&gt;yadjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3385 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.h_adv_off += FigureDeviceTable(&amp;pst-&gt;u.pos.adjust-&gt;xadv,data-&gt;pixelsize);</span>
<span class="lineNum">    3386 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.v_adv_off += FigureDeviceTable(&amp;pst-&gt;u.pos.adjust-&gt;yadv,data-&gt;pixelsize);</span>
<span class="lineNum">    3387 </span>            :     }
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<a name="3389"><span class="lineNum">    3389 </span>            : }</a>
<span class="lineNum">    3390 </span>            : 
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 : static int ApplyPairPosAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos,int allow_class0) {</span>
<span class="lineNum">    3392 </span>            :     PST *pst;
<span class="lineNum">    3393 </span>            :     int npos, isv, within, f, l, kcspecd;
<span class="lineNum">    3394 </span>            :     KernPair *kp;
<span class="lineNum">    3395 </span>            : 
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :     npos = skipglyphs(sub-&gt;lookup-&gt;lookup_flags,data,pos+1);</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :     if ( npos&gt;=data-&gt;cnt )</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :     if ( sub-&gt;kc!=NULL ) {</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :         kcspecd = sub-&gt;kc-&gt;firsts[0] != NULL;</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :         f = KCFindName(data-&gt;str[pos].sc-&gt;name ,sub-&gt;kc-&gt;firsts ,sub-&gt;kc-&gt;first_cnt ,allow_class0);</span>
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :         l = KCFindName(data-&gt;str[npos].sc-&gt;name,sub-&gt;kc-&gt;seconds,sub-&gt;kc-&gt;second_cnt,allow_class0);</span>
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :         if ( f==-1 || l==-1 || ( !kcspecd &amp;&amp; f==0 &amp;&amp; l==0 ) )</span>
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3405 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].kc_index = within = f*sub-&gt;kc-&gt;second_cnt+l;</span>
<span class="lineNum">    3406 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].kc = sub-&gt;kc;</span>
<span class="lineNum">    3407 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].prev_kc0 = ( !kcspecd &amp;&amp; f==0 );</span>
<span class="lineNum">    3408 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].next_kc0 = ( l==0 );</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :         if ( sub-&gt;vertical_kerning ) {</span>
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 :             data-&gt;str[pos].vr.v_adv_off += rint( sub-&gt;kc-&gt;offsets[within] * data-&gt;scale );</span>
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :             data-&gt;str[pos].vr.v_adv_off += FigureDeviceTable(&amp;sub-&gt;kc-&gt;adjusts[within],data-&gt;pixelsize);</span>
<span class="lineNum">    3412 </span><span class="lineNoCov">          0 :         } else if ( sub-&gt;lookup-&gt;lookup_flags &amp; pst_r2l ) {</span>
<span class="lineNum">    3413 </span><span class="lineNoCov">          0 :             data-&gt;str[npos].vr.h_adv_off += rint( sub-&gt;kc-&gt;offsets[within] * data-&gt;scale );</span>
<span class="lineNum">    3414 </span><span class="lineNoCov">          0 :             data-&gt;str[npos].vr.h_adv_off += FigureDeviceTable(&amp;sub-&gt;kc-&gt;adjusts[within],data-&gt;pixelsize);</span>
<span class="lineNum">    3415 </span>            :         } else {
<span class="lineNum">    3416 </span><span class="lineNoCov">          0 :             data-&gt;str[pos].vr.h_adv_off += rint( sub-&gt;kc-&gt;offsets[within] * data-&gt;scale );</span>
<span class="lineNum">    3417 </span><span class="lineNoCov">          0 :             data-&gt;str[pos].vr.h_adv_off += FigureDeviceTable(&amp;sub-&gt;kc-&gt;adjusts[within],data-&gt;pixelsize);</span>
<span class="lineNum">    3418 </span>            :         }
<span class="lineNum">    3419 </span>            :         /* Return 1 if the result we have got comes from a combination with an {Everything Else} class */
<span class="lineNum">    3420 </span>            :         /* This is acceptable, but we should continue looking for a better match */
<span class="lineNum">    3421 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<span class="lineNum">    3422 </span>            :     } else {
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :         for ( pst=data-&gt;str[pos].sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">    3424 </span><span class="lineNoCov">          0 :             if ( pst-&gt;subtable==sub &amp;&amp; strcmp(pst-&gt;u.pair.paired,data-&gt;str[npos].sc-&gt;name)==0 ) {</span>
<span class="lineNum">    3425 </span><span class="lineNoCov">          0 :                 data-&gt;str[pos].vr.xoff += rint( pst-&gt;u.pair.vr[0].xoff * data-&gt;scale);</span>
<span class="lineNum">    3426 </span><span class="lineNoCov">          0 :                 data-&gt;str[pos].vr.yoff += rint( pst-&gt;u.pair.vr[0].yoff * data-&gt;scale);</span>
<span class="lineNum">    3427 </span><span class="lineNoCov">          0 :                 data-&gt;str[pos].vr.h_adv_off += rint( pst-&gt;u.pair.vr[0].h_adv_off * data-&gt;scale);</span>
<span class="lineNum">    3428 </span><span class="lineNoCov">          0 :                 data-&gt;str[pos].vr.v_adv_off += rint( pst-&gt;u.pair.vr[0].v_adv_off * data-&gt;scale);</span>
<span class="lineNum">    3429 </span><span class="lineNoCov">          0 :                 data-&gt;str[npos].vr.xoff += rint( pst-&gt;u.pair.vr[1].xoff * data-&gt;scale);</span>
<span class="lineNum">    3430 </span><span class="lineNoCov">          0 :                 data-&gt;str[npos].vr.yoff += rint( pst-&gt;u.pair.vr[1].yoff * data-&gt;scale);</span>
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 :                 data-&gt;str[npos].vr.h_adv_off += rint( pst-&gt;u.pair.vr[1].h_adv_off * data-&gt;scale);</span>
<span class="lineNum">    3432 </span><span class="lineNoCov">          0 :                 data-&gt;str[npos].vr.v_adv_off += rint( pst-&gt;u.pair.vr[1].v_adv_off * data-&gt;scale);</span>
<span class="lineNum">    3433 </span>            :                 /* I got bored. I should do all of them */
<span class="lineNum">    3434 </span><span class="lineNoCov">          0 :                 if ( pst-&gt;u.pair.vr[0].adjust!=NULL ) {</span>
<span class="lineNum">    3435 </span><span class="lineNoCov">          0 :                     data-&gt;str[pos].vr.h_adv_off += FigureDeviceTable(&amp;pst-&gt;u.pair.vr[0].adjust-&gt;xadv,data-&gt;pixelsize);</span>
<span class="lineNum">    3436 </span>            :                 }
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 : return( pos+1 );        /* We do NOT want to return npos+1 */</span>
<span class="lineNum">    3438 </span>            :             }
<span class="lineNum">    3439 </span>            :         }
<span class="lineNum">    3440 </span><span class="lineNoCov">          0 :         for ( isv = 0; isv&lt;2; ++isv ) {</span>
<span class="lineNum">    3441 </span><span class="lineNoCov">          0 :             for ( kp = isv ? data-&gt;str[pos].sc-&gt;vkerns : data-&gt;str[pos].sc-&gt;kerns; kp!=NULL; kp=kp-&gt;next ) {</span>
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :                 if ( kp-&gt;subtable == sub &amp;&amp; kp-&gt;sc == data-&gt;str[npos].sc ) {</span>
<span class="lineNum">    3443 </span><span class="lineNoCov">          0 :                     data-&gt;str[pos].kp = kp;</span>
<span class="lineNum">    3444 </span><span class="lineNoCov">          0 :                     if ( isv ) {</span>
<span class="lineNum">    3445 </span><span class="lineNoCov">          0 :                         data-&gt;str[pos].vr.v_adv_off += rint( kp-&gt;off * data-&gt;scale);</span>
<span class="lineNum">    3446 </span><span class="lineNoCov">          0 :                         data-&gt;str[pos].vr.v_adv_off += FigureDeviceTable(kp-&gt;adjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3447 </span><span class="lineNoCov">          0 :                     } else if ( sub-&gt;lookup-&gt;lookup_flags &amp; pst_r2l ) {</span>
<span class="lineNum">    3448 </span><span class="lineNoCov">          0 :                         data-&gt;str[npos].vr.h_adv_off += rint( kp-&gt;off * data-&gt;scale);</span>
<span class="lineNum">    3449 </span><span class="lineNoCov">          0 :                         data-&gt;str[npos].vr.h_adv_off += FigureDeviceTable(kp-&gt;adjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3450 </span>            :                     } else {
<span class="lineNum">    3451 </span><span class="lineNoCov">          0 :                         data-&gt;str[pos].vr.h_adv_off += rint( kp-&gt;off * data-&gt;scale);</span>
<span class="lineNum">    3452 </span><span class="lineNoCov">          0 :                         data-&gt;str[pos].vr.h_adv_off += FigureDeviceTable(kp-&gt;adjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3453 </span>            :                     }
<span class="lineNum">    3454 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<span class="lineNum">    3455 </span>            :                 }
<span class="lineNum">    3456 </span>            :             }
<span class="lineNum">    3457 </span>            :         }
<span class="lineNum">    3458 </span>            :     }
<span class="lineNum">    3459 </span>            : 
<span class="lineNum">    3460 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="3461"><span class="lineNum">    3461 </span>            : }</a>
<span class="lineNum">    3462 </span>            : 
<span class="lineNum">    3463 </span><span class="lineNoCov">          0 : static int ApplyAnchorPosAtPos(struct lookup_subtable *sub,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3464 </span>            :     AnchorPoint *ap1, *ap2;
<span class="lineNum">    3465 </span>            :     int bpos;
<span class="lineNum">    3466 </span>            : 
<span class="lineNum">    3467 </span>            :     /* Anchors do not position the base glyph, but the mark (or second glyph */
<span class="lineNum">    3468 </span>            :     /*  of a cursive attachment). This means we don't apply the attachment when*/
<span class="lineNum">    3469 </span>            :     /*  we meet the first glyph, but wait until we meet the second, and then */
<span class="lineNum">    3470 </span>            :     /*  walk backwards */
<span class="lineNum">    3471 </span>            :     /* The backwards walk is different depending on the lookup type (I think) */
<span class="lineNum">    3472 </span>            :     /*  mark to base and mark to ligature lookups will skip all marks even if */
<span class="lineNum">    3473 </span>            :     /*  lookup flags don't specify that */
<span class="lineNum">    3474 </span>            :     /* mark to mark, and cursive attachment only skip what the lookup flags */
<span class="lineNum">    3475 </span>            :     /*  tell them to skip. */
<span class="lineNum">    3476 </span><span class="lineNoCov">          0 :     for ( ap2=data-&gt;str[pos].sc-&gt;anchor; ap2!=NULL ; ap2=ap2-&gt;next ) {</span>
<span class="lineNum">    3477 </span><span class="lineNoCov">          0 :         if ( ap2-&gt;anchor-&gt;subtable==sub &amp;&amp; (ap2-&gt;type == at_mark || ap2-&gt;type == at_centry))</span>
<span class="lineNum">    3478 </span>            :     break;
<span class="lineNum">    3479 </span>            :     }
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :     if ( ap2==NULL ) {</span>
<span class="lineNum">    3481 </span>            :         /* This subtable is not used by this glyph ... at least this glyph is */
<span class="lineNum">    3482 </span>            :         /*  neither a mark nor an entry point for this subtable */
<span class="lineNum">    3483 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3484 </span>            :     }
<span class="lineNum">    3485 </span>            : 
<span class="lineNum">    3486 </span>            :     /* There's only going to be one mark anchor on a glyph in a given subtable*/
<span class="lineNum">    3487 </span>            :     /* And cursive attachments only allow one anchor class per subtable */
<span class="lineNum">    3488 </span>            :     /* in either case we have already found the only attachment site possible */
<span class="lineNum">    3489 </span>            :     /*  in the current glyph */
<span class="lineNum">    3490 </span>            : 
<span class="lineNum">    3491 </span><span class="lineNoCov">          0 :     if ( sub-&gt;lookup-&gt;lookup_type == gpos_mark2base ||</span>
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 :             sub-&gt;lookup-&gt;lookup_type == gpos_mark2ligature )</span>
<span class="lineNum">    3493 </span><span class="lineNoCov">          0 :         bpos = bskipmarkglyphs(sub-&gt;lookup-&gt;lookup_flags,data,pos-1);</span>
<span class="lineNum">    3494 </span>            :     else
<span class="lineNum">    3495 </span><span class="lineNoCov">          0 :         bpos = bskipglyphs(sub-&gt;lookup-&gt;lookup_flags,data,pos-1);</span>
<span class="lineNum">    3496 </span><span class="lineNoCov">          0 :     if ( bpos==-1 )</span>
<span class="lineNum">    3497 </span><span class="lineNoCov">          0 : return( 0 );            /* No match */</span>
<span class="lineNum">    3498 </span>            : 
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :     if ( sub-&gt;lookup-&gt;lookup_type == gpos_cursive ) {</span>
<span class="lineNum">    3500 </span><span class="lineNoCov">          0 :         for ( ap1=data-&gt;str[bpos].sc-&gt;anchor; ap1!=NULL ; ap1=ap1-&gt;next ) {</span>
<span class="lineNum">    3501 </span><span class="lineNoCov">          0 :             if ( ap1-&gt;anchor==ap2-&gt;anchor &amp;&amp; ap1-&gt;type==at_cexit )</span>
<span class="lineNum">    3502 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3503 </span>            :         }
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :     } else if ( sub-&gt;lookup-&gt;lookup_type == gpos_mark2ligature ) {</span>
<span class="lineNum">    3505 </span><span class="lineNoCov">          0 :         for ( ap1=data-&gt;str[bpos].sc-&gt;anchor; ap1!=NULL ; ap1=ap1-&gt;next ) {</span>
<span class="lineNum">    3506 </span><span class="lineNoCov">          0 :             if ( ap1-&gt;anchor==ap2-&gt;anchor &amp;&amp; ap1-&gt;type==at_baselig &amp;&amp;</span>
<span class="lineNum">    3507 </span><span class="lineNoCov">          0 :                     ap1-&gt;lig_index == data-&gt;str[pos].lig_pos )</span>
<span class="lineNum">    3508 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3509 </span>            :         }
<span class="lineNum">    3510 </span>            :     } else {
<span class="lineNum">    3511 </span><span class="lineNoCov">          0 :         for ( ap1=data-&gt;str[bpos].sc-&gt;anchor; ap1!=NULL ; ap1=ap1-&gt;next ) {</span>
<span class="lineNum">    3512 </span><span class="lineNoCov">          0 :             if ( ap1-&gt;anchor==ap2-&gt;anchor &amp;&amp;</span>
<span class="lineNum">    3513 </span><span class="lineNoCov">          0 :                     (ap1-&gt;type==at_basechar || ap1-&gt;type==at_basemark) )</span>
<span class="lineNum">    3514 </span>            :         break;
<span class="lineNum">    3515 </span>            :         }
<span class="lineNum">    3516 </span>            :     }
<span class="lineNum">    3517 </span><span class="lineNoCov">          0 :     if ( ap1==NULL )</span>
<span class="lineNum">    3518 </span><span class="lineNoCov">          0 : return( 0 );            /* No match */</span>
<span class="lineNum">    3519 </span>            : 
<span class="lineNum">    3520 </span>            : /* This probably doesn't work for vertical text */
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :     data-&gt;str[pos].vr.yoff = data-&gt;str[bpos].vr.yoff +</span>
<span class="lineNum">    3522 </span><span class="lineNoCov">          0 :             rint((ap1-&gt;me.y - ap2-&gt;me.y) * data-&gt;scale);</span>
<span class="lineNum">    3523 </span><span class="lineNoCov">          0 :     data-&gt;str[pos].vr.yoff += FigureDeviceTable(&amp;ap1-&gt;yadjust,data-&gt;pixelsize)-</span>
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :                 FigureDeviceTable(&amp;ap2-&gt;yadjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :     if ( sub-&gt;lookup-&gt;lookup_flags&amp;pst_r2l ) {</span>
<span class="lineNum">    3526 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.xoff = data-&gt;str[bpos].vr.xoff +</span>
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :                 rint( -(ap1-&gt;me.x - ap2-&gt;me.x)*data-&gt;scale );</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.xoff -= FigureDeviceTable(&amp;ap1-&gt;xadjust,data-&gt;pixelsize)-</span>
<span class="lineNum">    3529 </span><span class="lineNoCov">          0 :                     FigureDeviceTable(&amp;ap2-&gt;xadjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3530 </span>            :     } else {
<span class="lineNum">    3531 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.xoff = data-&gt;str[bpos].vr.xoff +</span>
<span class="lineNum">    3532 </span><span class="lineNoCov">          0 :                 rint( (ap1-&gt;me.x - ap2-&gt;me.x - data-&gt;str[bpos].sc-&gt;width)*data-&gt;scale -</span>
<span class="lineNum">    3533 </span><span class="lineNoCov">          0 :                 data-&gt;str[bpos].vr.h_adv_off);</span>
<span class="lineNum">    3534 </span><span class="lineNoCov">          0 :         data-&gt;str[pos].vr.xoff += FigureDeviceTable(&amp;ap1-&gt;xadjust,data-&gt;pixelsize)-</span>
<span class="lineNum">    3535 </span><span class="lineNoCov">          0 :                     FigureDeviceTable(&amp;ap2-&gt;xadjust,data-&gt;pixelsize);</span>
<span class="lineNum">    3536 </span>            :     }
<span class="lineNum">    3537 </span>            : 
<span class="lineNum">    3538 </span><span class="lineNoCov">          0 : return( pos+1 );</span>
<a name="3539"><span class="lineNum">    3539 </span>            : }</a>
<span class="lineNum">    3540 </span>            : 
<span class="lineNum">    3541 </span><span class="lineNoCov">          0 : static int ConditionalTagOk(uint32 tag, OTLookup *otl,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3542 </span>            :     int npos, bpos;
<span class="lineNum">    3543 </span>            :     uint32 script;
<span class="lineNum">    3544 </span>            :     int before_in_script, after_in_script;
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :     if ( tag==CHR('i','n','i','t') || tag==CHR('i','s','o','l') ||</span>
<span class="lineNum">    3547 </span><span class="lineNoCov">          0 :             tag==CHR('f','i','n','a') || tag==CHR('m','e','d','i') ) {</span>
<span class="lineNum">    3548 </span><span class="lineNoCov">          0 :         npos = skipglyphs(otl-&gt;lookup_flags,data,pos+1);</span>
<span class="lineNum">    3549 </span><span class="lineNoCov">          0 :         bpos = bskipglyphs(otl-&gt;lookup_flags,data,pos-1);</span>
<span class="lineNum">    3550 </span><span class="lineNoCov">          0 :         script = SCScriptFromUnicode(data-&gt;str[pos].sc);</span>
<span class="lineNum">    3551 </span><span class="lineNoCov">          0 :         before_in_script = (bpos&gt;=0 &amp;&amp; SCScriptFromUnicode(data-&gt;str[bpos].sc)==script);</span>
<span class="lineNum">    3552 </span><span class="lineNoCov">          0 :         after_in_script = (npos&lt;data-&gt;cnt &amp;&amp; SCScriptFromUnicode(data-&gt;str[npos].sc)==script);</span>
<span class="lineNum">    3553 </span><span class="lineNoCov">          0 :         if ( tag==CHR('i','n','i','t') )</span>
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 : return( !before_in_script &amp;&amp; after_in_script );</span>
<span class="lineNum">    3555 </span><span class="lineNoCov">          0 :         else if ( tag==CHR('i','s','o','l') )</span>
<span class="lineNum">    3556 </span><span class="lineNoCov">          0 : return( !before_in_script &amp;&amp; !after_in_script );</span>
<span class="lineNum">    3557 </span><span class="lineNoCov">          0 :         else if ( tag==CHR('f','i','n','a') )</span>
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 : return( before_in_script &amp;&amp; !after_in_script );</span>
<span class="lineNum">    3559 </span>            :         else
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 : return( before_in_script &amp;&amp; after_in_script );</span>
<span class="lineNum">    3561 </span>            :     }
<span class="lineNum">    3562 </span>            : 
<span class="lineNum">    3563 </span><span class="lineNoCov">          0 : return( true );</span>
<a name="3564"><span class="lineNum">    3564 </span>            : }</a>
<span class="lineNum">    3565 </span>            : 
<span class="lineNum">    3566 </span><span class="lineNoCov">          0 : static int ApplyLookupAtPos(uint32 tag, OTLookup *otl,struct lookup_data *data,int pos) {</span>
<span class="lineNum">    3567 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    3568 </span>            :     int newpos;
<span class="lineNum">    3569 </span>            :     /* Need two passes for pair kerning lookups. At the second pass we accept */
<span class="lineNum">    3570 </span>            :     /* also combinations with the {Everything Else} class */
<span class="lineNum">    3571 </span><span class="lineNoCov">          0 :     int i, pcnt = otl-&gt;lookup_type==gpos_pair ? 2 : 1;</span>
<span class="lineNum">    3572 </span>            : 
<span class="lineNum">    3573 </span>            :     /* Some tags imply a conditional check. Do that now */
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :     if ( !ConditionalTagOk(tag,otl,data,pos))</span>
<span class="lineNum">    3575 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3576 </span>            : 
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;pcnt; i++ ) {</span>
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :         for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :             switch ( otl-&gt;lookup_type ) {</span>
<span class="lineNum">    3580 </span>            :               case gsub_single:
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 :                 newpos = ApplySingleSubsAtPos(sub,data,pos);</span>
<span class="lineNum">    3582 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3583 </span>            :               case gsub_multiple:
<span class="lineNum">    3584 </span><span class="lineNoCov">          0 :                 newpos = ApplyMultSubsAtPos(sub,data,pos);</span>
<span class="lineNum">    3585 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3586 </span>            :               case gsub_alternate:
<span class="lineNum">    3587 </span><span class="lineNoCov">          0 :                 newpos = ApplyAltSubsAtPos(sub,data,pos);</span>
<span class="lineNum">    3588 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3589 </span>            :               case gsub_ligature:
<span class="lineNum">    3590 </span><span class="lineNoCov">          0 :                 newpos = ApplyLigatureSubsAtPos(sub,data,pos);</span>
<span class="lineNum">    3591 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3592 </span>            :               case gsub_context:
<span class="lineNum">    3593 </span><span class="lineNoCov">          0 :                 newpos = ApplyContextual(sub,data,pos);</span>
<span class="lineNum">    3594 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3595 </span>            :               case gsub_contextchain:
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :                 newpos = ApplyContextual(sub,data,pos);</span>
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3598 </span>            :               case gsub_reversecchain:
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :                 newpos = ApplySingleSubsAtPos(sub,data,pos);</span>
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3601 </span>            : 
<span class="lineNum">    3602 </span>            :               case gpos_single:
<span class="lineNum">    3603 </span><span class="lineNoCov">          0 :                 newpos = ApplySinglePosAtPos(sub,data,pos);</span>
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3605 </span>            :               case gpos_pair:
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :                 newpos = ApplyPairPosAtPos(sub,data,pos,i&gt;0);</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3608 </span>            :               case gpos_cursive:
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :                 newpos = ApplyAnchorPosAtPos(sub,data,pos);</span>
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3611 </span>            :               case gpos_mark2base:
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :                 newpos = ApplyAnchorPosAtPos(sub,data,pos);</span>
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3614 </span>            :               case gpos_mark2ligature:
<span class="lineNum">    3615 </span><span class="lineNoCov">          0 :                 newpos = ApplyAnchorPosAtPos(sub,data,pos);</span>
<span class="lineNum">    3616 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3617 </span>            :               case gpos_mark2mark:
<span class="lineNum">    3618 </span><span class="lineNoCov">          0 :                 newpos = ApplyAnchorPosAtPos(sub,data,pos);</span>
<span class="lineNum">    3619 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3620 </span>            :               case gpos_context:
<span class="lineNum">    3621 </span><span class="lineNoCov">          0 :                 newpos = ApplyContextual(sub,data,pos);</span>
<span class="lineNum">    3622 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3623 </span>            :               case gpos_contextchain:
<span class="lineNum">    3624 </span><span class="lineNoCov">          0 :                 newpos = ApplyContextual(sub,data,pos);</span>
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3626 </span>            :               default:
<span class="lineNum">    3627 </span>            :                 /* apple state machines */
<span class="lineNum">    3628 </span><span class="lineNoCov">          0 :                 newpos = 0;</span>
<span class="lineNum">    3629 </span><span class="lineNoCov">          0 :               break;</span>
<span class="lineNum">    3630 </span>            :             }
<span class="lineNum">    3631 </span>            :             /* if a subtable worked, we don't try to apply the next one */
<span class="lineNum">    3632 </span><span class="lineNoCov">          0 :             if ( newpos!=0 )</span>
<span class="lineNum">    3633 </span><span class="lineNoCov">          0 :     return( newpos );</span>
<span class="lineNum">    3634 </span>            :         }
<span class="lineNum">    3635 </span>            :     }
<span class="lineNum">    3636 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="3637"><span class="lineNum">    3637 </span>            : }</a>
<span class="lineNum">    3638 </span>            : 
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 : static void ApplyLookup(uint32 tag, OTLookup *otl,struct lookup_data *data) {</span>
<span class="lineNum">    3640 </span>            :     int pos, npos;
<span class="lineNum">    3641 </span><span class="lineNoCov">          0 :     int lt = otl-&gt;lookup_type;</span>
<span class="lineNum">    3642 </span>            : 
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 :     if ( lt == morx_indic || lt == morx_context || lt == morx_insert ||</span>
<span class="lineNum">    3644 </span>            :             lt == kern_statemachine )
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :         ApplyAppleStateMachine(otl,data);</span>
<span class="lineNum">    3646 </span>            :     else {
<span class="lineNum">    3647 </span>            :         /* OpenType */
<span class="lineNum">    3648 </span><span class="lineNoCov">          0 :         for ( pos = 0; pos&lt;data-&gt;cnt; ) {</span>
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 :             npos = ApplyLookupAtPos(tag,otl,data,pos);</span>
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :             if ( npos&lt;=pos)          /* !!!!! */</span>
<span class="lineNum">    3651 </span><span class="lineNoCov">          0 :                 npos = pos+1;</span>
<span class="lineNum">    3652 </span><span class="lineNoCov">          0 :             pos = npos;</span>
<span class="lineNum">    3653 </span>            :         }
<span class="lineNum">    3654 </span>            :     }
<a name="3655"><span class="lineNum">    3655 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span><span class="lineNoCov">          0 : static uint32 FSLLMatches(FeatureScriptLangList *fl,uint32 *flist,uint32 script,uint32 lang) {</span>
<span class="lineNum">    3658 </span>            :     int i,l;
<span class="lineNum">    3659 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">    3660 </span>            : 
<span class="lineNum">    3661 </span><span class="lineNoCov">          0 :     if ( flist==NULL )</span>
<span class="lineNum">    3662 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3663 </span>            : 
<span class="lineNum">    3664 </span><span class="lineNoCov">          0 :     while ( fl!=NULL ) {</span>
<span class="lineNum">    3665 </span><span class="lineNoCov">          0 :         for ( i=0; flist[i]!=0; ++i ) {</span>
<span class="lineNum">    3666 </span><span class="lineNoCov">          0 :             if ( fl-&gt;featuretag==flist[i] )</span>
<span class="lineNum">    3667 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3668 </span>            :         }
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :         if ( flist[i]!=0 ) {</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :             for ( sl=fl-&gt;scripts; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :                 if ( sl-&gt;script == script ) {</span>
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :                     if ( fl-&gt;ismac ) /* Language irrelevant on macs (scripts too, but we pretend they matter) */</span>
<span class="lineNum">    3673 </span><span class="lineNoCov">          0 : return( fl-&gt;featuretag );</span>
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :                     for ( l=0; l&lt;sl-&gt;lang_cnt; ++l )</span>
<span class="lineNum">    3675 </span><span class="lineNoCov">          0 :                         if ( (l&lt;MAX_LANG &amp;&amp; sl-&gt;langs[l]==lang) ||</span>
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :                                 (l&gt;=MAX_LANG &amp;&amp; sl-&gt;morelangs[l-MAX_LANG]==lang))</span>
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 : return( fl-&gt;featuretag );</span>
<span class="lineNum">    3678 </span>            :                 }
<span class="lineNum">    3679 </span>            :             }
<span class="lineNum">    3680 </span>            :         }
<span class="lineNum">    3681 </span><span class="lineNoCov">          0 :         fl = fl-&gt;next;</span>
<span class="lineNum">    3682 </span>            :     }
<span class="lineNum">    3683 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3684 </span>            : }
<span class="lineNum">    3685 </span>            : 
<span class="lineNum">    3686 </span>            : /* This routine takes a string of glyphs and applies the opentype transformations */
<span class="lineNum">    3687 </span>            : /*  indicated by the features (and script and language) we are passed, it returns */
<a name="3688"><span class="lineNum">    3688 </span>            : /*  a transformed string with substitutions applied and containing positioning */</a>
<span class="lineNum">    3689 </span>            : /*  info */
<span class="lineNum">    3690 </span><span class="lineNoCov">          0 : struct opentype_str *ApplyTickedFeatures(SplineFont *sf,uint32 *flist, uint32 script, uint32 lang,</span>
<span class="lineNum">    3691 </span>            :         int pixelsize, SplineChar **glyphs) {
<span class="lineNum">    3692 </span>            :     int isgpos, cnt;
<span class="lineNum">    3693 </span>            :     OTLookup *otl;
<span class="lineNum">    3694 </span>            :     struct lookup_data data;
<span class="lineNum">    3695 </span>            :     uint32 *langs, templang;
<span class="lineNum">    3696 </span>            :     int i;
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :     memset(&amp;data,0,sizeof(data));</span>
<span class="lineNum">    3699 </span><span class="lineNoCov">          0 :     for ( cnt=0; glyphs[cnt]!=NULL; ++cnt );</span>
<span class="lineNum">    3700 </span><span class="lineNoCov">          0 :     data.str = calloc(cnt+1,sizeof(struct opentype_str));</span>
<span class="lineNum">    3701 </span><span class="lineNoCov">          0 :     data.cnt = data.max = cnt;</span>
<span class="lineNum">    3702 </span><span class="lineNoCov">          0 :     for ( cnt=0; glyphs[cnt]!=NULL; ++cnt ) {</span>
<span class="lineNum">    3703 </span><span class="lineNoCov">          0 :         data.str[cnt].sc = glyphs[cnt];</span>
<span class="lineNum">    3704 </span><span class="lineNoCov">          0 :         data.str[cnt].orig_index = cnt;</span>
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :         data.str[cnt].lig_pos = data.str[cnt].context_pos = -1;</span>
<span class="lineNum">    3706 </span>            :     }
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :     if ( sf-&gt;cidmaster!=NULL ) sf=sf-&gt;cidmaster;</span>
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :     data.sf = sf;</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :     data.pixelsize = pixelsize;</span>
<span class="lineNum">    3710 </span><span class="lineNoCov">          0 :     data.scale = pixelsize/(double) (sf-&gt;ascent+sf-&gt;descent);</span>
<span class="lineNum">    3711 </span>            : 
<span class="lineNum">    3712 </span>            :     /* Indic glyph reordering???? */
<span class="lineNum">    3713 </span><span class="lineNoCov">          0 :     for ( isgpos=0; isgpos&lt;2; ++isgpos ) {</span>
<span class="lineNum">    3714 </span>            :         /* Check that this table has an entry for this language */
<span class="lineNum">    3715 </span>            :         /*  if it doesn't use the default language */
<span class="lineNum">    3716 </span>            :         /* GPOS/GSUB may have different language sets, so we must be prepared */
<span class="lineNum">    3717 </span><span class="lineNoCov">          0 :         templang = lang;</span>
<span class="lineNum">    3718 </span><span class="lineNoCov">          0 :         langs = SFLangsInScript(sf,isgpos,script);</span>
<span class="lineNum">    3719 </span><span class="lineNoCov">          0 :         for ( i=0; langs[i]!=0 &amp;&amp; langs[i]!=lang; ++i );</span>
<span class="lineNum">    3720 </span><span class="lineNoCov">          0 :         if ( langs[i]==0 )</span>
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :             templang = DEFAULT_LANG;</span>
<span class="lineNum">    3722 </span><span class="lineNoCov">          0 :         free(langs);</span>
<span class="lineNum">    3723 </span>            : 
<span class="lineNum">    3724 </span><span class="lineNoCov">          0 :         for ( otl = isgpos ? sf-&gt;gpos_lookups : sf-&gt;gsub_lookups; otl!=NULL ; otl = otl-&gt;next ) {</span>
<span class="lineNum">    3725 </span>            :             uint32 tag;
<span class="lineNum">    3726 </span><span class="lineNoCov">          0 :             if ( (tag=FSLLMatches(otl-&gt;features,flist,script,templang))!=0 )</span>
<span class="lineNum">    3727 </span><span class="lineNoCov">          0 :                 ApplyLookup(tag,otl,&amp;data);</span>
<span class="lineNum">    3728 </span>            :         }
<span class="lineNum">    3729 </span>            :     }
<span class="lineNum">    3730 </span><span class="lineNoCov">          0 :     LigatureFree(&amp;data);</span>
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :     free(data.ligs);</span>
<span class="lineNum">    3732 </span>            : 
<span class="lineNum">    3733 </span><span class="lineNoCov">          0 :     data.str = realloc(data.str,(data.cnt+1)*sizeof(struct opentype_str));</span>
<span class="lineNum">    3734 </span><span class="lineNoCov">          0 :     memset(&amp;data.str[data.cnt],0,sizeof(struct opentype_str));</span>
<span class="lineNum">    3735 </span><span class="lineNoCov">          0 : return( data.str );</span>
<a name="3736"><span class="lineNum">    3736 </span>            : }</a>
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span><span class="lineNoCov">          0 : static void doreplace(char **haystack,char *start,const char *rpl,int slen) {</span>
<span class="lineNum">    3739 </span>            :     int rlen;
<span class="lineNum">    3740 </span><span class="lineNoCov">          0 :     char *pt = start+slen;</span>
<span class="lineNum">    3741 </span>            : 
<span class="lineNum">    3742 </span><span class="lineNoCov">          0 :     rlen = strlen(rpl);</span>
<span class="lineNum">    3743 </span><span class="lineNoCov">          0 :     if ( slen&gt;=rlen ) {</span>
<span class="lineNum">    3744 </span><span class="lineNoCov">          0 :         memcpy(start,rpl,rlen);</span>
<span class="lineNum">    3745 </span><span class="lineNoCov">          0 :         if ( slen&gt;rlen ) {</span>
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :             int diff = slen-rlen;</span>
<span class="lineNum">    3747 </span><span class="lineNoCov">          0 :             for ( ; *pt ; ++pt )</span>
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 :                 pt[-diff] = *pt;</span>
<span class="lineNum">    3749 </span><span class="lineNoCov">          0 :             pt[-diff] = '\0';</span>
<span class="lineNum">    3750 </span>            :         }
<span class="lineNum">    3751 </span>            :     } else {
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :         char *base = *haystack;</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :         char *new = malloc(pt-base+strlen(pt)+rlen-slen+1);</span>
<span class="lineNum">    3754 </span><span class="lineNoCov">          0 :         memcpy(new,base,start-base);</span>
<span class="lineNum">    3755 </span><span class="lineNoCov">          0 :         memcpy(new+(start-base),rpl,rlen);</span>
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :         strcpy(new+(start-base)+rlen,pt);</span>
<span class="lineNum">    3757 </span><span class="lineNoCov">          0 :         free( base );</span>
<span class="lineNum">    3758 </span><span class="lineNoCov">          0 :         *haystack = new;</span>
<span class="lineNum">    3759 </span>            :     }
<a name="3760"><span class="lineNum">    3760 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 : static int rplstr(char **haystack,const char *search, const char *rpl,int multipleoccurances) {</span>
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :     char *start, *pt, *base = *haystack;</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :     int ch, match, slen = strlen(search);</span>
<span class="lineNum">    3765 </span><span class="lineNoCov">          0 :     int any = 0;</span>
<span class="lineNum">    3766 </span>            : 
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :     if ( base==NULL )</span>
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    3769 </span>            : 
<span class="lineNum">    3770 </span><span class="lineNoCov">          0 :     for ( pt=base ; ; ) {</span>
<span class="lineNum">    3771 </span><span class="lineNoCov">          0 :         while ( *pt==' ' ) ++pt;</span>
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' )</span>
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 : return( any );</span>
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :         start=pt;</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :         while ( *pt!=' ' &amp;&amp; *pt!='\0' ) ++pt;</span>
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :         if ( pt-start!=slen )</span>
<span class="lineNum">    3777 </span><span class="lineNoCov">          0 :             match = -1;</span>
<span class="lineNum">    3778 </span>            :         else {
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :             ch = *pt; *pt='\0';</span>
<span class="lineNum">    3780 </span><span class="lineNoCov">          0 :             match = strcmp(start,search);</span>
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :             *pt = ch;</span>
<span class="lineNum">    3782 </span>            :         }
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :         if ( match==0 ) {</span>
<span class="lineNum">    3784 </span><span class="lineNoCov">          0 :             doreplace(haystack,start,rpl,slen);</span>
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :             if ( !multipleoccurances )</span>
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    3787 </span><span class="lineNoCov">          0 :             any = true;</span>
<span class="lineNum">    3788 </span><span class="lineNoCov">          0 :             if ( base!=*haystack ) {</span>
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :                 pt = *haystack + (start-base)+strlen(rpl);</span>
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :                 base = *haystack;</span>
<span class="lineNum">    3791 </span>            :             } else
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :                 pt = start+strlen(rpl);</span>
<span class="lineNum">    3793 </span>            :         }
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :     }</span>
<a name="3795"><span class="lineNum">    3795 </span>            : }</a>
<span class="lineNum">    3796 </span>            : 
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 : static int rplglyphname(char **haystack,const char *search, const char *rpl) {</span>
<span class="lineNum">    3798 </span>            :     /* If we change &quot;f&quot; to &quot;uni0066&quot; then we should also change &quot;f.sc&quot; to */
<span class="lineNum">    3799 </span>            :     /*  &quot;uni0066.sc&quot; and &quot;f_f_l&quot; to &quot;uni0066_uni0066_l&quot; */
<span class="lineNum">    3800 </span><span class="lineNoCov">          0 :     char *start, *pt, *base = *haystack;</span>
<span class="lineNum">    3801 </span>            :     int ch, match;
<span class="lineNum">    3802 </span><span class="lineNoCov">          0 :     size_t slen = strlen(search);</span>
<span class="lineNum">    3803 </span><span class="lineNoCov">          0 :     int any = 0;</span>
<span class="lineNum">    3804 </span>            : 
<span class="lineNum">    3805 </span><span class="lineNoCov">          0 :     if ( slen&gt;=strlen( base ))</span>
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    3807 </span>            : 
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :     for ( pt=base ; ; ) {</span>
<span class="lineNum">    3809 </span><span class="lineNoCov">          0 :         while ( *pt=='_' ) ++pt;</span>
<span class="lineNum">    3810 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' || *pt=='.' )</span>
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 : return( any );</span>
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :         start=pt;</span>
<span class="lineNum">    3813 </span><span class="lineNoCov">          0 :         while ( *pt!='_' &amp;&amp; *pt!='\0' &amp;&amp; *pt!='.' ) ++pt;</span>
<span class="lineNum">    3814 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' &amp;&amp; start==base ) /* Don't change any unsegmented names */</span>
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 : return( false );                        /* In particular don't rename ourselves*/</span>
<span class="lineNum">    3816 </span><span class="lineNoCov">          0 :         if ( pt-start!=(ptrdiff_t)slen )</span>
<span class="lineNum">    3817 </span><span class="lineNoCov">          0 :             match = -1;</span>
<span class="lineNum">    3818 </span>            :         else {
<span class="lineNum">    3819 </span><span class="lineNoCov">          0 :             ch = *pt; *pt='\0';</span>
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :             match = strcmp(start,search);</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :             *pt = ch;</span>
<span class="lineNum">    3822 </span>            :         }
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :         if ( match==0 ) {</span>
<span class="lineNum">    3824 </span><span class="lineNoCov">          0 :             doreplace(haystack,start,rpl,slen);</span>
<span class="lineNum">    3825 </span><span class="lineNoCov">          0 :             any = true;</span>
<span class="lineNum">    3826 </span><span class="lineNoCov">          0 :             if ( base!=*haystack ) {</span>
<span class="lineNum">    3827 </span><span class="lineNoCov">          0 :                 pt = *haystack + (start-base) + strlen(rpl);</span>
<span class="lineNum">    3828 </span><span class="lineNoCov">          0 :                 base = *haystack;</span>
<span class="lineNum">    3829 </span>            :             } else
<span class="lineNum">    3830 </span><span class="lineNoCov">          0 :                 pt = start+strlen(rpl);</span>
<span class="lineNum">    3831 </span>            :         }
<span class="lineNum">    3832 </span><span class="lineNoCov">          0 :     }</span>
<a name="3833"><span class="lineNum">    3833 </span>            : }</a>
<span class="lineNum">    3834 </span>            : 
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 : static int glyphnameIsComponent(const char *haystack, const char *search) {</span>
<span class="lineNum">    3836 </span>            :     /* Check for a glyph name in ligature names and dotted names */
<span class="lineNum">    3837 </span>            :     const char *start, *pt;
<span class="lineNum">    3838 </span><span class="lineNoCov">          0 :     size_t slen = strlen(search);</span>
<span class="lineNum">    3839 </span>            : 
<span class="lineNum">    3840 </span><span class="lineNoCov">          0 :     if ( slen&gt;=strlen( haystack ))</span>
<span class="lineNum">    3841 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    3842 </span>            : 
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :     for ( pt=haystack ; ; ) {</span>
<span class="lineNum">    3844 </span><span class="lineNoCov">          0 :         while ( *pt=='_' ) ++pt;</span>
<span class="lineNum">    3845 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' || *pt=='.' )</span>
<span class="lineNum">    3846 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    3847 </span><span class="lineNoCov">          0 :         start=pt;</span>
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :         while ( *pt!='_' &amp;&amp; *pt!='\0' &amp;&amp; *pt!='.' ) ++pt;</span>
<span class="lineNum">    3849 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' &amp;&amp; start==haystack )/* Don't change any unsegmented names */</span>
<span class="lineNum">    3850 </span><span class="lineNoCov">          0 : return( false );                        /* In particular don't rename ourselves*/</span>
<span class="lineNum">    3851 </span><span class="lineNoCov">          0 :         if ( pt-start==(ptrdiff_t)slen &amp;&amp; strncmp(start,search,slen)==0 )</span>
<span class="lineNum">    3852 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    3853 </span><span class="lineNoCov">          0 :     }</span>
<a name="3854"><span class="lineNum">    3854 </span>            : }</a>
<span class="lineNum">    3855 </span>            : 
<span class="lineNum">    3856 </span><span class="lineNoCov">          0 : static int gvfixup(struct glyphvariants *gv,const char *old, const char *new) {</span>
<span class="lineNum">    3857 </span>            :     int i;
<span class="lineNum">    3858 </span><span class="lineNoCov">          0 :     int ret=0;</span>
<span class="lineNum">    3859 </span>            : 
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 :     if ( gv==NULL )</span>
<span class="lineNum">    3861 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    3862 </span><span class="lineNoCov">          0 :     ret = rplstr(&amp;gv-&gt;variants,old,new,false);</span>
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;gv-&gt;part_cnt; ++i ) {</span>
<span class="lineNum">    3864 </span><span class="lineNoCov">          0 :         if ( strcmp(gv-&gt;parts[i].component,old)==0 ) {</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :             free( gv-&gt;parts[i].component);</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :             gv-&gt;parts[i].component = copy(new);</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :             ret = true;</span>
<span class="lineNum">    3868 </span>            :         }
<span class="lineNum">    3869 </span>            :     }
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 : return( ret );</span>
<a name="3871"><span class="lineNum">    3871 </span>            : }</a>
<span class="lineNum">    3872 </span>            : 
<span class="lineNum">    3873 </span><span class="lineNoCov">          0 : void SFGlyphRenameFixup(SplineFont *sf, const char *old, const char *new, int rename_related_glyphs) {</span>
<span class="lineNum">    3874 </span>            : /* NOTE: Existing GUI behaviour renames glyphs, rename_related_glyphs turns */
<span class="lineNum">    3875 </span>            : /* off this behaviour for scripting - see github issue #523 */
<span class="lineNum">    3876 </span>            :     int k, gid, isv;
<span class="lineNum">    3877 </span>            :     int i,r;
<span class="lineNum">    3878 </span><span class="lineNoCov">          0 :     SplineFont *master = sf;</span>
<span class="lineNum">    3879 </span>            :     SplineChar *sc;
<span class="lineNum">    3880 </span>            :     PST *pst;
<span class="lineNum">    3881 </span>            :     FPST *fpst;
<span class="lineNum">    3882 </span>            :     KernClass *kc;
<span class="lineNum">    3883 </span>            :     ASM *sm;
<span class="lineNum">    3884 </span>            : 
<span class="lineNum">    3885 </span><span class="lineNoCov">          0 :     CVGlyphRenameFixup(sf,old,new);</span>
<span class="lineNum">    3886 </span><span class="lineNoCov">          0 :     if ( sf-&gt;cidmaster!=NULL )</span>
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :         master = sf-&gt;cidmaster;</span>
<span class="lineNum">    3888 </span>            : 
<span class="lineNum">    3889 </span>            :     /* Look through all substitutions (and pairwise psts) stored on the glyphs*/
<span class="lineNum">    3890 </span>            :     /*  and change any occurances of the name */
<span class="lineNum">    3891 </span>            :     /* (KernPairs have a reference to the SC rather than the name, and need no fixup) */
<span class="lineNum">    3892 </span>            :     /* Also if the name is &quot;f&quot; then look for glyph names like &quot;f.sc&quot; or &quot;f_f_l&quot;*/
<span class="lineNum">    3893 </span>            :     /*  and be ready to change them too */
<span class="lineNum">    3894 </span><span class="lineNoCov">          0 :     k = 0;</span>
<span class="lineNum">    3895 </span>            :     do {
<span class="lineNum">    3896 </span><span class="lineNoCov">          0 :         sf = k&lt;master-&gt;subfontcnt ? master-&gt;subfonts[k] : master;</span>
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :         for ( gid=0; gid&lt;sf-&gt;glyphcnt; ++gid ) if ( (sc=sf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">    3898 </span><span class="lineNoCov">          0 :             if ( rename_related_glyphs &amp;&amp; glyphnameIsComponent(sc-&gt;name,old) ) {</span>
<span class="lineNum">    3899 </span><span class="lineNoCov">          0 :                 char *newer = copy(sc-&gt;name);</span>
<span class="lineNum">    3900 </span><span class="lineNoCov">          0 :                 rplglyphname(&amp;newer,old,new);</span>
<span class="lineNum">    3901 </span><span class="lineNoCov">          0 :                 SFGlyphRenameFixup(master,sc-&gt;name,newer,true);</span>
<span class="lineNum">    3902 </span><span class="lineNoCov">          0 :                 free(sc-&gt;name);</span>
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :                 sc-&gt;name = newer;</span>
<span class="lineNum">    3904 </span><span class="lineNoCov">          0 :                 sc-&gt;namechanged = sc-&gt;changed = true;</span>
<span class="lineNum">    3905 </span>            :             }
<span class="lineNum">    3906 </span><span class="lineNoCov">          0 :             for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">    3907 </span><span class="lineNoCov">          0 :                 if ( pst-&gt;type==pst_substitution || pst-&gt;type==pst_alternate ||</span>
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :                         pst-&gt;type==pst_multiple || pst-&gt;type==pst_pair ||</span>
<span class="lineNum">    3909 </span><span class="lineNoCov">          0 :                         pst-&gt;type==pst_ligature ) {</span>
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :                     if ( rplstr(&amp;pst-&gt;u.mult.components,old,new,pst-&gt;type==pst_ligature))</span>
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :                         sc-&gt;changed = true;</span>
<span class="lineNum">    3912 </span>            :                 }
<span class="lineNum">    3913 </span>            :             }
<span class="lineNum">    3914 </span>            :             /* For once I don't want a short circuit eval of &quot;or&quot;, so I use */
<span class="lineNum">    3915 </span>            :             /*  bitwise rather than boolean intentionally */
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :             if ( gvfixup(sc-&gt;vert_variants,old,new) |</span>
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 :                     gvfixup(sc-&gt;horiz_variants,old,new))</span>
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :                 sc-&gt;changed = true;</span>
<span class="lineNum">    3919 </span>            :         }
<span class="lineNum">    3920 </span><span class="lineNoCov">          0 :         ++k;</span>
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :     } while ( k&lt;master-&gt;subfontcnt );</span>
<span class="lineNum">    3922 </span>            : 
<span class="lineNum">    3923 </span>            :     /* Now look for contextual fpsts which might use the name */
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :     for ( fpst=master-&gt;possub; fpst!=NULL; fpst=fpst-&gt;next ) {</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;format==pst_class ) {</span>
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;fpst-&gt;nccnt; ++i ) if ( fpst-&gt;nclass[i]!=NULL ) {</span>
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :                 if ( rplstr(&amp;fpst-&gt;nclass[i],old,new,false))</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3929 </span>            :             }
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;fpst-&gt;bccnt; ++i ) if ( fpst-&gt;bclass[i]!=NULL ) {</span>
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :                 if ( rplstr(&amp;fpst-&gt;bclass[i],old,new,false))</span>
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3933 </span>            :             }
<span class="lineNum">    3934 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;fpst-&gt;fccnt; ++i ) if ( fpst-&gt;fclass[i]!=NULL ) {</span>
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :                 if ( rplstr(&amp;fpst-&gt;fclass[i],old,new,false))</span>
<span class="lineNum">    3936 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3937 </span>            :             }
<span class="lineNum">    3938 </span>            :         }
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :         for ( r=0; r&lt;fpst-&gt;rule_cnt; ++r ) {</span>
<span class="lineNum">    3940 </span><span class="lineNoCov">          0 :             struct fpst_rule *rule = &amp;fpst-&gt;rules[r];</span>
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format==pst_glyphs ) {</span>
<span class="lineNum">    3942 </span><span class="lineNoCov">          0 :                 rplstr(&amp;rule-&gt;u.glyph.names,old,new,true);</span>
<span class="lineNum">    3943 </span><span class="lineNoCov">          0 :                 rplstr(&amp;rule-&gt;u.glyph.back,old,new,true);</span>
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :                 rplstr(&amp;rule-&gt;u.glyph.fore,old,new,true);</span>
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :             } else if ( fpst-&gt;format==pst_coverage ||</span>
<span class="lineNum">    3946 </span><span class="lineNoCov">          0 :                     fpst-&gt;format==pst_reversecoverage ) {</span>
<span class="lineNum">    3947 </span><span class="lineNoCov">          0 :                 for ( i=0; i&lt;rule-&gt;u.coverage.ncnt ; ++i )</span>
<span class="lineNum">    3948 </span><span class="lineNoCov">          0 :                     rplstr(&amp;rule-&gt;u.coverage.ncovers[i],old,new,false);</span>
<span class="lineNum">    3949 </span><span class="lineNoCov">          0 :                 for ( i=0; i&lt;rule-&gt;u.coverage.bcnt ; ++i )</span>
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 :                     rplstr(&amp;rule-&gt;u.coverage.bcovers[i],old,new,false);</span>
<span class="lineNum">    3951 </span><span class="lineNoCov">          0 :                 for ( i=0; i&lt;rule-&gt;u.coverage.fcnt ; ++i )</span>
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :                     rplstr(&amp;rule-&gt;u.coverage.fcovers[i],old,new,false);</span>
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :                 if ( fpst-&gt;format==pst_reversecoverage )</span>
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :                     rplstr(&amp;rule-&gt;u.rcoverage.replacements,old,new,true);</span>
<span class="lineNum">    3955 </span>            :             }
<span class="lineNum">    3956 </span>            :         }
<span class="lineNum">    3957 </span>            :     }
<span class="lineNum">    3958 </span>            : 
<span class="lineNum">    3959 </span>            :     /* Now look for contextual apple state machines which might use the name */
<span class="lineNum">    3960 </span><span class="lineNoCov">          0 :     for ( sm = master-&gt;sm; sm!=NULL; sm=sm-&gt;next ) {</span>
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;sm-&gt;class_cnt; ++i ) if ( sm-&gt;classes[i]!=NULL ) {</span>
<span class="lineNum">    3962 </span><span class="lineNoCov">          0 :             if ( rplstr(&amp;sm-&gt;classes[i],old,new,false))</span>
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    3964 </span>            :         }
<span class="lineNum">    3965 </span>            :     }
<span class="lineNum">    3966 </span>            : 
<span class="lineNum">    3967 </span>            :     /* Now look for contextual kerning classes which might use the name */
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :     for ( isv=0; isv&lt;2; ++isv ) {</span>
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :         for ( kc=isv ? master-&gt;vkerns : master-&gt;kerns; kc!=NULL; kc=kc-&gt;next ) {</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;kc-&gt;first_cnt; ++i ) if ( kc-&gt;firsts[i]!=NULL ) {</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :                 if ( rplstr(&amp;kc-&gt;firsts[i],old,new,false))</span>
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3973 </span>            :             }
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;kc-&gt;second_cnt; ++i ) if ( kc-&gt;seconds[i]!=NULL ) {</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :                 if ( rplstr(&amp;kc-&gt;seconds[i],old,new,false))</span>
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3977 </span>            :             }
<span class="lineNum">    3978 </span>            :         }
<span class="lineNum">    3979 </span>            :     }
<a name="3980"><span class="lineNum">    3980 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3981 </span>            : 
<span class="lineNum">    3982 </span><span class="lineCov">      10182 : struct lookup_subtable *SFSubTableFindOrMake(SplineFont *sf,uint32 tag,uint32 script,</span>
<span class="lineNum">    3983 </span>            :         int lookup_type ) {
<span class="lineNum">    3984 </span>            :     OTLookup **base;
<span class="lineNum">    3985 </span><span class="lineCov">      10182 :     OTLookup *otl, *found=NULL;</span>
<span class="lineNum">    3986 </span><span class="lineCov">      10182 :     int isgpos = lookup_type&gt;=gpos_start;</span>
<span class="lineNum">    3987 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    3988 </span>            : 
<span class="lineNum">    3989 </span><span class="lineCov">      10182 :     if ( sf-&gt;cidmaster ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    3990 </span><span class="lineCov">      10182 :     base = isgpos ? &amp;sf-&gt;gpos_lookups : &amp;sf-&gt;gsub_lookups;</span>
<span class="lineNum">    3991 </span><span class="lineCov">      12935 :     for ( otl= *base; otl!=NULL; otl=otl-&gt;next ) {</span>
<span class="lineNum">    3992 </span><span class="lineCov">      25840 :         if ( otl-&gt;lookup_type==lookup_type &amp;&amp;</span>
<span class="lineNum">    3993 </span><span class="lineCov">      12920 :                 FeatureScriptTagInFeatureScriptList(tag,script,otl-&gt;features) ) {</span>
<span class="lineNum">    3994 </span><span class="lineCov">      10167 :             for ( sub = otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next )</span>
<span class="lineNum">    3995 </span><span class="lineCov">      10167 :                 if ( sub-&gt;kc==NULL )</span>
<span class="lineNum">    3996 </span><span class="lineCov">      10167 : return( sub );</span>
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 :             found = otl;</span>
<span class="lineNum">    3998 </span>            :         }
<span class="lineNum">    3999 </span>            :     }
<span class="lineNum">    4000 </span>            : 
<span class="lineNum">    4001 </span><span class="lineCov">         15 :     if ( found==NULL ) {</span>
<span class="lineNum">    4002 </span><span class="lineCov">         15 :         found = chunkalloc(sizeof(OTLookup));</span>
<span class="lineNum">    4003 </span><span class="lineCov">         15 :         found-&gt;lookup_type = lookup_type;</span>
<span class="lineNum">    4004 </span><span class="lineCov">         15 :         found-&gt;features = chunkalloc(sizeof(FeatureScriptLangList));</span>
<span class="lineNum">    4005 </span><span class="lineCov">         15 :         found-&gt;features-&gt;featuretag = tag;</span>
<span class="lineNum">    4006 </span><span class="lineCov">         15 :         found-&gt;features-&gt;scripts = chunkalloc(sizeof(struct scriptlanglist));</span>
<span class="lineNum">    4007 </span><span class="lineCov">         15 :         found-&gt;features-&gt;scripts-&gt;script = script;</span>
<span class="lineNum">    4008 </span><span class="lineCov">         15 :         found-&gt;features-&gt;scripts-&gt;langs[0] = DEFAULT_LANG;</span>
<span class="lineNum">    4009 </span><span class="lineCov">         15 :         found-&gt;features-&gt;scripts-&gt;lang_cnt = 1;</span>
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span><span class="lineCov">         15 :         SortInsertLookup(sf, found);</span>
<span class="lineNum">    4012 </span>            :     }
<span class="lineNum">    4013 </span>            : 
<span class="lineNum">    4014 </span><span class="lineCov">         15 :     sub = chunkalloc(sizeof(struct lookup_subtable));</span>
<span class="lineNum">    4015 </span><span class="lineCov">         15 :     sub-&gt;next = found-&gt;subtables;</span>
<span class="lineNum">    4016 </span><span class="lineCov">         15 :     found-&gt;subtables = sub;</span>
<span class="lineNum">    4017 </span><span class="lineCov">         15 :     sub-&gt;lookup = found;</span>
<span class="lineNum">    4018 </span><span class="lineCov">         15 :     sub-&gt;per_glyph_pst_or_kern = true;</span>
<span class="lineNum">    4019 </span>            : 
<span class="lineNum">    4020 </span><span class="lineCov">         15 :     NameOTLookup(found,sf);</span>
<span class="lineNum">    4021 </span><span class="lineCov">         15 : return( sub );</span>
<a name="4022"><span class="lineNum">    4022 </span>            : }</a>
<span class="lineNum">    4023 </span>            : 
<span class="lineNum">    4024 </span><span class="lineNoCov">          0 : struct lookup_subtable *SFSubTableMake(SplineFont *sf,uint32 tag,uint32 script,</span>
<span class="lineNum">    4025 </span>            :         int lookup_type ) {
<span class="lineNum">    4026 </span>            :     OTLookup **base;
<span class="lineNum">    4027 </span><span class="lineNoCov">          0 :     OTLookup *otl, *found=NULL;</span>
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 :     int isgpos = lookup_type&gt;=gpos_start;</span>
<span class="lineNum">    4029 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    4030 </span><span class="lineNoCov">          0 :     int isnew = false;</span>
<span class="lineNum">    4031 </span>            : 
<span class="lineNum">    4032 </span><span class="lineNoCov">          0 :     if ( sf-&gt;cidmaster ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :     base = isgpos ? &amp;sf-&gt;gpos_lookups : &amp;sf-&gt;gsub_lookups;</span>
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :     for ( otl= *base; otl!=NULL; otl=otl-&gt;next ) {</span>
<span class="lineNum">    4035 </span><span class="lineNoCov">          0 :         if ( otl-&gt;lookup_type==lookup_type &amp;&amp;</span>
<span class="lineNum">    4036 </span><span class="lineNoCov">          0 :                 FeatureScriptTagInFeatureScriptList(tag,script,otl-&gt;features) ) {</span>
<span class="lineNum">    4037 </span><span class="lineNoCov">          0 :             found = otl;</span>
<span class="lineNum">    4038 </span>            :         }
<span class="lineNum">    4039 </span>            :     }
<span class="lineNum">    4040 </span>            : 
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :     if ( found==NULL ) {</span>
<span class="lineNum">    4042 </span><span class="lineNoCov">          0 :         found = chunkalloc(sizeof(OTLookup));</span>
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :         found-&gt;lookup_type = lookup_type;</span>
<span class="lineNum">    4044 </span><span class="lineNoCov">          0 :         found-&gt;features = chunkalloc(sizeof(FeatureScriptLangList));</span>
<span class="lineNum">    4045 </span><span class="lineNoCov">          0 :         found-&gt;features-&gt;featuretag = tag;</span>
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :         found-&gt;features-&gt;scripts = chunkalloc(sizeof(struct scriptlanglist));</span>
<span class="lineNum">    4047 </span><span class="lineNoCov">          0 :         found-&gt;features-&gt;scripts-&gt;script = script;</span>
<span class="lineNum">    4048 </span><span class="lineNoCov">          0 :         found-&gt;features-&gt;scripts-&gt;langs[0] = DEFAULT_LANG;</span>
<span class="lineNum">    4049 </span><span class="lineNoCov">          0 :         found-&gt;features-&gt;scripts-&gt;lang_cnt = 1;</span>
<span class="lineNum">    4050 </span>            : 
<span class="lineNum">    4051 </span><span class="lineNoCov">          0 :         SortInsertLookup(sf, found);</span>
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :         isnew = true;</span>
<span class="lineNum">    4053 </span>            :     }
<span class="lineNum">    4054 </span>            : 
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 :     sub = chunkalloc(sizeof(struct lookup_subtable));</span>
<span class="lineNum">    4056 </span><span class="lineNoCov">          0 :     sub-&gt;next = found-&gt;subtables;</span>
<span class="lineNum">    4057 </span><span class="lineNoCov">          0 :     found-&gt;subtables = sub;</span>
<span class="lineNum">    4058 </span><span class="lineNoCov">          0 :     sub-&gt;lookup = found;</span>
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span><span class="lineNoCov">          0 :     if ( isnew )</span>
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :         NameOTLookup(found,sf);</span>
<span class="lineNum">    4062 </span><span class="lineNoCov">          0 : return( sub );</span>
<a name="4063"><span class="lineNum">    4063 </span>            : }</a>
<span class="lineNum">    4064 </span>            : 
<span class="lineNum">    4065 </span><span class="lineNoCov">          0 : int LookupUsedNested(SplineFont *sf,OTLookup *checkme) {</span>
<span class="lineNum">    4066 </span>            :     OTLookup *otl;
<span class="lineNum">    4067 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    4068 </span>            :     int r,c;
<span class="lineNum">    4069 </span>            : 
<span class="lineNum">    4070 </span><span class="lineNoCov">          0 :     if ( checkme-&gt;lookup_type&gt;=gpos_start )</span>
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :         otl = sf-&gt;gpos_lookups;</span>
<span class="lineNum">    4072 </span>            :     else
<span class="lineNum">    4073 </span><span class="lineNoCov">          0 :         otl = sf-&gt;gsub_lookups;</span>
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :     while ( otl!=NULL ) {</span>
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :         for ( sub = otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :             if ( sub-&gt;fpst!=NULL ) {</span>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :                 for ( r=0; r&lt;sub-&gt;fpst-&gt;rule_cnt; ++r ) {</span>
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :                     struct fpst_rule *rule = &amp;sub-&gt;fpst-&gt;rules[r];</span>
<span class="lineNum">    4079 </span><span class="lineNoCov">          0 :                     for ( c=0; c&lt;rule-&gt;lookup_cnt; ++c ) {</span>
<span class="lineNum">    4080 </span><span class="lineNoCov">          0 :                         if ( rule-&gt;lookups[c].lookup == checkme )</span>
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    4082 </span>            :                     }
<span class="lineNum">    4083 </span>            :                 }
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :             } else if ( otl-&gt;lookup_type==morx_context ) {</span>
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :                 for ( c = 0; c&lt;sub-&gt;sm-&gt;class_cnt*sub-&gt;sm-&gt;state_cnt; ++c ) {</span>
<span class="lineNum">    4086 </span><span class="lineNoCov">          0 :                     struct asm_state *state = &amp;sub-&gt;sm-&gt;state[c];</span>
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :                     if ( state-&gt;u.context.mark_lookup==checkme )</span>
<span class="lineNum">    4088 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    4089 </span><span class="lineNoCov">          0 :                     if ( state-&gt;u.context.cur_lookup==checkme )</span>
<span class="lineNum">    4090 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    4091 </span>            :                 }
<span class="lineNum">    4092 </span>            :             }
<span class="lineNum">    4093 </span>            :         }
<span class="lineNum">    4094 </span>            :     }
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 : return( false );</span>
<a name="4096"><span class="lineNum">    4096 </span>            : }</a>
<span class="lineNum">    4097 </span>            : 
<span class="lineNum">    4098 </span><span class="lineNoCov">          0 : static void AALTRemoveOld(SplineFont *sf) {</span>
<span class="lineNum">    4099 </span>            :     FeatureScriptLangList *fl, *prev;
<span class="lineNum">    4100 </span>            :     OTLookup *otl, *otlnext;
<span class="lineNum">    4101 </span>            : 
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 :     for ( otl=sf-&gt;gsub_lookups; otl!=NULL; otl=otlnext ) {</span>
<span class="lineNum">    4103 </span><span class="lineNoCov">          0 :         otlnext = otl-&gt;next;</span>
<span class="lineNum">    4104 </span><span class="lineNoCov">          0 :         prev = NULL;</span>
<span class="lineNum">    4105 </span><span class="lineNoCov">          0 :         for ( fl = otl-&gt;features; fl!=NULL; prev=fl, fl=fl-&gt;next ) {</span>
<span class="lineNum">    4106 </span><span class="lineNoCov">          0 :             if ( fl-&gt;featuretag==CHR('a','a','l','t') ) {</span>
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :                 if ( fl==otl-&gt;features &amp;&amp; fl-&gt;next==NULL &amp;&amp; !LookupUsedNested(sf,otl))</span>
<span class="lineNum">    4108 </span><span class="lineNoCov">          0 :                     SFRemoveLookup(sf,otl,0);</span>
<span class="lineNum">    4109 </span>            :                 else {
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :                     if ( prev==NULL )</span>
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :                         otl-&gt;features = fl-&gt;next;</span>
<span class="lineNum">    4112 </span>            :                     else
<span class="lineNum">    4113 </span><span class="lineNoCov">          0 :                         prev-&gt;next = fl-&gt;next;</span>
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :                     fl-&gt;next = NULL;</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :                     FeatureScriptLangListFree(fl);</span>
<span class="lineNum">    4116 </span>            :                 }
<span class="lineNum">    4117 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    4118 </span>            :             }
<span class="lineNum">    4119 </span>            :         }
<span class="lineNum">    4120 </span>            :     }
<a name="4121"><span class="lineNum">    4121 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4122 </span>            : 
<span class="lineNum">    4123 </span><span class="lineNoCov">          0 : void SllkFree(struct sllk *sllk,int sllk_cnt) {</span>
<span class="lineNum">    4124 </span>            :     int i;
<span class="lineNum">    4125 </span>            : 
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sllk_cnt; ++i ) {</span>
<span class="lineNum">    4127 </span><span class="lineNoCov">          0 :         free( sllk[i].langs );</span>
<span class="lineNum">    4128 </span><span class="lineNoCov">          0 :         free( sllk[i].lookups );</span>
<span class="lineNum">    4129 </span>            :     }
<span class="lineNum">    4130 </span><span class="lineNoCov">          0 :     free(sllk);</span>
<a name="4131"><span class="lineNum">    4131 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4132 </span>            : 
<span class="lineNum">    4133 </span><span class="lineNoCov">          0 : static void AddOTLToSllk(struct sllk *sllk, OTLookup *otl, struct scriptlanglist *sl) {</span>
<span class="lineNum">    4134 </span>            :     int i,j,k,l;
<span class="lineNum">    4135 </span>            : 
<span class="lineNum">    4136 </span><span class="lineNoCov">          0 :     if ( otl-&gt;lookup_type==gsub_single || otl-&gt;lookup_type==gsub_alternate ) {</span>
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;sllk-&gt;cnt; ++i )</span>
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :             if ( sllk-&gt;lookups[i]==otl )</span>
<span class="lineNum">    4139 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    4140 </span><span class="lineNoCov">          0 :         if ( i==sllk-&gt;cnt ) {</span>
<span class="lineNum">    4141 </span><span class="lineNoCov">          0 :             if ( sllk-&gt;cnt&gt;=sllk-&gt;max )</span>
<span class="lineNum">    4142 </span><span class="lineNoCov">          0 :                 sllk-&gt;lookups = realloc(sllk-&gt;lookups,(sllk-&gt;max+=5)*sizeof(OTLookup *));</span>
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 :             sllk-&gt;lookups[sllk-&gt;cnt++] = otl;</span>
<span class="lineNum">    4144 </span><span class="lineNoCov">          0 :             for ( l=0; l&lt;sl-&gt;lang_cnt; ++l ) {</span>
<span class="lineNum">    4145 </span><span class="lineNoCov">          0 :                 uint32 lang = l&lt;MAX_LANG ? sl-&gt;langs[l] : sl-&gt;morelangs[l-MAX_LANG];</span>
<span class="lineNum">    4146 </span><span class="lineNoCov">          0 :                 for ( j=0; j&lt;sllk-&gt;lcnt; ++j )</span>
<span class="lineNum">    4147 </span><span class="lineNoCov">          0 :                     if ( sllk-&gt;langs[j]==lang )</span>
<span class="lineNum">    4148 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4149 </span><span class="lineNoCov">          0 :                 if ( j==sllk-&gt;lcnt ) {</span>
<span class="lineNum">    4150 </span><span class="lineNoCov">          0 :                     if ( sllk-&gt;lcnt&gt;=sllk-&gt;lmax )</span>
<span class="lineNum">    4151 </span><span class="lineNoCov">          0 :                         sllk-&gt;langs = realloc(sllk-&gt;langs,(sllk-&gt;lmax+=sl-&gt;lang_cnt+MAX_LANG)*sizeof(uint32));</span>
<span class="lineNum">    4152 </span><span class="lineNoCov">          0 :                     sllk-&gt;langs[sllk-&gt;lcnt++] = lang;</span>
<span class="lineNum">    4153 </span>            :                 }
<span class="lineNum">    4154 </span>            :             }
<span class="lineNum">    4155 </span>            :         }
<span class="lineNum">    4156 </span><span class="lineNoCov">          0 :     } else if ( otl-&gt;lookup_type==gsub_context || otl-&gt;lookup_type==gsub_contextchain ) {</span>
<span class="lineNum">    4157 </span>            :         struct lookup_subtable *sub;
<span class="lineNum">    4158 </span><span class="lineNoCov">          0 :         for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :             FPST *fpst = sub-&gt;fpst;</span>
<span class="lineNum">    4160 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;fpst-&gt;rule_cnt; ++j ) {</span>
<span class="lineNum">    4161 </span><span class="lineNoCov">          0 :                 struct fpst_rule *r = &amp;fpst-&gt;rules[j];</span>
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :                 for ( k=0; k&lt;r-&gt;lookup_cnt; ++k )</span>
<span class="lineNum">    4163 </span><span class="lineNoCov">          0 :                     AddOTLToSllk(sllk,r-&gt;lookups[k].lookup,sl);</span>
<span class="lineNum">    4164 </span>            :             }
<span class="lineNum">    4165 </span>            :         }
<span class="lineNum">    4166 </span>            :     }
<span class="lineNum">    4167 </span>            :     /* reverse contextual chaining is weird and I shall ignore it. Adobe does too*/
<a name="4168"><span class="lineNum">    4168 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span><span class="lineNoCov">          0 : static char *ComponentsFromPSTs(PST **psts,int pcnt) {</span>
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 :     char **names=NULL;</span>
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :     int ncnt=0, nmax=0;</span>
<span class="lineNum">    4173 </span>            :     int i,j,len;
<span class="lineNum">    4174 </span>            :     char *ret;
<span class="lineNum">    4175 </span>            : 
<span class="lineNum">    4176 </span>            :     /* First find all the names */
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;pcnt; ++i ) {</span>
<span class="lineNum">    4178 </span><span class="lineNoCov">          0 :         char *nlist = psts[i]-&gt;u.alt.components;</span>
<span class="lineNum">    4179 </span>            :         char *start, *pt, ch;
<span class="lineNum">    4180 </span>            : 
<span class="lineNum">    4181 </span><span class="lineNoCov">          0 :         for ( start = nlist; ; ) {</span>
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :             while ( *start==' ' )</span>
<span class="lineNum">    4183 </span><span class="lineNoCov">          0 :                 ++start;</span>
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :             if ( *start=='\0' )</span>
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    4186 </span><span class="lineNoCov">          0 :             for ( pt=start; *pt!=' ' &amp;&amp; *pt!='\0'; ++pt );</span>
<span class="lineNum">    4187 </span><span class="lineNoCov">          0 :             ch = *pt; *pt = '\0';</span>
<span class="lineNum">    4188 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;ncnt; ++j )</span>
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :                 if ( strcmp( start,names[j])==0 )</span>
<span class="lineNum">    4190 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :             if ( j==ncnt ) {</span>
<span class="lineNum">    4192 </span><span class="lineNoCov">          0 :                 if ( ncnt&gt;=nmax )</span>
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :                     names = realloc(names,(nmax+=10)*sizeof(char *));</span>
<span class="lineNum">    4194 </span><span class="lineNoCov">          0 :                 names[ncnt++] = copy(start);</span>
<span class="lineNum">    4195 </span>            :             }
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :             *pt = ch;</span>
<span class="lineNum">    4197 </span><span class="lineNoCov">          0 :             start = pt;</span>
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    4199 </span>            :     }
<span class="lineNum">    4200 </span>            : 
<span class="lineNum">    4201 </span><span class="lineNoCov">          0 :     len = 0;</span>
<span class="lineNum">    4202 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;ncnt; ++i )</span>
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 :         len += strlen(names[i])+1;</span>
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :     if ( len==0 ) len=1;</span>
<span class="lineNum">    4205 </span><span class="lineNoCov">          0 :     ret = malloc(len);</span>
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :     len = 0;</span>
<span class="lineNum">    4207 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;ncnt; ++i ) {</span>
<span class="lineNum">    4208 </span><span class="lineNoCov">          0 :         strcpy(ret+len,names[i]);</span>
<span class="lineNum">    4209 </span><span class="lineNoCov">          0 :         len += strlen(names[i]);</span>
<span class="lineNum">    4210 </span><span class="lineNoCov">          0 :         ret[len++] = ' ';</span>
<span class="lineNum">    4211 </span>            :     }
<span class="lineNum">    4212 </span><span class="lineNoCov">          0 :     if ( len==0 )</span>
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :         *ret = '\0';</span>
<span class="lineNum">    4214 </span>            :     else
<span class="lineNum">    4215 </span><span class="lineNoCov">          0 :         ret[len-1] = '\0';</span>
<span class="lineNum">    4216 </span>            : 
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;ncnt; ++i )</span>
<span class="lineNum">    4218 </span><span class="lineNoCov">          0 :         free(names[i]);</span>
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 :     free(names);</span>
<span class="lineNum">    4220 </span><span class="lineNoCov">          0 : return( ret );</span>
<a name="4221"><span class="lineNum">    4221 </span>            : }</a>
<span class="lineNum">    4222 </span>            : 
<span class="lineNum">    4223 </span><span class="lineNoCov">          0 : static int SllkMatch(struct sllk *sllk,int s1,int s2) {</span>
<span class="lineNum">    4224 </span>            :     int i;
<span class="lineNum">    4225 </span>            : 
<span class="lineNum">    4226 </span><span class="lineNoCov">          0 :     if ( sllk[s1].cnt != sllk[s2].cnt )</span>
<span class="lineNum">    4227 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sllk[s1].cnt; ++i ) {</span>
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :         if ( sllk[s1].lookups[i] != sllk[s2].lookups[i] )</span>
<span class="lineNum">    4231 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    4232 </span>            :     }
<span class="lineNum">    4233 </span>            : 
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 : return( true );</span>
<a name="4235"><span class="lineNum">    4235 </span>            : }</a>
<span class="lineNum">    4236 </span>            : 
<span class="lineNum">    4237 </span><span class="lineNoCov">          0 : struct sllk *AddOTLToSllks( OTLookup *otl, struct sllk *sllk,</span>
<span class="lineNum">    4238 </span>            :         int *_sllk_cnt, int *_sllk_max ) {
<span class="lineNum">    4239 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">    4240 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">    4241 </span>            :     int s;
<span class="lineNum">    4242 </span>            : 
<span class="lineNum">    4243 </span><span class="lineNoCov">          0 :     for ( fl=otl-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">    4244 </span><span class="lineNoCov">          0 :         for ( sl=fl-&gt;scripts; sl!=NULL; sl=sl-&gt;next ) {</span>
<span class="lineNum">    4245 </span><span class="lineNoCov">          0 :             for ( s=0; s&lt;*_sllk_cnt; ++s )</span>
<span class="lineNum">    4246 </span><span class="lineNoCov">          0 :                 if ( sl-&gt;script == sllk[s].script )</span>
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :             if ( s==*_sllk_cnt ) {</span>
<span class="lineNum">    4249 </span><span class="lineNoCov">          0 :                 if ( *_sllk_cnt&gt;=*_sllk_max )</span>
<span class="lineNum">    4250 </span><span class="lineNoCov">          0 :                     sllk = realloc(sllk,((*_sllk_max)+=10)*sizeof(struct sllk));</span>
<span class="lineNum">    4251 </span><span class="lineNoCov">          0 :                 memset(&amp;sllk[*_sllk_cnt],0,sizeof(struct sllk));</span>
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :                 sllk[(*_sllk_cnt)++].script = sl-&gt;script;</span>
<span class="lineNum">    4253 </span>            :             }
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :             AddOTLToSllk(&amp;sllk[s], otl,sl);</span>
<span class="lineNum">    4255 </span>            :         }
<span class="lineNum">    4256 </span>            :     }
<span class="lineNum">    4257 </span><span class="lineNoCov">          0 : return( sllk );</span>
<a name="4258"><span class="lineNum">    4258 </span>            : }</a>
<span class="lineNum">    4259 </span>            : 
<span class="lineNum">    4260 </span><span class="lineNoCov">          0 : OTLookup *NewAALTLookup(SplineFont *sf,struct sllk *sllk, int sllk_cnt, int i) {</span>
<span class="lineNum">    4261 </span>            :     OTLookup *otl;
<span class="lineNum">    4262 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    4263 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">    4264 </span>            :     struct scriptlanglist *sl;
<span class="lineNum">    4265 </span>            :     PST **psts, *pst;
<span class="lineNum">    4266 </span>            :     int j,k,l;
<span class="lineNum">    4267 </span>            :     int gid,pcnt;
<span class="lineNum">    4268 </span>            :     SplineFont *_sf;
<span class="lineNum">    4269 </span>            :     SplineChar *sc;
<span class="lineNum">    4270 </span>            : 
<span class="lineNum">    4271 </span>            :     /* Make the new lookup (and all its supporting data structures) */
<span class="lineNum">    4272 </span><span class="lineNoCov">          0 :     otl = chunkalloc(sizeof(OTLookup));</span>
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :     otl-&gt;lookup_type = gsub_alternate;</span>
<span class="lineNum">    4274 </span><span class="lineNoCov">          0 :     otl-&gt;lookup_flags = sllk[i].lookups[0]-&gt;lookup_flags &amp; pst_r2l;</span>
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :     otl-&gt;features = fl = chunkalloc(sizeof(FeatureScriptLangList));</span>
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :     fl-&gt;featuretag = CHR('a','a','l','t');</span>
<span class="lineNum">    4277 </span>            :     /* Any other scripts with the same lookup set? */
<span class="lineNum">    4278 </span><span class="lineNoCov">          0 :     for ( j=i; j&lt;sllk_cnt; ++j ) {</span>
<span class="lineNum">    4279 </span><span class="lineNoCov">          0 :         if ( i==j || SllkMatch(sllk,i,j)) {</span>
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :             sl = chunkalloc(sizeof(struct scriptlanglist));</span>
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :             sl-&gt;next = fl-&gt;scripts;</span>
<span class="lineNum">    4282 </span><span class="lineNoCov">          0 :             fl-&gt;scripts = sl;</span>
<span class="lineNum">    4283 </span><span class="lineNoCov">          0 :             sl-&gt;script = sllk[j].script;</span>
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :             sl-&gt;lang_cnt = sllk[j].lcnt;</span>
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 :             if ( sl-&gt;lang_cnt&gt;MAX_LANG )</span>
<span class="lineNum">    4286 </span><span class="lineNoCov">          0 :                 sl-&gt;morelangs = malloc((sl-&gt;lang_cnt-MAX_LANG)*sizeof(uint32));</span>
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :             for ( l=0; l&lt;sl-&gt;lang_cnt; ++l )</span>
<span class="lineNum">    4288 </span><span class="lineNoCov">          0 :                 if ( l&lt;MAX_LANG )</span>
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :                     sl-&gt;langs[l] = sllk[j].langs[l];</span>
<span class="lineNum">    4290 </span>            :                 else
<span class="lineNum">    4291 </span><span class="lineNoCov">          0 :                     sl-&gt;morelangs[l-MAX_LANG] = sllk[j].langs[l];</span>
<span class="lineNum">    4292 </span><span class="lineNoCov">          0 :             if ( i!=j ) sllk[j].cnt = 0;        /* Mark as processed */</span>
<span class="lineNum">    4293 </span>            :         }
<span class="lineNum">    4294 </span>            :     }
<span class="lineNum">    4295 </span><span class="lineNoCov">          0 :     otl-&gt;subtables = sub = chunkalloc(sizeof(struct lookup_subtable));</span>
<span class="lineNum">    4296 </span><span class="lineNoCov">          0 :     sub-&gt;lookup = otl;</span>
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 :     sub-&gt;per_glyph_pst_or_kern = true;</span>
<span class="lineNum">    4298 </span>            : 
<span class="lineNum">    4299 </span>            :     /* Add it to the various lists it needs to be in */
<span class="lineNum">    4300 </span><span class="lineNoCov">          0 :     otl-&gt;next = sf-&gt;gsub_lookups;</span>
<span class="lineNum">    4301 </span><span class="lineNoCov">          0 :     sf-&gt;gsub_lookups = otl;</span>
<span class="lineNum">    4302 </span>            : 
<span class="lineNum">    4303 </span>            :     /* Now look at every glyph in the font, and see if it has any of the */
<span class="lineNum">    4304 </span>            :     /*  lookups we are interested in, and if it does, build a new pst */
<span class="lineNum">    4305 </span>            :     /*  containing all posibilities listed on any of them */
<span class="lineNum">    4306 </span><span class="lineNoCov">          0 :     if ( sf-&gt;cidmaster ) sf = sf-&gt;cidmaster;</span>
<span class="lineNum">    4307 </span><span class="lineNoCov">          0 :     psts = malloc(sllk[i].cnt*sizeof(PST *));</span>
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :     k=0;</span>
<span class="lineNum">    4309 </span>            :     do {
<span class="lineNum">    4310 </span><span class="lineNoCov">          0 :         _sf = k&lt;sf-&gt;subfontcnt ? sf-&gt;subfonts[k] : sf;</span>
<span class="lineNum">    4311 </span><span class="lineNoCov">          0 :         for ( gid=0; gid&lt;_sf-&gt;glyphcnt; ++gid ) if ( (sc = _sf-&gt;glyphs[gid])!=NULL ) {</span>
<span class="lineNum">    4312 </span><span class="lineNoCov">          0 :             pcnt = 0;</span>
<span class="lineNum">    4313 </span><span class="lineNoCov">          0 :             for ( pst=sc-&gt;possub; pst!=NULL; pst=pst-&gt;next ) {</span>
<span class="lineNum">    4314 </span><span class="lineNoCov">          0 :                 if ( pst-&gt;subtable==NULL )</span>
<span class="lineNum">    4315 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 :                 for ( j=0; j&lt;sllk[i].cnt; ++j )</span>
<span class="lineNum">    4317 </span><span class="lineNoCov">          0 :                     if ( pst-&gt;subtable-&gt;lookup == sllk[i].lookups[j] )</span>
<span class="lineNum">    4318 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4319 </span><span class="lineNoCov">          0 :                 if ( j&lt;sllk[i].cnt )</span>
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :                     psts[pcnt++] = pst;</span>
<span class="lineNum">    4321 </span>            :             }
<span class="lineNum">    4322 </span><span class="lineNoCov">          0 :             if ( pcnt==0 )</span>
<span class="lineNum">    4323 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    4324 </span><span class="lineNoCov">          0 :             pst = chunkalloc(sizeof(PST));</span>
<span class="lineNum">    4325 </span><span class="lineNoCov">          0 :             pst-&gt;subtable = sub;</span>
<span class="lineNum">    4326 </span><span class="lineNoCov">          0 :             pst-&gt;type = pst_alternate;</span>
<span class="lineNum">    4327 </span><span class="lineNoCov">          0 :             pst-&gt;next = sc-&gt;possub;</span>
<span class="lineNum">    4328 </span><span class="lineNoCov">          0 :             sc-&gt;possub = pst;</span>
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 :             pst-&gt;u.alt.components = ComponentsFromPSTs(psts,pcnt);</span>
<span class="lineNum">    4330 </span>            :         }
<span class="lineNum">    4331 </span><span class="lineNoCov">          0 :         ++k;</span>
<span class="lineNum">    4332 </span><span class="lineNoCov">          0 :     } while ( k&lt;sf-&gt;subfontcnt );</span>
<span class="lineNum">    4333 </span><span class="lineNoCov">          0 :     free(psts);</span>
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 :     NameOTLookup(otl,sf);</span>
<span class="lineNum">    4335 </span><span class="lineNoCov">          0 : return( otl );</span>
<a name="4336"><span class="lineNum">    4336 </span>            : }</a>
<span class="lineNum">    4337 </span>            : 
<span class="lineNum">    4338 </span><span class="lineNoCov">          0 : void AddNewAALTFeatures(SplineFont *sf) {</span>
<span class="lineNum">    4339 </span>            :     /* different script/lang combinations may need different 'aalt' lookups */
<span class="lineNum">    4340 </span>            :     /*  well, let's just say different script combinations */
<span class="lineNum">    4341 </span>            :     /* for each script/lang combo find all single/alternate subs for each */
<span class="lineNum">    4342 </span>            :     /*  glyph. Merge those choices and create new lookup with that info */
<span class="lineNum">    4343 </span><span class="lineNoCov">          0 :     struct sllk *sllk = NULL;</span>
<span class="lineNum">    4344 </span><span class="lineNoCov">          0 :     int sllk_cnt=0, sllk_max = 0;</span>
<span class="lineNum">    4345 </span>            :     int i;
<span class="lineNum">    4346 </span>            :     OTLookup *otl;
<span class="lineNum">    4347 </span>            : 
<span class="lineNum">    4348 </span><span class="lineNoCov">          0 :     AALTRemoveOld(sf);</span>
<span class="lineNum">    4349 </span>            : 
<span class="lineNum">    4350 </span>            :     /* Find all scripts, and all the single/alternate lookups for each */
<span class="lineNum">    4351 </span>            :     /*  and all the languages used for these in each script */
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :     for ( otl=sf-&gt;gsub_lookups; otl!=NULL; otl=otl-&gt;next ) {</span>
<span class="lineNum">    4353 </span><span class="lineNoCov">          0 :         sllk = AddOTLToSllks( otl, sllk, &amp;sllk_cnt, &amp;sllk_max );</span>
<span class="lineNum">    4354 </span>            :     }
<span class="lineNum">    4355 </span>            :     /* Each of these gets its own gsub_alternate lookup which gets inserted */
<span class="lineNum">    4356 </span>            :     /*  at the head of the lookup list. Each lookup has one subtable */
<span class="lineNum">    4357 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sllk_cnt; ++i ) {</span>
<span class="lineNum">    4358 </span><span class="lineNoCov">          0 :         if ( sllk[i].cnt==0 )           /* Script used, but provides no alternates */</span>
<span class="lineNum">    4359 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    4360 </span><span class="lineNoCov">          0 :         NewAALTLookup(sf,sllk,sllk_cnt,i);</span>
<span class="lineNum">    4361 </span>            :     }
<span class="lineNum">    4362 </span>            : 
<span class="lineNum">    4363 </span><span class="lineNoCov">          0 :     SllkFree(sllk,sllk_cnt);</span>
<span class="lineNum">    4364 </span><span class="lineNoCov">          0 : }</span>
<a name="4365"><span class="lineNum">    4365 </span>            : </a>
<span class="lineNum">    4366 </span>            : 
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 : int VerticalKernFeature(SplineFont *sf, OTLookup *otl, int ask) {</span>
<span class="lineNum">    4368 </span>            :     FeatureScriptLangList *fl;
<span class="lineNum">    4369 </span>            :     struct lookup_subtable *sub;
<span class="lineNum">    4370 </span>            :     KernClass *kc;
<span class="lineNum">    4371 </span>            :     char *buts[3];
<span class="lineNum">    4372 </span>            : 
<span class="lineNum">    4373 </span><span class="lineNoCov">          0 :     for ( fl=otl-&gt;features; fl!=NULL; fl=fl-&gt;next ) {</span>
<span class="lineNum">    4374 </span><span class="lineNoCov">          0 :         if ( fl-&gt;featuretag==CHR('k','e','r','n') )</span>
<span class="lineNum">    4375 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    4376 </span><span class="lineNoCov">          0 :         else if ( fl-&gt;featuretag==CHR('v','k','r','n') )</span>
<span class="lineNum">    4377 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    4378 </span>            :     }
<span class="lineNum">    4379 </span>            : 
<span class="lineNum">    4380 </span><span class="lineNoCov">          0 :     for ( sub=otl-&gt;subtables; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    4381 </span><span class="lineNoCov">          0 :         if ( sub-&gt;kc!=NULL ) {</span>
<span class="lineNum">    4382 </span><span class="lineNoCov">          0 :             for ( kc=sf-&gt;kerns; kc!=NULL; kc=kc-&gt;next )</span>
<span class="lineNum">    4383 </span><span class="lineNoCov">          0 :                 if ( kc==sub-&gt;kc )</span>
<span class="lineNum">    4384 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    4385 </span><span class="lineNoCov">          0 :             for ( kc=sf-&gt;vkerns; kc!=NULL; kc=kc-&gt;next )</span>
<span class="lineNum">    4386 </span><span class="lineNoCov">          0 :                 if ( kc==sub-&gt;kc )</span>
<span class="lineNum">    4387 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">    4388 </span>            :         }
<span class="lineNum">    4389 </span>            :     }
<span class="lineNum">    4390 </span>            : 
<span class="lineNum">    4391 </span><span class="lineNoCov">          0 :     if ( !ask )</span>
<span class="lineNum">    4392 </span><span class="lineNoCov">          0 : return( -1 );</span>
<span class="lineNum">    4393 </span>            : 
<span class="lineNum">    4394 </span><span class="lineNoCov">          0 :     buts[0] = _(&quot;_Horizontal&quot;); buts[1] = _(&quot;_Vertical&quot;); buts[2] = NULL;</span>
<span class="lineNum">    4395 </span><span class="lineNoCov">          0 : return( ff_ask(_(&quot;Kerning direction&quot;),(const char **) buts,0,1,_(&quot;Is this horizontal or vertical kerning data?&quot;)) );</span>
<a name="4396"><span class="lineNum">    4396 </span>            : }</a>
<span class="lineNum">    4397 </span>            : 
<span class="lineNum">    4398 </span><span class="lineNoCov">          0 : int IsAnchorClassUsed(SplineChar *sc,AnchorClass *an) {</span>
<span class="lineNum">    4399 </span>            :     AnchorPoint *ap;
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :     int waslig=0, sawentry=0, sawexit=0;</span>
<span class="lineNum">    4401 </span>            : 
<span class="lineNum">    4402 </span><span class="lineNoCov">          0 :     for ( ap=sc-&gt;anchor; ap!=NULL; ap=ap-&gt;next ) {</span>
<span class="lineNum">    4403 </span><span class="lineNoCov">          0 :         if ( ap-&gt;anchor==an ) {</span>
<span class="lineNum">    4404 </span><span class="lineNoCov">          0 :             if ( ap-&gt;type==at_centry )</span>
<span class="lineNum">    4405 </span><span class="lineNoCov">          0 :                 sawentry = true;</span>
<span class="lineNum">    4406 </span><span class="lineNoCov">          0 :             else if ( ap-&gt;type==at_cexit )</span>
<span class="lineNum">    4407 </span><span class="lineNoCov">          0 :                 sawexit = true;</span>
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 :             else if ( an-&gt;type==act_mkmk ) {</span>
<span class="lineNum">    4409 </span><span class="lineNoCov">          0 :                 if ( ap-&gt;type==at_basemark )</span>
<span class="lineNum">    4410 </span><span class="lineNoCov">          0 :                     sawexit = true;</span>
<span class="lineNum">    4411 </span>            :                 else
<span class="lineNum">    4412 </span><span class="lineNoCov">          0 :                     sawentry = true;</span>
<span class="lineNum">    4413 </span><span class="lineNoCov">          0 :             } else if ( an-&gt;type==act_unknown ) {</span>
<span class="lineNum">    4414 </span><span class="lineNoCov">          0 :                 if ( ap-&gt;type==at_basechar )</span>
<span class="lineNum">    4415 </span><span class="lineNoCov">          0 :                     sawexit = true;</span>
<span class="lineNum">    4416 </span>            :                 else
<span class="lineNum">    4417 </span><span class="lineNoCov">          0 :                     sawentry = true;</span>
<span class="lineNum">    4418 </span><span class="lineNoCov">          0 :             } else if ( ap-&gt;type!=at_baselig )</span>
<span class="lineNum">    4419 </span><span class="lineNoCov">          0 : return( -1 );</span>
<span class="lineNum">    4420 </span><span class="lineNoCov">          0 :             else if ( waslig&lt;ap-&gt;lig_index+1 )</span>
<span class="lineNum">    4421 </span><span class="lineNoCov">          0 :                 waslig = ap-&gt;lig_index+1;</span>
<span class="lineNum">    4422 </span>            :         }
<span class="lineNum">    4423 </span>            :     }
<span class="lineNum">    4424 </span><span class="lineNoCov">          0 :     if ( sawentry &amp;&amp; sawexit )</span>
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 : return( -1 );</span>
<span class="lineNum">    4426 </span><span class="lineNoCov">          0 :     else if ( sawentry )</span>
<span class="lineNum">    4427 </span><span class="lineNoCov">          0 : return( -2 );</span>
<span class="lineNum">    4428 </span><span class="lineNoCov">          0 :     else if ( sawexit )</span>
<span class="lineNum">    4429 </span><span class="lineNoCov">          0 : return( -3 );</span>
<span class="lineNum">    4430 </span><span class="lineNoCov">          0 : return( waslig );</span>
<a name="4431"><span class="lineNum">    4431 </span>            : }</a>
<span class="lineNum">    4432 </span>            : 
<span class="lineNum">    4433 </span><span class="lineCov">         32 : int PSTContains(const char *components,const char *name) {</span>
<span class="lineNum">    4434 </span>            :     const char *pt;
<span class="lineNum">    4435 </span><span class="lineCov">         32 :     int len = strlen(name);</span>
<span class="lineNum">    4436 </span>            : 
<span class="lineNum">    4437 </span><span class="lineCov">         32 :     for ( pt = strstr(components,name); pt!=NULL; pt = strstr(pt+len,name)) {</span>
<span class="lineNum">    4438 </span><span class="lineCov">          8 :         if (( pt==components || pt[-1]==' ') &amp;&amp; (pt[len]==' ' || pt[len]=='\0'))</span>
<span class="lineNum">    4439 </span><span class="lineCov">          8 : return( true );</span>
<span class="lineNum">    4440 </span>            :     }
<span class="lineNum">    4441 </span><span class="lineCov">         24 : return( false );</span>
<span class="lineNum">    4442 </span>            : }
<a name="4443"><span class="lineNum">    4443 </span>            : </a>
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span><span class="lineNoCov">          0 : int KernClassFindIndexContaining( char **firsts_or_seconds,</span>
<span class="lineNum">    4446 </span>            :                                   int firsts_or_seconds_size,
<span class="lineNum">    4447 </span>            :                                   const char *name )
<span class="lineNum">    4448 </span>            : {
<span class="lineNum">    4449 </span><span class="lineNoCov">          0 :     int ret = -1;</span>
<span class="lineNum">    4450 </span><span class="lineNoCov">          0 :     int i = 0 ;</span>
<span class="lineNum">    4451 </span>            : 
<span class="lineNum">    4452 </span><span class="lineNoCov">          0 :     for ( i=1; i &lt; firsts_or_seconds_size; ++i )</span>
<span class="lineNum">    4453 </span>            :     {
<span class="lineNum">    4454 </span><span class="lineNoCov">          0 :         if ( PSTContains(firsts_or_seconds[i],name) )</span>
<span class="lineNum">    4455 </span>            :         {
<span class="lineNum">    4456 </span><span class="lineNoCov">          0 :             ret = i;</span>
<span class="lineNum">    4457 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    4458 </span>            :         }
<span class="lineNum">    4459 </span>            :     }
<span class="lineNum">    4460 </span>            : 
<span class="lineNum">    4461 </span><span class="lineNoCov">          0 :     return ret;</span>
<span class="lineNum">    4462 </span>            : }
<a name="4463"><span class="lineNum">    4463 </span>            : </a>
<span class="lineNum">    4464 </span>            : 
<span class="lineNum">    4465 </span><span class="lineCov">          4 : int KernClassContains(KernClass *kc, const char *name1, const char *name2, int ordered ) {</span>
<span class="lineNum">    4466 </span><span class="lineCov">          4 :     int infirst=0, insecond=0, scpos1, kwpos1, scpos2, kwpos2;</span>
<span class="lineNum">    4467 </span>            :     int i;
<span class="lineNum">    4468 </span>            : 
<span class="lineNum">    4469 </span><span class="lineCov">         13 :     for ( i=1; i&lt;kc-&gt;first_cnt; ++i ) {</span>
<span class="lineNum">    4470 </span><span class="lineCov">          9 :         if ( PSTContains(kc-&gt;firsts[i],name1) ) {</span>
<span class="lineNum">    4471 </span><span class="lineCov">          4 :             scpos1 = i;</span>
<span class="lineNum">    4472 </span><span class="lineCov">          4 :             if ( ++infirst&gt;=3 )              /* The name occurs twice??? */</span>
<span class="lineNum">    4473 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4474 </span><span class="lineCov">          5 :         } else if ( PSTContains(kc-&gt;firsts[i],name2) ) {</span>
<span class="lineNum">    4475 </span><span class="lineNoCov">          0 :             kwpos1 = i;</span>
<span class="lineNum">    4476 </span><span class="lineNoCov">          0 :             if ( (infirst+=2)&gt;=3 )</span>
<span class="lineNum">    4477 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4478 </span>            :         }
<span class="lineNum">    4479 </span>            :     }
<span class="lineNum">    4480 </span><span class="lineCov">          4 :     if ( infirst==0 || infirst&gt;3 )</span>
<span class="lineNum">    4481 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    4482 </span><span class="lineCov">         13 :     for ( i=1; i&lt;kc-&gt;second_cnt; ++i ) {</span>
<span class="lineNum">    4483 </span><span class="lineCov">          9 :         if ( PSTContains(kc-&gt;seconds[i],name1) ) {</span>
<span class="lineNum">    4484 </span><span class="lineNoCov">          0 :             scpos2 = i;</span>
<span class="lineNum">    4485 </span><span class="lineNoCov">          0 :             if ( ++insecond&gt;=3 )</span>
<span class="lineNum">    4486 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4487 </span><span class="lineCov">          9 :         } else if ( PSTContains(kc-&gt;seconds[i],name2) ) {</span>
<span class="lineNum">    4488 </span><span class="lineCov">          4 :             kwpos2 = i;</span>
<span class="lineNum">    4489 </span><span class="lineCov">          4 :             if ( (insecond+=2)&gt;=3 )</span>
<span class="lineNum">    4490 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4491 </span>            :         }
<span class="lineNum">    4492 </span>            :     }
<span class="lineNum">    4493 </span><span class="lineCov">          4 :     if ( insecond==0 || insecond&gt;3 )</span>
<span class="lineNum">    4494 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    4495 </span><span class="lineCov">          4 :     if ( (infirst&amp;1) &amp;&amp; (insecond&amp;2) ) {</span>
<span class="lineNum">    4496 </span><span class="lineCov">          4 :         if ( kc-&gt;offsets[scpos1*kc-&gt;second_cnt+kwpos2]!=0 )</span>
<span class="lineNum">    4497 </span><span class="lineCov">          4 : return( kc-&gt;offsets[scpos1*kc-&gt;second_cnt+kwpos2] );</span>
<span class="lineNum">    4498 </span>            :     }
<span class="lineNum">    4499 </span><span class="lineNoCov">          0 :     if ( !ordered ) {</span>
<span class="lineNum">    4500 </span><span class="lineNoCov">          0 :         if ( (infirst&amp;2) &amp;&amp; (insecond&amp;1) ) {</span>
<span class="lineNum">    4501 </span><span class="lineNoCov">          0 :             if ( kc-&gt;offsets[kwpos1*kc-&gt;second_cnt+scpos2]!=0 )</span>
<span class="lineNum">    4502 </span><span class="lineNoCov">          0 : return( kc-&gt;offsets[kwpos1*kc-&gt;second_cnt+scpos2] );</span>
<span class="lineNum">    4503 </span>            :         }
<span class="lineNum">    4504 </span>            :     }
<span class="lineNum">    4505 </span><span class="lineNoCov">          0 : return( 0 );</span>
<a name="4506"><span class="lineNum">    4506 </span>            : }</a>
<span class="lineNum">    4507 </span>            : 
<span class="lineNum">    4508 </span><span class="lineNoCov">          0 : int KCFindName(const char *name, char **classnames, int cnt, int allow_class0 ) {</span>
<span class="lineNum">    4509 </span>            :     int i;
<span class="lineNum">    4510 </span>            :     char *pt, *end, ch;
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    4513 </span><span class="lineNoCov">          0 :         if ( classnames[i]==NULL )</span>
<span class="lineNum">    4514 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    4515 </span><span class="lineNoCov">          0 :         for ( pt = classnames[i]; *pt; pt=end+1 ) {</span>
<span class="lineNum">    4516 </span><span class="lineNoCov">          0 :             end = strchr(pt,' ');</span>
<span class="lineNum">    4517 </span><span class="lineNoCov">          0 :             if ( end==NULL ) end = pt+strlen(pt);</span>
<span class="lineNum">    4518 </span><span class="lineNoCov">          0 :             ch = *end;</span>
<span class="lineNum">    4519 </span><span class="lineNoCov">          0 :             *end = '\0';</span>
<span class="lineNum">    4520 </span><span class="lineNoCov">          0 :             if ( strcmp(pt,name)==0 ) {</span>
<span class="lineNum">    4521 </span><span class="lineNoCov">          0 :                 *end = ch;</span>
<span class="lineNum">    4522 </span><span class="lineNoCov">          0 : return( i );</span>
<span class="lineNum">    4523 </span>            :             }
<span class="lineNum">    4524 </span><span class="lineNoCov">          0 :             *end = ch;</span>
<span class="lineNum">    4525 </span><span class="lineNoCov">          0 :             if ( ch=='\0' )</span>
<span class="lineNum">    4526 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    4527 </span>            :         }
<span class="lineNum">    4528 </span>            :     }
<span class="lineNum">    4529 </span>            :     /* If class 0 is specified, then we didn't find anything. If class 0 is */
<span class="lineNum">    4530 </span>            :     /*  unspecified then it means &quot;anything&quot; so we found something */
<span class="lineNum">    4531 </span><span class="lineNoCov">          0 : return( classnames[0]!=NULL || !allow_class0 ? -1 : 0 );</span>
<span class="lineNum">    4532 </span>            : }
<a name="4533"><span class="lineNum">    4533 </span>            : </a>
<span class="lineNum">    4534 </span>            : /* Routines to generate human readable forms of FPST rules */
<span class="lineNum">    4535 </span><span class="lineNoCov">          0 : static void GrowBufferAddLookup(GrowBuf *gb,struct fpst_rule *rule, int seq) {</span>
<span class="lineNum">    4536 </span>            :     int i;
<span class="lineNum">    4537 </span>            : 
<span class="lineNum">    4538 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;rule-&gt;lookup_cnt; ++i ) {</span>
<span class="lineNum">    4539 </span><span class="lineNoCov">          0 :         if ( seq==rule-&gt;lookups[i].seq ) {</span>
<span class="lineNum">    4540 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(gb,&quot;@&lt;&quot;);</span>
<span class="lineNum">    4541 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(gb,rule-&gt;lookups[i].lookup-&gt;lookup_name);</span>
<span class="lineNum">    4542 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(gb,&quot;&gt; &quot;);</span>
<span class="lineNum">    4543 </span>            :         }
<span class="lineNum">    4544 </span>            :     }
<a name="4545"><span class="lineNum">    4545 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4546 </span>            : 
<span class="lineNum">    4547 </span><span class="lineNoCov">          0 : static void GrowBufferAddClass(GrowBuf *gb,int class_n,char **classnames, int class_cnt) {</span>
<span class="lineNum">    4548 </span>            :     char buffer[20], *str;
<span class="lineNum">    4549 </span>            : 
<span class="lineNum">    4550 </span><span class="lineNoCov">          0 :     if ( class_n&lt;0 || class_n&gt;=class_cnt ) {</span>
<span class="lineNum">    4551 </span><span class="lineNoCov">          0 :         IError(&quot;Bad class in FPST&quot; );</span>
<span class="lineNum">    4552 </span><span class="lineNoCov">          0 :         class_n = 0;</span>
<span class="lineNum">    4553 </span>            :     }
<span class="lineNum">    4554 </span><span class="lineNoCov">          0 :     if ( classnames==NULL || (str=classnames[class_n])==NULL ) {</span>
<span class="lineNum">    4555 </span><span class="lineNoCov">          0 :         sprintf( buffer,&quot;%d&quot;, class_n );</span>
<span class="lineNum">    4556 </span><span class="lineNoCov">          0 :         str = buffer;</span>
<span class="lineNum">    4557 </span>            :     }
<span class="lineNum">    4558 </span><span class="lineNoCov">          0 :     GrowBufferAddStr(gb,str);</span>
<span class="lineNum">    4559 </span><span class="lineNoCov">          0 :     GrowBufferAdd(gb,' ');</span>
<a name="4560"><span class="lineNum">    4560 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    4561 </span>            : 
<span class="lineNum">    4562 </span><span class="lineNoCov">          0 : int GlyphNameCnt(const char *pt) {</span>
<span class="lineNum">    4563 </span><span class="lineNoCov">          0 :     int cnt = 0;</span>
<span class="lineNum">    4564 </span>            : 
<span class="lineNum">    4565 </span><span class="lineNoCov">          0 :     while ( *pt ) {</span>
<span class="lineNum">    4566 </span><span class="lineNoCov">          0 :         while ( isspace( *pt )) ++pt;</span>
<span class="lineNum">    4567 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' )</span>
<span class="lineNum">    4568 </span><span class="lineNoCov">          0 : return( cnt );</span>
<span class="lineNum">    4569 </span><span class="lineNoCov">          0 :         ++cnt;</span>
<span class="lineNum">    4570 </span><span class="lineNoCov">          0 :         while ( !isspace(*pt) &amp;&amp; *pt!='\0' ) ++pt;</span>
<span class="lineNum">    4571 </span>            :     }
<span class="lineNum">    4572 </span><span class="lineNoCov">          0 : return( cnt );</span>
<a name="4573"><span class="lineNum">    4573 </span>            : }</a>
<span class="lineNum">    4574 </span>            : 
<span class="lineNum">    4575 </span><span class="lineNoCov">          0 : char *reverseGlyphNames(char *str) {</span>
<span class="lineNum">    4576 </span>            :     char *ret;
<span class="lineNum">    4577 </span>            :     char *rpt, *pt, *start, *spt;
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span><span class="lineNoCov">          0 :     if ( str==NULL )</span>
<span class="lineNum">    4580 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    4581 </span>            : 
<span class="lineNum">    4582 </span><span class="lineNoCov">          0 :     rpt = ret = malloc(strlen(str)+1);</span>
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :     *ret = '\0';</span>
<span class="lineNum">    4584 </span><span class="lineNoCov">          0 :     for ( pt=str+strlen(str); pt&gt;str; pt=start ) {</span>
<span class="lineNum">    4585 </span><span class="lineNoCov">          0 :         for ( start = pt-1; start&gt;=str &amp;&amp; *start!=' '; --start );</span>
<span class="lineNum">    4586 </span><span class="lineNoCov">          0 :         for ( spt=start+1; spt&lt;pt; )</span>
<span class="lineNum">    4587 </span><span class="lineNoCov">          0 :             *rpt++ = *spt++;</span>
<span class="lineNum">    4588 </span><span class="lineNoCov">          0 :         *rpt++ = ' ';</span>
<span class="lineNum">    4589 </span>            :     }
<span class="lineNum">    4590 </span><span class="lineNoCov">          0 :     if ( rpt&gt;ret )</span>
<span class="lineNum">    4591 </span><span class="lineNoCov">          0 :         rpt[-1] = '\0';</span>
<span class="lineNum">    4592 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    4593 </span>            : }
<span class="lineNum">    4594 </span>            : 
<span class="lineNum">    4595 </span>            : /* Note: My string format cannot represent contextual rules were the order */
<span class="lineNum">    4596 </span>            : /*  of application of lookups is not the same as textual order. This rarely */
<a name="4597"><span class="lineNum">    4597 </span>            : /*  happens. Adobe's feature files have the same drawback. And there are */</a>
<span class="lineNum">    4598 </span>            : /*  rarely two or more lookups applied by one rule. But it could, so be aware!*/
<span class="lineNum">    4599 </span><span class="lineNoCov">          0 : char *FPSTRule_To_Str(SplineFont *sf,FPST *fpst,struct fpst_rule *rule) {</span>
<span class="lineNum">    4600 </span><span class="lineNoCov">          0 :     int i, max=0;</span>
<span class="lineNum">    4601 </span>            :     char *ret, *npt;
<span class="lineNum">    4602 </span><span class="lineNoCov">          0 :     int seq=0;</span>
<span class="lineNum">    4603 </span>            :     GrowBuf gb;
<span class="lineNum">    4604 </span>            : 
<span class="lineNum">    4605 </span>            :     /* Note that nothing in the output distinquishes between back, match and forward */
<span class="lineNum">    4606 </span>            :     /*  the thought being that to all intents and purposes, match starts at */
<span class="lineNum">    4607 </span>            :     /*  the first lookup and ends at the last. Anything before is back, */
<span class="lineNum">    4608 </span>            :     /*  anything after is for */ /* Adobe uses this convention in feature files*/
<span class="lineNum">    4609 </span>            :     /* Drat. That doesn't work for classes if the back/fore classes differ */
<span class="lineNum">    4610 </span>            :     /*  from match classes */ /* Adobe doesn't support classes in feature files*/
<span class="lineNum">    4611 </span>            :     /* Nor does it work when the lookup needs more than one input characters */
<span class="lineNum">    4612 </span>            :     /*  ligature lookups */
<span class="lineNum">    4613 </span><span class="lineNoCov">          0 :     memset(&amp;gb,0,sizeof(gb));</span>
<span class="lineNum">    4614 </span><span class="lineNoCov">          0 :     switch ( fpst-&gt;format ) {</span>
<span class="lineNum">    4615 </span>            :       case pst_glyphs:
<span class="lineNum">    4616 </span><span class="lineNoCov">          0 :         max = ( rule-&gt;u.glyph.names ? strlen(rule-&gt;u.glyph.names) : 0 ) +</span>
<span class="lineNum">    4617 </span><span class="lineNoCov">          0 :                 ( rule-&gt;u.glyph.back ? strlen(rule-&gt;u.glyph.back) : 0 ) +</span>
<span class="lineNum">    4618 </span><span class="lineNoCov">          0 :                 ( rule-&gt;u.glyph.fore ? strlen(rule-&gt;u.glyph.fore) : 0 ) +</span>
<span class="lineNum">    4619 </span>            :                 200;
<span class="lineNum">    4620 </span><span class="lineNoCov">          0 :         gb.base = gb.pt = malloc(max+1);</span>
<span class="lineNum">    4621 </span><span class="lineNoCov">          0 :         gb.end = gb.base+max;</span>
<span class="lineNum">    4622 </span><span class="lineNoCov">          0 :         if ( rule-&gt;u.glyph.back!=NULL ) {</span>
<span class="lineNum">    4623 </span>            :             char *temp;
<span class="lineNum">    4624 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,(temp = reverseGlyphNames(rule-&gt;u.glyph.back)));</span>
<span class="lineNum">    4625 </span><span class="lineNoCov">          0 :             free(temp);</span>
<span class="lineNum">    4626 </span><span class="lineNoCov">          0 :             GrowBufferAdd(&amp;gb,' ');</span>
<span class="lineNum">    4627 </span>            :         }
<span class="lineNum">    4628 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type!=pst_contextpos &amp;&amp; fpst-&gt;type!=pst_contextsub )</span>
<span class="lineNum">    4629 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;| &quot;);</span>
<span class="lineNum">    4630 </span><span class="lineNoCov">          0 :         for ( npt=rule-&gt;u.glyph.names; isspace(*npt); ++npt)</span>
<span class="lineNum">    4631 </span>            :             /* Skip over leading spaces, if any */;
<span class="lineNum">    4632 </span><span class="lineNoCov">          0 :         for ( npt=rule-&gt;u.glyph.names, seq=0; *npt; ++seq ) {</span>
<span class="lineNum">    4633 </span><span class="lineNoCov">          0 :             while ( isspace(*npt))</span>
<span class="lineNum">    4634 </span><span class="lineNoCov">          0 :                 ++npt;</span>
<span class="lineNum">    4635 </span><span class="lineNoCov">          0 :             while ( *npt!='\0' &amp;&amp; !isspace( *npt ) ) {</span>
<span class="lineNum">    4636 </span><span class="lineNoCov">          0 :                 GrowBufferAdd(&amp;gb, *npt++);</span>
<span class="lineNum">    4637 </span>            :             }
<span class="lineNum">    4638 </span><span class="lineNoCov">          0 :             GrowBufferAdd(&amp;gb,' ');</span>
<span class="lineNum">    4639 </span><span class="lineNoCov">          0 :             GrowBufferAddLookup(&amp;gb,rule,seq);</span>
<span class="lineNum">    4640 </span>            :         }
<span class="lineNum">    4641 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type!=pst_contextpos &amp;&amp; fpst-&gt;type!=pst_contextsub )</span>
<span class="lineNum">    4642 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;| &quot;);</span>
<span class="lineNum">    4643 </span><span class="lineNoCov">          0 :         if ( rule-&gt;u.glyph.fore!=NULL ) {</span>
<span class="lineNum">    4644 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,rule-&gt;u.glyph.fore);</span>
<span class="lineNum">    4645 </span>            :         }
<span class="lineNum">    4646 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4647 </span>            :       case pst_class:
<span class="lineNum">    4648 </span>            :         /* Reverse the backtrack classes */
<span class="lineNum">    4649 </span><span class="lineNoCov">          0 :         for ( i=rule-&gt;u.class.bcnt-1; i&gt;=0; --i )</span>
<span class="lineNum">    4650 </span><span class="lineNoCov">          0 :             GrowBufferAddClass(&amp;gb,rule-&gt;u.class.bclasses[i],fpst-&gt;bclassnames,fpst-&gt;bccnt);</span>
<span class="lineNum">    4651 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type!=pst_contextpos &amp;&amp; fpst-&gt;type!=pst_contextsub )</span>
<span class="lineNum">    4652 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;| &quot;);</span>
<span class="lineNum">    4653 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;rule-&gt;u.class.ncnt; ++i ) {</span>
<span class="lineNum">    4654 </span><span class="lineNoCov">          0 :             GrowBufferAddClass(&amp;gb,rule-&gt;u.class.nclasses[i],fpst-&gt;nclassnames,fpst-&gt;nccnt);</span>
<span class="lineNum">    4655 </span><span class="lineNoCov">          0 :             GrowBufferAddLookup(&amp;gb,rule,i);</span>
<span class="lineNum">    4656 </span>            :         }
<span class="lineNum">    4657 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type!=pst_contextpos &amp;&amp; fpst-&gt;type!=pst_contextsub )</span>
<span class="lineNum">    4658 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;| &quot;);</span>
<span class="lineNum">    4659 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;rule-&gt;u.class.fcnt; ++i )</span>
<span class="lineNum">    4660 </span><span class="lineNoCov">          0 :             GrowBufferAddClass(&amp;gb,rule-&gt;u.class.fclasses[i],fpst-&gt;fclassnames,fpst-&gt;fccnt);</span>
<span class="lineNum">    4661 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4662 </span>            :       case pst_coverage:
<span class="lineNum">    4663 </span>            :       case pst_reversecoverage:
<span class="lineNum">    4664 </span>            :         /* Reverse the backtrack tables */
<span class="lineNum">    4665 </span><span class="lineNoCov">          0 :         for ( i=rule-&gt;u.coverage.bcnt-1; i&gt;=0; --i ) {</span>
<span class="lineNum">    4666 </span><span class="lineNoCov">          0 :             GrowBufferAdd(&amp;gb,'[');</span>
<span class="lineNum">    4667 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,rule-&gt;u.coverage.bcovers[i]);</span>
<span class="lineNum">    4668 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;] &quot;);</span>
<span class="lineNum">    4669 </span>            :         }
<span class="lineNum">    4670 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type!=pst_contextpos &amp;&amp; fpst-&gt;type!=pst_contextsub )</span>
<span class="lineNum">    4671 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;| &quot;);</span>
<span class="lineNum">    4672 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;rule-&gt;u.coverage.ncnt; ++i ) {</span>
<span class="lineNum">    4673 </span><span class="lineNoCov">          0 :             GrowBufferAdd(&amp;gb,'[');</span>
<span class="lineNum">    4674 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,rule-&gt;u.coverage.ncovers[i]);</span>
<span class="lineNum">    4675 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;] &quot;);</span>
<span class="lineNum">    4676 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format==pst_reversecoverage ) {</span>
<span class="lineNum">    4677 </span><span class="lineNoCov">          0 :                 GrowBufferAddStr(&amp;gb,&quot;=&gt; [&quot;);</span>
<span class="lineNum">    4678 </span><span class="lineNoCov">          0 :                 GrowBufferAddStr(&amp;gb,rule-&gt;u.rcoverage.replacements);</span>
<span class="lineNum">    4679 </span><span class="lineNoCov">          0 :                 GrowBufferAddStr(&amp;gb,&quot;] &quot;);</span>
<span class="lineNum">    4680 </span>            :             } else {
<span class="lineNum">    4681 </span><span class="lineNoCov">          0 :                 GrowBufferAddLookup(&amp;gb,rule,i);</span>
<span class="lineNum">    4682 </span>            :             }
<span class="lineNum">    4683 </span>            :         }
<span class="lineNum">    4684 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;type!=pst_contextpos &amp;&amp; fpst-&gt;type!=pst_contextsub )</span>
<span class="lineNum">    4685 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;| &quot;);</span>
<span class="lineNum">    4686 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;rule-&gt;u.coverage.fcnt; ++i ) {</span>
<span class="lineNum">    4687 </span><span class="lineNoCov">          0 :             GrowBufferAdd(&amp;gb,'[');</span>
<span class="lineNum">    4688 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,rule-&gt;u.coverage.fcovers[i]);</span>
<span class="lineNum">    4689 </span><span class="lineNoCov">          0 :             GrowBufferAddStr(&amp;gb,&quot;] &quot;);</span>
<span class="lineNum">    4690 </span>            :         }
<span class="lineNum">    4691 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4692 </span>            :       default:
<span class="lineNum">    4693 </span><span class="lineNoCov">          0 :         IError( &quot;Bad FPST format&quot;);</span>
<span class="lineNum">    4694 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    4695 </span>            :     }
<span class="lineNum">    4696 </span><span class="lineNoCov">          0 :     if ( gb.pt&gt;gb.base &amp;&amp; gb.pt[-1]==' ' )</span>
<span class="lineNum">    4697 </span><span class="lineNoCov">          0 :         gb.pt[-1] = '\0';</span>
<span class="lineNum">    4698 </span><span class="lineNoCov">          0 :     ret = copy(gb.base);</span>
<span class="lineNum">    4699 </span><span class="lineNoCov">          0 :     free(gb.base);</span>
<span class="lineNum">    4700 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    4701 </span>            : }
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span>            : typedef struct lookuplist {
<span class="lineNum">    4704 </span>            :     OTLookup *lookup;
<span class="lineNum">    4705 </span>            :     struct lookuplist *next;
<span class="lineNum">    4706 </span>            : } LookupList;
<span class="lineNum">    4707 </span>            : 
<span class="lineNum">    4708 </span>            : typedef struct matchstr {
<span class="lineNum">    4709 </span>            :     char *entity;
<span class="lineNum">    4710 </span>            :     char *replacements;         /* For reverse contextual chaining */
<span class="lineNum">    4711 </span>            :     LookupList *lookups;
<span class="lineNum">    4712 </span>            : } MatchStr;
<span class="lineNum">    4713 </span>            : 
<a name="4714"><span class="lineNum">    4714 </span>            : /* Returns an error message, a warning, or NULL if parsing were successful */</a>
<span class="lineNum">    4715 </span>            : /*  if successful rule will be filled in. Error msg must be freed */
<span class="lineNum">    4716 </span><span class="lineNoCov">          0 : char *FPSTRule_From_Str(SplineFont *sf,FPST *fpst,struct fpst_rule *rule,</span>
<span class="lineNum">    4717 </span>            :         char *line, int *return_is_warning ) {
<span class="lineNum">    4718 </span>            :     char *lpt, *start, *end;
<span class="lineNum">    4719 </span>            :     int ch;
<span class="lineNum">    4720 </span><span class="lineNoCov">          0 :     int do_replacements=0, anylookup=0;</span>
<span class="lineNum">    4721 </span><span class="lineNoCov">          0 :     int cnt=0, max=0;</span>
<span class="lineNum">    4722 </span><span class="lineNoCov">          0 :     MatchStr *parsed=NULL;</span>
<span class="lineNum">    4723 </span>            :     LookupList *ll, *llp;
<span class="lineNum">    4724 </span>            :     int i,j,first,last;
<span class="lineNum">    4725 </span>            :     char *ret;
<span class="lineNum">    4726 </span><span class="lineNoCov">          0 :     int isgpos = fpst-&gt;type==pst_contextpos || fpst-&gt;type==pst_chainpos;</span>
<span class="lineNum">    4727 </span>            :     OTLookup *lookup;
<span class="lineNum">    4728 </span>            : 
<span class="lineNum">    4729 </span>            :     /* Parse the string into meaningful chunks. These could be:
<span class="lineNum">    4730 </span>            :         A coverage table (a list of glyph names enclosed in []
<span class="lineNum">    4731 </span>            :         A glyph name    (I'll accept this as a degenerate coverage table containing one glyph)
<span class="lineNum">    4732 </span>            :         A class name
<span class="lineNum">    4733 </span>            :         A lookup invocation
<span class="lineNum">    4734 </span>            :         A list of replacement glyphs for a reverse contextual chaining lookup
<span class="lineNum">    4735 </span>            :             (This is a two step process. First parse the replacement marker &quot;=&gt;&quot;
<span class="lineNum">    4736 </span>            :              then parse the coverage table)
<span class="lineNum">    4737 </span>            :         We can also have a mark that we've switched from the backtracking list
<span class="lineNum">    4738 </span>            :             to the match list to the forward list. Might be needed for classes
<span class="lineNum">    4739 </span>            :     */
<span class="lineNum">    4740 </span>            : 
<span class="lineNum">    4741 </span><span class="lineNoCov">          0 :     first = last = -1;</span>
<span class="lineNum">    4742 </span><span class="lineNoCov">          0 :     *return_is_warning = false;</span>
<span class="lineNum">    4743 </span><span class="lineNoCov">          0 :     for ( lpt=line; *lpt; ) {</span>
<span class="lineNum">    4744 </span><span class="lineNoCov">          0 :         while ( isspace(*lpt)) ++lpt;</span>
<span class="lineNum">    4745 </span><span class="lineNoCov">          0 :         if ( *lpt=='\0' )</span>
<span class="lineNum">    4746 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4747 </span><span class="lineNoCov">          0 :         start = lpt;</span>
<span class="lineNum">    4748 </span><span class="lineNoCov">          0 :         if ( *start=='|' ) {</span>
<span class="lineNum">    4749 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;type==pst_contextpos || fpst-&gt;type==pst_contextsub )</span>
<span class="lineNum">    4750 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;Separation marks only meaningful in contextual chaining lookups, starting at: %.20s...&quot;), lpt ));</span>
<span class="lineNum">    4751 </span><span class="lineNoCov">          0 :             if ( first==-1 )</span>
<span class="lineNum">    4752 </span><span class="lineNoCov">          0 :                 first = cnt;</span>
<span class="lineNum">    4753 </span><span class="lineNoCov">          0 :             else if ( last==-1 )</span>
<span class="lineNum">    4754 </span><span class="lineNoCov">          0 :                 last = cnt-1;</span>
<span class="lineNum">    4755 </span>            :             else
<span class="lineNum">    4756 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;Too many separation marks, starting at: %.20s...&quot;), lpt ));</span>
<span class="lineNum">    4757 </span><span class="lineNoCov">          0 :             ++lpt;</span>
<span class="lineNum">    4758 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    4759 </span><span class="lineNoCov">          0 :         } else if ( *start=='[' ) {</span>
<span class="lineNum">    4760 </span>            :             /* A coverage table */
<span class="lineNum">    4761 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format!=pst_coverage &amp;&amp; fpst-&gt;format!=pst_reversecoverage )</span>
<span class="lineNum">    4762 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;A coverage table was found in a glyph or class based contextual lookup, starting at: %.20s...&quot;), lpt ));</span>
<span class="lineNum">    4763 </span><span class="lineNoCov">          0 :             ++start;</span>
<span class="lineNum">    4764 </span><span class="lineNoCov">          0 :             for ( lpt = start; *lpt!='\0' &amp;&amp; *lpt!=']'; ++lpt );</span>
<span class="lineNum">    4765 </span><span class="lineNoCov">          0 :             if ( *lpt!=']' )</span>
<span class="lineNum">    4766 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;Unterminated coverage table, starting at: %.20s...&quot;), start-1 ));</span>
<span class="lineNum">    4767 </span><span class="lineNoCov">          0 :             end = lpt++;</span>
<span class="lineNum">    4768 </span><span class="lineNoCov">          0 :             if ( do_replacements==1 ) {</span>
<span class="lineNum">    4769 </span>            :                 int rcnt, ecnt;
<span class="lineNum">    4770 </span><span class="lineNoCov">          0 :                 do_replacements = 2;</span>
<span class="lineNum">    4771 </span><span class="lineNoCov">          0 :                 if ( cnt==0 )</span>
<span class="lineNum">    4772 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;Replacements must follow the coverage table to which they apply: %s&quot;), start-4 ));</span>
<span class="lineNum">    4773 </span><span class="lineNoCov">          0 :                 ch = *end; *end = '\0';</span>
<span class="lineNum">    4774 </span><span class="lineNoCov">          0 :                 parsed[cnt].replacements = copy(start);</span>
<span class="lineNum">    4775 </span><span class="lineNoCov">          0 :                 *end = ch;</span>
<span class="lineNum">    4776 </span><span class="lineNoCov">          0 :                 rcnt = GlyphNameCnt(parsed[cnt].replacements);</span>
<span class="lineNum">    4777 </span><span class="lineNoCov">          0 :                 ecnt = GlyphNameCnt(parsed[cnt].entity);</span>
<span class="lineNum">    4778 </span><span class="lineNoCov">          0 :                 if ( ecnt==rcnt )</span>
<span class="lineNum">    4779 </span>            :                     /* Good */;
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :                 else if ( rcnt==1 &amp;&amp; ecnt&gt;1 ) {</span>
<span class="lineNum">    4781 </span>            :                     char *newr;
<span class="lineNum">    4782 </span><span class="lineNoCov">          0 :                     newr = malloc(ecnt*(strlen(parsed[cnt].replacements)+1)+1);</span>
<span class="lineNum">    4783 </span><span class="lineNoCov">          0 :                     *newr = '\0';</span>
<span class="lineNum">    4784 </span><span class="lineNoCov">          0 :                     for ( i=0; i&lt;ecnt; ++i ) {</span>
<span class="lineNum">    4785 </span><span class="lineNoCov">          0 :                         strcat(newr,parsed[cnt].replacements);</span>
<span class="lineNum">    4786 </span><span class="lineNoCov">          0 :                         if ( i!=ecnt-1 )</span>
<span class="lineNum">    4787 </span><span class="lineNoCov">          0 :                             strcat(newr,&quot; &quot;);</span>
<span class="lineNum">    4788 </span>            :                     }
<span class="lineNum">    4789 </span><span class="lineNoCov">          0 :                     free(parsed[cnt].replacements);</span>
<span class="lineNum">    4790 </span><span class="lineNoCov">          0 :                     parsed[cnt].replacements = newr;</span>
<span class="lineNum">    4791 </span>            :                 } else
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;There must be as many replacement glyphs as there are match glyphs: %s =&gt; %s&quot;),</span>
<span class="lineNum">    4793 </span><span class="lineNoCov">          0 :                     parsed[cnt].entity, parsed[cnt].replacements));</span>
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    4795 </span>            :             }
<span class="lineNum">    4796 </span><span class="lineNoCov">          0 :         } else if ( *start!='@' &amp;&amp; *start!='&lt;' &amp;&amp; !(*start=='=' &amp;&amp; start[1]=='&gt;') ) {</span>
<span class="lineNum">    4797 </span>            :             /* Just a normal glyph or class name. (If we expect a coverage table we'll treat it as a table with one glyph) */
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 :             while ( *lpt!='\0' &amp;&amp; !isspace(*lpt) &amp;&amp; *lpt!='@' &amp;&amp; *lpt!='&lt;' &amp;&amp; *lpt!='[' )</span>
<span class="lineNum">    4799 </span><span class="lineNoCov">          0 :                 ++lpt;</span>
<span class="lineNum">    4800 </span><span class="lineNoCov">          0 :             end = lpt;</span>
<span class="lineNum">    4801 </span><span class="lineNoCov">          0 :         } else if ( *start=='=' &amp;&amp; start[1]=='&gt;' ) {</span>
<span class="lineNum">    4802 </span>            :             /* A reverse contextual chaining */
<span class="lineNum">    4803 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format!=pst_reversecoverage )</span>
<span class="lineNum">    4804 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;No replacement lists may be specified in this contextual lookup, use a nested lookup instead, starting at: %.20s...&quot;), lpt ));</span>
<span class="lineNum">    4805 </span><span class="lineNoCov">          0 :             if ( do_replacements )</span>
<span class="lineNum">    4806 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;Only one replacement list may be specified in a reverse contextual chaining lookup, starting at: %.20s...&quot;), lpt ));</span>
<span class="lineNum">    4807 </span><span class="lineNoCov">          0 :             do_replacements = true;</span>
<span class="lineNum">    4808 </span><span class="lineNoCov">          0 :             lpt += 2;</span>
<span class="lineNum">    4809 </span>            :         } else {
<span class="lineNum">    4810 </span>            :             /* A lookup invocation */
<span class="lineNum">    4811 </span><span class="lineNoCov">          0 :             if ( fpst-&gt;format==pst_reversecoverage )</span>
<span class="lineNum">    4812 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;No lookups may be specified in a reverse contextual lookup (use a replacement list instead), starting at: %.20s...&quot;), lpt ));</span>
<span class="lineNum">    4813 </span>            : 
<span class="lineNum">    4814 </span><span class="lineNoCov">          0 :             if ( *start=='@' ) {</span>
<span class="lineNum">    4815 </span><span class="lineNoCov">          0 :                 for ( lpt=start+1; isspace( *lpt ); ++lpt );</span>
<span class="lineNum">    4816 </span><span class="lineNoCov">          0 :                 if ( *lpt!='&lt;' )</span>
<span class="lineNum">    4817 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;A lookup invocation must be started by the sequence '@&lt;' and ended with '&gt;', starting at: %.20s...&quot; ), start ) );</span>
<span class="lineNum">    4818 </span>            :             }
<span class="lineNum">    4819 </span><span class="lineNoCov">          0 :             start= ++lpt;</span>
<span class="lineNum">    4820 </span><span class="lineNoCov">          0 :             for ( lpt = start; *lpt!='\0' &amp;&amp; *lpt!='&gt;'; ++lpt );</span>
<span class="lineNum">    4821 </span><span class="lineNoCov">          0 :             if ( *lpt!='&gt;' )</span>
<span class="lineNum">    4822 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;Unterminated lookup invocation, starting at: %.20s...&quot;), start-1 ));</span>
<span class="lineNum">    4823 </span><span class="lineNoCov">          0 :             *lpt = '\0';</span>
<span class="lineNum">    4824 </span><span class="lineNoCov">          0 :             lookup = SFFindLookup(sf,start);</span>
<span class="lineNum">    4825 </span><span class="lineNoCov">          0 :             if ( lookup==NULL ) {</span>
<span class="lineNum">    4826 </span><span class="lineNoCov">          0 :                 ret = xasprintf( _(&quot;Unknown lookup: %s&quot;), start );</span>
<span class="lineNum">    4827 </span><span class="lineNoCov">          0 :                 *lpt = '&gt;';</span>
<span class="lineNum">    4828 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    4829 </span><span class="lineNoCov">          0 :             } else if ( (isgpos &amp;&amp; lookup-&gt;lookup_type&lt;gpos_start) || (!isgpos &amp;&amp; lookup-&gt;lookup_type&gt;gpos_start)) {</span>
<span class="lineNum">    4830 </span><span class="lineNoCov">          0 :                 ret = xasprintf( isgpos ? _(&quot;GSUB lookup refered to in this GPOS contextual lookup: %s&quot;):</span>
<span class="lineNum">    4831 </span>            :                             _(&quot;GPOS lookup refered to in this GSUB contextual lookup: %s&quot;),
<span class="lineNum">    4832 </span>            :                         start );
<span class="lineNum">    4833 </span><span class="lineNoCov">          0 :                 *lpt = '&gt;';</span>
<span class="lineNum">    4834 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    4835 </span><span class="lineNoCov">          0 :             } else if ( cnt==0 ) {</span>
<span class="lineNum">    4836 </span><span class="lineNoCov">          0 :                 ret = xasprintf( _(&quot;Lookups must follow the glyph, class or coverage table to which they apply: %s&quot;), start );</span>
<span class="lineNum">    4837 </span><span class="lineNoCov">          0 :                 *lpt = '&gt;';</span>
<span class="lineNum">    4838 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    4839 </span>            :             }
<span class="lineNum">    4840 </span><span class="lineNoCov">          0 :             *lpt++ = '&gt;';</span>
<span class="lineNum">    4841 </span><span class="lineNoCov">          0 :             ll = chunkalloc(sizeof(LookupList));</span>
<span class="lineNum">    4842 </span><span class="lineNoCov">          0 :             ll-&gt;lookup = lookup;</span>
<span class="lineNum">    4843 </span>            :             /* Lookup order is important */
<span class="lineNum">    4844 </span><span class="lineNoCov">          0 :             if ( parsed[cnt-1].lookups==NULL )</span>
<span class="lineNum">    4845 </span><span class="lineNoCov">          0 :                 parsed[cnt-1].lookups = ll;</span>
<span class="lineNum">    4846 </span>            :             else {
<span class="lineNum">    4847 </span><span class="lineNoCov">          0 :                 for ( llp=parsed[cnt-1].lookups; llp-&gt;next!=NULL; llp=llp-&gt;next );</span>
<span class="lineNum">    4848 </span><span class="lineNoCov">          0 :                 llp-&gt;next = ll;</span>
<span class="lineNum">    4849 </span>            :             }
<span class="lineNum">    4850 </span><span class="lineNoCov">          0 :             anylookup = true;</span>
<span class="lineNum">    4851 </span><span class="lineNoCov">          0 :             if ( first==-1 ) first = cnt-1;</span>
<span class="lineNum">    4852 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    4853 </span>            :         }
<span class="lineNum">    4854 </span>            :         /* We get here on glyph/class names and coverage tables */
<span class="lineNum">    4855 </span>            :         /*  not on lookup invocations */
<span class="lineNum">    4856 </span><span class="lineNoCov">          0 :         ch = *end; *end='\0';</span>
<span class="lineNum">    4857 </span><span class="lineNoCov">          0 :         if ( cnt&gt;=max )</span>
<span class="lineNum">    4858 </span><span class="lineNoCov">          0 :             parsed = realloc(parsed,(max+=200)*sizeof(MatchStr));</span>
<span class="lineNum">    4859 </span><span class="lineNoCov">          0 :         memset(&amp;parsed[cnt],'\0',sizeof(MatchStr));</span>
<span class="lineNum">    4860 </span><span class="lineNoCov">          0 :         parsed[cnt++].entity = copy(start);</span>
<span class="lineNum">    4861 </span><span class="lineNoCov">          0 :         *end = ch;</span>
<span class="lineNum">    4862 </span>            :     }
<span class="lineNum">    4863 </span>            : 
<span class="lineNum">    4864 </span><span class="lineNoCov">          0 :     if ( cnt==0 )</span>
<span class="lineNum">    4865 </span><span class="lineNoCov">          0 : return( copy( _(&quot;Empty rule&quot; )) );</span>
<span class="lineNum">    4866 </span>            : 
<span class="lineNum">    4867 </span><span class="lineNoCov">          0 :     ret = NULL;</span>
<span class="lineNum">    4868 </span>            : 
<span class="lineNum">    4869 </span><span class="lineNoCov">          0 :     if ( !do_replacements &amp;&amp; !anylookup ) {</span>
<span class="lineNum">    4870 </span><span class="lineNoCov">          0 :         if ( fpst-&gt;format==pst_reversecoverage )</span>
<span class="lineNum">    4871 </span><span class="lineNoCov">          0 : return( copy( _(&quot;A reverse contextual chaining lookup must have a set of replacement glyphs somewhere&quot; )) );</span>
<span class="lineNum">    4872 </span>            :         else {
<span class="lineNum">    4873 </span><span class="lineNoCov">          0 :             *return_is_warning = true;</span>
<span class="lineNum">    4874 </span>            :             /* If there are no lookups then this rule matches and does nothing */
<span class="lineNum">    4875 </span>            :             /*  which can make it easier to write subsequent rules */
<span class="lineNum">    4876 </span><span class="lineNoCov">          0 :             ret = copy( _(&quot;This contextual rule applies no lookups.&quot; ));</span>
<span class="lineNum">    4877 </span>            :         }
<span class="lineNum">    4878 </span>            :     }
<span class="lineNum">    4879 </span>            : 
<span class="lineNum">    4880 </span>            :     /* Figure out the boundaries between backtrack, match and forward */
<span class="lineNum">    4881 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    4882 </span><span class="lineNoCov">          0 :         if ( parsed[i].lookups!=NULL ) {</span>
<span class="lineNum">    4883 </span><span class="lineNoCov">          0 :             if ( i&gt;last ) last = i;</span>
<span class="lineNum">    4884 </span><span class="lineNoCov">          0 :             if ( first==-1 ) first = i;</span>
<span class="lineNum">    4885 </span>            :         }
<span class="lineNum">    4886 </span><span class="lineNoCov">          0 :         if ( parsed[i].replacements!=NULL ) {</span>
<span class="lineNum">    4887 </span><span class="lineNoCov">          0 :             if (( first!=-1 &amp;&amp; first!=i ) || (last!=-1 &amp;&amp; last!=i ))</span>
<span class="lineNum">    4888 </span><span class="lineNoCov">          0 : return( copy( _(&quot;A reverse contextual chaining lookup can only match one coverage table directly&quot; )) );</span>
<span class="lineNum">    4889 </span><span class="lineNoCov">          0 :             first = last = i;</span>
<span class="lineNum">    4890 </span>            :         }
<span class="lineNum">    4891 </span>            :     }
<span class="lineNum">    4892 </span><span class="lineNoCov">          0 :     if ( fpst-&gt;type==pst_contextpos || fpst-&gt;type==pst_contextsub ) {</span>
<span class="lineNum">    4893 </span><span class="lineNoCov">          0 :         first = 0;</span>
<span class="lineNum">    4894 </span><span class="lineNoCov">          0 :         last = cnt-1;</span>
<span class="lineNum">    4895 </span>            :     }
<span class="lineNum">    4896 </span>            : 
<span class="lineNum">    4897 </span><span class="lineNoCov">          0 :     switch ( fpst-&gt;format ) {</span>
<span class="lineNum">    4898 </span>            :       case pst_glyphs: {
<span class="lineNum">    4899 </span><span class="lineNoCov">          0 :         int blen=0, mlen=0, flen=0;</span>
<span class="lineNum">    4900 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    4901 </span><span class="lineNoCov">          0 :             if ( SFGetChar(sf,-1,parsed[i].entity)==NULL ) {</span>
<span class="lineNum">    4902 </span><span class="lineNoCov">          0 :                 if ( ret==NULL ) {</span>
<span class="lineNum">    4903 </span><span class="lineNoCov">          0 :                     ret = xasprintf( _(&quot;There is no glyph named \&quot;%s\&quot; in the font.&quot;), parsed[i].entity );</span>
<span class="lineNum">    4904 </span><span class="lineNoCov">          0 :                     *return_is_warning = true;</span>
<span class="lineNum">    4905 </span>            :                 }
<span class="lineNum">    4906 </span>            :             }
<span class="lineNum">    4907 </span><span class="lineNoCov">          0 :             if ( i&lt;first )</span>
<span class="lineNum">    4908 </span><span class="lineNoCov">          0 :                 blen += strlen(parsed[i].entity)+1;</span>
<span class="lineNum">    4909 </span><span class="lineNoCov">          0 :             else if ( i&lt;=last )</span>
<span class="lineNum">    4910 </span><span class="lineNoCov">          0 :                 mlen += strlen(parsed[i].entity)+1;</span>
<span class="lineNum">    4911 </span>            :             else
<span class="lineNum">    4912 </span><span class="lineNoCov">          0 :                 flen += strlen(parsed[i].entity)+1;</span>
<span class="lineNum">    4913 </span>            :         }
<span class="lineNum">    4914 </span><span class="lineNoCov">          0 :         rule-&gt;u.glyph.names = calloc(mlen+1,1);</span>
<span class="lineNum">    4915 </span><span class="lineNoCov">          0 :         if ( blen!=0 )</span>
<span class="lineNum">    4916 </span><span class="lineNoCov">          0 :             rule-&gt;u.glyph.back = calloc(blen+1,1);</span>
<span class="lineNum">    4917 </span><span class="lineNoCov">          0 :         if ( flen!=0 )</span>
<span class="lineNum">    4918 </span><span class="lineNoCov">          0 :             rule-&gt;u.glyph.fore = calloc(flen+1,1);</span>
<span class="lineNum">    4919 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    4920 </span><span class="lineNoCov">          0 :             if ( i&lt;first ) {</span>
<span class="lineNum">    4921 </span><span class="lineNoCov">          0 :                 strcat(rule-&gt;u.glyph.back,parsed[i].entity);</span>
<span class="lineNum">    4922 </span><span class="lineNoCov">          0 :                 if ( i!=first-1)</span>
<span class="lineNum">    4923 </span><span class="lineNoCov">          0 :                     strcat(rule-&gt;u.glyph.back,&quot; &quot;);</span>
<span class="lineNum">    4924 </span><span class="lineNoCov">          0 :             } else if ( i&lt;=last ) {</span>
<span class="lineNum">    4925 </span><span class="lineNoCov">          0 :                 strcat(rule-&gt;u.glyph.names,parsed[i].entity);</span>
<span class="lineNum">    4926 </span><span class="lineNoCov">          0 :                 if ( i!=last)</span>
<span class="lineNum">    4927 </span><span class="lineNoCov">          0 :                     strcat(rule-&gt;u.glyph.names,&quot; &quot;);</span>
<span class="lineNum">    4928 </span>            :             } else {
<span class="lineNum">    4929 </span><span class="lineNoCov">          0 :                 strcat(rule-&gt;u.glyph.fore,parsed[i].entity);</span>
<span class="lineNum">    4930 </span><span class="lineNoCov">          0 :                 if ( i!=cnt-1)</span>
<span class="lineNum">    4931 </span><span class="lineNoCov">          0 :                     strcat(rule-&gt;u.glyph.fore,&quot; &quot;);</span>
<span class="lineNum">    4932 </span>            :             }
<span class="lineNum">    4933 </span>            :         }
<span class="lineNum">    4934 </span><span class="lineNoCov">          0 :         if ( blen!=0 ) {</span>
<span class="lineNum">    4935 </span><span class="lineNoCov">          0 :             char *temp = reverseGlyphNames(rule-&gt;u.glyph.back);</span>
<span class="lineNum">    4936 </span><span class="lineNoCov">          0 :             free(rule-&gt;u.glyph.back);</span>
<span class="lineNum">    4937 </span><span class="lineNoCov">          0 :             rule-&gt;u.glyph.back = temp;</span>
<span class="lineNum">    4938 </span>            :         }
<span class="lineNum">    4939 </span><span class="lineNoCov">          0 :       } break;</span>
<span class="lineNum">    4940 </span>            :       case pst_class:
<span class="lineNum">    4941 </span><span class="lineNoCov">          0 :         rule-&gt;u.class.ncnt = last+1-first;</span>
<span class="lineNum">    4942 </span><span class="lineNoCov">          0 :         rule-&gt;u.class.nclasses = malloc(rule-&gt;u.class.ncnt*sizeof(uint16));</span>
<span class="lineNum">    4943 </span><span class="lineNoCov">          0 :         rule-&gt;u.class.bcnt = first;</span>
<span class="lineNum">    4944 </span><span class="lineNoCov">          0 :         if ( first!=0 )</span>
<span class="lineNum">    4945 </span><span class="lineNoCov">          0 :             rule-&gt;u.class.bclasses = malloc(first*sizeof(uint16));</span>
<span class="lineNum">    4946 </span><span class="lineNoCov">          0 :         rule-&gt;u.class.fcnt = cnt==last?0:cnt-last-1;</span>
<span class="lineNum">    4947 </span><span class="lineNoCov">          0 :         if ( rule-&gt;u.class.fcnt!=0 )</span>
<span class="lineNum">    4948 </span><span class="lineNoCov">          0 :             rule-&gt;u.class.fclasses = malloc(rule-&gt;u.class.fcnt*sizeof(uint16));</span>
<span class="lineNum">    4949 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    4950 </span>            :             char **classnames, *pend;
<span class="lineNum">    4951 </span>            :             int class_cnt, val;
<span class="lineNum">    4952 </span><span class="lineNoCov">          0 :             if ( i&lt;first ) {</span>
<span class="lineNum">    4953 </span><span class="lineNoCov">          0 :                 classnames = fpst-&gt;bclassnames;</span>
<span class="lineNum">    4954 </span><span class="lineNoCov">          0 :                 class_cnt = fpst-&gt;bccnt;</span>
<span class="lineNum">    4955 </span><span class="lineNoCov">          0 :             } else if ( i&lt;=last ) {</span>
<span class="lineNum">    4956 </span><span class="lineNoCov">          0 :                 classnames = fpst-&gt;nclassnames;</span>
<span class="lineNum">    4957 </span><span class="lineNoCov">          0 :                 class_cnt = fpst-&gt;nccnt;</span>
<span class="lineNum">    4958 </span>            :             } else {
<span class="lineNum">    4959 </span><span class="lineNoCov">          0 :                 classnames = fpst-&gt;fclassnames;</span>
<span class="lineNum">    4960 </span><span class="lineNoCov">          0 :                 class_cnt = fpst-&gt;fccnt;</span>
<span class="lineNum">    4961 </span>            :             }
<span class="lineNum">    4962 </span><span class="lineNoCov">          0 :             val = strtol(parsed[i].entity,&amp;pend,10);</span>
<span class="lineNum">    4963 </span><span class="lineNoCov">          0 :             if ( *pend!='\0' )</span>
<span class="lineNum">    4964 </span><span class="lineNoCov">          0 :                 val = -1;</span>
<span class="lineNum">    4965 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;class_cnt; ++j ) {</span>
<span class="lineNum">    4966 </span><span class="lineNoCov">          0 :                 if ( classnames[j]!=NULL ) {</span>
<span class="lineNum">    4967 </span><span class="lineNoCov">          0 :                     if ( strcmp(parsed[i].entity,classnames[j])==0 )</span>
<span class="lineNum">    4968 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    4969 </span>            :                 } else {
<span class="lineNum">    4970 </span><span class="lineNoCov">          0 :                     if ( val==j )</span>
<span class="lineNum">    4971 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    4972 </span>            :                 }
<span class="lineNum">    4973 </span>            :             }
<span class="lineNum">    4974 </span><span class="lineNoCov">          0 :             if ( j==class_cnt ) {</span>
<span class="lineNum">    4975 </span><span class="lineNoCov">          0 :                 free( rule-&gt;u.class.nclasses ); rule-&gt;u.class.nclasses = NULL;</span>
<span class="lineNum">    4976 </span><span class="lineNoCov">          0 :                 free( rule-&gt;u.class.bclasses ); rule-&gt;u.class.bclasses = NULL;</span>
<span class="lineNum">    4977 </span><span class="lineNoCov">          0 :                 free( rule-&gt;u.class.fclasses ); rule-&gt;u.class.fclasses = NULL;</span>
<span class="lineNum">    4978 </span><span class="lineNoCov">          0 :                 rule-&gt;u.class.bcnt = rule-&gt;u.class.fcnt = rule-&gt;u.class.ncnt = 0;</span>
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :                 if ( i&lt;first )</span>
<span class="lineNum">    4980 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;%s is not a class name for the backtracking classes.&quot; ), parsed[i].entity ) );</span>
<span class="lineNum">    4981 </span><span class="lineNoCov">          0 :                 else if ( i&lt;=last )</span>
<span class="lineNum">    4982 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;%s is not a class name for the matching classes.&quot; ), parsed[i].entity ) );</span>
<span class="lineNum">    4983 </span>            :                 else
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 : return( xasprintf( _(&quot;%s is not a class name for the forward classes.&quot; ), parsed[i].entity ) );</span>
<span class="lineNum">    4985 </span>            :             }
<span class="lineNum">    4986 </span><span class="lineNoCov">          0 :             if ( i&lt;first )</span>
<span class="lineNum">    4987 </span><span class="lineNoCov">          0 :                 rule-&gt;u.class.bclasses[first-1-i] = j;       /* Reverse the backtrack classes */</span>
<span class="lineNum">    4988 </span><span class="lineNoCov">          0 :             else if ( i&lt;=last )</span>
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :                 rule-&gt;u.class.nclasses[i-first] = j;</span>
<span class="lineNum">    4990 </span>            :             else
<span class="lineNum">    4991 </span><span class="lineNoCov">          0 :                 rule-&gt;u.class.fclasses[i-last-1] = j;</span>
<span class="lineNum">    4992 </span>            :         }
<span class="lineNum">    4993 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    4994 </span>            :       case pst_coverage:
<span class="lineNum">    4995 </span>            :       case pst_reversecoverage:
<span class="lineNum">    4996 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    4997 </span><span class="lineNoCov">          0 :             for ( lpt = parsed[i].entity; *lpt ; ) {</span>
<span class="lineNum">    4998 </span><span class="lineNoCov">          0 :                 while ( isspace(*lpt)) ++lpt;</span>
<span class="lineNum">    4999 </span><span class="lineNoCov">          0 :                 if ( *lpt=='\0' )</span>
<span class="lineNum">    5000 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    5001 </span><span class="lineNoCov">          0 :                 start = lpt;</span>
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :                 while ( !isspace(*lpt) &amp;&amp; *lpt!='\0' )</span>
<span class="lineNum">    5003 </span><span class="lineNoCov">          0 :                     ++lpt;</span>
<span class="lineNum">    5004 </span><span class="lineNoCov">          0 :                 ch = *lpt; *lpt='\0';</span>
<span class="lineNum">    5005 </span><span class="lineNoCov">          0 :                 if ( SFGetChar(sf,-1,start)==NULL ) {</span>
<span class="lineNum">    5006 </span><span class="lineNoCov">          0 :                     if ( ret==NULL ) {</span>
<span class="lineNum">    5007 </span><span class="lineNoCov">          0 :                         ret = xasprintf( _(&quot;There is no glyph named \&quot;%s\&quot; in the font.&quot;), start );</span>
<span class="lineNum">    5008 </span><span class="lineNoCov">          0 :                         *return_is_warning = true;</span>
<span class="lineNum">    5009 </span>            :                     }
<span class="lineNum">    5010 </span>            :                 }
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :                 *lpt = ch;</span>
<span class="lineNum">    5012 </span>            :             }
<span class="lineNum">    5013 </span>            :         }
<span class="lineNum">    5014 </span><span class="lineNoCov">          0 :         rule-&gt;u.coverage.ncnt = last+1-first;</span>
<span class="lineNum">    5015 </span><span class="lineNoCov">          0 :         rule-&gt;u.coverage.ncovers = malloc(rule-&gt;u.coverage.ncnt*sizeof(char *));</span>
<span class="lineNum">    5016 </span><span class="lineNoCov">          0 :         rule-&gt;u.coverage.bcnt = first;</span>
<span class="lineNum">    5017 </span><span class="lineNoCov">          0 :         if ( first!=0 )</span>
<span class="lineNum">    5018 </span><span class="lineNoCov">          0 :             rule-&gt;u.coverage.bcovers = malloc(first*sizeof(char *));</span>
<span class="lineNum">    5019 </span><span class="lineNoCov">          0 :         rule-&gt;u.coverage.fcnt = cnt-last-1;</span>
<span class="lineNum">    5020 </span><span class="lineNoCov">          0 :         if ( rule-&gt;u.coverage.fcnt!=0 )</span>
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :             rule-&gt;u.coverage.fcovers = malloc(rule-&gt;u.coverage.fcnt*sizeof(char *));</span>
<span class="lineNum">    5022 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :             if ( i&lt;first )</span>
<span class="lineNum">    5024 </span><span class="lineNoCov">          0 :                 rule-&gt;u.coverage.bcovers[first-1-i] = parsed[i].entity;      /* Reverse the order of backtrack coverage tables */</span>
<span class="lineNum">    5025 </span><span class="lineNoCov">          0 :             else if ( i&lt;=last ) {</span>
<span class="lineNum">    5026 </span><span class="lineNoCov">          0 :                 rule-&gt;u.coverage.ncovers[i-first] = parsed[i].entity;</span>
<span class="lineNum">    5027 </span><span class="lineNoCov">          0 :                 if ( fpst-&gt;format==pst_reversecoverage ) {</span>
<span class="lineNum">    5028 </span><span class="lineNoCov">          0 :                     rule-&gt;u.rcoverage.replacements = parsed[i].replacements;</span>
<span class="lineNum">    5029 </span><span class="lineNoCov">          0 :                     parsed[i].replacements = NULL;</span>
<span class="lineNum">    5030 </span>            :                 }
<span class="lineNum">    5031 </span>            :             } else
<span class="lineNum">    5032 </span><span class="lineNoCov">          0 :                 rule-&gt;u.coverage.ncovers[i-last-1] = parsed[i].entity;</span>
<span class="lineNum">    5033 </span><span class="lineNoCov">          0 :             parsed[i].entity = NULL;</span>
<span class="lineNum">    5034 </span>            :         }
<span class="lineNum">    5035 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    5036 </span>            :       default:
<span class="lineNum">    5037 </span><span class="lineNoCov">          0 : return( copy( _(&quot;Bad FPST format&quot;)) );</span>
<span class="lineNum">    5038 </span>            :     }
<span class="lineNum">    5039 </span><span class="lineNoCov">          0 :     if ( fpst-&gt;format!=pst_reversecoverage ) {</span>
<span class="lineNum">    5040 </span><span class="lineNoCov">          0 :         int tot=0;</span>
<span class="lineNum">    5041 </span><span class="lineNoCov">          0 :         for ( i=first; i&lt;=last; ++i ) {</span>
<span class="lineNum">    5042 </span><span class="lineNoCov">          0 :             for ( ll=parsed[i].lookups; ll!=NULL; ll=ll-&gt;next )</span>
<span class="lineNum">    5043 </span><span class="lineNoCov">          0 :                 ++tot;</span>
<span class="lineNum">    5044 </span>            :         }
<span class="lineNum">    5045 </span><span class="lineNoCov">          0 :         rule-&gt;lookups = calloc(tot,sizeof(struct seqlookup));</span>
<span class="lineNum">    5046 </span><span class="lineNoCov">          0 :         rule-&gt;lookup_cnt = tot;</span>
<span class="lineNum">    5047 </span><span class="lineNoCov">          0 :         tot = 0;</span>
<span class="lineNum">    5048 </span><span class="lineNoCov">          0 :         for ( i=first; i&lt;=last; ++i ) {</span>
<span class="lineNum">    5049 </span><span class="lineNoCov">          0 :             for ( ll=parsed[i].lookups; ll!=NULL; ll=llp ) {</span>
<span class="lineNum">    5050 </span><span class="lineNoCov">          0 :                 llp = ll-&gt;next;</span>
<span class="lineNum">    5051 </span><span class="lineNoCov">          0 :                 rule-&gt;lookups[tot].seq = i-first;</span>
<span class="lineNum">    5052 </span><span class="lineNoCov">          0 :                 rule-&gt;lookups[tot].lookup = ll-&gt;lookup;</span>
<span class="lineNum">    5053 </span><span class="lineNoCov">          0 :                 ++tot;</span>
<span class="lineNum">    5054 </span><span class="lineNoCov">          0 :                 chunkfree(ll,sizeof(*ll));</span>
<span class="lineNum">    5055 </span>            :             }
<span class="lineNum">    5056 </span>            :         }
<span class="lineNum">    5057 </span>            :     }
<span class="lineNum">    5058 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;cnt; ++i )</span>
<span class="lineNum">    5059 </span><span class="lineNoCov">          0 :         free( parsed[i].entity );</span>
<span class="lineNum">    5060 </span><span class="lineNoCov">          0 :     free(parsed);</span>
<span class="lineNum">    5061 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    5062 </span>            : }
<a name="5063"><span class="lineNum">    5063 </span>            : </a>
<span class="lineNum">    5064 </span>            : /* User interface functionality when we have no UI */
<span class="lineNum">    5065 </span><span class="lineNoCov">          0 : static void NOFI_SortInsertLookup(SplineFont *sf, OTLookup *newotl) {</span>
<a name="5066"><span class="lineNum">    5066 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    5067 </span>            : 
<span class="lineNum">    5068 </span><span class="lineNoCov">          0 : static void NOFI_OTLookupCopyInto(SplineFont *into_sf,SplineFont *from_sf,</span>
<span class="lineNum">    5069 </span>            :         OTLookup *from_otl, OTLookup *to_otl, int scnt, OTLookup *before ) {
<a name="5070"><span class="lineNum">    5070 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    5071 </span>            : 
<span class="lineNum">    5072 </span><span class="lineNoCov">          0 : static void NOFI_Destroy(SplineFont *sf) {</span>
<span class="lineNum">    5073 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5074 </span>            : 
<span class="lineNum">    5075 </span>            : struct fi_interface noui_fi = {
<span class="lineNum">    5076 </span>            :     NOFI_SortInsertLookup,
<span class="lineNum">    5077 </span>            :     NOFI_OTLookupCopyInto,
<span class="lineNum">    5078 </span>            :     NOFI_Destroy
<span class="lineNum">    5079 </span>            : };
<span class="lineNum">    5080 </span>            : 
<a name="5081"><span class="lineNum">    5081 </span>            : struct fi_interface *fi_interface = &amp;noui_fi;</a>
<span class="lineNum">    5082 </span>            : 
<span class="lineNum">    5083 </span><span class="lineCov">         40 : void FF_SetFIInterface(struct fi_interface *fii) {</span>
<span class="lineNum">    5084 </span><span class="lineCov">         40 :     fi_interface = fii;</span>
<span class="lineNum">    5085 </span><span class="lineCov">         40 : }</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
