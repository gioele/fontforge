<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd) - fontforge/ufo.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">fontforge</a> - ufo.c<span style="font-size: 80%;"> (source / <a href="ufo.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd)</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2663</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-08-04</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">86</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright (C) 2003-2012 by George Williams */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       4 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :  * Redistributions of source code must retain the above copyright notice, this
<span class="lineNum">       7 </span>            :  * list of conditions and the following disclaimer.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :  * Redistributions in binary form must reproduce the above copyright notice,
<span class="lineNum">      10 </span>            :  * this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      11 </span>            :  * and/or other materials provided with the distribution.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :  * The name of the author may not be used to endorse or promote products
<span class="lineNum">      14 </span>            :  * derived from this software without specific prior written permission.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
<span class="lineNum">      17 </span>            :  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
<span class="lineNum">      18 </span>            :  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
<span class="lineNum">      19 </span>            :  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      20 </span>            :  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      21 </span>            :  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
<span class="lineNum">      22 </span>            :  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
<span class="lineNum">      23 </span>            :  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
<span class="lineNum">      24 </span>            :  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
<span class="lineNum">      25 </span>            :  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : #include &lt;fontforge-config.h&gt;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">      30 </span>            : # include &quot;Python.h&quot;
<span class="lineNum">      31 </span>            : # include &quot;structmember.h&quot;
<span class="lineNum">      32 </span>            : #else
<span class="lineNum">      33 </span>            : # include &lt;utype.h&gt;
<span class="lineNum">      34 </span>            : #endif
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : #include &quot;autohint.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;dumppfa.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;featurefile.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;fontforgevw.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;fvfonts.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;fvfonts.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;lookups.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;splinesaveafm.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;splineutil.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;splineutil2.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;svg.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;tottf.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;tottfgpos.h&quot;
<span class="lineNum">      49 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      50 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      51 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      52 </span>            : #include &lt;locale.h&gt;
<span class="lineNum">      53 </span>            : #include &lt;chardata.h&gt;
<span class="lineNum">      54 </span>            : #include &lt;gfile.h&gt;
<span class="lineNum">      55 </span>            : #include &lt;ustring.h&gt;
<span class="lineNum">      56 </span>            : #include &lt;unistd.h&gt;
<span class="lineNum">      57 </span>            : #include &lt;sys/types.h&gt;
<span class="lineNum">      58 </span>            : #include &lt;sys/stat.h&gt;
<span class="lineNum">      59 </span>            : #include &lt;time.h&gt;
<span class="lineNum">      60 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">      61 </span>            : # include &quot;ffpython.h&quot;
<span class="lineNum">      62 </span>            : #endif
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #include &lt;stdarg.h&gt;
<span class="lineNum">      65 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #undef extended                 /* used in xlink.h */
<span class="lineNum">      68 </span>            : #include &lt;libxml/tree.h&gt;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">      71 </span>            : #include &quot;glif_name_hash.h&quot;
<span class="lineNum">      72 </span>            : #endif
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /* The UFO (Unified Font Object) format ( http://unifiedfontobject.org/ ) */
<span class="lineNum">      75 </span>            : /* is a directory containing a bunch of (mac style) property lists and another*/
<span class="lineNum">      76 </span>            : /* directory containing glif files (and contents.plist). */
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /* Property lists contain one &lt;dict&gt; element which contains &lt;key&gt; elements */
<span class="lineNum">      79 </span>            : /*  each followed by an &lt;integer&gt;, &lt;real&gt;, &lt;true/&gt;, &lt;false/&gt; or &lt;string&gt; element, */
<span class="lineNum">      80 </span>            : /*  or another &lt;dict&gt; */
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : /* UFO format 2.0 includes an adobe feature file &quot;features.fea&quot; and slightly */
<a name="83"><span class="lineNum">      83 </span>            : /*  different/more tags in fontinfo.plist */</a>
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span><span class="lineNoCov">          0 : static char *buildname(const char *basedir, const char *sub) {</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     char *fname = malloc(strlen(basedir)+strlen(sub)+2);</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     strcpy(fname, basedir);</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     if ( fname[strlen(fname)-1]!='/' )</span>
<span class="lineNum">      90 </span><span class="lineNoCov">          0 :         strcat(fname,&quot;/&quot;);</span>
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     strcat(fname,sub);</span>
<span class="lineNum">      92 </span><span class="lineNoCov">          0 : return( fname );</span>
<a name="93"><span class="lineNum">      93 </span>            : }</a>
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span><span class="lineNoCov">          0 : static void extractNumericVersion(const char * textVersion, int * versionMajor, int * versionMinor) {</span>
<span class="lineNum">      96 </span>            :   // We extract integer values for major and minor versions from a version string.
<span class="lineNum">      97 </span><span class="lineNoCov">          0 :   *versionMajor = -1; *versionMinor = -1;</span>
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   if (textVersion == NULL) return;</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   char *nextText1 = NULL;</span>
<span class="lineNum">     100 </span><span class="lineNoCov">          0 :   char *nextText2 = NULL;</span>
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :   int tempVersion = -1;</span>
<span class="lineNum">     102 </span><span class="lineNoCov">          0 :   tempVersion = strtol(textVersion, &amp;nextText1, 10);</span>
<span class="lineNum">     103 </span><span class="lineNoCov">          0 :   if (tempVersion != -1 &amp;&amp; nextText1 != NULL &amp;&amp; (nextText1[0] == '\0' || nextText1[0] == ' ' || nextText1[0] == '.')) {</span>
<span class="lineNum">     104 </span><span class="lineNoCov">          0 :     *versionMajor = tempVersion;</span>
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   } else return;</span>
<span class="lineNum">     106 </span><span class="lineNoCov">          0 :   if (nextText1[0] == '\0') return;</span>
<span class="lineNum">     107 </span><span class="lineNoCov">          0 :   tempVersion = strtol(nextText1+1, &amp;nextText2, 10);</span>
<span class="lineNum">     108 </span><span class="lineNoCov">          0 :   if (tempVersion != -1 &amp;&amp; nextText2 != NULL &amp;&amp; (nextText2[0] == '\0' || nextText2[0] == ' ' || nextText2[0] == '.')) {</span>
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :     *versionMinor = tempVersion;</span>
<span class="lineNum">     110 </span><span class="lineNoCov">          0 :   } else return;</span>
<span class="lineNum">     111 </span><span class="lineNoCov">          0 :   return;</span>
<a name="112"><span class="lineNum">     112 </span>            : }</a>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 : static void injectNumericVersion(char ** textVersion, int versionMajor, int versionMinor) {</span>
<span class="lineNum">     115 </span>            :   // We generate a version string from numeric values if available.
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   if (versionMajor == -1) asprintf(textVersion, &quot;%s&quot;, &quot;&quot;);</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   else if (versionMinor == -1) asprintf(textVersion, &quot;%d&quot;, versionMajor);</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   else asprintf(textVersion, &quot;%d.%d&quot;, versionMajor, versionMinor);</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     120 </span>            : }
<span class="lineNum">     121 </span>            : 
<a name="122"><span class="lineNum">     122 </span>            : /* The spec does not really require padding the version str but it clears */</a>
<span class="lineNum">     123 </span>            : /* 1.8 vs. 1.008 ambiguities and makes us inline with the AFDKO. */
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : char* paddedVersionStr(const char * textVersion, char * buffer) {</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :     int major = -1;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :     int minor = -1;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :     extractNumericVersion(textVersion, &amp;major, &amp;minor);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :     if (major &lt; 0 || minor &lt; 0) return (char *) textVersion;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     snprintf(buffer, 6, &quot;%d.%03d&quot;, major, minor);</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :     return buffer;</span>
<span class="lineNum">     131 </span>            : }
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : const char * DOS_reserved[12] = {&quot;CON&quot;, &quot;PRN&quot;, &quot;AUX&quot;, &quot;CLOCK$&quot;, &quot;NUL&quot;, &quot;COM1&quot;, &quot;COM2&quot;, &quot;COM3&quot;, &quot;COM4&quot;, &quot;LPT1&quot;, &quot;LPT2&quot;, &quot;LPT3&quot;};
<a name="134"><span class="lineNum">     134 </span>            : const int DOS_reserved_count = 12;</a>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineNoCov">          0 : int polyMatch(const char * input, int reference_count, const char ** references) {</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   for (off_t pos = 0; pos &lt; reference_count; pos++) {</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :     if (strcmp(references[pos], input) == 0) return 1;</span>
<span class="lineNum">     139 </span>            :   }
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="141"><span class="lineNum">     141 </span>            : }</a>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineNoCov">          0 : int is_DOS_drive(char * input) {</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   if ((input != NULL) &amp;&amp;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :      (strlen(input) == 2) &amp;&amp;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :      (((input[0] &gt;= 'A') &amp;&amp; (input[0] &lt;= 'Z')) || ((input[0] &gt;= 'a') &amp;&amp; (input[0] &lt;= 'z'))) &amp;&amp;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :      (input[1] == ':'))</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :        return 1;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="150"><span class="lineNum">     150 </span>            : }</a>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span><span class="lineNoCov">          0 : char * ufo_name_mangle(const char * input, const char * prefix, const char * suffix, int flags) {</span>
<span class="lineNum">     153 </span>            :   // This does not append the prefix or the suffix.
<span class="lineNum">     154 </span>            :   // flags &amp; 1 determines whether to post-pad caps (something implemented in the standard).
<span class="lineNum">     155 </span>            :   // flags &amp; 2 determines whether to replace a leading '.' (standard).
<span class="lineNum">     156 </span>            :   // flags &amp; 4 determines whether to restrict DOS names (standard).
<span class="lineNum">     157 </span>            :   // flags &amp; 8 determines whether to implement additional character restrictions.
<span class="lineNum">     158 </span>            :   // The specification lists '&quot;' '*' '+' '/' ':' '&lt;' '&gt;' '?' '[' '\\' ']' '|'
<span class="lineNum">     159 </span>            :   // and also anything in the range 0x00-0x1F and 0x7F.
<span class="lineNum">     160 </span>            :   // Our additional restriction list includes '\'' '&amp;' '%' '$' '#' '`' '=' '!' ';'
<span class="lineNum">     161 </span>            :   // Standard behavior comes from passing a flags value of 7.
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :   const char * standard_restrict = &quot;\&quot;*+/:&lt;&gt;?[]\\]|&quot;;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :   const char * extended_restrict = &quot;\'&amp;%$#`=!;&quot;;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :   size_t prefix_length = strlen(prefix);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :   size_t max_length = 255 - prefix_length - strlen(suffix);</span>
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :   size_t input_length = strlen(input);</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :   size_t stop_pos = ((max_length &lt; input_length) ? max_length : input_length); // Minimum.</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :   size_t output_length_1 = input_length;</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :   if (flags &amp; 1) output_length_1 += count_caps(input); // Add space for underscore pads on caps.</span>
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :   off_t output_pos = 0;</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   char * output = malloc(output_length_1 + 1);</span>
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; input_length; i++) {</span>
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :     if (strchr(standard_restrict, input[i]) || (input[i] &lt;= 0x1F) || (input[i] &gt;= 0x7F)) {</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       output[output_pos++] = '_'; // If the character is restricted, place an underscore.</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :     } else if ((flags &amp; 8) &amp;&amp; strchr(extended_restrict, input[i])) {</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :       output[output_pos++] = '_'; // If the extended restriction list is enabled and matches, ....</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :     } else if ((flags &amp; 1) &amp;&amp; (input[i] &gt;= 'A') &amp;&amp; (input[i] &lt;= 'Z')) {</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :       output[output_pos++] = input[i];</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :       output[output_pos++] = '_'; // If we have a capital letter, we post-pad if desired.</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :     } else if ((flags &amp; 2) &amp;&amp; (i == 0) &amp;&amp; (prefix_length == 0) &amp;&amp; (input[i] == '.')) {</span>
<span class="lineNum">     181 </span><span class="lineNoCov">          0 :       output[output_pos++] = '_'; // If we have a leading '.', we convert to an underscore.</span>
<span class="lineNum">     182 </span>            :     } else {
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :       output[output_pos++] = input[i];</span>
<span class="lineNum">     184 </span>            :     }
<span class="lineNum">     185 </span>            :   }
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :   output[output_pos] = '\0';</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   if (output_pos &gt; max_length) {</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :     output[max_length] = '\0';</span>
<span class="lineNum">     189 </span>            :   }
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :   char * output2 = NULL;</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :   off_t output2_pos = 0;</span>
<span class="lineNum">     192 </span>            :   {
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :     char * disposable = malloc(output_length_1 + 1);</span>
<span class="lineNum">     194 </span><span class="lineNoCov">          0 :     strcpy(disposable, output); // strtok rewrites the input string, so we make a copy.</span>
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :     output2 = malloc((2 * output_length_1) + 1); // It's easier to pad than to calculate.</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :     output2_pos = 0;</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :     char * saveptr = NULL;</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :     char * current = strtok_r(disposable, &quot;.&quot;, &amp;saveptr); // We get the first name part.</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :     while (current != NULL) {</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :       char * uppered = upper_case(output);</span>
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :       if (polyMatch(uppered, DOS_reserved_count, DOS_reserved) || is_DOS_drive(uppered)) {</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         output2[output2_pos++] = '_'; // Prefix an underscore if it's a reserved name.</span>
<span class="lineNum">     203 </span>            :       }
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :       free(uppered); uppered = NULL;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :       for (off_t parti = 0; current[parti] != '\0'; parti++) {</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :         output2[output2_pos++] = current[parti];</span>
<span class="lineNum">     207 </span>            :       }
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :       current = strtok_r(NULL, &quot;.&quot;, &amp;saveptr);</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       if (current != NULL) output2[output2_pos++] = '.';</span>
<span class="lineNum">     210 </span>            :     }
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :     output2[output2_pos] = '\0';</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :     output2 = realloc(output2, output2_pos + 1);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :     free(disposable); disposable = NULL;</span>
<span class="lineNum">     214 </span>            :   }
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :   free(output); output = NULL;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :   return output2;</span>
<a name="217"><span class="lineNum">     217 </span>            : }</a>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span><span class="lineNoCov">          0 : char * ufo_name_number(</span>
<span class="lineNum">     220 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">     221 </span>            : struct glif_name_index * glif_name_hash,
<span class="lineNum">     222 </span>            : #else
<span class="lineNum">     223 </span>            : void * glif_name_hash,
<span class="lineNum">     224 </span>            : #endif
<span class="lineNum">     225 </span>            : int index, const char * input, const char * prefix, const char * suffix, int flags) {
<span class="lineNum">     226 </span>            :         // This does not append the prefix or the suffix.
<span class="lineNum">     227 </span>            :         // The specification deals with name collisions by appending a 15-digit decimal number to the name.
<span class="lineNum">     228 </span>            :         // But the name length cannot exceed 255 characters, so it is necessary to crop the base name if it is too long.
<span class="lineNum">     229 </span>            :         // Name exclusions are case insensitive, so we uppercase.
<span class="lineNum">     230 </span>            :         // flags &amp; 16 forces appending a number.
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         char * name_numbered = upper_case(input);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :         char * full_name_base = same_case(input); // This is in case we do not need a number added.</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :         if (strlen(input) &gt; (255 - strlen(prefix) - strlen(suffix))) {</span>
<span class="lineNum">     234 </span>            :           // If the numbered name base is too long, we crop it, even if we are not numbering.
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :           full_name_base[(255 - strlen(suffix))] = '\0';</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :           full_name_base = realloc(full_name_base, ((255 - strlen(prefix) - strlen(suffix)) + 1));</span>
<span class="lineNum">     237 </span>            :         }
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :         char * name_base = same_case(input); // This is in case we need a number added.</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :         long int name_number = 0;</span>
<span class="lineNum">     240 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         if (glif_name_hash != NULL) {</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :           if (strlen(input) &gt; (255 - 15 - strlen(prefix) - strlen(suffix))) {</span>
<span class="lineNum">     243 </span>            :             // If the numbered name base is too long, we crop it.
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :             name_base[(255 - 15 - strlen(suffix))] = '\0';</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :             name_base = realloc(name_base, ((255 - 15 - strlen(prefix) - strlen(suffix)) + 1));</span>
<span class="lineNum">     246 </span>            :           }
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :           int number_once = ((flags &amp; 16) ? 1 : 0);</span>
<span class="lineNum">     248 </span>            :           // Check the resulting name against a hash table of names.
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :           if (glif_name_search_glif_name(glif_name_hash, name_numbered) != NULL || number_once) {</span>
<span class="lineNum">     250 </span>            :             // If the name is taken, we must make space for a 15-digit number.
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :             char * name_base_upper = upper_case(name_base);</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :             while (glif_name_search_glif_name(glif_name_hash, name_numbered) != NULL || number_once) {</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :               name_number++; // Remangle the name until we have no more matches.</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :               free(name_numbered); name_numbered = NULL;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :               asprintf(&amp;name_numbered, &quot;%s%015ld&quot;, name_base_upper, name_number);</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :               number_once = 0;</span>
<span class="lineNum">     257 </span>            :             }
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :             free(name_base_upper); name_base_upper = NULL;</span>
<span class="lineNum">     259 </span>            :           }
<span class="lineNum">     260 </span>            :           // Insert the result into the hash table.
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :           glif_name_track_new(glif_name_hash, index, name_numbered);</span>
<span class="lineNum">     262 </span>            :         }
<span class="lineNum">     263 </span>            : #endif
<span class="lineNum">     264 </span>            :         // Now we want the correct capitalization.
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :         free(name_numbered); name_numbered = NULL;</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :         if (name_number &gt; 0) {</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :           asprintf(&amp;name_numbered, &quot;%s%015ld&quot;, name_base, name_number);</span>
<span class="lineNum">     268 </span>            :         } else {
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :           asprintf(&amp;name_numbered, &quot;%s&quot;, full_name_base);</span>
<span class="lineNum">     270 </span>            :         }
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :         free(name_base); name_base = NULL;</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :         free(full_name_base); full_name_base = NULL;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         return name_numbered;</span>
<a name="274"><span class="lineNum">     274 </span>            : }</a>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewChildInteger(xmlNodePtr parent, xmlNsPtr ns, const xmlChar * name, long int value) {</span>
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :   char * valtmp = NULL;</span>
<span class="lineNum">     278 </span>            :   // Textify the value to be enclosed.
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   if (asprintf(&amp;valtmp, &quot;%ld&quot;, value) &gt;= 0) {</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :     xmlNodePtr childtmp = xmlNewChild(parent, NULL, BAD_CAST name, BAD_CAST valtmp); // Make a text node for the value.</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :     free(valtmp); valtmp = NULL; // Free the temporary text store.</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :     return childtmp;</span>
<span class="lineNum">     283 </span>            :   }
<a name="284"><span class="lineNum">     284 </span><span class="lineNoCov">          0 :   return NULL;</span></a>
<span class="lineNum">     285 </span>            : }
<span class="lineNum">     286 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewNodeInteger(xmlNsPtr ns, const xmlChar * name, long int value) {</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :   char * valtmp = NULL;</span>
<span class="lineNum">     288 </span><span class="lineNoCov">          0 :   xmlNodePtr childtmp = xmlNewNode(NULL, BAD_CAST name); // Create a named node.</span>
<span class="lineNum">     289 </span>            :   // Textify the value to be enclosed.
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   if (asprintf(&amp;valtmp, &quot;%ld&quot;, value) &gt;= 0) {</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     xmlNodePtr valtmpxml = xmlNewText(BAD_CAST valtmp); // Make a text node for the value.</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     xmlAddChild(childtmp, valtmpxml); // Attach the text node as content of the named node.</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :     free(valtmp); valtmp = NULL; // Free the temporary text store.</span>
<span class="lineNum">     294 </span>            :   } else {
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :     xmlFreeNode(childtmp); childtmp = NULL;</span>
<span class="lineNum">     296 </span>            :   }
<a name="297"><span class="lineNum">     297 </span><span class="lineNoCov">          0 :   return childtmp;</span></a>
<span class="lineNum">     298 </span>            : }
<span class="lineNum">     299 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewChildFloat(xmlNodePtr parent, xmlNsPtr ns, const xmlChar * name, double value) {</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :   char * valtmp = NULL;</span>
<span class="lineNum">     301 </span>            :   // Textify the value to be enclosed.
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :   if (asprintf(&amp;valtmp, &quot;%g&quot;, value) &gt;= 0) {</span>
<span class="lineNum">     303 </span><span class="lineNoCov">          0 :     xmlNodePtr childtmp = xmlNewChild(parent, NULL, BAD_CAST name, BAD_CAST valtmp); // Make a text node for the value.</span>
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     free(valtmp); valtmp = NULL; // Free the temporary text store.</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :     return childtmp;</span>
<span class="lineNum">     306 </span>            :   }
<a name="307"><span class="lineNum">     307 </span><span class="lineNoCov">          0 :   return NULL;</span></a>
<span class="lineNum">     308 </span>            : }
<span class="lineNum">     309 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewNodeFloat(xmlNsPtr ns, const xmlChar * name, double value) {</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   char * valtmp = NULL;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   xmlNodePtr childtmp = xmlNewNode(NULL, BAD_CAST name); // Create a named node.</span>
<span class="lineNum">     312 </span>            :   // Textify the value to be enclosed.
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :   if (asprintf(&amp;valtmp, &quot;%g&quot;, value) &gt;= 0) {</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     xmlNodePtr valtmpxml = xmlNewText(BAD_CAST valtmp); // Make a text node for the value.</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :     xmlAddChild(childtmp, valtmpxml); // Attach the text node as content of the named node.</span>
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     free(valtmp); valtmp = NULL; // Free the temporary text store.</span>
<span class="lineNum">     317 </span>            :   } else {
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :     xmlFreeNode(childtmp); childtmp = NULL;</span>
<span class="lineNum">     319 </span>            :   }
<a name="320"><span class="lineNum">     320 </span><span class="lineNoCov">          0 :   return NULL;</span></a>
<span class="lineNum">     321 </span>            : }
<span class="lineNum">     322 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewChildString(xmlNodePtr parent, xmlNsPtr ns, const xmlChar * name, char * value) {</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :   xmlNodePtr childtmp = xmlNewTextChild(parent, ns, BAD_CAST name, BAD_CAST value); // Make a text node for the value.</span>
<a name="324"><span class="lineNum">     324 </span><span class="lineNoCov">          0 :   return childtmp;</span></a>
<span class="lineNum">     325 </span>            : }
<span class="lineNum">     326 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewNodeString(xmlNsPtr ns, const xmlChar * name, char * value) {</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   xmlNodePtr childtmp = xmlNewNode(NULL, BAD_CAST name); // Create a named node.</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :   xmlNodePtr valtmpxml = xmlNewText(BAD_CAST value); // Make a text node for the value.</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   xmlAddChild(childtmp, valtmpxml); // Attach the text node as content of the named node.</span>
<a name="330"><span class="lineNum">     330 </span><span class="lineNoCov">          0 :   return childtmp;</span></a>
<span class="lineNum">     331 </span>            : }
<span class="lineNum">     332 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewNodeVPrintf(xmlNsPtr ns, const xmlChar * name, char * format, va_list arguments) {</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   char * valtmp = NULL;</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :   if (vasprintf(&amp;valtmp, format, arguments) &lt; 0) {</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     336 </span>            :   }
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :   xmlNodePtr childtmp = xmlNewNode(NULL, BAD_CAST name); // Create a named node.</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :   xmlNodePtr valtmpxml = xmlNewText(BAD_CAST valtmp); // Make a text node for the value.</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :   xmlAddChild(childtmp, valtmpxml); // Attach the text node as content of the named node.</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :   free(valtmp); valtmp = NULL; // Free the temporary text store.</span>
<a name="341"><span class="lineNum">     341 </span><span class="lineNoCov">          0 :   return childtmp;</span></a>
<span class="lineNum">     342 </span>            : }
<span class="lineNum">     343 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewNodePrintf(xmlNsPtr ns, const xmlChar * name, char * format, ...) {</span>
<span class="lineNum">     344 </span>            :   va_list arguments;
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :   va_start(arguments, format);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :   xmlNodePtr output = xmlNewNodeVPrintf(ns, name, format, arguments);</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   va_end(arguments);</span>
<a name="348"><span class="lineNum">     348 </span><span class="lineNoCov">          0 :   return output;</span></a>
<span class="lineNum">     349 </span>            : }
<span class="lineNum">     350 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewChildVPrintf(xmlNodePtr parent, xmlNsPtr ns, const xmlChar * name, char * format, va_list arguments) {</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   xmlNodePtr output = xmlNewNodeVPrintf(ns, name, format, arguments);</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :   xmlAddChild(parent, output);</span>
<a name="353"><span class="lineNum">     353 </span><span class="lineNoCov">          0 :   return output;</span></a>
<span class="lineNum">     354 </span>            : }
<span class="lineNum">     355 </span><span class="lineNoCov">          0 : static xmlNodePtr xmlNewChildPrintf(xmlNodePtr parent, xmlNsPtr ns, const xmlChar * name, char * format, ...) {</span>
<span class="lineNum">     356 </span>            :   va_list arguments;
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :   va_start(arguments, format);</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :   xmlNodePtr output = xmlNewChildVPrintf(parent, ns, name, format, arguments);</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :   va_end(arguments);</span>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :   return output;</span></a>
<span class="lineNum">     361 </span>            : }
<span class="lineNum">     362 </span><span class="lineNoCov">          0 : static void xmlSetPropVPrintf(xmlNodePtr target, const xmlChar * name, char * format, va_list arguments) {</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :   char * valtmp = NULL;</span>
<span class="lineNum">     364 </span>            :   // Generate the value.
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :   if (vasprintf(&amp;valtmp, format, arguments) &lt; 0) {</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     367 </span>            :   }
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :   xmlSetProp(target, name, valtmp); // Set the property.</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :   free(valtmp); valtmp = NULL; // Free the temporary text store.</span>
<a name="370"><span class="lineNum">     370 </span><span class="lineNoCov">          0 :   return;</span></a>
<span class="lineNum">     371 </span>            : }
<span class="lineNum">     372 </span><span class="lineNoCov">          0 : static void xmlSetPropPrintf(xmlNodePtr target, const xmlChar * name, char * format, ...) {</span>
<span class="lineNum">     373 </span>            :   va_list arguments;
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :   va_start(arguments, format);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   xmlSetPropVPrintf(target, name, format, arguments);</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   va_end(arguments);</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :   return;</span>
<span class="lineNum">     378 </span>            : }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : /* ************************************************************************** */
<span class="lineNum">     381 </span>            : /* *************************   Python lib Output    ************************* */
<span class="lineNum">     382 </span>            : /* ************************************************************************** */
<span class="lineNum">     383 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">     384 </span>            : static int PyObjDumpable(PyObject *value, int has_lists);
<span class="lineNum">     385 </span>            : xmlNodePtr PyObjectToXML( PyObject *value, int has_lists );
<a name="386"><span class="lineNum">     386 </span>            : #endif</a>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineNoCov">          0 : xmlNodePtr PythonLibToXML(void *python_persistent, const SplineChar *sc, int has_lists) {</span>
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     int has_hints = (sc!=NULL &amp;&amp; (sc-&gt;hstem!=NULL || sc-&gt;vstem!=NULL ));</span>
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :     xmlNodePtr retval = NULL, dictnode = NULL, keynode = NULL, valnode = NULL;</span>
<span class="lineNum">     391 </span>            :     // retval = xmlNewNode(NULL, BAD_CAST &quot;lib&quot;); //     &quot;&lt;lib&gt;&quot;
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     dictnode = xmlNewNode(NULL, BAD_CAST &quot;dict&quot;); //     &quot;  &lt;dict&gt;&quot;</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     if ( has_hints </span>
<span class="lineNum">     394 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :          || (python_persistent!=NULL &amp;&amp; PyMapping_Check((PyObject *)python_persistent))</span>
<span class="lineNum">     396 </span>            : #endif
<span class="lineNum">     397 </span>            :        ) {
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :         xmlAddChild(retval, dictnode);</span>
<span class="lineNum">     400 </span>            :         /* Not officially part of the UFO/glif spec, but used by robofab */
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :         if ( has_hints ) {</span>
<span class="lineNum">     402 </span>            :             // Remember that the value of the plist key is in the node that follows it in the dict (not an x.m.l. child).
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :             xmlNewChild(dictnode, NULL, BAD_CAST &quot;key&quot;, BAD_CAST &quot;com.fontlab.hintData&quot;); // Label the hint data block.</span>
<span class="lineNum">     404 </span>            :             //                                           &quot;    &lt;key&gt;com.fontlab.hintData&lt;/key&gt;\n&quot;
<span class="lineNum">     405 </span>            :             //                                           &quot;    &lt;dict&gt;&quot;
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :             xmlNodePtr hintdict = xmlNewChild(dictnode, NULL, BAD_CAST &quot;dict&quot;, NULL);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :             if ( sc != NULL ) {</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 if ( sc-&gt;hstem!=NULL ) {</span>
<span class="lineNum">     409 </span>            :                     StemInfo *h;
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                     xmlNewChild(hintdict, NULL, BAD_CAST &quot;key&quot;, BAD_CAST &quot;hhints&quot;);</span>
<span class="lineNum">     411 </span>            :                     //                                   &quot;      &lt;key&gt;hhints&lt;/key&gt;&quot;
<span class="lineNum">     412 </span>            :                     //                                   &quot;      &lt;array&gt;&quot;
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :                     xmlNodePtr hintarray = xmlNewChild(hintdict, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :                     for ( h = sc-&gt;hstem; h!=NULL; h=h-&gt;next ) {</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :                         char * valtmp = NULL;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :                         xmlNodePtr stemdict = xmlNewChild(hintarray, NULL, BAD_CAST &quot;dict&quot;, NULL);</span>
<span class="lineNum">     417 </span>            :                         //                               &quot;        &lt;dict&gt;&quot;
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                         xmlNewChild(stemdict, NULL, BAD_CAST &quot;key&quot;, &quot;position&quot;);</span>
<span class="lineNum">     419 </span>            :                         //                               &quot;          &lt;key&gt;position&lt;/key&gt;&quot;
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :                         xmlNewChildInteger(stemdict, NULL, BAD_CAST &quot;integer&quot;, (int) rint(h-&gt;start));</span>
<span class="lineNum">     421 </span>            :                         //                               &quot;          &lt;integer&gt;%d&lt;/integer&gt;\n&quot; ((int) rint(h-&gt;start))
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                         xmlNewChild(stemdict, NULL, BAD_CAST &quot;key&quot;, &quot;width&quot;);</span>
<span class="lineNum">     423 </span>            :                         //                               &quot;          &lt;key&gt;width&lt;/key&gt;&quot;
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :                         xmlNewChildInteger(stemdict, NULL, BAD_CAST &quot;integer&quot;, (int) rint(h-&gt;width));</span>
<span class="lineNum">     425 </span>            :                         //                               &quot;          &lt;integer&gt;%d&lt;/integer&gt;\n&quot; ((int) rint(h-&gt;width))
<span class="lineNum">     426 </span>            :                         //                               &quot;        &lt;/dict&gt;\n&quot;
<span class="lineNum">     427 </span>            :                     }
<span class="lineNum">     428 </span>            :                     //                                   &quot;      &lt;/array&gt;\n&quot;
<span class="lineNum">     429 </span>            :                 }
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :                 if ( sc-&gt;vstem!=NULL ) {</span>
<span class="lineNum">     431 </span>            :                     StemInfo *h;
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :                     xmlNewChild(hintdict, NULL, BAD_CAST &quot;key&quot;, BAD_CAST &quot;vhints&quot;);</span>
<span class="lineNum">     433 </span>            :                     //                                   &quot;      &lt;key&gt;vhints&lt;/key&gt;&quot;
<span class="lineNum">     434 </span>            :                     //                                   &quot;      &lt;array&gt;&quot;
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :                     xmlNodePtr hintarray = xmlNewChild(hintdict, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                     for ( h = sc-&gt;vstem; h!=NULL; h=h-&gt;next ) {</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :                         char * valtmp = NULL;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                         xmlNodePtr stemdict = xmlNewChild(hintarray, NULL, BAD_CAST &quot;dict&quot;, NULL);</span>
<span class="lineNum">     439 </span>            :                         //                               &quot;        &lt;dict&gt;&quot;
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                         xmlNewChild(stemdict, NULL, BAD_CAST &quot;key&quot;, &quot;position&quot;);</span>
<span class="lineNum">     441 </span>            :                         //                               &quot;          &lt;key&gt;position&lt;/key&gt;&quot;
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                         xmlNewChildInteger(stemdict, NULL, BAD_CAST &quot;integer&quot;, (int) rint(h-&gt;start));</span>
<span class="lineNum">     443 </span>            :                         //                               &quot;          &lt;integer&gt;%d&lt;/integer&gt;\n&quot; ((int) rint(h-&gt;start))
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                         xmlNewChild(stemdict, NULL, BAD_CAST &quot;key&quot;, &quot;width&quot;);</span>
<span class="lineNum">     445 </span>            :                         //                               &quot;          &lt;key&gt;width&lt;/key&gt;&quot;
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                         xmlNewChildInteger(stemdict, NULL, BAD_CAST &quot;integer&quot;, (int) rint(h-&gt;width));</span>
<span class="lineNum">     447 </span>            :                         //                               &quot;          &lt;integer&gt;%d&lt;/integer&gt;\n&quot; ((int) rint(h-&gt;width))
<span class="lineNum">     448 </span>            :                         //                               &quot;        &lt;/dict&gt;\n&quot;
<span class="lineNum">     449 </span>            :                     }
<span class="lineNum">     450 </span>            :                     //                                   &quot;      &lt;/array&gt;\n&quot;
<span class="lineNum">     451 </span>            :                 }
<span class="lineNum">     452 </span>            :             }
<span class="lineNum">     453 </span>            :             //                                           &quot;    &lt;/dict&gt;&quot;
<span class="lineNum">     454 </span>            :         }
<span class="lineNum">     455 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         PyObject *dict = python_persistent, *items, *key, *value;</span>
<span class="lineNum">     457 </span>            :         /* Ok, look at the persistent data and output it (all except for a */
<span class="lineNum">     458 </span>            :         /*  hint entry -- we've already handled that with the real hints, */
<span class="lineNum">     459 </span>            :         /*  no point in retaining out of date hints too */
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :         if ( dict != NULL ) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :           if (!PyMapping_Check((PyObject *)python_persistent)) fprintf(stderr, &quot;python_persistent is not a mapping.\n&quot;);</span>
<span class="lineNum">     462 </span>            :           else {
<span class="lineNum">     463 </span>            :             int i, len;
<span class="lineNum">     464 </span>            :             char *str;
<span class="lineNum">     465 </span><span class="lineNoCov">          0 :             items = PyMapping_Items(dict);</span>
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :             len = PySequence_Size(items);</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;len; ++i ) {</span>
<span class="lineNum">     468 </span>            :                         // According to the Python reference manual,
<span class="lineNum">     469 </span>            :                         // PySequence_GetItem returns a reference that we must release,
<span class="lineNum">     470 </span>            :                         // but PyTuple_GetItem returns a borrowed reference.
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :                         PyObject *item = PySequence_GetItem(items,i);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                         key = PyTuple_GetItem(item,0);</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                         if ( !PyBytes_Check(key))               /* Keys need not be strings */</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         { Py_DECREF(item); item = NULL; continue; }</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                         str = PyBytes_AsString(key);</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                         if ( !str || (strcmp(str,&quot;com.fontlab.hintData&quot;)==0 &amp;&amp; sc!=NULL) )    /* Already done */</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                         { Py_DECREF(item); item = NULL; continue; }</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :                         value = PyTuple_GetItem(item,1);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                         if ( !value || !PyObjDumpable(value, has_lists))</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                         { Py_DECREF(item); item = NULL; continue; }</span>
<span class="lineNum">     481 </span>            :                         // &quot;&lt;key&gt;%s&lt;/key&gt;&quot; str
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :       xmlNewChild(dictnode, NULL, BAD_CAST &quot;key&quot;, str);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :       xmlNodePtr tmpNode = PyObjectToXML(value, has_lists);</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       xmlAddChild(dictnode, tmpNode);</span>
<span class="lineNum">     485 </span>            :                         // &quot;&lt;...&gt;...&lt;/...&gt;&quot;
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                         Py_DECREF(item); item = NULL;</span>
<span class="lineNum">     487 </span>            :             }
<span class="lineNum">     488 </span>            :           }
<span class="lineNum">     489 </span>            :         }
<span class="lineNum">     490 </span>            : #endif
<span class="lineNum">     491 </span>            :     }
<span class="lineNum">     492 </span>            :     //                                                 &quot;  &lt;/dict&gt;&quot;
<span class="lineNum">     493 </span>            :     // //                                                 &quot;&lt;/lib&gt;&quot;
<span class="lineNum">     494 </span><span class="lineNoCov">          0 :     return dictnode;</span>
<span class="lineNum">     495 </span>            : }
<a name="496"><span class="lineNum">     496 </span>            : </a>
<span class="lineNum">     497 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">     498 </span><span class="lineNoCov">          0 : static int PyObjDumpable(PyObject *value, int has_lists) {</span>
<span class="lineNum">     499 </span><span class="lineNoCov">          0 :     if ( PyTuple_Check(value))</span>
<span class="lineNum">     500 </span><span class="lineNoCov">          0 : return( true ); // Note that this means two different things depending upon has_lists.</span>
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :     if ( PyList_Check(value))</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :     if ( PyInt_Check(value))</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :     if ( PyFloat_Check(value))</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     507 </span><span class="lineNoCov">          0 :         if ( PyDict_Check(value))</span>
<span class="lineNum">     508 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :     if ( PyBytes_Check(value))</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :     if ( has_lists &amp;&amp; PyList_Check(value))</span>
<span class="lineNum">     512 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     if ( PyMapping_Check(value))</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :     if ( PyBool_Check(value))</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :     if ( value == Py_None )</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 : return( true );</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span><span class="lineNoCov">          0 : return( false );</span>
<a name="521"><span class="lineNum">     521 </span>            : }</a>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : xmlNodePtr PyObjectToXML( PyObject *value, int has_lists ) {</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :     xmlNodePtr childtmp = NULL;</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :     xmlNodePtr valtmpxml = NULL;</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     char * valtmp = NULL;</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :     if (has_lists &amp;&amp; PyTuple_Check(value) &amp;&amp; (PyTuple_Size(value) == 3) &amp;&amp;</span>
<span class="lineNum">     528 </span><span class="lineNoCov">          0 :        PyBytes_Check(PyTuple_GetItem(value,0)) &amp;&amp; PyBytes_Check(PyTuple_GetItem(value,1))) {</span>
<span class="lineNum">     529 </span>            :       // This is a chunk of unrecognized data.
<span class="lineNum">     530 </span>            :       // Since there's no equivalent in X. M. L., we can use the Tuple for this special case.
<span class="lineNum">     531 </span>            :       // But we can only do this if the arrays are being mapped as lists rather than as tuples.
<span class="lineNum">     532 </span>            :       // So we miss foreign data in old S. F. D. versions.
<span class="lineNum">     533 </span>            :       // childtmp = xmlNewNode(NULL, (xmlChar*)(PyBytes_AsString(PyTuple_GetItem(value,0)))); // Set name.
<span class="lineNum">     534 </span>            :       // xmlNodeSetContent(childtmp, (xmlChar*)(PyBytes_AsString(PyTuple_GetItem(value,1)))); // Set contents.
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       xmlDocPtr innerdoc = xmlReadMemory((xmlChar*)(PyBytes_AsString(PyTuple_GetItem(value,1))),</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :                                          PyBytes_Size(PyTuple_GetItem(value,1)), &quot;noname.xml&quot;, NULL, 0);</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 :       childtmp = xmlCopyNode(xmlDocGetRootElement(innerdoc), 1);</span>
<span class="lineNum">     538 </span><span class="lineNoCov">          0 :       xmlFreeDoc(innerdoc); innerdoc = NULL;</span>
<span class="lineNum">     539 </span><span class="lineNoCov">          0 :     } else if (PyDict_Check(value)) {</span>
<span class="lineNum">     540 </span><span class="lineNoCov">          0 :       childtmp = PythonLibToXML(value,NULL,has_lists);</span>
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :     } else if ( PyMapping_Check(value)) {</span>
<span class="lineNum">     542 </span><span class="lineNoCov">          0 :       childtmp = PythonLibToXML(value,NULL,has_lists);</span>
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :     } else if ( PyBytes_Check(value)) {         /* Must precede the sequence check */</span>
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :       char *str = PyBytes_AsString(value);</span>
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :       if (str != NULL) {</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNodeString(NULL, BAD_CAST &quot;string&quot;, str); // Create a string node.</span>
<span class="lineNum">     547 </span>            :           // &quot;&lt;string&gt;%s&lt;/string&gt;&quot; str
<span class="lineNum">     548 </span>            :       }
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :     } else if ( value==Py_True )</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNode(NULL, BAD_CAST &quot;true&quot;); // &quot;&lt;true/&gt;&quot;</span>
<span class="lineNum">     551 </span><span class="lineNoCov">          0 :     else if ( value==Py_False )</span>
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNode(NULL, BAD_CAST &quot;false&quot;); // &quot;&lt;false/&gt;&quot;</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     else if ( value==Py_None )</span>
<span class="lineNum">     554 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNode(NULL, BAD_CAST &quot;none&quot;);  // &quot;&lt;none/&gt;&quot;</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     else if (PyInt_Check(value)) {</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNodeInteger(NULL, BAD_CAST &quot;integer&quot;, PyInt_AsLong(value)); // Create an integer node.</span>
<span class="lineNum">     557 </span>            :         // &quot;&lt;integer&gt;%ld&lt;/integer&gt;&quot;
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :     } else if (PyFloat_Check(value)) {</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNode(NULL, BAD_CAST &quot;real&quot;);</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :         if (asprintf(&amp;valtmp, &quot;%g&quot;, PyFloat_AsDouble(value)) &gt;= 0) {</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :           valtmpxml = xmlNewText(BAD_CAST valtmp);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :           xmlAddChild(childtmp, valtmpxml);</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :           free(valtmp); valtmp = NULL;</span>
<span class="lineNum">     564 </span>            :         } else {
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :           xmlFreeNode(childtmp); childtmp = NULL;</span>
<span class="lineNum">     566 </span>            :         }
<span class="lineNum">     567 </span>            :         // &quot;&lt;real&gt;%g&lt;/real&gt;&quot;
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :     } else if ((!has_lists &amp;&amp; PyTuple_Check(value)) || (has_lists &amp;&amp; PyList_Check(value))) {</span>
<span class="lineNum">     569 </span>            :         // Note that PyList is an extension of PySequence, so the original PySequence code would work either way.
<span class="lineNum">     570 </span>            :         // But we want to be able to detect mismatches.
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :         int i, len = ( has_lists ? PyList_Size(value) : PyTuple_Size(value) );</span>
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         xmlNodePtr itemtmp = NULL;</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :         childtmp = xmlNewNode(NULL, BAD_CAST &quot;array&quot;);</span>
<span class="lineNum">     574 </span>            :         // &quot;&lt;array&gt;&quot;
<span class="lineNum">     575 </span><span class="lineNoCov">          0 :         for ( i=0; i&lt;len; ++i ) {</span>
<span class="lineNum">     576 </span><span class="lineNoCov">          0 :             PyObject *obj = ( has_lists ? PyList_GetItem(value,i) : PyTuple_GetItem(value,i) );</span>
<span class="lineNum">     577 </span><span class="lineNoCov">          0 :             if (obj != NULL) {</span>
<span class="lineNum">     578 </span><span class="lineNoCov">          0 :               if ( PyObjDumpable(obj, has_lists)) {</span>
<span class="lineNum">     579 </span><span class="lineNoCov">          0 :                 itemtmp = PyObjectToXML(obj, has_lists);</span>
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :                 xmlAddChild(childtmp, itemtmp);</span>
<span class="lineNum">     581 </span>            :               }
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :               obj = NULL; // PyTuple_GetItem and PyList_GetItem both return borrowed references.</span>
<span class="lineNum">     583 </span>            :             }
<span class="lineNum">     584 </span>            :         }
<span class="lineNum">     585 </span>            :         // &quot;&lt;/array&gt;&quot;
<span class="lineNum">     586 </span>            :     }
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :     return childtmp;</span>
<span class="lineNum">     588 </span>            : }
<span class="lineNum">     589 </span>            : #endif
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : /* ************************************************************************** */
<span class="lineNum">     592 </span>            : /* ****************************   GLIF Output    **************************** */
<a name="593"><span class="lineNum">     593 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineNoCov">          0 : static int refcomp(const void *_r1, const void *_r2) {</span>
<span class="lineNum">     596 </span><span class="lineNoCov">          0 :     const RefChar *ref1 = *(RefChar * const *)_r1;</span>
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :     const RefChar *ref2 = *(RefChar * const *)_r2;</span>
<span class="lineNum">     598 </span><span class="lineNoCov">          0 : return( strcmp( ref1-&gt;sc-&gt;name, ref2-&gt;sc-&gt;name) );</span>
<a name="599"><span class="lineNum">     599 </span>            : }</a>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : xmlNodePtr _GlifToXML(const SplineChar *sc,int layer) {</span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :     if (layer &gt; sc-&gt;layer_cnt) return NULL;</span>
<span class="lineNum">     603 </span>            :     const struct altuni *altuni;
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     int isquad = sc-&gt;layers[layer].order2;</span>
<span class="lineNum">     605 </span>            :     const SplineSet *spl;
<span class="lineNum">     606 </span>            :     const SplinePoint *sp;
<span class="lineNum">     607 </span>            :     const AnchorPoint *ap;
<span class="lineNum">     608 </span>            :     const RefChar *ref;
<span class="lineNum">     609 </span>            :     int err;
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :     char * stringtmp = NULL;</span>
<span class="lineNum">     611 </span>            :     char numstring[32];
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     memset(numstring, 0, sizeof(numstring));</span>
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :     // &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;&quot;
<span class="lineNum">     615 </span>            :     /* No DTD for these guys??? */
<span class="lineNum">     616 </span>            :     // Is there a DTD for glif data? (asks Frank)
<span class="lineNum">     617 </span>            :     // Perhaps we need to make one.
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :     xmlNodePtr topglyphxml = xmlNewNode(NULL, BAD_CAST &quot;glyph&quot;); // Create the glyph node.</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :     xmlSetProp(topglyphxml, &quot;name&quot;, sc-&gt;name); // Set the name for the glyph.</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     xmlSetProp(topglyphxml, &quot;format&quot;, &quot;1&quot;); // Set the format of the glyph.</span>
<span class="lineNum">     622 </span>            :     // &quot;&lt;glyph name=\&quot;%s\&quot; format=\&quot;1\&quot;&gt;&quot; sc-&gt;name
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :     xmlNodePtr tmpxml2 = xmlNewChild(topglyphxml, NULL, BAD_CAST &quot;advance&quot;, NULL); // Create the advance node.</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :     xmlSetPropPrintf(tmpxml2, BAD_CAST &quot;width&quot;, &quot;%d&quot;, sc-&gt;width);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :     if ( sc-&gt;parent-&gt;hasvmetrics ) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       if (asprintf(&amp;stringtmp, &quot;%d&quot;, sc-&gt;width) &gt;= 0) {</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         xmlSetProp(tmpxml2, BAD_CAST &quot;height&quot;, stringtmp);</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :         free(stringtmp); stringtmp = NULL;</span>
<span class="lineNum">     630 </span>            :       }
<span class="lineNum">     631 </span>            :     }
<span class="lineNum">     632 </span>            :     // &quot;&lt;advance width=\&quot;%d\&quot; height=\&quot;%d\&quot;/&gt;&quot; sc-&gt;width sc-&gt;vwidth
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :     if ( sc-&gt;unicodeenc!=-1 ) {</span>
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       xmlNodePtr unicodexml = xmlNewChild(topglyphxml, NULL, BAD_CAST &quot;unicode&quot;, NULL);</span>
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       xmlSetPropPrintf(unicodexml, BAD_CAST &quot;hex&quot;, &quot;%04X&quot;, sc-&gt;unicodeenc);</span>
<span class="lineNum">     637 </span>            :     }
<span class="lineNum">     638 </span>            :     // &quot;&lt;unicode hex=\&quot;%04X\&quot;/&gt;\n&quot; sc-&gt;unicodeenc
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :     for ( altuni = sc-&gt;altuni; altuni!=NULL; altuni = altuni-&gt;next )</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :         if ( altuni-&gt;vs==-1 &amp;&amp; altuni-&gt;fid==0 ) {</span>
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :           xmlNodePtr unicodexml = xmlNewChild(topglyphxml, NULL, BAD_CAST &quot;unicode&quot;, NULL);</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :           xmlSetPropPrintf(unicodexml, BAD_CAST &quot;hex&quot;, &quot;%04X&quot;, altuni-&gt;unienc);</span>
<span class="lineNum">     644 </span>            :         }
<span class="lineNum">     645 </span>            :         // &quot;&lt;unicode hex=\&quot;%04X\&quot;/&gt;&quot; altuni-&gt;unienc
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :     if ( sc-&gt;layers[layer].refs!=NULL || sc-&gt;layers[layer].splines!=NULL ) {</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :       xmlNodePtr outlinexml = xmlNewChild(topglyphxml, NULL, BAD_CAST &quot;outline&quot;, NULL);</span>
<span class="lineNum">     649 </span>            :         // &quot;&lt;outline&gt;&quot;
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :         for ( ap=sc-&gt;anchor; ap!=NULL; ap=ap-&gt;next ) {</span>
<span class="lineNum">     651 </span><span class="lineNoCov">          0 :             int ismark = (ap-&gt;type==at_mark || ap-&gt;type==at_centry);</span>
<span class="lineNum">     652 </span><span class="lineNoCov">          0 :             xmlNodePtr contourxml = xmlNewChild(outlinexml, NULL, BAD_CAST &quot;contour&quot;, NULL);</span>
<span class="lineNum">     653 </span>            :             // &quot;&lt;contour&gt;&quot;
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :             xmlNodePtr pointxml = xmlNewChild(contourxml, NULL, BAD_CAST &quot;point&quot;, NULL);</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :             xmlSetPropPrintf(pointxml, BAD_CAST &quot;x&quot;, &quot;%g&quot;, ap-&gt;me.x);</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :             xmlSetPropPrintf(pointxml, BAD_CAST &quot;y&quot;, &quot;%g&quot;, ap-&gt;me.y);</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :             xmlSetPropPrintf(pointxml, BAD_CAST &quot;type&quot;, &quot;move&quot;);</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :             xmlSetPropPrintf(pointxml, BAD_CAST &quot;name&quot;, &quot;%s%s&quot;, ismark ? &quot;_&quot; : &quot;&quot;, ap-&gt;anchor-&gt;name);</span>
<span class="lineNum">     659 </span>            :             // &quot;&lt;point x=\&quot;%g\&quot; y=\&quot;%g\&quot; type=\&quot;move\&quot; name=\&quot;%s%s\&quot;/&gt;&quot; ap-&gt;me.x ap-&gt;me.y (ismark ? &quot;_&quot; : &quot;&quot;) ap-&gt;anchor-&gt;name
<span class="lineNum">     660 </span>            :             // &quot;&lt;/contour&gt;&quot;
<span class="lineNum">     661 </span>            :         }
<span class="lineNum">     662 </span><span class="lineNoCov">          0 :         for ( spl=sc-&gt;layers[layer].splines; spl!=NULL; spl=spl-&gt;next ) {</span>
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :             xmlNodePtr contourxml = xmlNewChild(outlinexml, NULL, BAD_CAST &quot;contour&quot;, NULL);</span>
<span class="lineNum">     664 </span>            :             // &quot;&lt;contour&gt;&quot;
<span class="lineNum">     665 </span>            :             // We write any leading control points.
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :             if (spl-&gt;start_offset == -2) {</span>
<span class="lineNum">     667 </span><span class="lineNoCov">          0 :                 if (spl-&gt;first &amp;&amp; spl-&gt;first-&gt;prev &amp;&amp; spl-&gt;first-&gt;prev-&gt;from &amp;&amp; !spl-&gt;first-&gt;prev-&gt;from-&gt;nonextcp &amp;&amp; !spl-&gt;first-&gt;prev-&gt;order2) {</span>
<span class="lineNum">     668 </span><span class="lineNoCov">          0 :                           xmlNodePtr pointxml = xmlNewChild(contourxml, NULL, BAD_CAST &quot;point&quot;, NULL);</span>
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;x&quot;, &quot;%g&quot;, (double)spl-&gt;first-&gt;prev-&gt;from-&gt;nextcp.x);</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;y&quot;, &quot;%g&quot;, (double)spl-&gt;first-&gt;prev-&gt;from-&gt;nextcp.y);</span>
<span class="lineNum">     671 </span>            :                           // &quot;&lt;point x=\&quot;%g\&quot; y=\&quot;%g\&quot;/&gt;\n&quot; (double)sp-&gt;prevcp.x (double)sp-&gt;prevcp.y
<span class="lineNum">     672 </span>            :                 }
<span class="lineNum">     673 </span>            :             }
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :             if (spl-&gt;start_offset &lt;= -1) {</span>
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :                 if (spl-&gt;first &amp;&amp; !spl-&gt;first-&gt;noprevcp) {</span>
<span class="lineNum">     676 </span><span class="lineNoCov">          0 :                           xmlNodePtr pointxml = xmlNewChild(contourxml, NULL, BAD_CAST &quot;point&quot;, NULL);</span>
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;x&quot;, &quot;%g&quot;, (double)spl-&gt;first-&gt;prevcp.x);</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;y&quot;, &quot;%g&quot;, (double)spl-&gt;first-&gt;prevcp.y);</span>
<span class="lineNum">     679 </span>            :                           // &quot;&lt;point x=\&quot;%g\&quot; y=\&quot;%g\&quot;/&gt;\n&quot; (double)sp-&gt;prevcp.x (double)sp-&gt;prevcp.y
<span class="lineNum">     680 </span>            :                 }
<span class="lineNum">     681 </span>            :             }
<span class="lineNum">     682 </span><span class="lineNoCov">          0 :             for ( sp=spl-&gt;first; sp!=NULL; ) {</span>
<span class="lineNum">     683 </span>            :                 /* Undocumented fact: If a contour contains a series of off-curve points with no on-curve then treat as quadratic even if no qcurve */
<span class="lineNum">     684 </span>            :                 // We write the next on-curve point.
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :                 if (!isquad || sp-&gt;ttfindex != 0xffff || !SPInterpolate(sp) || sp-&gt;pointtype!=pt_curve || sp-&gt;name != NULL) {</span>
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :                   xmlNodePtr pointxml = xmlNewChild(contourxml, NULL, BAD_CAST &quot;point&quot;, NULL);</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(pointxml, BAD_CAST &quot;x&quot;, &quot;%g&quot;, (double)sp-&gt;me.x);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(pointxml, BAD_CAST &quot;y&quot;, &quot;%g&quot;, (double)sp-&gt;me.y);</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(pointxml, BAD_CAST &quot;type&quot;, BAD_CAST (</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :                   sp-&gt;prev==NULL        ? &quot;move&quot;   :</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :                                         sp-&gt;noprevcp ? &quot;line&quot;   :</span>
<span class="lineNum">     692 </span>            :                                         isquad                ? &quot;qcurve&quot; :
<span class="lineNum">     693 </span>            :                                         &quot;curve&quot;));
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :                   if (sp-&gt;pointtype != pt_corner) xmlSetProp(pointxml, BAD_CAST &quot;smooth&quot;, BAD_CAST &quot;yes&quot;);</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :                   if (sp-&gt;name !=NULL) xmlSetProp(pointxml, BAD_CAST &quot;name&quot;, BAD_CAST sp-&gt;name);</span>
<span class="lineNum">     696 </span>            :                   // &quot;&lt;point x=\&quot;%g\&quot; y=\&quot;%g\&quot; type=\&quot;%s\&quot;%s%s%s%s/&gt;\n&quot; (double)sp-&gt;me.x (double)sp-&gt;me.y
<span class="lineNum">     697 </span>            :                   // (sp-&gt;prev==NULL ? &quot;move&quot; : sp-&gt;prev-&gt;knownlinear ? &quot;line&quot; : isquad ? &quot;qcurve&quot; : &quot;curve&quot;)
<span class="lineNum">     698 </span>            :                   // (sp-&gt;pointtype!=pt_corner?&quot; smooth=\&quot;yes\&quot;&quot;:&quot;&quot;)
<span class="lineNum">     699 </span>            :                   // (sp-&gt;name?&quot; name=\&quot;&quot;:&quot;&quot;) (sp-&gt;name?sp-&gt;name:&quot;&quot;) (sp-&gt;name?&quot;\&quot;&quot;:&quot;&quot;)
<span class="lineNum">     700 </span>            :                 }
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :                 if ( sp-&gt;next==NULL )</span>
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :                   break;</span>
<span class="lineNum">     703 </span>            :                 // We write control points.
<span class="lineNum">     704 </span>            :                 // The conditionals regarding the start offset avoid duplicating points previously written.
<span class="lineNum">     705 </span><span class="lineNoCov">          0 :                 if (sp &amp;&amp; !sp-&gt;nonextcp &amp;&amp; sp-&gt;next &amp;&amp; (sp-&gt;next-&gt;to != spl-&gt;first || spl-&gt;start_offset &gt; -2) &amp;&amp; sp-&gt;next &amp;&amp; !sp-&gt;next-&gt;order2) {</span>
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :                           xmlNodePtr pointxml = xmlNewChild(contourxml, NULL, BAD_CAST &quot;point&quot;, NULL);</span>
<span class="lineNum">     707 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;x&quot;, &quot;%g&quot;, (double)sp-&gt;nextcp.x);</span>
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;y&quot;, &quot;%g&quot;, (double)sp-&gt;nextcp.y);</span>
<span class="lineNum">     709 </span>            :                           // &quot;&lt;point x=\&quot;%g\&quot; y=\&quot;%g\&quot;/&gt;\n&quot; (double)sp-&gt;nextcp.x (double)sp-&gt;nextcp.y
<span class="lineNum">     710 </span>            :                 }
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :                 sp = sp-&gt;next-&gt;to;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :                 if (sp &amp;&amp; !sp-&gt;noprevcp &amp;&amp; (sp != spl-&gt;first || spl-&gt;start_offset &gt; -1)) {</span>
<span class="lineNum">     713 </span><span class="lineNoCov">          0 :                           xmlNodePtr pointxml = xmlNewChild(contourxml, NULL, BAD_CAST &quot;point&quot;, NULL);</span>
<span class="lineNum">     714 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;x&quot;, &quot;%g&quot;, (double)sp-&gt;prevcp.x);</span>
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :                           xmlSetPropPrintf(pointxml, BAD_CAST &quot;y&quot;, &quot;%g&quot;, (double)sp-&gt;prevcp.y);</span>
<span class="lineNum">     716 </span>            :                           // &quot;&lt;point x=\&quot;%g\&quot; y=\&quot;%g\&quot;/&gt;\n&quot; (double)sp-&gt;prevcp.x (double)sp-&gt;prevcp.y
<span class="lineNum">     717 </span>            :                 }
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :                 if ( sp==spl-&gt;first )</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     720 </span>            :             }
<span class="lineNum">     721 </span>            :             // &quot;&lt;/contour&gt;&quot;
<span class="lineNum">     722 </span>            :         }
<span class="lineNum">     723 </span>            :         /* RoboFab outputs components in alphabetic (case sensitive) order. */
<span class="lineNum">     724 </span>            :         /* Somebody asked George to do that too (as in the disabled code below). */
<span class="lineNum">     725 </span>            :         /* But it seems important to leave the ordering as it is. */
<span class="lineNum">     726 </span>            :         /* And David Raymond advises that tampering with the ordering can break things. */
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         if ( sc-&gt;layers[layer].refs!=NULL ) {</span>
<span class="lineNum">     728 </span>            :             const RefChar **refs;
<span class="lineNum">     729 </span>            :             int i, cnt;
<span class="lineNum">     730 </span><span class="lineNoCov">          0 :             for ( cnt=0, ref = sc-&gt;layers[layer].refs; ref!=NULL; ref=ref-&gt;next ) if ((SCWorthOutputting(ref-&gt;sc) || SCHasData(ref-&gt;sc) || ref-&gt;sc-&gt;glif_name != NULL))</span>
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :                 ++cnt;</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :             refs = malloc(cnt*sizeof(RefChar *));</span>
<span class="lineNum">     733 </span><span class="lineNoCov">          0 :             for ( cnt=0, ref = sc-&gt;layers[layer].refs; ref!=NULL; ref=ref-&gt;next ) if ((SCWorthOutputting(ref-&gt;sc) || SCHasData(ref-&gt;sc) || ref-&gt;sc-&gt;glif_name != NULL))</span>
<span class="lineNum">     734 </span><span class="lineNoCov">          0 :                 refs[cnt++] = ref;</span>
<span class="lineNum">     735 </span>            :             // It seems that sorting these breaks something.
<span class="lineNum">     736 </span>            : #if 0
<span class="lineNum">     737 </span>            :             if ( cnt&gt;1 )
<span class="lineNum">     738 </span>            :                 qsort(refs,cnt,sizeof(RefChar *),refcomp);
<span class="lineNum">     739 </span>            : #endif // 0
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :             for ( i=0; i&lt;cnt; ++i ) {</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :                 ref = refs[i];</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :     xmlNodePtr componentxml = xmlNewChild(outlinexml, NULL, BAD_CAST &quot;component&quot;, NULL);</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :     xmlSetPropPrintf(componentxml, BAD_CAST &quot;base&quot;, &quot;%s&quot;, ref-&gt;sc-&gt;name);</span>
<span class="lineNum">     744 </span>            :                 // &quot;&lt;component base=\&quot;%s\&quot;&quot; ref-&gt;sc-&gt;name
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :     char *floattmp = NULL;</span>
<span class="lineNum">     746 </span><span class="lineNoCov">          0 :                 if ( ref-&gt;transform[0]!=1 ) {</span>
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(componentxml, BAD_CAST &quot;xScale&quot;, &quot;%g&quot;, (double) ref-&gt;transform[0]);</span>
<span class="lineNum">     748 </span>            :                     // &quot;xScale=\&quot;%g\&quot;&quot; (double)ref-&gt;transform[0]
<span class="lineNum">     749 </span>            :                 }
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :                 if ( ref-&gt;transform[3]!=1 ) {</span>
<span class="lineNum">     751 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(componentxml, BAD_CAST &quot;yScale&quot;, &quot;%g&quot;, (double) ref-&gt;transform[3]);</span>
<span class="lineNum">     752 </span>            :                     // &quot;yScale=\&quot;%g\&quot;&quot; (double)ref-&gt;transform[3]
<span class="lineNum">     753 </span>            :                 }
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :                 if ( ref-&gt;transform[1]!=0 ) {</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(componentxml, BAD_CAST &quot;xyScale&quot;, &quot;%g&quot;, (double) ref-&gt;transform[1]);</span>
<span class="lineNum">     756 </span>            :                     // &quot;xyScale=\&quot;%g\&quot;&quot; (double)ref-&gt;transform[1]
<span class="lineNum">     757 </span>            :                 }
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :                 if ( ref-&gt;transform[2]!=0 ) {</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(componentxml, BAD_CAST &quot;yxScale&quot;, &quot;%g&quot;, (double) ref-&gt;transform[2]);</span>
<span class="lineNum">     760 </span>            :                     // &quot;yxScale=\&quot;%g\&quot;&quot; (double)ref-&gt;transform[2]
<span class="lineNum">     761 </span>            :                 }
<span class="lineNum">     762 </span><span class="lineNoCov">          0 :                 if ( ref-&gt;transform[4]!=0 ) {</span>
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(componentxml, BAD_CAST &quot;xOffset&quot;, &quot;%g&quot;, (double) ref-&gt;transform[4]);</span>
<span class="lineNum">     764 </span>            :                     // &quot;xOffset=\&quot;%g\&quot;&quot; (double)ref-&gt;transform[4]
<span class="lineNum">     765 </span>            :                 }
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 if ( ref-&gt;transform[5]!=0 ) {</span>
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :                   xmlSetPropPrintf(componentxml, BAD_CAST &quot;yOffset&quot;, &quot;%g&quot;, (double) ref-&gt;transform[5]);</span>
<span class="lineNum">     768 </span>            :                     // &quot;yOffset=\&quot;%g\&quot;&quot; (double)ref-&gt;transform[5]
<span class="lineNum">     769 </span>            :                 }
<span class="lineNum">     770 </span>            :                 // &quot;/&gt;&quot;
<span class="lineNum">     771 </span>            :             }
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :             free(refs);</span>
<span class="lineNum">     773 </span>            :         }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :         // &quot;&lt;/outline&gt;&quot;
<span class="lineNum">     776 </span>            :     }
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     if (sc-&gt;layers[layer].python_persistent != NULL || (layer == ly_fore &amp;&amp; (sc-&gt;hstem!=NULL || sc-&gt;vstem!=NULL ))) {</span>
<span class="lineNum">     778 </span>            :       // If the layer has lib data or if this is the foreground and the glyph has hints, we output lib data.
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :       xmlNodePtr libxml = xmlNewChild(topglyphxml, NULL, BAD_CAST &quot;lib&quot;, NULL);</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :       xmlNodePtr pythonblob = PythonLibToXML(sc-&gt;layers[layer].python_persistent, (layer == ly_fore ? sc : NULL), sc-&gt;layers[layer].python_persistent_has_lists);</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :       xmlAddChild(libxml, pythonblob);</span>
<span class="lineNum">     782 </span>            :     }
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     return topglyphxml;</span>
<a name="784"><span class="lineNum">     784 </span>            : }</a>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineNoCov">          0 : static int GlifDump(const char *glyphdir, const char *gfname, const SplineChar *sc, int layer) {</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     char *gn = buildname(glyphdir,gfname);</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     xmlDocPtr doc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     if (doc == NULL) {</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         free(gn);</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">     792 </span>            :     }
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     xmlNodePtr root_node = _GlifToXML(sc, layer);</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     if (root_node == NULL) {xmlFreeDoc(doc); doc = NULL; free(gn); return 0;}</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     xmlDocSetRootElement(doc, root_node);</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     int ret = (xmlSaveFormatFileEnc(gn, doc, &quot;UTF-8&quot;, 1) != -1);</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc); doc = NULL;</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     free(gn);</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     return ret;</span>
<a name="800"><span class="lineNum">     800 </span>            : }</a>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineNoCov">          0 : int _ExportGlif(FILE *glif,SplineChar *sc,int layer) {</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     xmlDocPtr doc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     xmlNodePtr root_node = _GlifToXML(sc, layer);</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     xmlDocSetRootElement(doc, root_node);</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     int output_status = xmlDocFormatDump(glif, doc, 1);</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc); doc = NULL;</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     return ( output_status != -1 );</span>
<span class="lineNum">     809 </span>            : }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : /* ************************************************************************** */
<span class="lineNum">     812 </span>            : /* ****************************    UFO Output    **************************** */
<a name="813"><span class="lineNum">     813 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineNoCov">          0 : void clear_cached_ufo_paths(SplineFont * sf) {</span>
<span class="lineNum">     816 </span>            :   // We cache the glif names and the layer paths.
<span class="lineNum">     817 </span>            :   // This is helpful for preserving the structure of a U. F. O. to be edited.
<span class="lineNum">     818 </span>            :   // But it may be desirable to purge that data on final output for consistency.
<span class="lineNum">     819 </span>            :   // This function does that.
<span class="lineNum">     820 </span>            :   int i;
<span class="lineNum">     821 </span>            :   // First we clear the glif names.
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; sf-&gt;glyphcnt; i++) {</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :     struct splinechar * sc = sf-&gt;glyphs[i];</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :     if (sc-&gt;glif_name != NULL) { free(sc-&gt;glif_name); sc-&gt;glif_name = NULL; }</span>
<span class="lineNum">     825 </span>            :   }
<span class="lineNum">     826 </span>            :   // Then we clear the layer names.
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; sf-&gt;layer_cnt; i++) {</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :     struct layerinfo * ly = &amp;(sf-&gt;layers[i]);</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :     if (ly-&gt;ufo_path != NULL) { free(ly-&gt;ufo_path); ly-&gt;ufo_path = NULL; }</span>
<span class="lineNum">     830 </span>            :   }
<a name="831"><span class="lineNum">     831 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineNoCov">          0 : void clear_cached_ufo_point_starts(SplineFont * sf) {</span>
<span class="lineNum">     834 </span>            :   // We store the offset from the leading spline point at which to start output
<span class="lineNum">     835 </span>            :   // so as to be able to start curves on control points as some incoming U. F. O. files do.
<span class="lineNum">     836 </span>            :   // But we may want to clear these sometimes.
<span class="lineNum">     837 </span>            :   int splinechar_index;
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :   for (splinechar_index = 0; splinechar_index &lt; sf-&gt;glyphcnt; splinechar_index ++) {</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :     struct splinechar *sc = sf-&gt;glyphs[splinechar_index];</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     if (sc != NULL) {</span>
<span class="lineNum">     841 </span>            :       int layer_index;
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :       for (layer_index = 0; layer_index &lt; sc-&gt;layer_cnt; layer_index ++) {</span>
<span class="lineNum">     843 </span>            :         // We look at the actual shapes for this layer.
<span class="lineNum">     844 </span>            :         {
<span class="lineNum">     845 </span>            :           struct splinepointlist *spl;
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :           for (spl = sc-&gt;layers[layer_index].splines; spl != NULL; spl = spl-&gt;next) {</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :             spl-&gt;start_offset = 0;</span>
<span class="lineNum">     848 </span>            :           }
<span class="lineNum">     849 </span>            :         }
<span class="lineNum">     850 </span>            :         // And then we go hunting for shapes in the refchars.
<span class="lineNum">     851 </span>            :         {
<span class="lineNum">     852 </span>            :           struct refchar *rc;
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :           for (rc = sc-&gt;layers[layer_index].refs; rc != NULL; rc = rc-&gt;next) {</span>
<span class="lineNum">     854 </span>            :             int reflayer_index;
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :             for (reflayer_index = 0; reflayer_index &lt; rc-&gt;layer_cnt; reflayer_index ++) {</span>
<span class="lineNum">     856 </span>            :               struct splinepointlist *spl;
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :               for (spl = rc-&gt;layers[reflayer_index].splines; spl != NULL; spl = spl-&gt;next) {</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :                 spl-&gt;start_offset = 0;</span>
<span class="lineNum">     859 </span>            :               }
<span class="lineNum">     860 </span>            :             }
<span class="lineNum">     861 </span>            :           }
<span class="lineNum">     862 </span>            :         }
<span class="lineNum">     863 </span>            :       }
<span class="lineNum">     864 </span>            :     }
<span class="lineNum">     865 </span>            :   }
<span class="lineNum">     866 </span>            :   // The SplineFont also has a grid.
<span class="lineNum">     867 </span>            :   {
<span class="lineNum">     868 </span>            :     struct splinepointlist *spl;
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :     for (spl = sf-&gt;grid.splines; spl != NULL; spl = spl-&gt;next) {</span>
<span class="lineNum">     870 </span><span class="lineNoCov">          0 :       spl-&gt;start_offset = 0;</span>
<span class="lineNum">     871 </span>            :     }
<span class="lineNum">     872 </span>            :   }
<a name="873"><span class="lineNum">     873 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span><span class="lineNoCov">          0 : xmlDocPtr PlistInit() {</span>
<span class="lineNum">     876 </span>            :     // Some of this code is pasted from libxml2 samples.
<span class="lineNum">     877 </span><span class="lineNoCov">          0 :     xmlDocPtr doc = NULL;</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :     xmlNodePtr root_node = NULL, dict_node = NULL;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :     xmlDtdPtr dtd = NULL;</span>
<span class="lineNum">     880 </span>            :     
<span class="lineNum">     881 </span>            :     char buff[256];
<span class="lineNum">     882 </span>            :     int i, j;
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :     LIBXML_TEST_VERSION;</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :     doc = xmlNewDoc(BAD_CAST &quot;1.0&quot;);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :     dtd = xmlCreateIntSubset(doc, BAD_CAST &quot;plist&quot;, BAD_CAST &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot;, BAD_CAST &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;);</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     root_node = xmlNewNode(NULL, BAD_CAST &quot;plist&quot;);</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     xmlSetProp(root_node, BAD_CAST &quot;version&quot;, BAD_CAST &quot;1.0&quot;);</span>
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :     xmlDocSetRootElement(doc, root_node);</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :     return doc;</span>
<a name="892"><span class="lineNum">     892 </span>            : }</a>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span><span class="lineNoCov">          0 : static void PListAddInteger(xmlNodePtr parent, const char *key, int value) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key);</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :     xmlNewChildPrintf(parent, NULL, BAD_CAST &quot;integer&quot;, &quot;%d&quot;, value);</span>
<a name="897"><span class="lineNum">     897 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineNoCov">          0 : static void PListAddReal(xmlNodePtr parent, const char *key, double value) {</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :     xmlNewChildPrintf(parent, NULL, BAD_CAST &quot;real&quot;, &quot;%g&quot;, value);</span>
<a name="902"><span class="lineNum">     902 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineNoCov">          0 : static void PListAddIntegerOrReal(xmlNodePtr parent, const char *key, double value) {</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :     if (value == floor(value)) PListAddInteger(parent, key, (int)value);</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :     else PListAddReal(parent, key, value);</span>
<a name="907"><span class="lineNum">     907 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span><span class="lineNoCov">          0 : static void PListAddBoolean(xmlNodePtr parent, const char *key, int value) {</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key);</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST (value ? &quot;true&quot;: &quot;false&quot;), NULL);</span>
<a name="912"><span class="lineNum">     912 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineNoCov">          0 : static void PListAddDate(xmlNodePtr parent, const char *key, time_t timestamp) {</span>
<span class="lineNum">     915 </span>            : /* openTypeHeadCreated = string format as \&quot;YYYY/MM/DD HH:MM:SS\&quot;.    */
<span class="lineNum">     916 </span>            : /* \&quot;YYYY/MM/DD\&quot; is year/month/day. The month is in the range 1-12 and       */
<span class="lineNum">     917 </span>            : /* the day is in the range 1-end of month.                              */
<span class="lineNum">     918 </span>            : /*  \&quot;HH:MM:SS\&quot; is hour:minute:second. The hour is in the range 0:23.        */
<span class="lineNum">     919 </span>            : /* Minutes and seconds are in the range 0-59.                           */
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :     struct tm *tm = gmtime(&amp;timestamp);</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key);</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :     xmlNewChildPrintf(parent, NULL, BAD_CAST &quot;string&quot;,</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :             &quot;%4d/%02d/%02d %02d:%02d:%02d&quot;, tm-&gt;tm_year+1900, tm-&gt;tm_mon+1,</span>
<span class="lineNum">     924 </span>            :             tm-&gt;tm_mday, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);
<a name="925"><span class="lineNum">     925 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span><span class="lineNoCov">          0 : int count_occurrence(const char* big, const char* little) {</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :     const char * tmp = big;</span>
<span class="lineNum">     929 </span><span class="lineNoCov">          0 :     int output = 0;</span>
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     while (tmp = strstr(tmp, little)) { output ++; tmp ++; }</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :     return output;</span>
<a name="932"><span class="lineNum">     932 </span>            : }</a>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineNoCov">          0 : static char* normalizeToASCII(char *str) {</span>
<span class="lineNum">     935 </span><span class="lineNoCov">          0 :     if ( str!=NULL &amp;&amp; !AllAscii(str))</span>
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :         return StripToASCII(str);</span>
<span class="lineNum">     937 </span>            :     else
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :         return copy(str);</span>
<a name="939"><span class="lineNum">     939 </span>            : }</a>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineNoCov">          0 : static char* fetchTTFAttribute(const SplineFont *sf, int strid) {</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :     char *value=NULL, *nonenglish=NULL;</span>
<span class="lineNum">     943 </span>            :     struct ttflangname *nm;
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :     for ( nm=sf-&gt;names; nm!=NULL; nm=nm-&gt;next ) {</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :                 if ( nm-&gt;names[strid]!=NULL ) {</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :                 nonenglish = nm-&gt;names[strid];</span>
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :                 if ( nm-&gt;lang == 0x409 ) {</span>
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :                                 value = nm-&gt;names[strid];</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     951 </span>            :                 }
<span class="lineNum">     952 </span>            :                 }
<span class="lineNum">     953 </span>            :     }
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     if ( value==NULL ) value=nonenglish;</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :     return value;</span>
<a name="956"><span class="lineNum">     956 </span>            : }</a>
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span><span class="lineNoCov">          0 : void PListAddString(xmlNodePtr parent, const char *key, const char *value) {</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :     if ( value==NULL ) value = &quot;&quot;;</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :     xmlNodePtr keynode = xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key); // &quot;&lt;key&gt;%s&lt;/key&gt;&quot; key</span>
<span class="lineNum">     961 </span>            : #ifdef ESCAPE_LIBXML_STRINGS
<span class="lineNum">     962 </span>            :     size_t main_size = strlen(value) +
<span class="lineNum">     963 </span>            :                        (count_occurrence(value, &quot;&lt;&quot;) * (strlen(&quot;&amp;lt&quot;)-strlen(&quot;&lt;&quot;))) +
<span class="lineNum">     964 </span>            :                        (count_occurrence(value, &quot;&gt;&quot;) * (strlen(&quot;&amp;gt&quot;)-strlen(&quot;&lt;&quot;))) +
<span class="lineNum">     965 </span>            :                        (count_occurrence(value, &quot;&amp;&quot;) * (strlen(&quot;&amp;amp&quot;)-strlen(&quot;&lt;&quot;)));
<span class="lineNum">     966 </span>            :     char *tmpstring = malloc(main_size + 1); tmpstring[0] = '\0';
<span class="lineNum">     967 </span>            :     off_t pos1 = 0;
<span class="lineNum">     968 </span>            :     while ( *value ) {
<span class="lineNum">     969 </span>            :         if ( *value=='&lt;' ) {
<span class="lineNum">     970 </span>            :             strcat(tmpstring, &quot;&amp;lt;&quot;);
<span class="lineNum">     971 </span>            :             pos1 += strlen(&quot;&amp;lt;&quot;);
<span class="lineNum">     972 </span>            :         } else if ( *value=='&gt;' ) {
<span class="lineNum">     973 </span>            :             strcat(tmpstring, &quot;&amp;gt;&quot;);
<span class="lineNum">     974 </span>            :             pos1 += strlen(&quot;&amp;gt;&quot;);
<span class="lineNum">     975 </span>            :         } else if ( *value == '&amp;' ) {
<span class="lineNum">     976 </span>            :             strcat(tmpstring, &quot;&amp;amp;&quot;);
<span class="lineNum">     977 </span>            :             pos1 += strlen(&quot;&amp;amp;&quot;);
<span class="lineNum">     978 </span>            :         } else {
<span class="lineNum">     979 </span>            :             tmpstring[pos1++] = *value;
<span class="lineNum">     980 </span>            :             tmpstring[pos1] = '\0';
<span class="lineNum">     981 </span>            :         }
<span class="lineNum">     982 </span>            :         ++value;
<span class="lineNum">     983 </span>            :     }
<span class="lineNum">     984 </span>            :     xmlNodePtr valnode = xmlNewChild(parent, NULL, BAD_CAST &quot;string&quot;, tmpstring); // &quot;&lt;string&gt;%s&lt;/string&gt;&quot; tmpstring
<span class="lineNum">     985 </span>            : #else
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :     xmlNodePtr valnode = xmlNewTextChild(parent, NULL, BAD_CAST &quot;string&quot;, value); // &quot;&lt;string&gt;%s&lt;/string&gt;&quot; tmpstring</span>
<span class="lineNum">     987 </span>            : #endif
<a name="988"><span class="lineNum">     988 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span><span class="lineNoCov">          0 : static void PListAddNameString(xmlNodePtr parent, const char *key, const SplineFont *sf, int strid) {</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :     char *value=NULL, *nonenglish=NULL, *freeme=NULL;</span>
<span class="lineNum">     992 </span>            :     struct ttflangname *nm;
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :     for ( nm=sf-&gt;names; nm!=NULL; nm=nm-&gt;next ) {</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :         if ( nm-&gt;names[strid]!=NULL ) {</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :             nonenglish = nm-&gt;names[strid];</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :             if ( nm-&gt;lang == 0x409 ) {</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :                 value = nm-&gt;names[strid];</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    1000 </span>            :             }
<span class="lineNum">    1001 </span>            :         }
<span class="lineNum">    1002 </span>            :     }
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :     if ( value==NULL &amp;&amp; strid==ttf_version &amp;&amp; sf-&gt;version!=NULL ) {</span>
<span class="lineNum">    1004 </span>            :         char versionStr[6];
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :         paddedVersionStr(sf-&gt;version, versionStr);</span>
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :         value = freeme = strconcat(&quot;Version &quot;, versionStr);</span>
<span class="lineNum">    1007 </span>            :     }
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :     if ( value==NULL &amp;&amp; strid==ttf_copyright &amp;&amp; sf-&gt;copyright!=NULL )</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         value = sf-&gt;copyright;</span>
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :     if ( value==NULL )</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :         value=nonenglish;</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :     if ( value!=NULL ) {</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :         PListAddString(parent,key,value);</span>
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :     free(freeme);</span>
<a name="1016"><span class="lineNum">    1016 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 : static void PListAddIntArray(xmlNodePtr parent, const char *key, const char *entries, int len) {</span>
<span class="lineNum">    1019 </span>            :     int i;
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key);</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :     xmlNodePtr arrayxml = xmlNewChild(parent, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;len; ++i ) {</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :       xmlNewChildInteger(arrayxml, NULL, BAD_CAST &quot;integer&quot;, entries[i]);</span>
<span class="lineNum">    1024 </span>            :     }
<a name="1025"><span class="lineNum">    1025 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 : static void PListAddPrivateArray(xmlNodePtr parent, const char *key, struct psdict *private) {</span>
<span class="lineNum">    1028 </span>            :     char *value;
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :     if ( private==NULL )</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     value = PSDictHasEntry(private,key);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 :     if ( value==NULL )</span>
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :     xmlNewChildPrintf(parent, NULL, BAD_CAST &quot;key&quot;, &quot;postscript%s&quot;, key); // &quot;&lt;key&gt;postscript%s&lt;/key&gt;&quot; key</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :     xmlNodePtr arrayxml = xmlNewChild(parent, NULL, BAD_CAST &quot;array&quot;, NULL); // &quot;&lt;array&gt;&quot;</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :     while ( *value==' ' || *value=='[' ) ++value;</span>
<span class="lineNum">    1037 </span>            :     for (;;) {
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :         int havedot=0;</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :         int skipping=0;</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :         size_t tmpsize = 8;</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :         char * tmp = malloc(tmpsize);</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :         off_t tmppos = 0;</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :         while ( *value!=']' &amp;&amp; *value!='\0' &amp;&amp; *value!=' ' &amp;&amp; tmp!=NULL) {</span>
<span class="lineNum">    1044 </span>            :             // We now deal with non-integers as necessary.
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :             if (*value=='.') {</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :               if (havedot) skipping = true;</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :               else havedot = 1;</span>
<span class="lineNum">    1048 </span>            :             }
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :             if (skipping)</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                 ++value;</span>
<span class="lineNum">    1051 </span>            :             else
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :                 tmp[tmppos++] = *value++;</span>
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :             if (tmppos == tmpsize) { tmpsize *= 2; tmp = realloc(tmp, tmpsize); }</span>
<span class="lineNum">    1054 </span>            :         }
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :         tmp[tmppos] = '\0';</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :         if (tmp != NULL) {</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :           if (havedot)</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :             xmlNewChildString(arrayxml, NULL, BAD_CAST &quot;real&quot;, BAD_CAST tmp); // &quot;&lt;real&gt;%s&lt;/real&gt;&quot; tmp</span>
<span class="lineNum">    1059 </span>            :           else
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :             xmlNewChildString(arrayxml, NULL, BAD_CAST &quot;integer&quot;, BAD_CAST tmp); // &quot;&lt;integer&gt;%s&lt;/integer&gt;&quot; tmp</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :           free(tmp); tmp = NULL;</span>
<span class="lineNum">    1062 </span>            :         }
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :         while ( *value==' ' ) ++value;</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 :         if ( *value==']' || *value=='\0' ) break;</span>
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    1066 </span>            :     // &quot;&lt;/array&gt;&quot;
<a name="1067"><span class="lineNum">    1067 </span>            : }</a>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 : static void PListAddPrivateThing(xmlNodePtr parent, const char *key, struct psdict *private, char *type) {</span>
<span class="lineNum">    1070 </span>            :     char *value;
<span class="lineNum">    1071 </span>            : 
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :     if ( private==NULL ) return;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :     value = PSDictHasEntry(private,key);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :     if ( value==NULL ) return;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :     while ( *value==' ' || *value=='[' ) ++value;</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :     xmlNewChildPrintf(parent, NULL, BAD_CAST &quot;key&quot;, &quot;postscript%s&quot;, key); // &quot;&lt;key&gt;postscript%s&lt;/key&gt;&quot; key</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     while ( *value==' ' || *value=='[' ) ++value;</span>
<span class="lineNum">    1080 </span>            :     {
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :         int havedot=0;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :         int skipping=0;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :         size_t tmpsize = 8;</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :         char * tmp = malloc(tmpsize);</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :         off_t tmppos = 0;</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :         while ( *value!=']' &amp;&amp; *value!='\0' &amp;&amp; *value!=' ' &amp;&amp; tmp!=NULL) {</span>
<span class="lineNum">    1087 </span>            :             // We now deal with non-integers as necessary.
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :             if (*value=='.') {</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :               if (havedot) skipping = true;</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :               else havedot = 1;</span>
<span class="lineNum">    1091 </span>            :             }
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :             if (skipping)</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :                 ++value;</span>
<span class="lineNum">    1094 </span>            :             else
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                 tmp[tmppos++] = *value++;</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :             if (tmppos == tmpsize) { tmpsize *= 2; tmp = realloc(tmp, tmpsize); }</span>
<span class="lineNum">    1097 </span>            :         }
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :         tmp[tmppos] = '\0';</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :         if (tmp != NULL) {</span>
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :           if (havedot)</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :             xmlNewChildString(parent, NULL, BAD_CAST &quot;real&quot;, BAD_CAST tmp); // &quot;&lt;real&gt;%s&lt;/real&gt;&quot; tmp</span>
<span class="lineNum">    1102 </span>            :           else
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :             xmlNewChildString(parent, NULL, BAD_CAST &quot;integer&quot;, BAD_CAST tmp); // &quot;&lt;integer&gt;%s&lt;/integer&gt;&quot; tmp</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :           free(tmp); tmp = NULL;</span>
<span class="lineNum">    1105 </span>            :         }
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :         while ( *value==' ' ) ++value;</span>
<span class="lineNum">    1107 </span>            :     }
<a name="1108"><span class="lineNum">    1108 </span>            : }</a>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 : static int UFOOutputMetaInfo(const char *basedir,SplineFont *sf) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Add the dict.</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;creator&quot;,&quot;net.GitHub.FontForge&quot;);</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :     PListAddInteger(dictnode,&quot;formatVersion&quot;,2);</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir, &quot;metainfo.plist&quot;); // Build the file name.</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     free(fname); fname = NULL;</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    1120 </span><span class="lineNoCov">          0 :     xmlCleanupParser();</span>
<span class="lineNum">    1121 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1122"><span class="lineNum">    1122 </span>            : }</a>
<span class="lineNum">    1123 </span>            : 
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : static int UFOOutputFontInfo(const char *basedir, SplineFont *sf, int layer) {</span>
<span class="lineNum">    1125 </span><span class="lineNoCov">          0 :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Add the dict.</span>
<span class="lineNum">    1128 </span>            : 
<span class="lineNum">    1129 </span>            :     DBounds bb;
<span class="lineNum">    1130 </span>            :     double test;
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            : /* Same keys in both formats */
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;familyName&quot;,sf-&gt;familyname_with_timestamp ? sf-&gt;familyname_with_timestamp : sf-&gt;familyname);</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;styleName&quot;,SFGetModifiers(sf));</span>
<span class="lineNum">    1135 </span>            :     {
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :         char* preferredFamilyName = fetchTTFAttribute(sf,ttf_preffamilyname);</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :         char* preferredSubfamilyName = fetchTTFAttribute(sf,ttf_prefmodifiers);</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :         char* styleMapFamily = NULL;</span>
<span class="lineNum">    1139 </span><span class="lineNoCov">          0 :         if (sf-&gt;styleMapFamilyName != NULL) {</span>
<span class="lineNum">    1140 </span>            :             /* Empty styleMapStyleName means we imported a UFO that does not have this field. Bypass the fallback. */
<span class="lineNum">    1141 </span><span class="lineNoCov">          0 :             if (sf-&gt;styleMapFamilyName[0]!='\0')</span>
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 :                 styleMapFamily = sf-&gt;styleMapFamilyName;</span>
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :         } else if (preferredFamilyName != NULL &amp;&amp; preferredSubfamilyName != NULL) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :             styleMapFamily = malloc(strlen(preferredFamilyName)+strlen(preferredSubfamilyName)+2);</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :             strcpy(styleMapFamily, preferredFamilyName);</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :             strcat(styleMapFamily, &quot; &quot;);</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :             strcat(styleMapFamily, preferredSubfamilyName);</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :         } else if (sf-&gt;fullname != NULL) styleMapFamily = sf-&gt;fullname;</span>
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :         if (styleMapFamily != NULL) PListAddString(dictnode,&quot;styleMapFamilyName&quot;, styleMapFamily);</span>
<span class="lineNum">    1150 </span>            :     }
<span class="lineNum">    1151 </span>            :     {
<span class="lineNum">    1152 </span><span class="lineNoCov">          0 :         char* styleMapName = NULL;</span>
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :         if (sf-&gt;pfminfo.stylemap != -1) {</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :             if (sf-&gt;pfminfo.stylemap == 0x21) styleMapName = &quot;bold italic&quot;;</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :             else if (sf-&gt;pfminfo.stylemap == 0x20) styleMapName = &quot;bold&quot;;</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :             else if (sf-&gt;pfminfo.stylemap == 0x01) styleMapName = &quot;italic&quot;;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :             else if (sf-&gt;pfminfo.stylemap == 0x40) styleMapName = &quot;regular&quot;;</span>
<span class="lineNum">    1158 </span>            :         } else {
<span class="lineNum">    1159 </span>            :             /* Figure out styleMapStyleName automatically. */
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :             if (sf-&gt;pfminfo.weight == 700 &amp;&amp; sf-&gt;italicangle &lt; 0) styleMapName = &quot;bold italic&quot;;</span>
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :             else if (sf-&gt;italicangle &lt; 0) styleMapName = &quot;italic&quot;;</span>
<span class="lineNum">    1162 </span><span class="lineNoCov">          0 :             else if (sf-&gt;pfminfo.weight == 700) styleMapName = &quot;bold&quot;;</span>
<span class="lineNum">    1163 </span><span class="lineNoCov">          0 :             else if (sf-&gt;pfminfo.weight == 400) styleMapName = &quot;regular&quot;;</span>
<span class="lineNum">    1164 </span>            :         }
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :         if (styleMapName != NULL) PListAddString(dictnode,&quot;styleMapStyleName&quot;, styleMapName);</span>
<span class="lineNum">    1166 </span>            :     }
<span class="lineNum">    1167 </span>            :     {
<span class="lineNum">    1168 </span>            :       // We attempt to get numeric major and minor versions for U. F. O. out of the FontForge version string.
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :       int versionMajor = -1;</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :       int versionMinor = -1;</span>
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :       if (sf-&gt;version != NULL) extractNumericVersion(sf-&gt;version, &amp;versionMajor, &amp;versionMinor);</span>
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :       if (versionMajor &gt;= 0) PListAddInteger(dictnode,&quot;versionMajor&quot;, versionMajor);</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :       if (versionMinor &gt;= 0) PListAddInteger(dictnode,&quot;versionMinor&quot;, versionMinor);</span>
<span class="lineNum">    1174 </span>            :     }
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;copyright&quot;,sf,ttf_copyright);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;trademark&quot;,sf,ttf_trademark);</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :     PListAddInteger(dictnode,&quot;unitsPerEm&quot;,sf-&gt;ascent+sf-&gt;descent);</span>
<span class="lineNum">    1178 </span>            : // We decided that it would be more helpful to round-trip the U. F. O. data.
<span class="lineNum">    1179 </span>            : #if 0
<span class="lineNum">    1180 </span>            :     test = SFXHeight(sf,layer,true);
<span class="lineNum">    1181 </span>            :     if ( test&gt;0 )
<span class="lineNum">    1182 </span>            :         PListAddInteger(dictnode,&quot;xHeight&quot;,(int) rint(test));
<span class="lineNum">    1183 </span>            :     test = SFCapHeight(sf,layer,true);
<span class="lineNum">    1184 </span>            :     if ( test&gt;0 )
<span class="lineNum">    1185 </span>            :         PListAddInteger(dictnode,&quot;capHeight&quot;,(int) rint(test));
<span class="lineNum">    1186 </span>            : #else
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     if (sf-&gt;pfminfo.os2_capheight) PListAddInteger(dictnode,&quot;capHeight&quot;,sf-&gt;pfminfo.os2_capheight);</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :     if (sf-&gt;pfminfo.os2_xheight) PListAddInteger(dictnode,&quot;xHeight&quot;,sf-&gt;pfminfo.os2_xheight);</span>
<span class="lineNum">    1189 </span>            : #endif // 0
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :     if ( sf-&gt;invalidem ) {</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :         PListAddIntegerOrReal(dictnode,&quot;ascender&quot;,sf-&gt;ufo_ascent);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         PListAddIntegerOrReal(dictnode,&quot;descender&quot;,sf-&gt;ufo_descent);</span>
<span class="lineNum">    1193 </span>            :     } else {
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         PListAddIntegerOrReal(dictnode,&quot;ascender&quot;,sf-&gt;ascent);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :         PListAddIntegerOrReal(dictnode,&quot;descender&quot;,-sf-&gt;descent);</span>
<span class="lineNum">    1196 </span>            :     }
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :     PListAddReal(dictnode,&quot;italicAngle&quot;,sf-&gt;italicangle);</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;note&quot;,sf-&gt;comments);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     PListAddDate(dictnode,&quot;openTypeHeadCreated&quot;,sf-&gt;creationtime);</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     SplineFontFindBounds(sf,&amp;bb);</span>
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.hheadascent_add )</span>
<span class="lineNum">    1203 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeHheaAscender&quot;,bb.maxy+sf-&gt;pfminfo.hhead_ascent);</span>
<span class="lineNum">    1204 </span>            :     else
<span class="lineNum">    1205 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeHheaAscender&quot;,sf-&gt;pfminfo.hhead_ascent);</span>
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.hheaddescent_add )</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeHheaDescender&quot;,bb.miny+sf-&gt;pfminfo.hhead_descent);</span>
<span class="lineNum">    1208 </span>            :     else
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeHheaDescender&quot;,sf-&gt;pfminfo.hhead_descent);</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :     PListAddInteger(dictnode,&quot;openTypeHheaLineGap&quot;,sf-&gt;pfminfo.linegap);</span>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameDesigner&quot;,sf,ttf_designer);</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameDesignerURL&quot;,sf,ttf_designerurl);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameManufacturer&quot;,sf,ttf_manufacturer);</span>
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameManufacturerURL&quot;,sf,ttf_venderurl);</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameLicense&quot;,sf,ttf_license);</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameLicenseURL&quot;,sf,ttf_licenseurl);</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameVersion&quot;,sf,ttf_version);</span>
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameUniqueID&quot;,sf,ttf_uniqueid);</span>
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameDescription&quot;,sf,ttf_descriptor);</span>
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNamePreferredFamilyName&quot;,sf,ttf_preffamilyname);</span>
<span class="lineNum">    1222 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNamePreferredSubfamilyName&quot;,sf,ttf_prefmodifiers);</span>
<span class="lineNum">    1223 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameCompatibleFullName&quot;,sf,ttf_compatfull);</span>
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeNameSampleText&quot;,sf,ttf_sampletext);</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeWWSFamilyName&quot;,sf,ttf_wwsfamily);</span>
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :     PListAddNameString(dictnode,&quot;openTypeWWSSubfamilyName&quot;,sf,ttf_wwssubfamily);</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.panose_set )</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :         PListAddIntArray(dictnode,&quot;openTypeOS2Panose&quot;,sf-&gt;pfminfo.panose,10);</span>
<span class="lineNum">    1229 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.pfmset ) {</span>
<span class="lineNum">    1230 </span>            :         char vendor[8], fc[2];
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2WidthClass&quot;,sf-&gt;pfminfo.width);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2WeightClass&quot;,sf-&gt;pfminfo.weight);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :         memcpy(vendor,sf-&gt;pfminfo.os2_vendor,4);</span>
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :         vendor[4] = 0;</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :         PListAddString(dictnode,&quot;openTypeOS2VendorID&quot;,vendor);</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :         fc[0] = sf-&gt;pfminfo.os2_family_class&gt;&gt;8; fc[1] = sf-&gt;pfminfo.os2_family_class&amp;0xff;</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :         PListAddIntArray(dictnode,&quot;openTypeOS2FamilyClass&quot;,fc,2);</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :         if ( sf-&gt;pfminfo.fstype!=-1 ) {</span>
<span class="lineNum">    1239 </span>            :             int fscnt,i;
<span class="lineNum">    1240 </span>            :             char fstype[16];
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :             for ( i=fscnt=0; i&lt;16; ++i )</span>
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :                 if ( sf-&gt;pfminfo.fstype&amp;(1&lt;&lt;i) )</span>
<span class="lineNum">    1243 </span><span class="lineNoCov">          0 :                     fstype[fscnt++] = i;</span>
<span class="lineNum">    1244 </span>            :             /*
<span class="lineNum">    1245 </span>            :              * Note that value 0x0 is represented by an empty bit, so in that case
<span class="lineNum">    1246 </span>            :              * we output an empty array, otherwise compilers will fallback to their
<span class="lineNum">    1247 </span>            :              * default fsType value.
<span class="lineNum">    1248 </span>            :              */
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :             PListAddIntArray(dictnode,&quot;openTypeOS2Type&quot;,fstype,fscnt);</span>
<span class="lineNum">    1250 </span>            :         }
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :         if ( sf-&gt;pfminfo.typoascent_add )</span>
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2TypoAscender&quot;,sf-&gt;ascent+sf-&gt;pfminfo.os2_typoascent);</span>
<span class="lineNum">    1253 </span>            :         else
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2TypoAscender&quot;,sf-&gt;pfminfo.os2_typoascent);</span>
<span class="lineNum">    1255 </span><span class="lineNoCov">          0 :         if ( sf-&gt;pfminfo.typodescent_add )</span>
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2TypoDescender&quot;,-sf-&gt;descent+sf-&gt;pfminfo.os2_typodescent);</span>
<span class="lineNum">    1257 </span>            :         else
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2TypoDescender&quot;,sf-&gt;pfminfo.os2_typodescent);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2TypoLineGap&quot;,sf-&gt;pfminfo.os2_typolinegap);</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :         if ( sf-&gt;pfminfo.winascent_add )</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2WinAscent&quot;,bb.maxy+sf-&gt;pfminfo.os2_winascent);</span>
<span class="lineNum">    1262 </span>            :         else
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2WinAscent&quot;,sf-&gt;pfminfo.os2_winascent);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :         if ( sf-&gt;pfminfo.windescent_add )</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2WinDescent&quot;,-bb.miny+sf-&gt;pfminfo.os2_windescent);</span>
<span class="lineNum">    1266 </span>            :         else
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :             PListAddInteger(dictnode,&quot;openTypeOS2WinDescent&quot;,sf-&gt;pfminfo.os2_windescent);</span>
<span class="lineNum">    1268 </span>            :     }
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.subsuper_set ) {</span>
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SubscriptXSize&quot;,sf-&gt;pfminfo.os2_subxsize);</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SubscriptYSize&quot;,sf-&gt;pfminfo.os2_subysize);</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SubscriptXOffset&quot;,sf-&gt;pfminfo.os2_subxoff);</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SubscriptYOffset&quot;,sf-&gt;pfminfo.os2_subyoff);</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SuperscriptXSize&quot;,sf-&gt;pfminfo.os2_supxsize);</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SuperscriptYSize&quot;,sf-&gt;pfminfo.os2_supysize);</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SuperscriptXOffset&quot;,sf-&gt;pfminfo.os2_supxoff);</span>
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2SuperscriptYOffset&quot;,sf-&gt;pfminfo.os2_supyoff);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2StrikeoutSize&quot;,sf-&gt;pfminfo.os2_strikeysize);</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeOS2StrikeoutPosition&quot;,sf-&gt;pfminfo.os2_strikeypos);</span>
<span class="lineNum">    1280 </span>            :     }
<span class="lineNum">    1281 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.vheadset )</span>
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :         PListAddInteger(dictnode,&quot;openTypeVheaTypoLineGap&quot;,sf-&gt;pfminfo.vlinegap);</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.hasunicoderanges ) {</span>
<span class="lineNum">    1284 </span>            :         char ranges[128];
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :         int i, j, c = 0;</span>
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :         for ( i = 0; i&lt;4; i++ )</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :             for ( j = 0; j&lt;32; j++ )</span>
<span class="lineNum">    1289 </span><span class="lineNoCov">          0 :                 if ( sf-&gt;pfminfo.unicoderanges[i] &amp; (1 &lt;&lt; j) )</span>
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :                     ranges[c++] = i*32+j;</span>
<span class="lineNum">    1291 </span><span class="lineNoCov">          0 :         if ( c!=0 )</span>
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :             PListAddIntArray(dictnode,&quot;openTypeOS2UnicodeRanges&quot;,ranges,c);</span>
<span class="lineNum">    1293 </span>            :     }
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :     if ( sf-&gt;pfminfo.hascodepages ) {</span>
<span class="lineNum">    1295 </span>            :         char pages[64];
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :         int i, j, c = 0;</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :         for ( i = 0; i&lt;2; i++)</span>
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :             for ( j=0; j&lt;32; j++ )</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :                 if ( sf-&gt;pfminfo.codepages[i] &amp; (1 &lt;&lt; j) )</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :                     pages[c++] = i*32+j;</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :         if ( c!=0 )</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :             PListAddIntArray(dictnode,&quot;openTypeOS2CodePageRanges&quot;,pages,c);</span>
<span class="lineNum">    1304 </span>            :     }
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;postscriptFontName&quot;,sf-&gt;fontname);</span>
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;postscriptFullName&quot;,sf-&gt;fullname);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;postscriptWeightName&quot;,sf-&gt;weight);</span>
<span class="lineNum">    1308 </span>            :     /* Spec defines a &quot;postscriptSlantAngle&quot; but I don't think postscript does*/
<span class="lineNum">    1309 </span>            :     /* PS does define an italicAngle, but presumably that's the general italic*/
<span class="lineNum">    1310 </span>            :     /* angle we output earlier */
<span class="lineNum">    1311 </span>            :     /* UniqueID is obsolete */
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :     PListAddInteger(dictnode,&quot;postscriptUnderlineThickness&quot;,sf-&gt;uwidth);</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :     PListAddInteger(dictnode,&quot;postscriptUnderlinePosition&quot;,sf-&gt;upos);</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     if ( sf-&gt;private!=NULL ) {</span>
<span class="lineNum">    1315 </span>            :         char *pt;
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :         PListAddPrivateArray(dictnode, &quot;BlueValues&quot;, sf-&gt;private);</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :         PListAddPrivateArray(dictnode, &quot;OtherBlues&quot;, sf-&gt;private);</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :         PListAddPrivateArray(dictnode, &quot;FamilyBlues&quot;, sf-&gt;private);</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :         PListAddPrivateArray(dictnode, &quot;FamilyOtherBlues&quot;, sf-&gt;private);</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :         PListAddPrivateArray(dictnode, &quot;StemSnapH&quot;, sf-&gt;private);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :         PListAddPrivateArray(dictnode, &quot;StemSnapV&quot;, sf-&gt;private);</span>
<span class="lineNum">    1322 </span><span class="lineNoCov">          0 :         PListAddPrivateThing(dictnode, &quot;BlueFuzz&quot;, sf-&gt;private, &quot;integer&quot;);</span>
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :         PListAddPrivateThing(dictnode, &quot;BlueShift&quot;, sf-&gt;private, &quot;integer&quot;);</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :         PListAddPrivateThing(dictnode, &quot;BlueScale&quot;, sf-&gt;private, &quot;real&quot;);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :         if ( (pt=PSDictHasEntry(sf-&gt;private,&quot;ForceBold&quot;))!=NULL )</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :             PListAddBoolean(dictnode, &quot;postscriptForceBold&quot;, strstr(pt,&quot;true&quot;)!=NULL ? true : false );</span>
<span class="lineNum">    1327 </span>            :     }
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :     if ( sf-&gt;fondname!=NULL )</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :     PListAddString(dictnode,&quot;macintoshFONDName&quot;,sf-&gt;fondname);</span>
<span class="lineNum">    1330 </span>            :     // TODO: Output unrecognized data.
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir, &quot;fontinfo.plist&quot;); // Build the file name.</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :     xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :     free(fname); fname = NULL;</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :     xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :     xmlCleanupParser();</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1337"><span class="lineNum">    1337 </span>            : }</a>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 : int kernclass_for_groups_plist(struct splinefont *sf, struct kernclass *kc, int flags) {</span>
<span class="lineNum">    1340 </span>            :   // Note that this is not a complete logical inverse of sister function kernclass_for_feature_file.
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :   return ((flags &amp; FF_KERNCLASS_FLAG_NATIVE) ||</span>
<span class="lineNum">    1342 </span><span class="lineNoCov">          0 :   (!(flags &amp; FF_KERNCLASS_FLAG_FEATURE) &amp;&amp; !kc-&gt;feature &amp;&amp; (sf-&gt;preferred_kerning &amp; 1)));</span>
<a name="1343"><span class="lineNum">    1343 </span>            : }</a>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 : void ClassKerningAddExtensions(struct kernclass * target) {</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :   if (target-&gt;firsts_names == NULL &amp;&amp; target-&gt;first_cnt) target-&gt;firsts_names = calloc(target-&gt;first_cnt, sizeof(char *));</span>
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   if (target-&gt;seconds_names == NULL &amp;&amp; target-&gt;second_cnt) target-&gt;seconds_names = calloc(target-&gt;second_cnt, sizeof(char *));</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   if (target-&gt;firsts_flags == NULL &amp;&amp; target-&gt;first_cnt) target-&gt;firsts_flags = calloc(target-&gt;first_cnt, sizeof(int));</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :   if (target-&gt;seconds_flags == NULL &amp;&amp; target-&gt;second_cnt) target-&gt;seconds_flags = calloc(target-&gt;second_cnt, sizeof(int));</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   if (target-&gt;offsets_flags == NULL &amp;&amp; (target-&gt;first_cnt * target-&gt;second_cnt)) target-&gt;offsets_flags = calloc(target-&gt;first_cnt * target-&gt;second_cnt, sizeof(int));</span>
<a name="1351"><span class="lineNum">    1351 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span><span class="lineNoCov">          0 : void UFONameKerningClasses(SplineFont *sf) {</span>
<span class="lineNum">    1354 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1355 </span>            :     struct glif_name_index _class_name_hash;
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :     struct glif_name_index * class_name_hash = &amp;_class_name_hash; // Open the hash table.</span>
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :     memset(class_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    1358 </span>            : #else
<span class="lineNum">    1359 </span>            :     void * class_name_hash = NULL;
<span class="lineNum">    1360 </span>            : #endif
<span class="lineNum">    1361 </span>            :     struct kernclass *current_kernclass;
<span class="lineNum">    1362 </span>            :     int isv;
<span class="lineNum">    1363 </span>            :     int isr;
<span class="lineNum">    1364 </span>            :     int i;
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     int absolute_index = 0; // This gives us a unique index for each kerning class.</span>
<span class="lineNum">    1366 </span>            :     // First we catch the existing names.
<span class="lineNum">    1367 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :     HashKerningClassNamesCaps(sf, class_name_hash); // Note that we use the all-caps hasher for compatibility with the official naming scheme and the following code.</span>
<span class="lineNum">    1369 </span>            : #endif
<span class="lineNum">    1370 </span>            :     // Next we create names for the unnamed. Note that we currently avoid naming anything that might go into the feature file (since that handler currently creates its own names).
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :     absolute_index = 0;</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :     for (isv = 0; isv &lt; 2; isv++)</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     for ( current_kernclass = (isv ? sf-&gt;vkerns : sf-&gt;kerns); current_kernclass != NULL; current_kernclass = current_kernclass-&gt;next )</span>
<span class="lineNum">    1374 </span><span class="lineNoCov">          0 :     for (isr = 0; isr &lt; 2; isr++) {</span>
<span class="lineNum">    1375 </span>            :       // If the special class kerning storage blocks are unallocated, we allocate them if using native U. F. O. class kerning or skip the naming otherwise.
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :       if ( (isr ? current_kernclass-&gt;seconds_names : current_kernclass-&gt;firsts_names) == NULL ) {</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :         if ( !(current_kernclass-&gt;feature) &amp;&amp; (sf-&gt;preferred_kerning &amp; 1) ) {</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :           ClassKerningAddExtensions(current_kernclass);</span>
<span class="lineNum">    1379 </span>            :         } else {
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    1381 </span>            :         }
<span class="lineNum">    1382 </span>            :       }
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :       for ( i=0; i&lt; (isr ? current_kernclass-&gt;second_cnt : current_kernclass-&gt;first_cnt); i++ )</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :       if ( ((isr ? current_kernclass-&gt;seconds_names[i] : current_kernclass-&gt;firsts_names[i]) == NULL) &amp;&amp;</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :         kernclass_for_groups_plist(sf, current_kernclass, (isr ? current_kernclass-&gt;seconds_flags[i] : current_kernclass-&gt;firsts_flags[i]))</span>
<span class="lineNum">    1386 </span>            :         ) {
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :         int classflags = isr ? current_kernclass-&gt;seconds_flags[i] : current_kernclass-&gt;firsts_flags[i];</span>
<span class="lineNum">    1388 </span>            :         // If the splinefont is not forcing a default group type and the group is already flagged for a feature file or to have a feature-compatible name, we give it a feature-compatible name.
<span class="lineNum">    1389 </span>            :         // Otherwise, we give it a native U. F. O. name.
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :         char * startname =</span>
<span class="lineNum">    1391 </span>            :           (
<span class="lineNum">    1392 </span>            :             (
<span class="lineNum">    1393 </span>            :               (
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :                 (sf-&gt;preferred_kerning == 0) &amp;&amp;</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :                 (classflags &amp; (FF_KERNCLASS_FLAG_FEATURE | FF_KERNCLASS_FLAG_NAMETYPE))</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :               ) ||</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :               (sf-&gt;preferred_kerning &amp; 2) || (sf-&gt;preferred_kerning &amp; 4)</span>
<span class="lineNum">    1398 </span>            :             ) ?
<span class="lineNum">    1399 </span>            :             (
<span class="lineNum">    1400 </span>            :               isv ?
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :               (isr ? &quot;@MMK_B_FF&quot; : &quot;@MMK_A_FF&quot;) :</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :               (isr ? &quot;@MMK_R_FF&quot; : &quot;@MMK_L_FF&quot;)</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :             ) :</span>
<span class="lineNum">    1404 </span>            :             (
<span class="lineNum">    1405 </span>            :               isv ?
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :               (isr ? &quot;public.vkern2.FF&quot; : &quot;public.vkern1.FF&quot;) :</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :               (isr ? &quot;public.kern2.FF&quot; : &quot;public.kern1.FF&quot;)</span>
<span class="lineNum">    1408 </span>            :             )
<span class="lineNum">    1409 </span>            :           );
<span class="lineNum">    1410 </span>            :         // We must flag the group as being destined for the native file if it has a non-feature-compatible name. Otherwise, we might corrupt the feature file if it ever starts using the names.
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :         if (startname[0] != '@') {</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :           if (isr) { current_kernclass-&gt;seconds_flags[i] |= FF_KERNCLASS_FLAG_NATIVE; current_kernclass-&gt;seconds_flags[i] &amp;= ~FF_KERNCLASS_FLAG_FEATURE; }</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :           else { current_kernclass-&gt;firsts_flags[i] |= FF_KERNCLASS_FLAG_NATIVE; current_kernclass-&gt;firsts_flags[i] &amp;= ~FF_KERNCLASS_FLAG_FEATURE; }</span>
<span class="lineNum">    1414 </span>            :         }
<span class="lineNum">    1415 </span>            :         // Number the name uniquely. (Note the number-forcing flag.)
<span class="lineNum">    1416 </span>            :         // And add it to the hash table with its index.
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :         char * numberedname = ufo_name_number(class_name_hash, absolute_index + i, startname, &quot;&quot;, &quot;&quot;, 23);</span>
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :         if (isr) current_kernclass-&gt;seconds_names[i] = numberedname;</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :         else current_kernclass-&gt;firsts_names[i] = numberedname;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :         numberedname = NULL;</span>
<span class="lineNum">    1421 </span>            :       }
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :       absolute_index +=i;</span>
<span class="lineNum">    1423 </span>            :     }
<span class="lineNum">    1424 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(class_name_hash); // Close the hash table.</span>
<span class="lineNum">    1426 </span>            : #endif
<a name="1427"><span class="lineNum">    1427 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineNoCov">          0 : static int UFOOutputGroups(const char *basedir, SplineFont *sf) {</span>
<span class="lineNum">    1430 </span>            :     SplineChar *sc;
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     int has_content = 0;</span>
<span class="lineNum">    1432 </span>            : 
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Add the dict.</span>
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            :     // In order to preserve ordering, we do some very icky and inefficient things.
<span class="lineNum">    1438 </span>            :     // First, we assign names to any unnamed kerning groups using the public.kern syntax if the splinefont is set to use native U. F. O. kerning.
<span class="lineNum">    1439 </span>            :     // We assign @MMK names otherwise.
<span class="lineNum">    1440 </span>            :     // In assigning names, we check collisions both with other kerning classes and with natively listed groups.
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :     UFONameKerningClasses(sf);</span>
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            :     // Once names are assigned, we start outputting the native groups, with some exceptions.
<span class="lineNum">    1444 </span>            :     // Since we consider kerning groups to be natively handled, any group with a kerning-style name gets checked against kerning classes.
<span class="lineNum">    1445 </span>            :     // If it exists, we output it and flag it as output in a temporary array. If it does not exist, we skip it.
<span class="lineNum">    1446 </span>            :     // When this is complete, we go through the left and right kerning classes and output any that have not been output, adding them to the native list as we do so.
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 :     int kerning_class_count = CountKerningClasses(sf);</span>
<span class="lineNum">    1449 </span><span class="lineNoCov">          0 :     char *output_done = kerning_class_count ? calloc(kerning_class_count, sizeof(char)) : NULL;</span>
<span class="lineNum">    1450 </span>            : 
<span class="lineNum">    1451 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1452 </span>            :     struct glif_name_index _class_name_hash;
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :     struct glif_name_index * class_name_hash = &amp;_class_name_hash; // Open the hash table.</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :     memset(class_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :     HashKerningClassNames(sf, class_name_hash);</span>
<span class="lineNum">    1456 </span>            : #else
<span class="lineNum">    1457 </span>            :     void * class_name_hash = NULL;
<span class="lineNum">    1458 </span>            : #endif
<span class="lineNum">    1459 </span>            :     struct ff_glyphclasses *current_group;
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :     for (current_group = sf-&gt;groups; current_group != NULL; current_group = current_group-&gt;next) {</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :       if (current_group-&gt;classname != NULL) {</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :         int grouptype = GroupNameType(current_group-&gt;classname);</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :         if (grouptype &gt; 0) {</span>
<span class="lineNum">    1464 </span>            :           // We skip the group if it has a corrupt feature-like name.
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :           if (grouptype &amp; (GROUP_NAME_KERNING_UFO | GROUP_NAME_KERNING_FEATURE)) {</span>
<span class="lineNum">    1466 </span>            :             // If the group is a kerning group, we defer to the native kerning data for existence and content.
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :             struct glif_name *class_name_record = glif_name_search_glif_name(class_name_hash, current_group-&gt;classname);</span>
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :             if (class_name_record != NULL) {</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :               int absolute_index = class_name_record-&gt;gid; // This gives us a unique index for the kerning class.</span>
<span class="lineNum">    1470 </span>            :               struct kernclass *kc;
<span class="lineNum">    1471 </span>            :               int isv;
<span class="lineNum">    1472 </span>            :               int isr;
<span class="lineNum">    1473 </span>            :               int i;
<span class="lineNum">    1474 </span>            :               int offset;
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :               if (KerningClassSeekByAbsoluteIndex(sf, absolute_index, &amp;kc, &amp;isv, &amp;isr, &amp;offset)) {</span>
<span class="lineNum">    1476 </span>            :                 // The group still exists.
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :                 xmlNewChild(dictnode, NULL, BAD_CAST &quot;key&quot;, current_group-&gt;classname);</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :                 xmlNodePtr grouparray = xmlNewChild(dictnode, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">    1479 </span>            :                 // We use the results of the preceding search in order to get the list.
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :                 char *rawglyphlist = (</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :                   (isr ? kc-&gt;seconds[offset] : kc-&gt;firsts[offset])</span>
<span class="lineNum">    1482 </span>            :                 );
<span class="lineNum">    1483 </span>            :                 // We need to convert from the space-delimited string to something more easily accessed on a per-item basis.
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                 char **glyphlist = StringExplode(rawglyphlist, ' ');</span>
<span class="lineNum">    1485 </span>            :                 // We will then output only those entries for which SFGetChar succeeds.
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :                 int index = 0;</span>
<span class="lineNum">    1487 </span><span class="lineNoCov">          0 :                 while (glyphlist[index] != NULL) {</span>
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :                   if (SFGetChar(sf, -1, glyphlist[index]))</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :                     xmlNewChild(grouparray, NULL, BAD_CAST &quot;string&quot;, glyphlist[index]);</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :                   index++;</span>
<span class="lineNum">    1491 </span>            :                 }
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :                 ExplodedStringFree(glyphlist);</span>
<span class="lineNum">    1493 </span>            :                 // We flag the output of this kerning class as complete.
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :                 output_done[absolute_index] |= 1;</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :                 has_content = 1;</span>
<span class="lineNum">    1496 </span>            :               }
<span class="lineNum">    1497 </span>            :             }
<span class="lineNum">    1498 </span>            :           }
<span class="lineNum">    1499 </span>            :         } else {
<span class="lineNum">    1500 </span>            :           // If the group is not a kerning group, we just output it raw (for now).
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :           xmlNewChild(dictnode, NULL, BAD_CAST &quot;key&quot;, current_group-&gt;classname);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :           xmlNodePtr grouparray = xmlNewChild(dictnode, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">    1503 </span>            :           // We need to convert from the space-delimited string to something more easily accessed on a per-item basis.
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :           char **glyphlist = StringExplode(current_group-&gt;glyphs, ' ');</span>
<span class="lineNum">    1505 </span>            :           // We will then output only those entries for which SFGetChar succeeds.
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :           int index = 0;</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :           while (glyphlist[index] != NULL) {</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :             if (SFGetChar(sf, -1, glyphlist[index]))</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :               xmlNewChild(grouparray, NULL, BAD_CAST &quot;string&quot;, glyphlist[index]);</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :             index++;</span>
<span class="lineNum">    1511 </span>            :           }
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :           ExplodedStringFree(glyphlist);</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :           has_content = 1;</span>
<span class="lineNum">    1514 </span>            :         }
<span class="lineNum">    1515 </span>            :       }
<span class="lineNum">    1516 </span>            :     }
<span class="lineNum">    1517 </span>            :     {
<span class="lineNum">    1518 </span>            :       // Oh. But we've not finished yet. Some kerning classes may not be in the groups listing.
<span class="lineNum">    1519 </span>            :       struct kernclass *current_kernclass;
<span class="lineNum">    1520 </span>            :       int isv;
<span class="lineNum">    1521 </span>            :       int isr;
<span class="lineNum">    1522 </span>            :       int i;
<span class="lineNum">    1523 </span><span class="lineNoCov">          0 :       int absolute_index = 0;</span>
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :       for (isv = 0; isv &lt; 2; isv++)</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :       for (current_kernclass = (isv ? sf-&gt;vkerns : sf-&gt;kerns); current_kernclass != NULL; current_kernclass = current_kernclass-&gt;next)</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :       for (isr = 0; isr &lt; 2; isr++)</span>
<span class="lineNum">    1527 </span><span class="lineNoCov">          0 :       if (isr ? current_kernclass-&gt;seconds_names : current_kernclass-&gt;firsts_names) {</span>
<span class="lineNum">    1528 </span><span class="lineNoCov">          0 :         for (i=0; i &lt; (isr ? current_kernclass-&gt;second_cnt : current_kernclass-&gt;first_cnt); ++i) {</span>
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :           const char *classname = (isr ? current_kernclass-&gt;seconds_names[i] : current_kernclass-&gt;firsts_names[i]);</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :           const char *rawglyphlist = (isr ? current_kernclass-&gt;seconds[i] : current_kernclass-&gt;firsts[i]);</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :           int classflags = (isr ? current_kernclass-&gt;seconds_flags[i] : current_kernclass-&gt;firsts_flags[i]);</span>
<span class="lineNum">    1532 </span>            :           // Note that we only output if the kernclass is destined for U. F. O. and has not already met said fate.
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :           if (classname != NULL &amp;&amp; rawglyphlist != NULL &amp;&amp;</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :               !(output_done[absolute_index + i]) &amp;&amp; kernclass_for_groups_plist(sf, current_kernclass, classflags)) {</span>
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :                 xmlNewChild(dictnode, NULL, BAD_CAST &quot;key&quot;, classname);</span>
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :                 xmlNodePtr grouparray = xmlNewChild(dictnode, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">    1537 </span>            :                 // We need to convert from the space-delimited string to something more easily accessed on a per-item basis.
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :                 char **glyphlist = StringExplode(rawglyphlist, ' ');</span>
<span class="lineNum">    1539 </span>            :                 // We will then output only those entries for which SFGetChar succeeds.
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :                 int index = 0;</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :                 while (glyphlist[index] != NULL) {</span>
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :                   if (SFGetChar(sf, -1, glyphlist[index]))</span>
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :                     xmlNewChild(grouparray, NULL, BAD_CAST &quot;string&quot;, glyphlist[index]);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :                   index++;</span>
<span class="lineNum">    1545 </span>            :                 }
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :                 ExplodedStringFree(glyphlist);</span>
<span class="lineNum">    1547 </span>            :                 // We flag the output of this kerning class as complete.
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :                 output_done[absolute_index + i] |= 1;</span>
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :                                 has_content = 1;</span>
<span class="lineNum">    1550 </span>            :           }
<span class="lineNum">    1551 </span>            :         }
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :         absolute_index +=i;</span>
<span class="lineNum">    1553 </span>            :       }
<span class="lineNum">    1554 </span>            :     }
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(class_name_hash); // Close the hash table.</span>
<span class="lineNum">    1558 </span>            : #endif
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :     if (output_done != NULL) { free(output_done); output_done = NULL; }</span>
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir, &quot;groups.plist&quot;); // Build the file name.</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :     if (has_content) xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :     free(fname); fname = NULL;</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :     xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :     xmlCleanupParser();</span>
<span class="lineNum">    1566 </span><span class="lineNoCov">          0 :     return true;</span>
<a name="1567"><span class="lineNum">    1567 </span>            : }</a>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 : static void KerningPListAddGlyph(xmlNodePtr parent, const char *key, const KernPair *kp) {</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :     xmlNewChild(parent, NULL, BAD_CAST &quot;key&quot;, BAD_CAST key); // &quot;&lt;key&gt;%s&lt;/key&gt;&quot; key</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :     xmlNodePtr dictxml = xmlNewChild(parent, NULL, BAD_CAST &quot;dict&quot;, NULL); // &quot;&lt;dict&gt;&quot;</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     while ( kp!=NULL ) {</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :       PListAddInteger(dictxml, kp-&gt;sc-&gt;name, kp-&gt;off); // &quot;&lt;key&gt;%s&lt;/key&gt;&lt;integer&gt;%d&lt;/integer&gt;&quot; kp-&gt;sc-&gt;name kp-&gt;off</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :       kp = kp-&gt;next;</span>
<span class="lineNum">    1575 </span>            :     }
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            : #ifndef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1579 </span>            : static int UFOOutputKerning(const char *basedir, const SplineFont *sf) {
<span class="lineNum">    1580 </span>            :     SplineChar *sc;
<span class="lineNum">    1581 </span>            :     int i;
<span class="lineNum">    1582 </span>            :     int has_content = 0;
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            :     if (!(sf-&gt;preferred_kerning &amp; 1)) return true; // This goes into the feature file by default now.
<span class="lineNum">    1585 </span>            : 
<span class="lineNum">    1586 </span>            :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.
<span class="lineNum">    1587 </span>            :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.
<span class="lineNum">    1588 </span>            :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Add the dict.
<span class="lineNum">    1589 </span>            : 
<span class="lineNum">    1590 </span>            :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( SCWorthOutputting(sc=sf-&gt;glyphs[i]) &amp;&amp; sc-&gt;kerns!=NULL ) {
<span class="lineNum">    1591 </span>            :         KerningPListAddGlyph(dictnode,sc-&gt;name,sc-&gt;kerns);
<span class="lineNum">    1592 </span>            :         has_content = 1;
<span class="lineNum">    1593 </span>            :     }
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            :     char *fname = buildname(basedir, &quot;kerning.plist&quot;); // Build the file name.
<span class="lineNum">    1596 </span>            :     if (has_content) xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document if it's not empty.
<span class="lineNum">    1597 </span>            :     free(fname); fname = NULL;
<span class="lineNum">    1598 </span>            :     xmlFreeDoc(plistdoc); // Free the memory.
<span class="lineNum">    1599 </span>            :     xmlCleanupParser();
<span class="lineNum">    1600 </span>            :     return true;
<span class="lineNum">    1601 </span>            : }
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            : static int UFOOutputVKerning(const char *basedir, const SplineFont *sf) {
<span class="lineNum">    1604 </span>            :     SplineChar *sc;
<span class="lineNum">    1605 </span>            :     int i;
<span class="lineNum">    1606 </span>            :     int has_content = 0;
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            :     if (!(sf-&gt;preferred_kerning &amp; 1)) return true; // This goes into the feature file by default now.
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span>            :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.
<span class="lineNum">    1611 </span>            :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.
<span class="lineNum">    1612 </span>            :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Add the dict.
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            :     for ( i=sf-&gt;glyphcnt-1; i&gt;=0; --i ) if ( SCWorthOutputting(sc=sf-&gt;glyphs[i]) &amp;&amp; sc-&gt;vkerns!=NULL ) break;
<span class="lineNum">    1615 </span>            :     if ( i&lt;0 ) return( true );
<span class="lineNum">    1616 </span>            :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( (sc=sf-&gt;glyphs[i])!=NULL &amp;&amp; sc-&gt;vkerns!=NULL ) {
<span class="lineNum">    1617 </span>            :         KerningPListAddGlyph(dictnode,sc-&gt;name,sc-&gt;vkerns);
<span class="lineNum">    1618 </span>            :         has_content = 1;
<span class="lineNum">    1619 </span>            :     }
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            :     char *fname = buildname(basedir, &quot;vkerning.plist&quot;); // Build the file name.
<span class="lineNum">    1622 </span>            :     if (has_content) xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document if it's not empty.
<span class="lineNum">    1623 </span>            :     free(fname); fname = NULL;
<span class="lineNum">    1624 </span>            :     xmlFreeDoc(plistdoc); // Free the memory.
<span class="lineNum">    1625 </span>            :     xmlCleanupParser();
<span class="lineNum">    1626 </span>            :     return true;
<span class="lineNum">    1627 </span>            : }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span>            : static int UFOOutputKerning2(const char *basedir, const SplineFont *sf, int isv) {
<span class="lineNum">    1630 </span>            :   if (isv) return UFOOutputVKerning(basedir, sf);
<span class="lineNum">    1631 </span>            :   else return UFOOutputKerning(basedir, sf);
<span class="lineNum">    1632 </span>            : }
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            : #else // FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1635 </span>            : // New approach.
<span class="lineNum">    1636 </span>            : // We will build a tree.
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            : struct ufo_kerning_tree_left;
<span class="lineNum">    1639 </span>            : struct ufo_kerning_tree_right;
<span class="lineNum">    1640 </span>            : struct ufo_kerning_tree_left {
<span class="lineNum">    1641 </span>            :   char *name;
<span class="lineNum">    1642 </span>            :   struct ufo_kerning_tree_right *first_right;
<span class="lineNum">    1643 </span>            :   struct ufo_kerning_tree_right *last_right;
<span class="lineNum">    1644 </span>            :   struct ufo_kerning_tree_left *next;
<span class="lineNum">    1645 </span>            : };
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span>            : struct ufo_kerning_tree_right {
<span class="lineNum">    1648 </span>            :   char *name;
<span class="lineNum">    1649 </span>            :   int value;
<span class="lineNum">    1650 </span>            :   struct ufo_kerning_tree_right *next;
<span class="lineNum">    1651 </span>            : };
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            : struct ufo_kerning_tree_session {
<span class="lineNum">    1654 </span>            :   struct ufo_kerning_tree_left *first_left;
<span class="lineNum">    1655 </span>            :   struct ufo_kerning_tree_left *last_left;
<span class="lineNum">    1656 </span>            :   int left_group_count;
<span class="lineNum">    1657 </span>            :   struct glif_name_index _left_group_name_hash;
<span class="lineNum">    1658 </span>            :   int class_pair_count;
<span class="lineNum">    1659 </span>            :   struct glif_name_index _class_pair_hash;
<a name="1660"><span class="lineNum">    1660 </span>            : };</a>
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 : void ufo_kerning_tree_destroy_contents(struct ufo_kerning_tree_session *session) {</span>
<span class="lineNum">    1663 </span>            :   struct ufo_kerning_tree_left *current_left;
<span class="lineNum">    1664 </span>            :   struct ufo_kerning_tree_left *next_left;
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :   for (current_left = session-&gt;first_left; current_left != NULL; current_left = next_left) {</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :     next_left = current_left-&gt;next;</span>
<span class="lineNum">    1667 </span>            :     struct ufo_kerning_tree_right *current_right;
<span class="lineNum">    1668 </span>            :     struct ufo_kerning_tree_right *next_right;
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :     for (current_right = current_left-&gt;first_right; current_right != NULL; current_right = next_right) {</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :       next_right = current_right-&gt;next;</span>
<span class="lineNum">    1671 </span><span class="lineNoCov">          0 :       if (current_right-&gt;name != NULL) free(current_right-&gt;name);</span>
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :       free(current_right);</span>
<span class="lineNum">    1673 </span>            :     }
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 :     if (current_left-&gt;name != NULL) free(current_left-&gt;name);</span>
<span class="lineNum">    1675 </span><span class="lineNoCov">          0 :     free(current_left);</span>
<span class="lineNum">    1676 </span>            :   }
<span class="lineNum">    1677 </span><span class="lineNoCov">          0 :   memset(session, 0, sizeof(struct ufo_kerning_tree_session));</span>
<a name="1678"><span class="lineNum">    1678 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 : int ufo_kerning_tree_attempt_insert(struct ufo_kerning_tree_session *session, const char *left_name, const char *right_name, int value) {</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :   struct glif_name_index *left_group_name_hash = &amp;(session-&gt;_left_group_name_hash);</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :   struct glif_name_index *class_pair_hash = &amp;(session-&gt;_class_pair_hash);</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :   char *tmppairname = NULL;</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :   asprintf(&amp;tmppairname, &quot;%s %s&quot;, left_name, right_name);</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :   struct ufo_kerning_tree_left *first_left = NULL;</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :   struct ufo_kerning_tree_left *last_left = NULL;</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :   if (!glif_name_search_glif_name(class_pair_hash, tmppairname)) {</span>
<span class="lineNum">    1688 </span>            :     struct ufo_kerning_tree_left *current_left;
<span class="lineNum">    1689 </span>            :     // We look for a tree node matching the left side of the pair.
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :     for (current_left = session-&gt;first_left; current_left != NULL &amp;&amp;</span>
<span class="lineNum">    1691 </span><span class="lineNoCov">          0 :       (current_left-&gt;name == NULL || strcmp(current_left-&gt;name, left_name));</span>
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :       current_left = current_left-&gt;next);</span>
<span class="lineNum">    1693 </span>            :     // If the search fails, we make a new node.
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :     if (current_left == NULL) {</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :       current_left = calloc(1, sizeof(struct ufo_kerning_tree_left));</span>
<span class="lineNum">    1696 </span><span class="lineNoCov">          0 :       current_left-&gt;name = copy(left_name);</span>
<span class="lineNum">    1697 </span><span class="lineNoCov">          0 :       if (session-&gt;last_left != NULL) session-&gt;last_left-&gt;next = current_left;</span>
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :       else session-&gt;first_left = current_left;</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :       session-&gt;last_left = current_left;</span>
<span class="lineNum">    1700 </span>            :     }
<span class="lineNum">    1701 </span>            :     {
<span class="lineNum">    1702 </span>            :       // We already know from the pair hash search that this pair does not exist.
<span class="lineNum">    1703 </span>            :       // So we go right to the end.
<span class="lineNum">    1704 </span><span class="lineNoCov">          0 :       struct ufo_kerning_tree_right *current_right = calloc(1, sizeof(struct ufo_kerning_tree_right));</span>
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :       current_right-&gt;name = copy(right_name);</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :       current_right-&gt;value = value;</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :       if (current_left-&gt;last_right != NULL) current_left-&gt;last_right-&gt;next = current_right;</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :       else current_left-&gt;first_right = current_right;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :       current_left-&gt;last_right = current_right;</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :       char *newpairname = NULL;</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :       asprintf(&amp;newpairname, &quot;%s %s&quot;, left_name, right_name);</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :       glif_name_track_new(class_pair_hash, session-&gt;class_pair_count++, newpairname);</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :       free(newpairname); newpairname = NULL;</span>
<span class="lineNum">    1714 </span>            :     }
<span class="lineNum">    1715 </span>            :   }
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :   free(tmppairname); tmppairname = NULL;</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1718 </span>            : }
<a name="1719"><span class="lineNum">    1719 </span>            : </a>
<span class="lineNum">    1720 </span>            : 
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 : static int UFOOutputKerning2(const char *basedir, SplineFont *sf, int isv) {</span>
<span class="lineNum">    1722 </span>            :     int i, j;
<span class="lineNum">    1723 </span><span class="lineNoCov">          0 :     int has_content = 0;</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :     if (!(sf-&gt;preferred_kerning &amp; 1)) return true; // This goes into the feature file by default now.</span>
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span><span class="lineNoCov">          0 :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Add the dict.</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :     // In order to preserve ordering, we do some very icky and inefficient things.
<span class="lineNum">    1732 </span>            :     // First, we assign names to any unnamed kerning groups using the public.kern syntax if the splinefont is set to use native U. F. O. kerning.
<span class="lineNum">    1733 </span>            :     // We assign @MMK names otherwise.
<span class="lineNum">    1734 </span>            :     // In assigning names, we check collisions both with other kerning classes and with natively listed groups.
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :     UFONameKerningClasses(sf);</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            :     // Once names are assigned, we start outputting the native groups, with some exceptions.
<span class="lineNum">    1738 </span>            :     // Since we consider kerning groups to be natively handled, any group with a kerning-style name gets checked against kerning classes.
<span class="lineNum">    1739 </span>            :     // If it exists, we output it and flag it as output in a temporary array. If it does not exist, we skip it.
<span class="lineNum">    1740 </span>            :     // When this is complete, we go through the left and right kerning classes and output any that have not been output, adding them to the native list as we do so.
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :     int kerning_class_count = CountKerningClasses(sf);</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :     int kerning_class_pair_count = kerning_class_count * kerning_class_count;</span>
<span class="lineNum">    1744 </span><span class="lineNoCov">          0 :     char *output_done = kerning_class_pair_count ? calloc(kerning_class_pair_count, sizeof(char)) : NULL;</span>
<span class="lineNum">    1745 </span>            : 
<span class="lineNum">    1746 </span>            :     struct ufo_kerning_tree_session _session;
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :     memset(&amp;_session, 0, sizeof(struct ufo_kerning_tree_session));</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :     struct ufo_kerning_tree_session *session = &amp;_session;</span>
<span class="lineNum">    1749 </span>            : 
<span class="lineNum">    1750 </span>            :     struct glif_name_index _class_name_hash;
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :     struct glif_name_index * class_name_hash = &amp;_class_name_hash; // Open the hash table.</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :     memset(class_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :     HashKerningClassNames(sf, class_name_hash);</span>
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span>            :     // We process the raw kerning list first in order to give preference to the original ordering.
<span class="lineNum">    1756 </span>            :     struct ff_rawoffsets *current_groupkern;
<span class="lineNum">    1757 </span><span class="lineNoCov">          0 :     for (current_groupkern = (isv ? sf-&gt;groupvkerns : sf-&gt;groupkerns); current_groupkern != NULL; current_groupkern = current_groupkern-&gt;next) {</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :       if (current_groupkern-&gt;left != NULL &amp;&amp; current_groupkern-&gt;right != NULL) {</span>
<span class="lineNum">    1759 </span><span class="lineNoCov">          0 :         int left_grouptype = GroupNameType(current_groupkern-&gt;left);</span>
<span class="lineNum">    1760 </span><span class="lineNoCov">          0 :         int right_grouptype = GroupNameType(current_groupkern-&gt;right);</span>
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 :         int offset = 0;</span>
<span class="lineNum">    1762 </span><span class="lineNoCov">          0 :         int valid = 0;</span>
<span class="lineNum">    1763 </span><span class="lineNoCov">          0 :         if (left_grouptype &gt; 0 &amp;&amp; right_grouptype &gt; 0) {</span>
<span class="lineNum">    1764 </span>            :           // It's a pure class look-up.
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :           struct glif_name *left_class_name_record = glif_name_search_glif_name(class_name_hash, current_groupkern-&gt;left);</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :           struct glif_name *right_class_name_record = glif_name_search_glif_name(class_name_hash, current_groupkern-&gt;right);</span>
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :           if ((left_grouptype &amp; right_grouptype &amp; (GROUP_NAME_KERNING_UFO | GROUP_NAME_KERNING_FEATURE)) &amp;&amp;</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :             !(left_grouptype &amp; GROUP_NAME_RIGHT) &amp;&amp; (right_grouptype &amp; GROUP_NAME_RIGHT) &amp;&amp;</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :             ((left_grouptype &amp; GROUP_NAME_VERTICAL) == (isv * GROUP_NAME_VERTICAL)) &amp;&amp;</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :             ((right_grouptype &amp; GROUP_NAME_VERTICAL) == (isv * GROUP_NAME_VERTICAL)) &amp;&amp;</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :             left_class_name_record != NULL &amp;&amp; right_class_name_record != NULL) {</span>
<span class="lineNum">    1772 </span>            :             // If the group is a kerning group, we defer to the native kerning data for existence and content.
<span class="lineNum">    1773 </span>            :             {
<span class="lineNum">    1774 </span><span class="lineNoCov">          0 :               int left_absolute_index = left_class_name_record-&gt;gid; // This gives us a unique index for the kerning class.</span>
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :               int right_absolute_index = right_class_name_record-&gt;gid; // This gives us a unique index for the kerning class.</span>
<span class="lineNum">    1776 </span>            :               struct kernclass *left_kc, *right_kc;
<span class="lineNum">    1777 </span>            :               int left_isv, right_isv;
<span class="lineNum">    1778 </span>            :               int left_isr, right_isr;
<span class="lineNum">    1779 </span>            :               int left_offset, right_offset;
<span class="lineNum">    1780 </span><span class="lineNoCov">          0 :               if (KerningClassSeekByAbsoluteIndex(sf, left_absolute_index, &amp;left_kc, &amp;left_isv, &amp;left_isr, &amp;left_offset) &amp;&amp;</span>
<span class="lineNum">    1781 </span><span class="lineNoCov">          0 :                 KerningClassSeekByAbsoluteIndex(sf, right_absolute_index, &amp;right_kc, &amp;right_isv, &amp;right_isr, &amp;right_offset) &amp;&amp;</span>
<span class="lineNum">    1782 </span><span class="lineNoCov">          0 :                 left_kc == right_kc) {</span>
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 :                 offset = left_kc-&gt;offsets[left_offset*left_kc-&gt;second_cnt+right_offset];</span>
<span class="lineNum">    1784 </span><span class="lineNoCov">          0 :                 valid = 1;</span>
<span class="lineNum">    1785 </span>            :               }
<span class="lineNum">    1786 </span>            :             }
<span class="lineNum">    1787 </span>            :           }
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :         } else if (left_grouptype == 0 &amp;&amp; right_grouptype == 0) {</span>
<span class="lineNum">    1789 </span>            :           // It's a plain kerning pair.
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :           struct splinechar *sc = SFGetChar(sf, -1, current_groupkern-&gt;left);</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :           struct splinechar *ssc = SFGetChar(sf, -1, current_groupkern-&gt;right);</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :           if (sc &amp;&amp; ssc) {</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :             struct kernpair *current_kernpair = (isv ? sc-&gt;vkerns : sc-&gt;kerns);</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :             while (current_kernpair != NULL &amp;&amp; current_kernpair-&gt;sc != ssc) current_kernpair = current_kernpair-&gt;next;</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :             if (current_kernpair != NULL &amp;&amp; current_kernpair-&gt;sc == ssc) {</span>
<span class="lineNum">    1796 </span><span class="lineNoCov">          0 :               offset = current_kernpair-&gt;off;</span>
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :               valid = 1;</span>
<span class="lineNum">    1798 </span>            :             }
<span class="lineNum">    1799 </span>            :           }
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :         } else if (left_grouptype == 0 &amp;&amp; right_grouptype &gt; 0) {</span>
<span class="lineNum">    1801 </span>            :           // It's a mixed pair. FontForge does not handle these natively right now, so, if the two references are valid, we output the raw value.
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :           struct splinechar *sc = SFGetChar(sf, -1, current_groupkern-&gt;left);</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :           struct glif_name *right_class_name_record = glif_name_search_glif_name(class_name_hash, current_groupkern-&gt;right);</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :           if ((right_grouptype &amp; (GROUP_NAME_KERNING_UFO | GROUP_NAME_KERNING_FEATURE)) &amp;&amp;</span>
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :             (right_grouptype &amp; GROUP_NAME_RIGHT) &amp;&amp;</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :             ((right_grouptype &amp; GROUP_NAME_VERTICAL) == (isv * GROUP_NAME_VERTICAL)) &amp;&amp;</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :             right_class_name_record != NULL &amp;&amp;</span>
<span class="lineNum">    1808 </span>            :             sc != NULL) {
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :             offset = current_groupkern-&gt;offset;</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :             valid = 1;</span>
<span class="lineNum">    1811 </span>            :           }
<span class="lineNum">    1812 </span><span class="lineNoCov">          0 :         } else if (left_grouptype &gt; 0 &amp;&amp; right_grouptype == 0) {</span>
<span class="lineNum">    1813 </span>            :           // It's a mixed pair. FontForge does not handle these natively right now, so, if the two references are valid, we output the raw value.
<span class="lineNum">    1814 </span><span class="lineNoCov">          0 :           struct splinechar *ssc = SFGetChar(sf, -1, current_groupkern-&gt;right);</span>
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :           struct glif_name *left_class_name_record = glif_name_search_glif_name(class_name_hash, current_groupkern-&gt;left);</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :           if ((left_grouptype &amp; (GROUP_NAME_KERNING_UFO | GROUP_NAME_KERNING_FEATURE)) &amp;&amp;</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :             !(left_grouptype &amp; GROUP_NAME_RIGHT) &amp;&amp;</span>
<span class="lineNum">    1818 </span><span class="lineNoCov">          0 :             ((left_grouptype &amp; GROUP_NAME_VERTICAL) == (isv * GROUP_NAME_VERTICAL)) &amp;&amp;</span>
<span class="lineNum">    1819 </span><span class="lineNoCov">          0 :             left_class_name_record != NULL &amp;&amp;</span>
<span class="lineNum">    1820 </span>            :             ssc != NULL) {
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :             offset = current_groupkern-&gt;offset;</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :             valid = 1;</span>
<span class="lineNum">    1823 </span>            :           }
<span class="lineNum">    1824 </span>            :         } else {
<span class="lineNum">    1825 </span>            :           // Something is wrong.
<span class="lineNum">    1826 </span>            :         }
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :         if (valid) {</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :           ufo_kerning_tree_attempt_insert(session, current_groupkern-&gt;left, current_groupkern-&gt;right, offset);</span>
<span class="lineNum">    1829 </span>            :         }
<span class="lineNum">    1830 </span>            :       }
<span class="lineNum">    1831 </span>            :     }
<span class="lineNum">    1832 </span>            :     {
<span class="lineNum">    1833 </span>            :       // Oh. But we've not finished yet. New class kerns may not be in the original list.
<span class="lineNum">    1834 </span>            :       struct kernclass *kc;
<span class="lineNum">    1835 </span>            :       char *left_name;
<span class="lineNum">    1836 </span>            :       char *right_name;
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :       for (kc = isv ? sf-&gt;vkerns : sf-&gt;kerns; kc != NULL; kc = kc-&gt;next)</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :       if (kc-&gt;firsts_names &amp;&amp; kc-&gt;seconds_names &amp;&amp; kc-&gt;firsts_flags &amp;&amp; kc-&gt;seconds_flags &amp;&amp;</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :         kc-&gt;offsets_flags)</span>
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :       for ( i=0; i&lt;kc-&gt;first_cnt; ++i ) if ( kc-&gt;firsts[i]!=NULL &amp;&amp; kc-&gt;firsts_names[i]!=NULL &amp;&amp; kernclass_for_groups_plist(sf, kc, kc-&gt;firsts_flags[i]))</span>
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :         for ( j=0; j&lt;kc-&gt;second_cnt; ++j ) if ( kc-&gt;seconds[j]!=NULL &amp;&amp; kc-&gt;seconds_names[j]!=NULL &amp;&amp; kernclass_for_groups_plist(sf, kc, kc-&gt;firsts_flags[j]))</span>
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :           if (kernclass_for_groups_plist(sf, kc, kc-&gt;offsets_flags[i*kc-&gt;second_cnt+j]) &amp;&amp; kc-&gt;offsets[i*kc-&gt;second_cnt+j] != 0)</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :             ufo_kerning_tree_attempt_insert(session, kc-&gt;firsts_names[i], kc-&gt;seconds_names[j], kc-&gt;offsets[i*kc-&gt;second_cnt+j]);</span>
<span class="lineNum">    1844 </span>            :     }
<span class="lineNum">    1845 </span>            :     {
<span class="lineNum">    1846 </span>            :       // And don't forget about pair kerns.
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :       for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) {</span>
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :         struct splinechar *sc = sf-&gt;glyphs[i];</span>
<span class="lineNum">    1849 </span>            :         struct kernpair *kp;
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :         if ( (SCWorthOutputting(sc) || SCHasData(sc) || sc-&gt;glif_name != NULL) &amp;&amp; (isv ? sc-&gt;vkerns : sc-&gt;kerns ) !=NULL )</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :           for (kp = (isv ? sc-&gt;vkerns : sc-&gt;kerns); kp != NULL; kp = kp-&gt;next)</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :             if (kp-&gt;sc != NULL &amp;&amp; sc-&gt;name != NULL &amp;&amp; kp-&gt;sc-&gt;name != NULL)</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :               ufo_kerning_tree_attempt_insert(session, sc-&gt;name, kp-&gt;sc-&gt;name, kp-&gt;off);</span>
<span class="lineNum">    1854 </span>            :       }
<span class="lineNum">    1855 </span>            :     }
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span>            :     {
<span class="lineNum">    1858 </span>            :       // Output time has arrived.
<span class="lineNum">    1859 </span>            :       struct ufo_kerning_tree_left *current_left;
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :       for (current_left = session-&gt;first_left; current_left != NULL; current_left = current_left-&gt;next) {</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :         if (current_left-&gt;name != NULL) {</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :           xmlNewChild(dictnode, NULL, BAD_CAST &quot;key&quot;, BAD_CAST current_left-&gt;name); // &quot;&lt;key&gt;%s&lt;/key&gt;&quot; key</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :           xmlNodePtr dictxml = xmlNewChild(dictnode, NULL, BAD_CAST &quot;dict&quot;, NULL); // &quot;&lt;dict&gt;&quot;</span>
<span class="lineNum">    1864 </span>            :           struct ufo_kerning_tree_right *current_right;
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :           for (current_right = current_left-&gt;first_right; current_right != NULL; current_right = current_right-&gt;next)</span>
<span class="lineNum">    1866 </span><span class="lineNoCov">          0 :             if (current_right-&gt;name != NULL) PListAddInteger(dictxml, current_right-&gt;name, current_right-&gt;value);</span>
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :           has_content = 1;</span>
<span class="lineNum">    1868 </span>            :         }
<span class="lineNum">    1869 </span>            :       }
<span class="lineNum">    1870 </span>            :     }
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(class_name_hash); // Close the hash table.</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :     ufo_kerning_tree_destroy_contents(session);</span>
<span class="lineNum">    1874 </span>            : 
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :     if (output_done != NULL) { free(output_done); output_done = NULL; }</span>
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir, (isv ? &quot;vkerning.plist&quot; : &quot;kerning.plist&quot;)); // Build the file name.</span>
<span class="lineNum">    1878 </span><span class="lineNoCov">          0 :     if (has_content) xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     free(fname); fname = NULL;</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :     xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :     xmlCleanupParser();</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :     return true;</span>
<span class="lineNum">    1883 </span>            : }
<span class="lineNum">    1884 </span>            : 
<a name="1885"><span class="lineNum">    1885 </span>            : #endif // FF_UTHASH_GLIF_NAMES</a>
<span class="lineNum">    1886 </span>            : 
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 : static int UFOOutputLib(const char *basedir, const SplineFont *sf) {</span>
<span class="lineNum">    1888 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :     if ( sf-&gt;python_persistent==NULL || PyMapping_Check(sf-&gt;python_persistent) == 0) return true;</span>
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    1892 </span><span class="lineNoCov">          0 :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) return false; // Find the root node.</span>
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     xmlNodePtr dictnode = PythonLibToXML(sf-&gt;python_persistent,NULL,sf-&gt;python_persistent_has_lists);</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :     xmlAddChild(rootnode, dictnode);</span>
<span class="lineNum">    1896 </span>            : 
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir, &quot;lib.plist&quot;); // Build the file name.</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :     xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :     free(fname); fname = NULL;</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :     xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :     xmlCleanupParser();</span>
<span class="lineNum">    1902 </span>            : #endif
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 : return( true );</span>
<a name="1904"><span class="lineNum">    1904 </span>            : }</a>
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 : static int UFOOutputFeatures(const char *basedir, SplineFont *sf) {</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir,&quot;features.fea&quot;);</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :     FILE *feats = fopen( fname, &quot;w&quot; );</span>
<span class="lineNum">    1909 </span>            :     int err;
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :     free(fname);</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :     if ( feats==NULL )</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 : return( false );</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :     FeatDumpFontLookups(feats,sf);</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     err = ferror(feats);</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     fclose(feats);</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 : return( !err );</span>
<a name="1918"><span class="lineNum">    1918 </span>            : }</a>
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 : int WriteUFOLayer(const char * glyphdir, SplineFont * sf, int layer) {</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :     xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :     xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :     xmlNodePtr dictnode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;dict&quot;, NULL); if (dictnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Make the dict.</span>
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :     GFileMkDir( glyphdir );</span>
<span class="lineNum">    1926 </span>            :     int i;
<span class="lineNum">    1927 </span>            :     SplineChar * sc;
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :     int err = 0;</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( SCLWorthOutputtingOrHasData(sc=sf-&gt;glyphs[i], layer) ||</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :       ( layer == ly_fore &amp;&amp; (SCWorthOutputting(sc) || SCHasData(sc) || sc-&gt;glif_name != NULL) ) ) {</span>
<span class="lineNum">    1931 </span>            :         // TODO: Optionally skip rewriting an untouched glyph.
<span class="lineNum">    1932 </span>            :         // Do we track modified glyphs carefully enough for this?
<span class="lineNum">    1933 </span>            :         char * final_name;
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :         asprintf(&amp;final_name, &quot;%s%s%s&quot;, &quot;&quot;, sc-&gt;glif_name, &quot;.glif&quot;); // Generate the final name with prefix and suffix.</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :         PListAddString(dictnode,sc-&gt;name,final_name); // Add the glyph to the table of contents.</span>
<span class="lineNum">    1936 </span><span class="lineNoCov">          0 :         err |= !GlifDump(glyphdir,final_name,sc,layer);</span>
<span class="lineNum">    1937 </span><span class="lineNoCov">          0 :         free(final_name); final_name = NULL;</span>
<span class="lineNum">    1938 </span>            :     }
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span><span class="lineNoCov">          0 :     char *fname = buildname(glyphdir, &quot;contents.plist&quot;); // Build the file name for the contents.</span>
<span class="lineNum">    1941 </span><span class="lineNoCov">          0 :     xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :     free(fname); fname = NULL;</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :     xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :     xmlCleanupParser();</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :     return err;</span>
<a name="1946"><span class="lineNum">    1946 </span>            : }</a>
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span><span class="lineNoCov">          0 : int WriteUFOFontFlex(const char *basedir, SplineFont *sf, enum fontformat ff,int flags,</span>
<span class="lineNum">    1949 </span>            :         const EncMap *map,int layer, int all_layers) {
<span class="lineNum">    1950 </span>            :     char *glyphdir, *gfname;
<span class="lineNum">    1951 </span>            :     int err;
<span class="lineNum">    1952 </span>            :     FILE *plist;
<span class="lineNum">    1953 </span>            :     int i;
<span class="lineNum">    1954 </span>            :     SplineChar *sc;
<span class="lineNum">    1955 </span>            : 
<span class="lineNum">    1956 </span>            :     /* Clean it out, if it exists */
<span class="lineNum">    1957 </span><span class="lineNoCov">          0 :     if (!GFileRemove(basedir, true)) {</span>
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Error clearing %s.&quot;), basedir);</span>
<span class="lineNum">    1959 </span>            :     }
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            :     /* Create it */
<span class="lineNum">    1962 </span><span class="lineNoCov">          0 :     if (GFileMkDir( basedir ) == -1) return false;</span>
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            :     locale_t tmplocale; locale_t oldlocale; // Declare temporary locale storage.
<span class="lineNum">    1965 </span><span class="lineNoCov">          0 :     switch_to_c_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the C locale temporarily and cache the old locale.</span>
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span><span class="lineNoCov">          0 :     err  = !UFOOutputMetaInfo(basedir,sf);</span>
<span class="lineNum">    1969 </span><span class="lineNoCov">          0 :     err |= !UFOOutputFontInfo(basedir,sf,layer);</span>
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :     err |= !UFOOutputGroups(basedir,sf);</span>
<span class="lineNum">    1971 </span><span class="lineNoCov">          0 :     err |= !UFOOutputKerning2(basedir,sf,0); // Horizontal.</span>
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     err |= !UFOOutputKerning2(basedir,sf,1); // Vertical.</span>
<span class="lineNum">    1973 </span><span class="lineNoCov">          0 :     err |= !UFOOutputLib(basedir,sf);</span>
<span class="lineNum">    1974 </span><span class="lineNoCov">          0 :     err |= !UFOOutputFeatures(basedir,sf);</span>
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 :     if ( err ) {</span>
<span class="lineNum">    1977 </span><span class="lineNoCov">          0 :         switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    1979 </span>            :     }
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    1982 </span>            :     struct glif_name_index _glif_name_hash;
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 :     struct glif_name_index * glif_name_hash = &amp;_glif_name_hash; // Open the hash table.</span>
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :     memset(glif_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    1985 </span>            : #else
<span class="lineNum">    1986 </span>            :     void * glif_name_hash = NULL;
<span class="lineNum">    1987 </span>            : #endif
<span class="lineNum">    1988 </span>            :     // First we generate glif names.
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i ) if ( SCWorthOutputting(sc=sf-&gt;glyphs[i]) || SCHasData(sf-&gt;glyphs[i]) ) {</span>
<span class="lineNum">    1990 </span><span class="lineNoCov">          0 :         char * startname = NULL;</span>
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :         if (sc-&gt;glif_name != NULL)</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :           startname = strdup(sc-&gt;glif_name); // If the splinechar has a glif name, try to use that.</span>
<span class="lineNum">    1993 </span>            :         else
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :           startname = ufo_name_mangle(sc-&gt;name, &quot;&quot;, &quot;.glif&quot;, 7); // If not, call the mangler.</span>
<span class="lineNum">    1995 </span>            :         // Number the name (as the specification requires) if there is a collision.
<span class="lineNum">    1996 </span>            :         // And add it to the hash table with its index.
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :         char * numberedname = ufo_name_number(glif_name_hash, i, startname, &quot;&quot;, &quot;.glif&quot;, 7);</span>
<span class="lineNum">    1998 </span><span class="lineNoCov">          0 :         free(startname); startname = NULL;</span>
<span class="lineNum">    1999 </span>            :         // We update the saved glif_name only if it is different (so as to minimize churn).
<span class="lineNum">    2000 </span><span class="lineNoCov">          0 :         if ((sc-&gt;glif_name != NULL) &amp;&amp; (strcmp(sc-&gt;glif_name, numberedname) != 0)) {</span>
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :           free(sc-&gt;glif_name); sc-&gt;glif_name = NULL;</span>
<span class="lineNum">    2002 </span>            :         }
<span class="lineNum">    2003 </span><span class="lineNoCov">          0 :         if (sc-&gt;glif_name == NULL) {</span>
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :           sc-&gt;glif_name = numberedname;</span>
<span class="lineNum">    2005 </span>            :         } else {
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :           free(numberedname);</span>
<span class="lineNum">    2007 </span>            :         }
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :         numberedname = NULL;</span>
<span class="lineNum">    2009 </span>            :     }
<span class="lineNum">    2010 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    2011 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(glif_name_hash); // Close the hash table.</span>
<span class="lineNum">    2012 </span>            : #endif
<span class="lineNum">    2013 </span>            :     
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :     if (all_layers) {</span>
<span class="lineNum">    2015 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    2016 </span>            :       struct glif_name_index _layer_name_hash;
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :       struct glif_name_index * layer_name_hash = &amp;_layer_name_hash; // Open the hash table.</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :       memset(layer_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    2019 </span>            :       struct glif_name_index _layer_path_hash;
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :       struct glif_name_index * layer_path_hash = &amp;_layer_path_hash; // Open the hash table.</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :       memset(layer_path_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    2022 </span>            : #else
<span class="lineNum">    2023 </span>            :       void * layer_name_hash = NULL;
<span class="lineNum">    2024 </span>            : #endif
<span class="lineNum">    2025 </span><span class="lineNoCov">          0 :       switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.</span>
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :       xmlDocPtr plistdoc = PlistInit(); if (plistdoc == NULL) return false; // Make the document.</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :       xmlNodePtr rootnode = xmlDocGetRootElement(plistdoc); if (rootnode == NULL) { xmlFreeDoc(plistdoc); return false; } // Find the root node.</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :       xmlNodePtr arraynode = xmlNewChild(rootnode, NULL, BAD_CAST &quot;array&quot;, NULL); if (arraynode == NULL) { xmlFreeDoc(plistdoc); return false; } // Make the dict.</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :       switch_to_c_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the C locale temporarily and cache the old locale.</span>
<span class="lineNum">    2030 </span>            :       int layer_pos;
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :       for (layer_pos = 0; layer_pos &lt; sf-&gt;layer_cnt; layer_pos++) {</span>
<span class="lineNum">    2032 </span>            :         // We don't want to emit the default background layer unless it has stuff in it or was in the input U. F. O..
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :         if (layer_pos == ly_back &amp;&amp; !LayerWorthOutputting(sf, layer_pos) &amp;&amp; sf-&gt;layers[layer_pos].ufo_path == NULL) continue;</span>
<span class="lineNum">    2034 </span>            :         // We start building the layer contents entry.
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :         xmlNodePtr layernode = xmlNewChild(arraynode, NULL, BAD_CAST &quot;array&quot;, NULL);</span>
<span class="lineNum">    2036 </span>            :         // We make the layer name.
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :         char * layer_name_start = NULL;</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :         if (layer_pos == ly_fore) layer_name_start = &quot;public.default&quot;;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :         else if (layer_pos == ly_back) layer_name_start = &quot;public.background&quot;;</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :         else layer_name_start = sf-&gt;layers[layer_pos].name;</span>
<span class="lineNum">    2041 </span><span class="lineNoCov">          0 :         if (layer_name_start == NULL) layer_name_start = &quot;unnamed&quot;; // The remangle step adds any needed numbers.</span>
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :         char * numberedlayername = ufo_name_number(layer_name_hash, layer_pos, layer_name_start, &quot;&quot;, &quot;&quot;, 7);</span>
<span class="lineNum">    2043 </span>            :         // We make the layer path.
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :         char * layer_path_start = NULL;</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :         char * numberedlayerpath = NULL;</span>
<span class="lineNum">    2046 </span><span class="lineNoCov">          0 :         char * numberedlayerpathwithglyphs = NULL;</span>
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :         if (layer_pos == ly_fore) {</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :           numberedlayerpath = strdup(&quot;glyphs&quot;);</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :           asprintf(&amp;numberedlayerpathwithglyphs, &quot;%s&quot;, numberedlayerpath);</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :         } else if (sf-&gt;layers[layer_pos].ufo_path != NULL) {</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :           layer_path_start = strdup(sf-&gt;layers[layer_pos].ufo_path);</span>
<span class="lineNum">    2052 </span><span class="lineNoCov">          0 :           numberedlayerpath = ufo_name_number(layer_path_hash, layer_pos, layer_path_start, &quot;&quot;, &quot;&quot;, 7);</span>
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :           asprintf(&amp;numberedlayerpathwithglyphs, &quot;%s&quot;, numberedlayerpath);</span>
<span class="lineNum">    2054 </span>            :         } else {
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :           layer_path_start = ufo_name_mangle(sf-&gt;layers[layer_pos].name, &quot;glyphs.&quot;, &quot;&quot;, 7);</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :           numberedlayerpath = ufo_name_number(layer_path_hash, layer_pos, layer_path_start, &quot;glyphs.&quot;, &quot;&quot;, 7);</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :           asprintf(&amp;numberedlayerpathwithglyphs, &quot;glyphs.%s&quot;, numberedlayerpath);</span>
<span class="lineNum">    2058 </span>            :         }
<span class="lineNum">    2059 </span><span class="lineNoCov">          0 :         if (layer_path_start != NULL) { free(layer_path_start); layer_path_start = NULL; }</span>
<span class="lineNum">    2060 </span>            :         // We write to the layer contents.
<span class="lineNum">    2061 </span><span class="lineNoCov">          0 :         xmlNewTextChild(layernode, NULL, BAD_CAST &quot;string&quot;, numberedlayername);</span>
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :         xmlNewTextChild(layernode, NULL, BAD_CAST &quot;string&quot;, numberedlayerpathwithglyphs);</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :         glyphdir = buildname(basedir, numberedlayerpathwithglyphs);</span>
<span class="lineNum">    2064 </span>            :         // We write the glyph directory.
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :         err |= WriteUFOLayer(glyphdir, sf, layer_pos);</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :         free(numberedlayername); numberedlayername = NULL;</span>
<span class="lineNum">    2067 </span><span class="lineNoCov">          0 :         free(numberedlayerpath); numberedlayerpath = NULL;</span>
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :         free(numberedlayerpathwithglyphs); numberedlayerpathwithglyphs = NULL;</span>
<span class="lineNum">    2069 </span><span class="lineNoCov">          0 :         free(glyphdir); glyphdir = NULL;</span>
<span class="lineNum">    2070 </span>            :       }
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 :       char *fname = buildname(basedir, &quot;layercontents.plist&quot;); // Build the file name for the contents.</span>
<span class="lineNum">    2072 </span><span class="lineNoCov">          0 :       xmlSaveFormatFileEnc(fname, plistdoc, &quot;UTF-8&quot;, 1); // Store the document.</span>
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :       free(fname); fname = NULL;</span>
<span class="lineNum">    2074 </span><span class="lineNoCov">          0 :       xmlFreeDoc(plistdoc); // Free the memory.</span>
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :       xmlCleanupParser();</span>
<span class="lineNum">    2076 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :       glif_name_hash_destroy(layer_name_hash); // Close the hash table.</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :       glif_name_hash_destroy(layer_path_hash); // Close the hash table.</span>
<span class="lineNum">    2079 </span>            : #endif
<span class="lineNum">    2080 </span>            :     } else {
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :         glyphdir = buildname(basedir,&quot;glyphs&quot;);</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :         WriteUFOLayer(glyphdir, sf, layer);</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :         free(glyphdir); glyphdir = NULL;</span>
<span class="lineNum">    2084 </span>            :     }
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :     switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :     return !err;</span>
<a name="2087"><span class="lineNum">    2087 </span>            : }</a>
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 : int SplineFontHasUFOLayerNames(SplineFont *sf) {</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :   if (sf == NULL || sf-&gt;layers == NULL) return 0;</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :   int layer_pos = 0;</span>
<span class="lineNum">    2092 </span><span class="lineNoCov">          0 :   for (layer_pos = 0; layer_pos &lt; sf-&gt;layer_cnt; layer_pos++) {</span>
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :     if (sf-&gt;layers[layer_pos].ufo_path != NULL) return 1;</span>
<span class="lineNum">    2094 </span>            :   }
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :   return 0;</span>
<a name="2096"><span class="lineNum">    2096 </span>            : }</a>
<span class="lineNum">    2097 </span>            : 
<span class="lineNum">    2098 </span><span class="lineNoCov">          0 : int WriteUFOFont(const char *basedir, SplineFont *sf, enum fontformat ff, int flags,</span>
<span class="lineNum">    2099 </span>            :         const EncMap *map, int layer) {
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :   if (SplineFontHasUFOLayerNames(sf))</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :     return WriteUFOFontFlex(basedir, sf, ff, flags, map, layer, 1);</span>
<span class="lineNum">    2102 </span>            :   else
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :     return WriteUFOFontFlex(basedir, sf, ff, flags, map, layer, 0);</span>
<span class="lineNum">    2104 </span>            : }
<span class="lineNum">    2105 </span>            : 
<span class="lineNum">    2106 </span>            : /* ************************************************************************** */
<span class="lineNum">    2107 </span>            : /* *****************************    UFO Input    **************************** */
<a name="2108"><span class="lineNum">    2108 </span>            : /* ************************************************************************** */</a>
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 : static char *get_thingy(FILE *file,char *buffer,char *tag) {</span>
<span class="lineNum">    2111 </span>            :     int ch;
<span class="lineNum">    2112 </span>            :     char *pt;
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span>            :     for (;;) {
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :         while ( (ch=getc(file))!='&lt;' &amp;&amp; ch!=EOF );</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :         if ( ch==EOF )</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :         while ( (ch=getc(file))!=EOF &amp;&amp; isspace(ch) );</span>
<span class="lineNum">    2119 </span><span class="lineNoCov">          0 :         pt = tag;</span>
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :         while ( ch==*pt || tolower(ch)==*pt ) {</span>
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :             ++pt;</span>
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :             ch = getc(file);</span>
<span class="lineNum">    2123 </span>            :         }
<span class="lineNum">    2124 </span><span class="lineNoCov">          0 :         if ( *pt=='\0' )</span>
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :         if ( ch==EOF )</span>
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2128 </span><span class="lineNoCov">          0 :         while ( isspace(ch)) ch=getc(file);</span>
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :         if ( ch!='&gt;' )</span>
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :     continue;</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :         pt = buffer;</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :         while ( (ch=getc(file))!='&lt;' &amp;&amp; ch!=EOF &amp;&amp; pt&lt;buffer+1000)</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :             *pt++ = ch;</span>
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :         *pt = '\0';</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 : return( buffer );</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :     }</span>
<a name="2137"><span class="lineNum">    2137 </span>            : }</a>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 : char **NamesReadUFO(char *filename) {</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :     char *fn = buildname(filename,&quot;fontinfo.plist&quot;);</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :     FILE *info = fopen(fn,&quot;r&quot;);</span>
<span class="lineNum">    2142 </span>            :     char buffer[1024];
<span class="lineNum">    2143 </span>            :     char **ret;
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :     free(fn);</span>
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :     if ( info==NULL )</span>
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :     while ( get_thingy(info,buffer,&quot;key&quot;)!=NULL ) {</span>
<span class="lineNum">    2149 </span><span class="lineNoCov">          0 :         if ( strcmp(buffer,&quot;fontName&quot;)!=0 ) {</span>
<span class="lineNum">    2150 </span><span class="lineNoCov">          0 :             if ( get_thingy(info,buffer,&quot;string&quot;)!=NULL ) {</span>
<span class="lineNum">    2151 </span><span class="lineNoCov">          0 :                 ret = calloc(2,sizeof(char *));</span>
<span class="lineNum">    2152 </span><span class="lineNoCov">          0 :                 ret[0] = copy(buffer);</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :                 fclose(info);</span>
<span class="lineNum">    2154 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    2155 </span>            :             }
<span class="lineNum">    2156 </span><span class="lineNoCov">          0 :             fclose(info);</span>
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2158 </span>            :         }
<span class="lineNum">    2159 </span>            :     }
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :     fclose(info);</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2162 </span>            : }
<span class="lineNum">    2163 </span>            : 
<a name="2164"><span class="lineNum">    2164 </span>            : #include &lt;libxml/parser.h&gt;</a>
<span class="lineNum">    2165 </span>            : 
<span class="lineNum">    2166 </span><span class="lineNoCov">          0 : static int libxml_init_base() {</span>
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 : return( true );</span>
<a name="2168"><span class="lineNum">    2168 </span>            : }</a>
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span><span class="lineNoCov">          0 : static xmlNodePtr FindNode(xmlNodePtr kids,char *name) {</span>
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :     while ( kids!=NULL ) {</span>
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(kids-&gt;name,(const xmlChar *) name)== 0 )</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 : return( kids );</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :         kids = kids-&gt;next;</span>
<span class="lineNum">    2175 </span>            :     }
<span class="lineNum">    2176 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2177 </span>            : }
<span class="lineNum">    2178 </span>            : 
<span class="lineNum">    2179 </span>            : #ifndef _NO_PYTHON
<a name="2180"><span class="lineNum">    2180 </span>            : static PyObject *XMLEntryToPython(xmlDocPtr doc, xmlNodePtr entry, int has_lists);</a>
<span class="lineNum">    2181 </span>            : 
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 : static PyObject *LibToPython(xmlDocPtr doc, xmlNodePtr dict, int has_lists) {</span>
<span class="lineNum">    2183 </span>            :         // This function is responsible for parsing keys in dicts.
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :     PyObject *pydict = PyDict_New();</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :     PyObject *item = NULL;</span>
<span class="lineNum">    2186 </span>            :     xmlNodePtr keys, temp;
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            :         // Get the first item, then iterate through all items in the dict.
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :     for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    2190 </span>            :                 // See that the item is in fact a key.
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)== 0 ) {</span>
<span class="lineNum">    2192 </span>            :                         // Fetch the key name, which, according to the libxml specification, is the first child of the key entry.
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :                         char *keyname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    2194 </span>            :                         // In a property list, the value entry is a sibling of the key entry. The value itself is a child.
<span class="lineNum">    2195 </span>            :                         // Iterate through the following siblings (including keys (!)) until we find a text entry.
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :                         for ( temp=keys-&gt;next; temp!=NULL; temp=temp-&gt;next ) {</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :                                 if ( xmlStrcmp(temp-&gt;name,(const xmlChar *) &quot;text&quot;)!=0 ) break;</span>
<span class="lineNum">    2198 </span>            :                         }
<span class="lineNum">    2199 </span>            :                         // Convert the X.M.L. entry into a Python object.
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :                         item = NULL;</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :                         if ( temp!=NULL) item = XMLEntryToPython(doc,temp,has_lists);</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :                         if ( item!=NULL ) PyDict_SetItemString(pydict, keyname, item );</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :                         if ( temp==NULL ) break;</span>
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :                         else if ( xmlStrcmp(temp-&gt;name,(const xmlChar *) &quot;key&quot;)!=0 ) keys = temp;</span>
<span class="lineNum">    2205 </span>            :                         // If and only if the parsing succeeds, jump over any entries we read when searching for a text block.
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :                         free(keyname);</span>
<span class="lineNum">    2207 </span>            :                 }
<span class="lineNum">    2208 </span>            :     }
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 : return( pydict );</span>
<a name="2210"><span class="lineNum">    2210 </span>            : }</a>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 : static PyObject *XMLEntryToPython(xmlDocPtr doc,xmlNodePtr entry, int has_lists) {</span>
<span class="lineNum">    2213 </span>            :     char *contents;
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;true&quot;)==0 ) {</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :         Py_INCREF(Py_True);</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 : return( Py_True );</span>
<span class="lineNum">    2218 </span>            :     }
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;false&quot;)==0 ) {</span>
<span class="lineNum">    2220 </span><span class="lineNoCov">          0 :         Py_INCREF(Py_False);</span>
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 : return( Py_False );</span>
<span class="lineNum">    2222 </span>            :     }
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;none&quot;)==0 ) {</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :         Py_INCREF(Py_None);</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 : return( Py_None );</span>
<span class="lineNum">    2226 </span>            :     }
<span class="lineNum">    2227 </span>            : 
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;dict&quot;)==0 )</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 : return( LibToPython(doc,entry, has_lists));</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;array&quot;)==0 ) {</span>
<span class="lineNum">    2231 </span>            :         xmlNodePtr sub;
<span class="lineNum">    2232 </span>            :         int cnt;
<span class="lineNum">    2233 </span>            :         PyObject *ret, *item;
<span class="lineNum">    2234 </span>            :         /* I'm translating &quot;Arrays&quot; as tuples... not sure how to deal with */
<span class="lineNum">    2235 </span>            :         /*  actual python arrays. But these look more like tuples than arrays*/
<span class="lineNum">    2236 </span>            :         /*  since each item gets its own type */
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :         for ( cnt=0, sub=entry-&gt;children; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    2239 </span><span class="lineNoCov">          0 :             if ( xmlStrcmp(sub-&gt;name,(const xmlChar *) &quot;text&quot;)==0 )</span>
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :             ++cnt;</span>
<span class="lineNum">    2242 </span>            :         }
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :         ret = ( has_lists ? PyList_New(cnt) : PyTuple_New(cnt) );</span>
<span class="lineNum">    2244 </span><span class="lineNoCov">          0 :         for ( cnt=0, sub=entry-&gt;children; sub!=NULL; sub=sub-&gt;next ) {</span>
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :             if ( xmlStrcmp(sub-&gt;name,(const xmlChar *) &quot;text&quot;)==0 )</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :             item = XMLEntryToPython(doc,sub,has_lists);</span>
<span class="lineNum">    2248 </span><span class="lineNoCov">          0 :             if ( item==NULL ) {</span>
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :                 item = Py_None;</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :                 Py_INCREF(item);</span>
<span class="lineNum">    2251 </span>            :             }
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :             if (has_lists) PyList_SetItem(ret,cnt,item);</span>
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :             else PyTuple_SetItem(ret,cnt,item);</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :             ++cnt;</span>
<span class="lineNum">    2255 </span>            :         }
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    2257 </span>            :     }
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :     if ((entry-&gt;children != NULL) &amp;&amp; ((contents = (char *) xmlNodeListGetString(doc,entry-&gt;children,true)) != NULL) &amp;&amp;</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :        (( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 ) || ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;real&quot;)==0 ) ||</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :        ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;string&quot;)==0 ))) {</span>
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :       contents = (char *) xmlNodeListGetString(doc,entry-&gt;children,true);</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :       if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 ) {</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :         long val = strtol(contents,NULL,0);</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :         free(contents);</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 : return( Py_BuildValue(&quot;i&quot;,val));</span>
<span class="lineNum">    2266 </span>            :       }
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :       if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;real&quot;)==0 ) {</span>
<span class="lineNum">    2268 </span><span class="lineNoCov">          0 :         double val = strtod(contents,NULL);</span>
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :         free(contents);</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 : return( Py_BuildValue(&quot;d&quot;,val));</span>
<span class="lineNum">    2271 </span>            :       }
<span class="lineNum">    2272 </span><span class="lineNoCov">          0 :       if ( xmlStrcmp(entry-&gt;name,(const xmlChar *) &quot;string&quot;)==0 ) {</span>
<span class="lineNum">    2273 </span><span class="lineNoCov">          0 :         PyObject *ret = Py_BuildValue(&quot;s&quot;,contents);</span>
<span class="lineNum">    2274 </span><span class="lineNoCov">          0 :         free(contents);</span>
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 : return( ret );</span>
<span class="lineNum">    2276 </span>            :       }
<span class="lineNum">    2277 </span>            :       
<span class="lineNum">    2278 </span><span class="lineNoCov">          0 :       free( contents );</span>
<span class="lineNum">    2279 </span>            :     }
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :     if (has_lists) {</span>
<span class="lineNum">    2281 </span>            :       // This special handler for unrecognized content depends
<span class="lineNum">    2282 </span>            :       // on the fact that there's no X. M. L. equivalent for the Python tuple.
<span class="lineNum">    2283 </span><span class="lineNoCov">          0 :       xmlBufferPtr buf = xmlBufferCreate(); // Create a buffer for dumping this portion of the tree.</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :       xmlNodeDump(buf, doc, entry, 0, 0); // Dump the tree into the buffer.</span>
<span class="lineNum">    2285 </span><span class="lineNoCov">          0 :       const xmlChar* tmpcontent = xmlBufferContent(buf); // Get the string from the buffer.</span>
<span class="lineNum">    2286 </span><span class="lineNoCov">          0 :       PyObject* ret = PyTuple_New(3); // Make a tuple in the Python tree.</span>
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :       PyTuple_SetItem(ret, 0, PyBytes_FromString((const char*)entry-&gt;name)); // Store the node name.</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :       PyTuple_SetItem(ret, 1, PyBytes_FromString((const char*)tmpcontent)); // Store the node content.</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :       PyTuple_SetItem(ret, 2, Py_None);</span>
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :       Py_INCREF(Py_None);</span>
<span class="lineNum">    2291 </span><span class="lineNoCov">          0 :       xmlBufferFree(buf);</span>
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :       return ret;</span>
<span class="lineNum">    2293 </span>            :     }
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :     LogError(_(&quot;Unknown python type &lt;%s&gt; when reading UFO/GLIF lib data.&quot;), (char *) entry-&gt;name);</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2296 </span>            : }
<a name="2297"><span class="lineNum">    2297 </span>            : #endif</a>
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span><span class="lineNoCov">          0 : static StemInfo *GlifParseHints(xmlDocPtr doc,xmlNodePtr dict,char *hinttype) {</span>
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :     StemInfo *head=NULL, *last=NULL, *h;</span>
<span class="lineNum">    2301 </span>            :     xmlNodePtr keys, array, kids, poswidth,temp;
<span class="lineNum">    2302 </span>            :     double pos, width;
<span class="lineNum">    2303 </span>            : 
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :     for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)== 0 ) {</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :             char *keyname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :             int found = strcmp(keyname,hinttype)==0;</span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :             free(keyname);</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :             if ( found ) {</span>
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :                 for ( array=keys-&gt;next; array!=NULL; array=array-&gt;next ) {</span>
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :                     if ( xmlStrcmp(array-&gt;name,(const xmlChar *) &quot;array&quot;)==0 )</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    2313 </span>            :                 }
<span class="lineNum">    2314 </span><span class="lineNoCov">          0 :                 if ( array!=NULL ) {</span>
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :                     for ( kids = array-&gt;children; kids!=NULL; kids=kids-&gt;next ) {</span>
<span class="lineNum">    2316 </span><span class="lineNoCov">          0 :                         if ( xmlStrcmp(kids-&gt;name,(const xmlChar *) &quot;dict&quot;)==0 ) {</span>
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 :                             pos = -88888888; width = 0;</span>
<span class="lineNum">    2318 </span><span class="lineNoCov">          0 :                             for ( poswidth=kids-&gt;children; poswidth!=NULL; poswidth=poswidth-&gt;next ) {</span>
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :                                 if ( xmlStrcmp(poswidth-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :                                     char *keyname2 = (char *) xmlNodeListGetString(doc,poswidth-&gt;children,true);</span>
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :                                     int ispos = strcmp(keyname2,&quot;position&quot;)==0, iswidth = strcmp(keyname2,&quot;width&quot;)==0;</span>
<span class="lineNum">    2322 </span>            :                                     double value;
<span class="lineNum">    2323 </span><span class="lineNoCov">          0 :                                     free(keyname2);</span>
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :                                     for ( temp=poswidth-&gt;next; temp!=NULL; temp=temp-&gt;next ) {</span>
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :                                         if ( xmlStrcmp(temp-&gt;name,(const xmlChar *) &quot;text&quot;)!=0 )</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :                                     break;</span>
<span class="lineNum">    2327 </span>            :                                     }
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :                                     if ( temp!=NULL ) {</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :                                         char *valname = (char *) xmlNodeListGetString(doc,temp-&gt;children,true);</span>
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :                                         if ( xmlStrcmp(temp-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 )</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :                                             value = strtol(valname,NULL,10);</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :                                         else if ( xmlStrcmp(temp-&gt;name,(const xmlChar *) &quot;real&quot;)==0 )</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :                                             value = strtod(valname,NULL);</span>
<span class="lineNum">    2334 </span>            :                                         else
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :                                             ispos = iswidth = false;</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :                                         free(valname);</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :                                         if ( ispos )</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :                                             pos = value;</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :                                         else if ( iswidth )</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :                                             width = value;</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :                                         poswidth = temp;</span>
<span class="lineNum">    2342 </span>            :                                     }
<span class="lineNum">    2343 </span>            :                                 }
<span class="lineNum">    2344 </span>            :                             }
<span class="lineNum">    2345 </span><span class="lineNoCov">          0 :                             if ( pos!=-88888888 &amp;&amp; width!=0 ) {</span>
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :                                 h = chunkalloc(sizeof(StemInfo));</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :                                 h-&gt;start = pos;</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :                                 h-&gt;width = width;</span>
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :                                 if ( width==-20 || width==-21 )</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :                                     h-&gt;ghost = true;</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :                                 if ( head==NULL )</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :                                     head = last = h;</span>
<span class="lineNum">    2353 </span>            :                                 else {
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :                                     last-&gt;next = h;</span>
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :                                     last = h;</span>
<span class="lineNum">    2356 </span>            :                                 }
<span class="lineNum">    2357 </span>            :                             }
<span class="lineNum">    2358 </span>            :                         }
<span class="lineNum">    2359 </span>            :                     }
<span class="lineNum">    2360 </span>            :                 }
<span class="lineNum">    2361 </span>            :             }
<span class="lineNum">    2362 </span>            :         }
<span class="lineNum">    2363 </span>            :     }
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 : return( head );</span>
<a name="2365"><span class="lineNum">    2365 </span>            : }</a>
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 : static SplineChar *_UFOLoadGlyph(SplineFont *sf, xmlDocPtr doc, char *glifname, char* glyphname, SplineChar* existingglyph, int layerdest) {</span>
<span class="lineNum">    2368 </span>            :     xmlNodePtr glyph, kids, contour, points;
<span class="lineNum">    2369 </span>            :     SplineChar *sc;
<span class="lineNum">    2370 </span>            :     xmlChar *format, *width, *height, *u;
<span class="lineNum">    2371 </span>            :     char *name, *tmpname;
<span class="lineNum">    2372 </span>            :     int uni;
<span class="lineNum">    2373 </span>            :     char *cpt;
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :     int newsc = 0;</span>
<span class="lineNum">    2375 </span>            : 
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :     glyph = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :     format = xmlGetProp(glyph,(xmlChar *) &quot;format&quot;);</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(glyph-&gt;name,(const xmlChar *) &quot;glyph&quot;)!=0 ||</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :             (format!=NULL &amp;&amp; xmlStrcmp(format,(xmlChar *) &quot;1&quot;)!=0 &amp;&amp; xmlStrcmp(format,(xmlChar *) &quot;2&quot;)!=0)) {</span>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :                 LogError(_(&quot;Expected glyph file with format==1 or 2&quot;));</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :                 xmlFreeDoc(doc);</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :                 free(format);</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :                 return( NULL );</span>
<span class="lineNum">    2384 </span>            :     }
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :         free(format);</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :         tmpname = (char *) xmlGetProp(glyph,(xmlChar *) &quot;name&quot;);</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :         if (glyphname != NULL) {</span>
<span class="lineNum">    2388 </span>            :                 // We use the provided name from the glyph listing since the specification says to trust that one more.
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :                 name = copy(glyphname);</span>
<span class="lineNum">    2390 </span>            :                 // But we still fetch the internally listed name for verification and fail on a mismatch.
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :                 if ((name == NULL) || ((name != NULL) &amp;&amp; (tmpname != NULL) &amp;&amp; (strcmp(glyphname, name) != 0))) {</span>
<span class="lineNum">    2392 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;Bad glyph name.&quot;));</span>
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :                         if ( tmpname != NULL ) { free(tmpname); tmpname = NULL; }</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :                         if ( name != NULL ) { free(name); name = NULL; }</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :                         xmlFreeDoc(doc);</span>
<span class="lineNum">    2396 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">    2397 </span>            :                 }
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :                 if ( tmpname != NULL ) { free(tmpname); tmpname = NULL; }</span>
<span class="lineNum">    2399 </span>            :         } else {
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :                 name = tmpname;</span>
<span class="lineNum">    2401 </span>            :         }
<span class="lineNum">    2402 </span><span class="lineNoCov">          0 :     if ( name==NULL &amp;&amp; glifname!=NULL ) {</span>
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :                 char *pt = strrchr(glifname,'/');</span>
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :                 name = copy(pt+1);</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :                 for ( pt=cpt=name; *cpt!='\0'; ++cpt ) {</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :                         if ( *cpt!='_' )</span>
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :                         *pt++ = *cpt;</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :                         else if ( islower(*name))</span>
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :                         *name = toupper(*name);</span>
<span class="lineNum">    2410 </span>            :                 }
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :                 *pt = '\0';</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :     } else if ( name==NULL )</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :                 name = copy(&quot;nameless&quot;);</span>
<span class="lineNum">    2414 </span>            :         // We assign a placeholder name if no name exists.
<span class="lineNum">    2415 </span>            :         // We create a new SplineChar 
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :         if (existingglyph != NULL) {</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :                 sc = existingglyph;</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :                 free(name); name = NULL;</span>
<span class="lineNum">    2419 </span>            :         } else {
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :         sc = SplineCharCreate(2);</span>
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :         sc-&gt;name = name;</span>
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :                 newsc = 1;</span>
<span class="lineNum">    2423 </span>            :         }
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :         if (sc == NULL) {</span>
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :                 xmlFreeDoc(doc);</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2427 </span>            :         }
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span>            :         // Check layer availability here.
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :         if ( layerdest&gt;=sc-&gt;layer_cnt ) {</span>
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :                 sc-&gt;layers = realloc(sc-&gt;layers,(layerdest+1)*sizeof(Layer));</span>
<span class="lineNum">    2432 </span><span class="lineNoCov">          0 :                 memset(sc-&gt;layers+sc-&gt;layer_cnt,0,(layerdest+1-sc-&gt;layer_cnt)*sizeof(Layer));</span>
<span class="lineNum">    2433 </span><span class="lineNoCov">          0 :                 sc-&gt;layer_cnt = layerdest + 1;</span>
<span class="lineNum">    2434 </span>            :         }
<span class="lineNum">    2435 </span><span class="lineNoCov">          0 :         if (sc-&gt;layers == NULL) {</span>
<span class="lineNum">    2436 </span><span class="lineNoCov">          0 :                 if ((newsc == 1) &amp;&amp; (sc != NULL)) {</span>
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :                         SplineCharFree(sc);</span>
<span class="lineNum">    2438 </span>            :                 }
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :                 xmlFreeDoc(doc);</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :                 return NULL;</span>
<span class="lineNum">    2441 </span>            :         }
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span>            :     // We track the last splineset so that we can add to the end of the chain.
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :     SplineSet *last = sc-&gt;layers[layerdest].splines;</span>
<span class="lineNum">    2445 </span><span class="lineNoCov">          0 :     while (last != NULL &amp;&amp; last-&gt;next != NULL) last = last-&gt;next;</span>
<span class="lineNum">    2446 </span>            :     // We track the last anchor point.
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :     AnchorPoint *lastap = sc-&gt;anchor;</span>
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :     while (lastap != NULL &amp;&amp; lastap-&gt;next != NULL) lastap = lastap-&gt;next;</span>
<span class="lineNum">    2449 </span>            :     // We track the last reference.
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :     RefChar *lastref = sc-&gt;layers[layerdest].refs;</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :     while (lastref != NULL &amp;&amp; lastref-&gt;next != NULL) lastref = lastref-&gt;next;</span>
<span class="lineNum">    2452 </span>            : 
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :     for ( kids = glyph-&gt;children; kids!=NULL; kids=kids-&gt;next ) {</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(kids-&gt;name,(const xmlChar *) &quot;advance&quot;)==0 ) {</span>
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :                 if ((layerdest == ly_fore) || newsc) {</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :                         width = xmlGetProp(kids,(xmlChar *) &quot;width&quot;);</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :                         height = xmlGetProp(kids,(xmlChar *) &quot;height&quot;);</span>
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :                         if ( width!=NULL )</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :                         sc-&gt;width = strtol((char *) width,NULL,10);</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :                         if ( height!=NULL )</span>
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :                         sc-&gt;vwidth = strtol((char *) height,NULL,10);</span>
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :                         sc-&gt;widthset = true;</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :                         free(width); free(height);</span>
<span class="lineNum">    2464 </span>            :                 }
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :         } else if ( xmlStrcmp(kids-&gt;name,(const xmlChar *) &quot;unicode&quot;)==0 ) {</span>
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :                 if ((layerdest == ly_fore) || newsc) {</span>
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :                         u = xmlGetProp(kids,(xmlChar *) &quot;hex&quot;);</span>
<span class="lineNum">    2468 </span><span class="lineNoCov">          0 :                         uni = strtol((char *) u,NULL,16);</span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :                         if ( sc-&gt;unicodeenc == -1 )</span>
<span class="lineNum">    2470 </span><span class="lineNoCov">          0 :                         sc-&gt;unicodeenc = uni;</span>
<span class="lineNum">    2471 </span>            :                         else
<span class="lineNum">    2472 </span><span class="lineNoCov">          0 :                         AltUniAdd(sc,uni);</span>
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :                         free(u);</span>
<span class="lineNum">    2474 </span>            :                 }
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :         } else if ( xmlStrcmp(kids-&gt;name,(const xmlChar *) &quot;outline&quot;)==0 ) {</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :             for ( contour = kids-&gt;children; contour!=NULL; contour=contour-&gt;next ) {</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(contour-&gt;name,(const xmlChar *) &quot;component&quot;)==0 ) {</span>
<span class="lineNum">    2478 </span>            :                     // We have a reference.
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :                     char *base = (char *) xmlGetProp(contour,(xmlChar *) &quot;base&quot;),</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :                         *xs = (char *) xmlGetProp(contour,(xmlChar *) &quot;xScale&quot;),</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :                         *ys = (char *) xmlGetProp(contour,(xmlChar *) &quot;yScale&quot;),</span>
<span class="lineNum">    2482 </span><span class="lineNoCov">          0 :                         *xys = (char *) xmlGetProp(contour,(xmlChar *) &quot;xyScale&quot;),</span>
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :                         *yxs = (char *) xmlGetProp(contour,(xmlChar *) &quot;yxScale&quot;),</span>
<span class="lineNum">    2484 </span><span class="lineNoCov">          0 :                         *xo = (char *) xmlGetProp(contour,(xmlChar *) &quot;xOffset&quot;),</span>
<span class="lineNum">    2485 </span><span class="lineNoCov">          0 :                         *yo = (char *) xmlGetProp(contour,(xmlChar *) &quot;yOffset&quot;);</span>
<span class="lineNum">    2486 </span>            :                     RefChar *r;
<span class="lineNum">    2487 </span><span class="lineNoCov">          0 :                     if ( base==NULL || strcmp(base,&quot;&quot;) == 0 )</span>
<span class="lineNum">    2488 </span><span class="lineNoCov">          0 :                                 LogError(_(&quot;component with no base glyph&quot;));</span>
<span class="lineNum">    2489 </span>            :                     else {
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 :                                 r = RefCharCreate();</span>
<span class="lineNum">    2491 </span><span class="lineNoCov">          0 :                                 r-&gt;sc = SplineCharCreate(0);</span>
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :                                 r-&gt;sc-&gt;name = base;</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :                                 r-&gt;transform[0] = r-&gt;transform[3] = 1;</span>
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :                                 if ( xs!=NULL )</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :                                         r-&gt;transform[0] = strtod(xs,NULL);</span>
<span class="lineNum">    2496 </span><span class="lineNoCov">          0 :                                 if ( ys!=NULL )</span>
<span class="lineNum">    2497 </span><span class="lineNoCov">          0 :                                         r-&gt;transform[3] = strtod(ys,NULL);</span>
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :                                 if ( xys!=NULL )</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :                                         r-&gt;transform[1] = strtod(xys,NULL);</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :                                 if ( yxs!=NULL )</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :                                         r-&gt;transform[2] = strtod(yxs,NULL);</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :                                 if ( xo!=NULL )</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :                                         r-&gt;transform[4] = strtod(xo,NULL);</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :                                 if ( yo!=NULL )</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :                                         r-&gt;transform[5] = strtod(yo,NULL);</span>
<span class="lineNum">    2506 </span>            : 
<span class="lineNum">    2507 </span><span class="lineNoCov">          0 :                                 if ( lastref==NULL ) {</span>
<span class="lineNum">    2508 </span>            :                                   // If there are no existing references, we point the main spline reference to this one.
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :                                   sc-&gt;layers[layerdest].refs = r;</span>
<span class="lineNum">    2510 </span>            :                                 } else {
<span class="lineNum">    2511 </span>            :                                   // If there are existing references, we attach to the last one.
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :                                   lastref-&gt;next = r;</span>
<span class="lineNum">    2513 </span>            :                                 }
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :                                 lastref = r;</span>
<span class="lineNum">    2515 </span>            :                     }
<span class="lineNum">    2516 </span><span class="lineNoCov">          0 :                     if (xs) free(xs); if (ys) free(ys); if (xys) free(xys); if (yxs) free(yxs); if (xo) free(xo); if (yo) free(yo);</span>
<span class="lineNum">    2517 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(contour-&gt;name,(const xmlChar *) &quot;contour&quot;)==0 ) {</span>
<span class="lineNum">    2518 </span>            :                     xmlNodePtr npoints;
<span class="lineNum">    2519 </span>            : 
<span class="lineNum">    2520 </span>            :                         // We now look for anchor points.
<span class="lineNum">    2521 </span>            :             char *sname;
<span class="lineNum">    2522 </span>            : 
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :             for ( points=contour-&gt;children; points!=NULL; points=points-&gt;next )</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(points-&gt;name,(const xmlChar *) &quot;point&quot;)==0 )</span>
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :             for ( npoints=points-&gt;next; npoints!=NULL; npoints=npoints-&gt;next )</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(npoints-&gt;name,(const xmlChar *) &quot;point&quot;)==0 )</span>
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    2529 </span>            :                         // If the contour has a single point without another point after it, we assume it to be an anchor point.
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :             if ( points!=NULL &amp;&amp; npoints==NULL ) {</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :                 sname = (char *) xmlGetProp(points, (xmlChar *) &quot;name&quot;);</span>
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :                 if ( sname!=NULL) {</span>
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span>            :                     /* make an AP and if necessary an AC */
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :                     AnchorPoint *ap = chunkalloc(sizeof(AnchorPoint));</span>
<span class="lineNum">    2536 </span>            :                     AnchorClass *ac;
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :                     char *namep = *sname=='_' ? sname + 1 : sname;</span>
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :                     char *xs = (char *) xmlGetProp(points, (xmlChar *) &quot;x&quot;);</span>
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :                     char *ys = (char *) xmlGetProp(points, (xmlChar *) &quot;y&quot;);</span>
<span class="lineNum">    2540 </span><span class="lineNoCov">          0 :                     if (xs) { ap-&gt;me.x = strtod(xs,NULL); free(xs); }</span>
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :                     if (ys) { ap-&gt;me.y = strtod(ys,NULL); free(ys); }</span>
<span class="lineNum">    2542 </span>            : 
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :                     ac = SFFindOrAddAnchorClass(sf,namep,NULL);</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :                     if (*sname=='_')</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :                         ap-&gt;type = ac-&gt;type==act_curs ? at_centry : at_mark;</span>
<span class="lineNum">    2546 </span>            :                     else
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :                         ap-&gt;type = ac-&gt;type==act_mkmk   ? at_basemark :</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :                                     ac-&gt;type==act_curs  ? at_cexit :</span>
<span class="lineNum">    2549 </span><span class="lineNoCov">          0 :                                     ac-&gt;type==act_mklg  ? at_baselig :</span>
<span class="lineNum">    2550 </span>            :                                                           at_basechar;
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :                     ap-&gt;anchor = ac;</span>
<span class="lineNum">    2552 </span><span class="lineNoCov">          0 :                     if ( lastap==NULL ) {</span>
<span class="lineNum">    2553 </span>            :                                 // If there are no existing anchors, we point the main spline reference to this one.
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :                                 sc-&gt;anchor = ap;</span>
<span class="lineNum">    2555 </span>            :                     } else {
<span class="lineNum">    2556 </span>            :                                 // If there are existing anchors, we attach to the last one.
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :                                 lastap-&gt;next = ap;</span>
<span class="lineNum">    2558 </span>            :                     }
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :                     lastap = ap;</span>
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :                     free(sname);</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :                                 continue; // We stop processing the contour at this point.</span>
<span class="lineNum">    2563 </span>            :                 }
<span class="lineNum">    2564 </span>            :             }
<span class="lineNum">    2565 </span>            : 
<span class="lineNum">    2566 </span>            :                         // If we have not identified the contour as holding an anchor point, we continue processing it as a rendered shape.
<span class="lineNum">    2567 </span>            :                         SplineSet *ss;
<span class="lineNum">    2568 </span>            :                         SplinePoint *sp;
<span class="lineNum">    2569 </span>            :                         SplinePoint *sp2;
<span class="lineNum">    2570 </span>            :                         BasePoint pre[2], init[4];
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :                         int precnt=0, initcnt=0, open=0;</span>
<span class="lineNum">    2572 </span>            :                         // precnt seems to count control points leading into the next on-curve point. pre stores those points.
<span class="lineNum">    2573 </span>            :                         // initcnt counts the control points that appear before the first on-curve point. This can get updated at the beginning and/or the end of the list.
<span class="lineNum">    2574 </span>            :                         // This is important for determining the order of the closing curve.
<span class="lineNum">    2575 </span>            :                         // A further improvement would be to prefetch the entire list so as to know the declared order of a curve before processing the point.
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :                         int wasquad = -1; // This tracks whether we identified the previous curve as quadratic. (-1 means undefined.)</span>
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :                         int firstpointsaidquad = -1; // This tracks the declared order of the curve leading into the first on-curve point.</span>
<span class="lineNum">    2579 </span>            : 
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :                     ss = chunkalloc(sizeof(SplineSet));</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :                         ss-&gt;first = NULL;</span>
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :                     for ( points = contour-&gt;children; points!=NULL; points=points-&gt;next ) {</span>
<span class="lineNum">    2584 </span>            :                         char *xs, *ys, *type, *pname, *smooths;
<span class="lineNum">    2585 </span>            :                         double x,y;
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :                         int smooth = 0;</span>
<span class="lineNum">    2587 </span>            :                         // We discard any entities in the splineset that are not points.
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :                         if ( xmlStrcmp(points-&gt;name,(const xmlChar *) &quot;point&quot;)!=0 )</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    2590 </span>            :                         // Read as strings from xml.
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :                         xs = (char *) xmlGetProp(points,(xmlChar *) &quot;x&quot;);</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :                         ys = (char *) xmlGetProp(points,(xmlChar *) &quot;y&quot;);</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :                         type = (char *) xmlGetProp(points,(xmlChar *) &quot;type&quot;);</span>
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :                         pname = (char *) xmlGetProp(points,(xmlChar *) &quot;name&quot;);</span>
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :                         smooths = (char *) xmlGetProp(points,(xmlChar *) &quot;smooth&quot;);</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :                         if (smooths != NULL) {</span>
<span class="lineNum">    2597 </span><span class="lineNoCov">          0 :                                 if (strcmp(smooths,&quot;yes&quot;) == 0) smooth = 1;</span>
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :                                 free(smooths); smooths=NULL;</span>
<span class="lineNum">    2599 </span>            :                         }
<span class="lineNum">    2600 </span><span class="lineNoCov">          0 :                         if ( xs==NULL || ys == NULL ) {</span>
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :                                 if (xs != NULL) { free(xs); xs = NULL; }</span>
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :                                 if (ys != NULL) { free(ys); ys = NULL; }</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :                                 if (type != NULL) { free(type); type = NULL; }</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :                                 if (pname != NULL) { free(pname); pname = NULL; }</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2606 </span>            :                         }
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :                         x = strtod(xs,NULL); y = strtod(ys,NULL);</span>
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :                         if ( type!=NULL &amp;&amp; (strcmp(type,&quot;move&quot;)==0 ||</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :                                             strcmp(type,&quot;line&quot;)==0 ||</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :                                             strcmp(type,&quot;curve&quot;)==0 ||</span>
<span class="lineNum">    2611 </span><span class="lineNoCov">          0 :                                             strcmp(type,&quot;qcurve&quot;)==0 )) {</span>
<span class="lineNum">    2612 </span>            :                                 // This handles only actual points.
<span class="lineNum">    2613 </span>            :                                 // We create and label the point.
<span class="lineNum">    2614 </span><span class="lineNoCov">          0 :                             sp = SplinePointCreate(x,y);</span>
<span class="lineNum">    2615 </span><span class="lineNoCov">          0 :                                 sp-&gt;dontinterpolate = 1;</span>
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 :                                 if (pname != NULL) {</span>
<span class="lineNum">    2617 </span><span class="lineNoCov">          0 :                                         sp-&gt;name = copy(pname);</span>
<span class="lineNum">    2618 </span>            :                                 }
<span class="lineNum">    2619 </span><span class="lineNoCov">          0 :                                 if (smooth == 1) sp-&gt;pointtype = pt_curve;</span>
<span class="lineNum">    2620 </span><span class="lineNoCov">          0 :                                 else sp-&gt;pointtype = pt_corner;</span>
<span class="lineNum">    2621 </span>            : 
<span class="lineNum">    2622 </span><span class="lineNoCov">          0 :                             if ( ss-&gt;first==NULL ) {</span>
<span class="lineNum">    2623 </span>            :                                 // So this is the first real point!
<span class="lineNum">    2624 </span><span class="lineNoCov">          0 :                                 ss-&gt;first = ss-&gt;last = sp;</span>
<span class="lineNum">    2625 </span>            :                                 // We move the lead-in points to the init buffer as we may need them for the final curve.
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 :                                 memcpy(init,pre,sizeof(pre));</span>
<span class="lineNum">    2627 </span><span class="lineNoCov">          0 :                                 initcnt = precnt;</span>
<span class="lineNum">    2628 </span><span class="lineNoCov">          0 :                                 if ( strcmp(type,&quot;move&quot;)==0 ) {</span>
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 :                                   open = true;</span>
<span class="lineNum">    2630 </span><span class="lineNoCov">          0 :                                   if (initcnt != 0) LogError(_(&quot;We cannot have lead-in points for an open curve.\n&quot;));</span>
<span class="lineNum">    2631 </span>            :                                 }
<span class="lineNum">    2632 </span>            :                             }
<span class="lineNum">    2633 </span>            : 
<span class="lineNum">    2634 </span><span class="lineNoCov">          0 :                             if ( strcmp(type,&quot;move&quot;)==0 ) {</span>
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 :                                 if (ss-&gt;first != sp) {</span>
<span class="lineNum">    2636 </span><span class="lineNoCov">          0 :                                   LogError(_(&quot;The move point must be at the beginning of the contour.\n&quot;));</span>
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :                                   SplinePointFree(sp); sp = NULL;</span>
<span class="lineNum">    2638 </span>            :                                 }
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :                             } else if ( strcmp(type,&quot;line&quot;)==0 ) {</span>
<span class="lineNum">    2640 </span><span class="lineNoCov">          0 :                                 SplineMake(ss-&gt;last,sp,false);</span>
<span class="lineNum">    2641 </span><span class="lineNoCov">          0 :                                 ss-&gt;last = sp;</span>
<span class="lineNum">    2642 </span><span class="lineNoCov">          0 :                             } else if ( strcmp(type,&quot;curve&quot;)==0 ) {</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :                                 wasquad = false;</span>
<span class="lineNum">    2644 </span><span class="lineNoCov">          0 :                                 if (ss-&gt;first == sp) {</span>
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :                                   firstpointsaidquad = false;</span>
<span class="lineNum">    2646 </span>            :                                 }
<span class="lineNum">    2647 </span><span class="lineNoCov">          0 :                                 if ( precnt==2 &amp;&amp; ss-&gt;first != sp ) {</span>
<span class="lineNum">    2648 </span><span class="lineNoCov">          0 :                                     ss-&gt;last-&gt;nextcp = pre[0];</span>
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 :                                     ss-&gt;last-&gt;nonextcp = false;</span>
<span class="lineNum">    2650 </span><span class="lineNoCov">          0 :                                     sp-&gt;prevcp = pre[1];</span>
<span class="lineNum">    2651 </span><span class="lineNoCov">          0 :                                     sp-&gt;noprevcp = false;</span>
<span class="lineNum">    2652 </span><span class="lineNoCov">          0 :                                     SplineMake(ss-&gt;last,sp,false);</span>
<span class="lineNum">    2653 </span>            :                                 }
<span class="lineNum">    2654 </span><span class="lineNoCov">          0 :                                 ss-&gt;last = sp;</span>
<span class="lineNum">    2655 </span><span class="lineNoCov">          0 :                             } else if ( strcmp(type,&quot;qcurve&quot;)==0 ) {</span>
<span class="lineNum">    2656 </span><span class="lineNoCov">          0 :                                         wasquad = true;</span>
<span class="lineNum">    2657 </span><span class="lineNoCov">          0 :                                 if (ss-&gt;first == sp) {</span>
<span class="lineNum">    2658 </span><span class="lineNoCov">          0 :                                   firstpointsaidquad = true;</span>
<span class="lineNum">    2659 </span>            :                                 }
<span class="lineNum">    2660 </span><span class="lineNoCov">          0 :                                         if ( precnt&gt;0 &amp;&amp; precnt&lt;=2 ) {</span>
<span class="lineNum">    2661 </span><span class="lineNoCov">          0 :                                                 if ( precnt==2 ) {</span>
<span class="lineNum">    2662 </span>            :                                                         // If we have two cached control points and the end point is quadratic, we need an implied point between the two control points.
<span class="lineNum">    2663 </span><span class="lineNoCov">          0 :                                                         sp2 = SplinePointCreate((pre[1].x+pre[0].x)/2,(pre[1].y+pre[0].y)/2);</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :                                                         sp2-&gt;prevcp = ss-&gt;last-&gt;nextcp = pre[0];</span>
<span class="lineNum">    2665 </span><span class="lineNoCov">          0 :                                                         sp2-&gt;noprevcp = ss-&gt;last-&gt;nonextcp = false;</span>
<span class="lineNum">    2666 </span><span class="lineNoCov">          0 :                                                         sp2-&gt;ttfindex = 0xffff;</span>
<span class="lineNum">    2667 </span><span class="lineNoCov">          0 :                                                         SplineMake(ss-&gt;last,sp2,true);</span>
<span class="lineNum">    2668 </span><span class="lineNoCov">          0 :                                                         ss-&gt;last = sp2;</span>
<span class="lineNum">    2669 </span>            :                                                 }
<span class="lineNum">    2670 </span>            :                                                 // Now we connect the real point.
<span class="lineNum">    2671 </span><span class="lineNoCov">          0 :                                                 sp-&gt;prevcp = ss-&gt;last-&gt;nextcp = pre[precnt-1];</span>
<span class="lineNum">    2672 </span><span class="lineNoCov">          0 :                                                 sp-&gt;noprevcp = ss-&gt;last-&gt;nonextcp = false;</span>
<span class="lineNum">    2673 </span>            :                                         }
<span class="lineNum">    2674 </span><span class="lineNoCov">          0 :                                         SplineMake(ss-&gt;last,sp,true);</span>
<span class="lineNum">    2675 </span><span class="lineNoCov">          0 :                                         ss-&gt;last = sp;</span>
<span class="lineNum">    2676 </span>            :                             } else {
<span class="lineNum">    2677 </span><span class="lineNoCov">          0 :                                 SplinePointFree(sp); sp = NULL;</span>
<span class="lineNum">    2678 </span>            :                             }
<span class="lineNum">    2679 </span><span class="lineNoCov">          0 :                             precnt = 0;</span>
<span class="lineNum">    2680 </span>            :                         } else {
<span class="lineNum">    2681 </span>            :                                 // This handles off-curve points (control points).
<span class="lineNum">    2682 </span><span class="lineNoCov">          0 :                             if ((wasquad == true || wasquad==-1) &amp;&amp; precnt==2 ) {</span>
<span class="lineNum">    2683 </span>            :                                 // We don't know whether the current curve is quadratic or cubic, but, if we're hitting three off-curve points in a row, something is off.
<span class="lineNum">    2684 </span>            :                                 // As mentioned below, we assume in this case that we're dealing with a quadratic TrueType curve that needs implied points.
<span class="lineNum">    2685 </span>            :                                 // We create those points since they are adjustable in Fontforge.
<span class="lineNum">    2686 </span>            :                                 // There is not a valid case as far as Frank knows in which a cubic curve would have implied points.
<span class="lineNum">    2687 </span>            :                                 /* Undocumented fact: If there are no on-curve points (and therefore no indication of quadratic/cubic), assume truetype implied points */
<span class="lineNum">    2688 </span>            :                                         // We make the point between the two already cached control points.
<span class="lineNum">    2689 </span><span class="lineNoCov">          0 :                                         sp = SplinePointCreate((pre[1].x+pre[0].x)/2,(pre[1].y+pre[0].y)/2);</span>
<span class="lineNum">    2690 </span><span class="lineNoCov">          0 :                                         sp-&gt;ttfindex = 0xffff;</span>
<span class="lineNum">    2691 </span><span class="lineNoCov">          0 :                                         if (pname != NULL) {</span>
<span class="lineNum">    2692 </span><span class="lineNoCov">          0 :                                                 sp-&gt;name = copy(pname);</span>
<span class="lineNum">    2693 </span>            :                                         }
<span class="lineNum">    2694 </span><span class="lineNoCov">          0 :                                 sp-&gt;nextcp = pre[1];</span>
<span class="lineNum">    2695 </span><span class="lineNoCov">          0 :                                 sp-&gt;nonextcp = false;</span>
<span class="lineNum">    2696 </span><span class="lineNoCov">          0 :                                 if ( ss-&gt;first==NULL ) {</span>
<span class="lineNum">    2697 </span>            :                                     // This is indeed possible if the first three points are control points.
<span class="lineNum">    2698 </span><span class="lineNoCov">          0 :                                     ss-&gt;first = sp;</span>
<span class="lineNum">    2699 </span><span class="lineNoCov">          0 :                                     memcpy(init,pre,sizeof(pre));</span>
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :                                     initcnt = 1;</span>
<span class="lineNum">    2701 </span>            :                                 } else {
<span class="lineNum">    2702 </span><span class="lineNoCov">          0 :                                     ss-&gt;last-&gt;nextcp = sp-&gt;prevcp = pre[0];</span>
<span class="lineNum">    2703 </span><span class="lineNoCov">          0 :                                     ss-&gt;last-&gt;nonextcp = sp-&gt;noprevcp = false;</span>
<span class="lineNum">    2704 </span><span class="lineNoCov">          0 :                                     initcnt = 0;</span>
<span class="lineNum">    2705 </span><span class="lineNoCov">          0 :                                     SplineMake(ss-&gt;last,sp,true);</span>
<span class="lineNum">    2706 </span>            :                                 }
<span class="lineNum">    2707 </span><span class="lineNoCov">          0 :                                 ss-&gt;last = sp;</span>
<span class="lineNum">    2708 </span>            : #if 1
<span class="lineNum">    2709 </span>            :                                 // We make the point between the previously cached control point and the new control point.
<span class="lineNum">    2710 </span>            :                                 // We have decided that the curve is quadratic, so we can make the next implied point as well.
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :                                 sp = SplinePointCreate((x+pre[1].x)/2,(y+pre[1].y)/2);</span>
<span class="lineNum">    2712 </span><span class="lineNoCov">          0 :                                 sp-&gt;prevcp = pre[1];</span>
<span class="lineNum">    2713 </span><span class="lineNoCov">          0 :                                 sp-&gt;noprevcp = false;</span>
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :                                         sp-&gt;ttfindex = 0xffff;</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :                                 SplineMake(ss-&gt;last,sp,true);</span>
<span class="lineNum">    2716 </span><span class="lineNoCov">          0 :                                 ss-&gt;last = sp;</span>
<span class="lineNum">    2717 </span><span class="lineNoCov">          0 :                                 pre[0].x = x; pre[0].y = y;</span>
<span class="lineNum">    2718 </span><span class="lineNoCov">          0 :                                 precnt = 1;</span>
<span class="lineNum">    2719 </span>            : #else
<span class="lineNum">    2720 </span>            :                                 // Let us instead save the second implied point for later.
<span class="lineNum">    2721 </span>            :                                 pre[0].x = pre[1].x; pre[0].y = pre[1].y;
<span class="lineNum">    2722 </span>            :                                 pre[1].x = x; pre[1].y = y;
<span class="lineNum">    2723 </span>            :                                 precnt = 2;
<span class="lineNum">    2724 </span>            : #endif
<span class="lineNum">    2725 </span><span class="lineNoCov">          0 :                                         wasquad = true;</span>
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :                             } else if ( wasquad==true &amp;&amp; precnt==1) {</span>
<span class="lineNum">    2727 </span>            :                                         // Frank thinks that this might generate false positives for qcurves.
<span class="lineNum">    2728 </span>            :                                         // This seems not to be the best way to handle it, but mixed-order spline sets are rare.
<span class="lineNum">    2729 </span><span class="lineNoCov">          0 :                                         sp = SplinePointCreate((x+pre[0].x)/2,(y+pre[0].y)/2);</span>
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :                                         if (pname != NULL) {</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :                                                 sp-&gt;name = copy(pname);</span>
<span class="lineNum">    2732 </span>            :                                         }
<span class="lineNum">    2733 </span><span class="lineNoCov">          0 :                                 sp-&gt;prevcp = pre[0];</span>
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :                                 sp-&gt;noprevcp = false;</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :                                         sp-&gt;ttfindex = 0xffff;</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :                                 if ( ss-&gt;first==NULL ) {</span>
<span class="lineNum">    2737 </span><span class="lineNoCov">          0 :                                         ss-&gt;first = sp;</span>
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 :                                     memcpy(init,pre,sizeof(pre));</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :                                     initcnt = 1;</span>
<span class="lineNum">    2740 </span>            :                                         } else {
<span class="lineNum">    2741 </span><span class="lineNoCov">          0 :                                             ss-&gt;last-&gt;nextcp = sp-&gt;prevcp;</span>
<span class="lineNum">    2742 </span><span class="lineNoCov">          0 :                                     ss-&gt;last-&gt;nonextcp = false;</span>
<span class="lineNum">    2743 </span><span class="lineNoCov">          0 :                                         SplineMake(ss-&gt;last,sp,true);</span>
<span class="lineNum">    2744 </span>            :                                         }
<span class="lineNum">    2745 </span><span class="lineNoCov">          0 :                                         ss-&gt;last = sp;</span>
<span class="lineNum">    2746 </span><span class="lineNoCov">          0 :                                 pre[0].x = x; pre[0].y = y;</span>
<span class="lineNum">    2747 </span><span class="lineNoCov">          0 :                             } else if ( precnt&lt;2 ) {</span>
<span class="lineNum">    2748 </span><span class="lineNoCov">          0 :                                         pre[precnt].x = x;</span>
<span class="lineNum">    2749 </span><span class="lineNoCov">          0 :                                 pre[precnt].y = y;</span>
<span class="lineNum">    2750 </span><span class="lineNoCov">          0 :                                 ++precnt;</span>
<span class="lineNum">    2751 </span>            :                             }
<span class="lineNum">    2752 </span>            :                         }
<span class="lineNum">    2753 </span><span class="lineNoCov">          0 :                         if (xs != NULL) { free(xs); xs = NULL; }</span>
<span class="lineNum">    2754 </span><span class="lineNoCov">          0 :                         if (ys != NULL) { free(ys); ys = NULL; }</span>
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :                         if (type != NULL) { free(type); type = NULL; }</span>
<span class="lineNum">    2756 </span><span class="lineNoCov">          0 :                         if (pname != NULL) { free(pname); pname = NULL; }</span>
<span class="lineNum">    2757 </span>            :                     }
<span class="lineNum">    2758 </span>            :                     // We are finished looping, so it's time to close the curve if it is to be closed.
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :                     if ( !open &amp;&amp; ss-&gt;first != NULL ) {</span>
<span class="lineNum">    2760 </span><span class="lineNoCov">          0 :                         ss-&gt;start_offset = -initcnt;</span>
<span class="lineNum">    2761 </span>            :                         // init has a list of control points leading into the first point. pre has a list of control points trailing the last processed on-curve point.
<span class="lineNum">    2762 </span>            :                         // We merge pre into init and use init as the list of control points between the last processed on-curve point and the first on-curve point.
<span class="lineNum">    2763 </span><span class="lineNoCov">          0 :                         if ( precnt!=0 ) {</span>
<span class="lineNum">    2764 </span>            :                             BasePoint temp[2];
<span class="lineNum">    2765 </span><span class="lineNoCov">          0 :                             memcpy(temp,init,sizeof(temp));</span>
<span class="lineNum">    2766 </span><span class="lineNoCov">          0 :                             memcpy(init,pre,sizeof(pre));</span>
<span class="lineNum">    2767 </span><span class="lineNoCov">          0 :                             memcpy(init+precnt,temp,sizeof(temp));</span>
<span class="lineNum">    2768 </span><span class="lineNoCov">          0 :                             initcnt += precnt;</span>
<span class="lineNum">    2769 </span>            :                         }
<span class="lineNum">    2770 </span><span class="lineNoCov">          0 :                         if ( ((firstpointsaidquad==true || (firstpointsaidquad == -1 &amp;&amp; wasquad == true)) &amp;&amp; initcnt&gt;0) || initcnt==1 ) {</span>
<span class="lineNum">    2771 </span>            :                                 // If the final curve is declared quadratic or is assumed to be by control point count, we proceed accordingly.
<span class="lineNum">    2772 </span>            :                             int i;
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :                             for ( i=0; i&lt;initcnt-1; ++i ) {</span>
<span class="lineNum">    2774 </span>            :                                         // If the final curve is declared quadratic but has more than one control point, we add implied points.
<span class="lineNum">    2775 </span><span class="lineNoCov">          0 :                                         sp = SplinePointCreate((init[i+1].x+init[i].x)/2,(init[i+1].y+init[i].y)/2);</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :                                 sp-&gt;prevcp = ss-&gt;last-&gt;nextcp = init[i];</span>
<span class="lineNum">    2777 </span><span class="lineNoCov">          0 :                                 sp-&gt;noprevcp = ss-&gt;last-&gt;nonextcp = false;</span>
<span class="lineNum">    2778 </span><span class="lineNoCov">          0 :                                         sp-&gt;ttfindex = 0xffff;</span>
<span class="lineNum">    2779 </span><span class="lineNoCov">          0 :                                 SplineMake(ss-&gt;last,sp,true);</span>
<span class="lineNum">    2780 </span><span class="lineNoCov">          0 :                                 ss-&gt;last = sp;</span>
<span class="lineNum">    2781 </span>            :                             }
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :                             ss-&gt;last-&gt;nextcp = ss-&gt;first-&gt;prevcp = init[initcnt-1];</span>
<span class="lineNum">    2783 </span><span class="lineNoCov">          0 :                             ss-&gt;last-&gt;nonextcp = ss-&gt;first-&gt;noprevcp = false;</span>
<span class="lineNum">    2784 </span><span class="lineNoCov">          0 :                             wasquad = true;</span>
<span class="lineNum">    2785 </span><span class="lineNoCov">          0 :                         } else if ( initcnt==2 ) {</span>
<span class="lineNum">    2786 </span><span class="lineNoCov">          0 :                             ss-&gt;last-&gt;nextcp = init[0];</span>
<span class="lineNum">    2787 </span><span class="lineNoCov">          0 :                             ss-&gt;first-&gt;prevcp = init[1];</span>
<span class="lineNum">    2788 </span><span class="lineNoCov">          0 :                             ss-&gt;last-&gt;nonextcp = ss-&gt;first-&gt;noprevcp = false;</span>
<span class="lineNum">    2789 </span><span class="lineNoCov">          0 :                                 wasquad = false;</span>
<span class="lineNum">    2790 </span>            :                         }
<span class="lineNum">    2791 </span><span class="lineNoCov">          0 :                         SplineMake(ss-&gt;last, ss-&gt;first, (firstpointsaidquad==true || (firstpointsaidquad == -1 &amp;&amp; wasquad == true)));</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :                         ss-&gt;last = ss-&gt;first;</span>
<span class="lineNum">    2793 </span>            :                     }
<span class="lineNum">    2794 </span><span class="lineNoCov">          0 :                     if (ss-&gt;first == NULL) {</span>
<span class="lineNum">    2795 </span><span class="lineNoCov">          0 :                                 LogError(_(&quot;This spline set has no points.\n&quot;));</span>
<span class="lineNum">    2796 </span><span class="lineNoCov">          0 :                                 SplinePointListFree(ss); ss = NULL;</span>
<span class="lineNum">    2797 </span>            :                     } else {
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :                         if ( last==NULL ) {</span>
<span class="lineNum">    2799 </span>            :                                 // If there are no existing spline sets, we point the main spline reference to this set.
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :                                 sc-&gt;layers[layerdest].splines = ss;</span>
<span class="lineNum">    2801 </span>            :                         } else {
<span class="lineNum">    2802 </span>            :                                 // If there are existing spline sets, we attach to the last one.
<span class="lineNum">    2803 </span><span class="lineNoCov">          0 :                                 last-&gt;next = ss;</span>
<span class="lineNum">    2804 </span>            :                         }
<span class="lineNum">    2805 </span><span class="lineNoCov">          0 :                                 last = ss;</span>
<span class="lineNum">    2806 </span>            :                     }
<span class="lineNum">    2807 </span>            :                     }
<span class="lineNum">    2808 </span>            :             }
<span class="lineNum">    2809 </span><span class="lineNoCov">          0 :         } else if ( xmlStrcmp(kids-&gt;name,(const xmlChar *) &quot;lib&quot;)==0 ) {</span>
<span class="lineNum">    2810 </span><span class="lineNoCov">          0 :             xmlNodePtr keys, temp, dict = FindNode(kids-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    2811 </span><span class="lineNoCov">          0 :             if ( dict!=NULL ) {</span>
<span class="lineNum">    2812 </span><span class="lineNoCov">          0 :                 for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    2813 </span><span class="lineNoCov">          0 :                     if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)== 0 ) {</span>
<span class="lineNum">    2814 </span><span class="lineNoCov">          0 :                                 char *keyname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    2815 </span><span class="lineNoCov">          0 :                                 if ( strcmp(keyname,&quot;com.fontlab.hintData&quot;)==0 ) {</span>
<span class="lineNum">    2816 </span><span class="lineNoCov">          0 :                                 for ( temp=keys-&gt;next; temp!=NULL; temp=temp-&gt;next ) {</span>
<span class="lineNum">    2817 </span><span class="lineNoCov">          0 :                                                 if ( xmlStrcmp(temp-&gt;name,(const xmlChar *) &quot;dict&quot;)==0 )</span>
<span class="lineNum">    2818 </span><span class="lineNoCov">          0 :                                                     break;</span>
<span class="lineNum">    2819 </span>            :                                 }
<span class="lineNum">    2820 </span><span class="lineNoCov">          0 :                                 if ( temp!=NULL ) {</span>
<span class="lineNum">    2821 </span><span class="lineNoCov">          0 :                                                 if (layerdest == ly_fore) {</span>
<span class="lineNum">    2822 </span><span class="lineNoCov">          0 :                                                         if (sc-&gt;hstem == NULL) {</span>
<span class="lineNum">    2823 </span><span class="lineNoCov">          0 :                                                                 sc-&gt;hstem = GlifParseHints(doc,temp,&quot;hhints&quot;);</span>
<span class="lineNum">    2824 </span><span class="lineNoCov">          0 :                                                                 SCGuessHHintInstancesList(sc,ly_fore);</span>
<span class="lineNum">    2825 </span>            :                                                         }
<span class="lineNum">    2826 </span><span class="lineNoCov">          0 :                                                         if (sc-&gt;vstem == NULL) {</span>
<span class="lineNum">    2827 </span><span class="lineNoCov">          0 :                                                                 sc-&gt;vstem = GlifParseHints(doc,temp,&quot;vhints&quot;);</span>
<span class="lineNum">    2828 </span><span class="lineNoCov">          0 :                                                         SCGuessVHintInstancesList(sc,ly_fore);</span>
<span class="lineNum">    2829 </span>            :                                                 }
<span class="lineNum">    2830 </span>            :                                                 }
<span class="lineNum">    2831 </span>            :                                 }
<span class="lineNum">    2832 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    2833 </span>            :                                 }
<span class="lineNum">    2834 </span><span class="lineNoCov">          0 :                                 free(keyname);</span>
<span class="lineNum">    2835 </span>            :                     }
<span class="lineNum">    2836 </span>            :                 }
<span class="lineNum">    2837 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">    2838 </span><span class="lineNoCov">          0 :                 if (sc-&gt;layers[layerdest].python_persistent == NULL) {</span>
<span class="lineNum">    2839 </span><span class="lineNoCov">          0 :                   sc-&gt;layers[layerdest].python_persistent = LibToPython(doc,dict,1);</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :                   sc-&gt;layers[layerdest].python_persistent_has_lists = 1;</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :                 } else LogError(_(&quot;Duplicate lib data.\n&quot;));</span>
<span class="lineNum">    2842 </span>            : #endif
<span class="lineNum">    2843 </span>            :             }
<span class="lineNum">    2844 </span>            :         }
<span class="lineNum">    2845 </span>            :     }
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc);</span>
<span class="lineNum">    2847 </span><span class="lineNoCov">          0 :     SPLCategorizePointsKeepCorners(sc-&gt;layers[layerdest].splines);</span>
<span class="lineNum">    2848 </span><span class="lineNoCov">          0 : return( sc );</span>
<a name="2849"><span class="lineNum">    2849 </span>            : }</a>
<span class="lineNum">    2850 </span>            : 
<span class="lineNum">    2851 </span><span class="lineNoCov">          0 : static SplineChar *UFOLoadGlyph(SplineFont *sf,char *glifname, char* glyphname, SplineChar* existingglyph, int layerdest) {</span>
<span class="lineNum">    2852 </span>            :     xmlDocPtr doc;
<span class="lineNum">    2853 </span>            : 
<span class="lineNum">    2854 </span><span class="lineNoCov">          0 :     doc = xmlParseFile(glifname);</span>
<span class="lineNum">    2855 </span><span class="lineNoCov">          0 :     if ( doc==NULL ) {</span>
<span class="lineNum">    2856 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Bad glif file %s&quot;), glifname);</span>
<span class="lineNum">    2857 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    2858 </span>            :     }
<span class="lineNum">    2859 </span><span class="lineNoCov">          0 : return( _UFOLoadGlyph(sf,doc,glifname,glyphname,existingglyph,layerdest));</span>
<span class="lineNum">    2860 </span>            : }
<a name="2861"><span class="lineNum">    2861 </span>            : </a>
<span class="lineNum">    2862 </span>            : 
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 : static void UFORefFixup(SplineFont *sf, SplineChar *sc, int layer ) {</span>
<span class="lineNum">    2864 </span>            :     RefChar *r, *prev;
<span class="lineNum">    2865 </span>            :     SplineChar *rsc;
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :     if ( sc==NULL || sc-&gt;ticked )</span>
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :     sc-&gt;ticked = true;</span>
<span class="lineNum">    2870 </span><span class="lineNoCov">          0 :     prev = NULL;</span>
<span class="lineNum">    2871 </span>            :         // For each reference, attempt to locate the real splinechar matching the name stored in the fake splinechar.
<span class="lineNum">    2872 </span>            :         // Free the fake splinechar afterwards.
<span class="lineNum">    2873 </span><span class="lineNoCov">          0 :     r=sc-&gt;layers[layer].refs;</span>
<span class="lineNum">    2874 </span><span class="lineNoCov">          0 :     while ( r!=NULL ) {</span>
<span class="lineNum">    2875 </span><span class="lineNoCov">          0 :                 if (r-&gt;sc-&gt;name == NULL || strcmp(r-&gt;sc-&gt;name, &quot;&quot;) == 0) {</span>
<span class="lineNum">    2876 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;There's a reference to a glyph with no name.&quot;));</span>
<span class="lineNum">    2877 </span><span class="lineNoCov">          0 :                         prev = r; r = r-&gt;next; continue;</span>
<span class="lineNum">    2878 </span>            :                 }
<span class="lineNum">    2879 </span><span class="lineNoCov">          0 :                 if (r-&gt;sc-&gt;ticked) {</span>
<span class="lineNum">    2880 </span>            :                   // We've already fixed this one.
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :                   prev = r; r = r-&gt;next; continue;</span>
<span class="lineNum">    2882 </span>            :                 }
<span class="lineNum">    2883 </span><span class="lineNoCov">          0 :                 rsc = SFGetChar(sf,-1, r-&gt;sc-&gt;name);</span>
<span class="lineNum">    2884 </span><span class="lineNoCov">          0 :                 if ( rsc==NULL || rsc-&gt;name == NULL || strcmp(rsc-&gt;name,&quot;&quot;) == 0 ) {</span>
<span class="lineNum">    2885 </span><span class="lineNoCov">          0 :                         if (rsc != NULL) {</span>
<span class="lineNum">    2886 </span><span class="lineNoCov">          0 :                           LogError(_(&quot;Invalid glyph for %s when fixing up references.&quot;), r-&gt;sc-&gt;name);</span>
<span class="lineNum">    2887 </span>            :                         } else
<span class="lineNum">    2888 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;Failed to find glyph %s when fixing up references.&quot;), r-&gt;sc-&gt;name);</span>
<span class="lineNum">    2889 </span><span class="lineNoCov">          0 :                         SplineCharFree(r-&gt;sc); // Delete the fake glyph.</span>
<span class="lineNum">    2890 </span><span class="lineNoCov">          0 :                         r-&gt;sc = NULL;</span>
<span class="lineNum">    2891 </span>            :                         // Elide r from the list and free it.
<span class="lineNum">    2892 </span><span class="lineNoCov">          0 :                         if ( prev==NULL ) sc-&gt;layers[layer].refs = r-&gt;next;</span>
<span class="lineNum">    2893 </span><span class="lineNoCov">          0 :                         else prev-&gt;next = r-&gt;next;</span>
<span class="lineNum">    2894 </span><span class="lineNoCov">          0 :                         RefCharFree(r);</span>
<span class="lineNum">    2895 </span><span class="lineNoCov">          0 :                         if ( prev==NULL ) r = sc-&gt;layers[layer].refs;</span>
<span class="lineNum">    2896 </span><span class="lineNoCov">          0 :                         else r = prev-&gt;next;</span>
<span class="lineNum">    2897 </span>            :                 } else {
<span class="lineNum">    2898 </span><span class="lineNoCov">          0 :                         UFORefFixup(sf,rsc, layer);</span>
<span class="lineNum">    2899 </span><span class="lineNoCov">          0 :                         if (r-&gt;sc-&gt;layer_cnt &gt; 0) {</span>
<span class="lineNum">    2900 </span><span class="lineNoCov">          0 :                           fprintf(stderr, &quot;Danger!\n&quot;);</span>
<span class="lineNum">    2901 </span>            :                         }
<span class="lineNum">    2902 </span><span class="lineNoCov">          0 :                         SplineCharFree(r-&gt;sc);</span>
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :                         r-&gt;sc = rsc;</span>
<span class="lineNum">    2904 </span><span class="lineNoCov">          0 :                         SCReinstanciateRefChar(sc,r,layer);</span>
<span class="lineNum">    2905 </span><span class="lineNoCov">          0 :                         prev = r; r = r-&gt;next;</span>
<span class="lineNum">    2906 </span>            :                 }
<span class="lineNum">    2907 </span>            :     }
<a name="2908"><span class="lineNum">    2908 </span>            : }</a>
<span class="lineNum">    2909 </span>            : 
<span class="lineNum">    2910 </span><span class="lineNoCov">          0 : static void UFOLoadGlyphs(SplineFont *sf,char *glyphdir, int layerdest) {</span>
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :     char *glyphlist = buildname(glyphdir,&quot;contents.plist&quot;);</span>
<span class="lineNum">    2912 </span>            :     xmlDocPtr doc;
<span class="lineNum">    2913 </span>            :     xmlNodePtr plist, dict, keys, value;
<span class="lineNum">    2914 </span>            :     char *valname, *glyphfname;
<span class="lineNum">    2915 </span>            :     int i;
<span class="lineNum">    2916 </span>            :     SplineChar *sc;
<span class="lineNum">    2917 </span>            :     int tot;
<span class="lineNum">    2918 </span>            : 
<span class="lineNum">    2919 </span><span class="lineNoCov">          0 :     doc = xmlParseFile(glyphlist);</span>
<span class="lineNum">    2920 </span><span class="lineNoCov">          0 :     free(glyphlist);</span>
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :     if ( doc==NULL ) {</span>
<span class="lineNum">    2922 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Bad contents.plist&quot;));</span>
<span class="lineNum">    2923 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    2924 </span>            :     }
<span class="lineNum">    2925 </span><span class="lineNoCov">          0 :     plist = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    2926 </span><span class="lineNoCov">          0 :     dict = FindNode(plist-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    2927 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(plist-&gt;name,(const xmlChar *) &quot;plist&quot;)!=0 || dict == NULL ) {</span>
<span class="lineNum">    2928 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Expected property list file&quot;));</span>
<span class="lineNum">    2929 </span><span class="lineNoCov">          0 :         xmlFreeDoc(doc);</span>
<span class="lineNum">    2930 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    2931 </span>            :     }
<span class="lineNum">    2932 </span>            :         // Count glyphs for the benefit of measuring progress.
<span class="lineNum">    2933 </span><span class="lineNoCov">          0 :     for ( tot=0, keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    2934 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 )</span>
<span class="lineNum">    2935 </span><span class="lineNoCov">          0 :                     ++tot;</span>
<span class="lineNum">    2936 </span>            :     }
<span class="lineNum">    2937 </span><span class="lineNoCov">          0 :     ff_progress_change_total(tot);</span>
<span class="lineNum">    2938 </span>            :         // Start reading in glyph name to file name mappings.
<span class="lineNum">    2939 </span><span class="lineNoCov">          0 :     for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    2940 </span><span class="lineNoCov">          0 :                 for ( value = keys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    2941 </span><span class="lineNoCov">          0 :                         value = value-&gt;next );</span>
<span class="lineNum">    2942 </span><span class="lineNoCov">          0 :                 if ( value==NULL )</span>
<span class="lineNum">    2943 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    2945 </span><span class="lineNoCov">          0 :                         char * glyphname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :                         int newsc = 0;</span>
<span class="lineNum">    2947 </span><span class="lineNoCov">          0 :                         SplineChar* existingglyph = NULL;</span>
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :                         if (glyphname != NULL) {</span>
<span class="lineNum">    2949 </span><span class="lineNoCov">          0 :                                 existingglyph = SFGetChar(sf,-1,glyphname);</span>
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :                                 if (existingglyph == NULL) newsc = 1;</span>
<span class="lineNum">    2951 </span><span class="lineNoCov">          0 :                                 valname = (char *) xmlNodeListGetString(doc,value-&gt;children,true);</span>
<span class="lineNum">    2952 </span><span class="lineNoCov">          0 :                                 glyphfname = buildname(glyphdir,valname);</span>
<span class="lineNum">    2953 </span><span class="lineNoCov">          0 :                                 sc = UFOLoadGlyph(sf, glyphfname, glyphname, existingglyph, layerdest);</span>
<span class="lineNum">    2954 </span>            :                                 // We want to stash the glif name (minus the extension) for future use.
<span class="lineNum">    2955 </span><span class="lineNoCov">          0 :                                 if (sc != NULL &amp;&amp; sc-&gt;glif_name == NULL &amp;&amp; valname != NULL) {</span>
<span class="lineNum">    2956 </span><span class="lineNoCov">          0 :                                   char * tmppos = strrchr(valname, '.'); if (tmppos) *tmppos = '\0';</span>
<span class="lineNum">    2957 </span><span class="lineNoCov">          0 :                                   sc-&gt;glif_name = copy(valname);</span>
<span class="lineNum">    2958 </span><span class="lineNoCov">          0 :                                   if (tmppos) *tmppos = '.';</span>
<span class="lineNum">    2959 </span>            :                                 }
<span class="lineNum">    2960 </span><span class="lineNoCov">          0 :                                 free(valname);</span>
<span class="lineNum">    2961 </span><span class="lineNoCov">          0 :                                 if ( ( sc!=NULL ) &amp;&amp; newsc ) {</span>
<span class="lineNum">    2962 </span><span class="lineNoCov">          0 :                                         sc-&gt;parent = sf;</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :                                         if ( sf-&gt;glyphcnt&gt;=sf-&gt;glyphmax )</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :                                                 sf-&gt;glyphs = realloc(sf-&gt;glyphs,(sf-&gt;glyphmax+=100)*sizeof(SplineChar *));</span>
<span class="lineNum">    2965 </span><span class="lineNoCov">          0 :                                         sc-&gt;orig_pos = sf-&gt;glyphcnt;</span>
<span class="lineNum">    2966 </span><span class="lineNoCov">          0 :                                         sf-&gt;glyphs[sf-&gt;glyphcnt++] = sc;</span>
<span class="lineNum">    2967 </span>            :                                 }
<span class="lineNum">    2968 </span>            :                         }
<span class="lineNum">    2969 </span><span class="lineNoCov">          0 :                         keys = value;</span>
<span class="lineNum">    2970 </span><span class="lineNoCov">          0 :                         ff_progress_next();</span>
<span class="lineNum">    2971 </span>            :                 }
<span class="lineNum">    2972 </span>            :     }
<span class="lineNum">    2973 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc);</span>
<span class="lineNum">    2974 </span>            : 
<span class="lineNum">    2975 </span><span class="lineNoCov">          0 :     GlyphHashFree(sf);</span>
<span class="lineNum">    2976 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;sf-&gt;glyphcnt; ++i )</span>
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 :         UFORefFixup(sf,sf-&gt;glyphs[i], layerdest);</span>
<a name="2978"><span class="lineNum">    2978 </span>            : }</a>
<span class="lineNum">    2979 </span>            : 
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 : static struct ff_glyphclasses *GlyphGroupDeduplicate(struct ff_glyphclasses *group_base, struct splinefont *sf, int check_kerns) {</span>
<span class="lineNum">    2981 </span>            :   // This removes internal duplicates from the specified group and also, if desired, the groups duplicating entities already named as kerning classes.
<span class="lineNum">    2982 </span>            :   // It takes the list head as its argument and returns the new list head (which may be the same unless the first item duplicates a kerning class).
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :   int temp_index = 0;</span>
<span class="lineNum">    2984 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    2985 </span>            :   struct glif_name_index _group_name_hash;
<span class="lineNum">    2986 </span><span class="lineNoCov">          0 :   struct glif_name_index * group_name_hash = &amp;_group_name_hash; // Open the group hash table.</span>
<span class="lineNum">    2987 </span><span class="lineNoCov">          0 :   memset(group_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    2988 </span>            :   struct glif_name_index _class_name_hash;
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :   struct glif_name_index * class_name_hash = &amp;_class_name_hash; // Open the class hash table.</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :   memset(class_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :   if (check_kerns &amp;&amp; sf) HashKerningClassNames(sf, class_name_hash);</span>
<span class="lineNum">    2992 </span><span class="lineNoCov">          0 :   struct ff_glyphclasses *group_current = group_base;</span>
<span class="lineNum">    2993 </span><span class="lineNoCov">          0 :   struct ff_glyphclasses *group_prev = NULL;</span>
<span class="lineNum">    2994 </span><span class="lineNoCov">          0 :   while (group_current != NULL) {</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :     if (group_current-&gt;classname == NULL || group_current-&gt;classname[0] == '\0' ||</span>
<span class="lineNum">    2996 </span><span class="lineNoCov">          0 :       glif_name_search_glif_name(group_name_hash, group_current-&gt;classname) ||</span>
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :       (check_kerns &amp;&amp; sf &amp;&amp; glif_name_search_glif_name(class_name_hash, group_current-&gt;classname))) {</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :       if (group_prev != NULL) group_prev-&gt;next = group_current-&gt;next;</span>
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :       else group_base = group_current-&gt;next;</span>
<span class="lineNum">    3000 </span><span class="lineNoCov">          0 :       GlyphGroupFree(group_current);</span>
<span class="lineNum">    3001 </span><span class="lineNoCov">          0 :       if (group_prev != NULL) group_current = group_prev-&gt;next;</span>
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :       else group_current = group_base;</span>
<span class="lineNum">    3003 </span>            :     } else {
<span class="lineNum">    3004 </span><span class="lineNoCov">          0 :       glif_name_track_new(group_name_hash, temp_index++, group_current-&gt;classname);</span>
<span class="lineNum">    3005 </span><span class="lineNoCov">          0 :       group_prev = group_current; group_current = group_current-&gt;next;</span>
<span class="lineNum">    3006 </span>            :     }
<span class="lineNum">    3007 </span>            :   }
<span class="lineNum">    3008 </span><span class="lineNoCov">          0 :   glif_name_hash_destroy(class_name_hash);</span>
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :   glif_name_hash_destroy(group_name_hash);</span>
<span class="lineNum">    3010 </span>            : #endif
<span class="lineNum">    3011 </span><span class="lineNoCov">          0 :   return group_base;</span>
<a name="3012"><span class="lineNum">    3012 </span>            : }</a>
<span class="lineNum">    3013 </span>            : 
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 : static uint32 script_from_glyph_list(SplineFont *sf, const char *glyph_names) {</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :   uint32 script = DEFAULT_SCRIPT;</span>
<span class="lineNum">    3016 </span>            :   char *delimited_names;
<span class="lineNum">    3017 </span>            :   off_t name_char_pos;
<span class="lineNum">    3018 </span><span class="lineNoCov">          0 :   name_char_pos = 0;</span>
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 :   delimited_names = delimit_null(glyph_names, ' ');</span>
<span class="lineNum">    3020 </span><span class="lineNoCov">          0 :   while (script == DEFAULT_SCRIPT &amp;&amp; glyph_names[name_char_pos] != '\0') {</span>
<span class="lineNum">    3021 </span><span class="lineNoCov">          0 :     SplineChar *sc = SFGetChar(sf, -1, delimited_names + name_char_pos);</span>
<span class="lineNum">    3022 </span><span class="lineNoCov">          0 :     script = SCScriptFromUnicode(sc);</span>
<span class="lineNum">    3023 </span><span class="lineNoCov">          0 :     name_char_pos += strlen(delimited_names + name_char_pos);</span>
<span class="lineNum">    3024 </span><span class="lineNoCov">          0 :     if (glyph_names[name_char_pos] != '\0') name_char_pos ++;</span>
<span class="lineNum">    3025 </span>            :   }
<span class="lineNum">    3026 </span><span class="lineNoCov">          0 :   free(delimited_names); delimited_names = NULL;</span>
<span class="lineNum">    3027 </span><span class="lineNoCov">          0 :   return script;</span>
<span class="lineNum">    3028 </span>            : }
<span class="lineNum">    3029 </span>            : 
<span class="lineNum">    3030 </span>            : #define GROUP_NAME_KERNING_UFO 1
<span class="lineNum">    3031 </span>            : #define GROUP_NAME_KERNING_FEATURE 2
<span class="lineNum">    3032 </span>            : #define GROUP_NAME_VERTICAL 4 // Otherwise horizontal.
<a name="3033"><span class="lineNum">    3033 </span>            : #define GROUP_NAME_RIGHT 8 // Otherwise left (or above).</a>
<span class="lineNum">    3034 </span>            : 
<span class="lineNum">    3035 </span><span class="lineNoCov">          0 : static void MakeKerningClasses(SplineFont *sf, struct ff_glyphclasses *group_base) {</span>
<span class="lineNum">    3036 </span>            :   // This silently ignores already extant groups for now but avoids duplicates unless group_base has internal duplication.
<span class="lineNum">    3037 </span><span class="lineNoCov">          0 :   int left_count = 0, right_count = 0, above_count = 0, below_count = 0;</span>
<span class="lineNum">    3038 </span><span class="lineNoCov">          0 :   int left_start = 0, right_start = 0, above_start = 0, below_start = 0;</span>
<span class="lineNum">    3039 </span>            : #ifdef FF_UTHASH_GLIF_NAMES
<span class="lineNum">    3040 </span>            :     struct glif_name_index _class_name_hash;
<span class="lineNum">    3041 </span><span class="lineNoCov">          0 :     struct glif_name_index * class_name_hash = &amp;_class_name_hash; // Open the hash table.</span>
<span class="lineNum">    3042 </span><span class="lineNoCov">          0 :     memset(class_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :     HashKerningClassNames(sf, class_name_hash);</span>
<span class="lineNum">    3044 </span>            : #else
<span class="lineNum">    3045 </span>            :     void * class_name_hash = NULL;
<span class="lineNum">    3046 </span>            : #endif
<span class="lineNum">    3047 </span>            :   // It is very difficult to create speculative indices for the unmerged group members during the size calculation.
<span class="lineNum">    3048 </span>            :   // So we expect that the incoming group list has no duplicates (as after a run through GlyphGroupDeduplicate).
<span class="lineNum">    3049 </span>            :   struct ff_glyphclasses *current_group;
<span class="lineNum">    3050 </span><span class="lineNoCov">          0 :   for (current_group = group_base; current_group != NULL; current_group = current_group-&gt;next) {</span>
<span class="lineNum">    3051 </span><span class="lineNoCov">          0 :     int group_type = GroupNameType(current_group-&gt;classname);</span>
<span class="lineNum">    3052 </span><span class="lineNoCov">          0 :     if ((group_type != -1) &amp;&amp; (group_type &amp; (GROUP_NAME_KERNING_UFO|GROUP_NAME_KERNING_FEATURE))) {</span>
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :       if (group_type &amp; GROUP_NAME_VERTICAL) {</span>
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :         if (group_type &amp; GROUP_NAME_RIGHT) {</span>
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :           below_count++;</span>
<span class="lineNum">    3056 </span>            :         } else {
<span class="lineNum">    3057 </span><span class="lineNoCov">          0 :           above_count++;</span>
<span class="lineNum">    3058 </span>            :         }
<span class="lineNum">    3059 </span>            :       } else {
<span class="lineNum">    3060 </span><span class="lineNoCov">          0 :         if (group_type &amp; GROUP_NAME_RIGHT) {</span>
<span class="lineNum">    3061 </span><span class="lineNoCov">          0 :           right_count++;</span>
<span class="lineNum">    3062 </span>            :         } else {
<span class="lineNum">    3063 </span><span class="lineNoCov">          0 :           left_count++;</span>
<span class="lineNum">    3064 </span>            :         }
<span class="lineNum">    3065 </span>            :       }
<span class="lineNum">    3066 </span>            :     }
<span class="lineNum">    3067 </span>            :   }
<span class="lineNum">    3068 </span>            :   // Allocate lookups if needed.
<span class="lineNum">    3069 </span><span class="lineNoCov">          0 :   if (sf-&gt;kerns == NULL &amp;&amp; (left_count || right_count)) {</span>
<span class="lineNum">    3070 </span><span class="lineNoCov">          0 :     sf-&gt;kerns = calloc(1, sizeof(struct kernclass));</span>
<span class="lineNum">    3071 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;subtable = SFSubTableFindOrMake(sf, CHR('k','e','r','n'), DEFAULT_SCRIPT, gpos_pair);</span>
<span class="lineNum">    3072 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;firsts = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3073 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;firsts_names = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;firsts_flags = calloc(1, sizeof(int));</span>
<span class="lineNum">    3075 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;seconds = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3076 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;seconds_names = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;seconds_flags = calloc(1, sizeof(int));</span>
<span class="lineNum">    3078 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;offsets = calloc(1, sizeof(int16));</span>
<span class="lineNum">    3079 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;offsets_flags = calloc(1, sizeof(int));</span>
<span class="lineNum">    3080 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;first_cnt = 1;</span>
<span class="lineNum">    3081 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;second_cnt = 1;</span>
<span class="lineNum">    3082 </span>            :   }
<span class="lineNum">    3083 </span><span class="lineNoCov">          0 :   if (sf-&gt;vkerns == NULL &amp;&amp; (above_count || below_count)) {</span>
<span class="lineNum">    3084 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns = calloc(1, sizeof(struct kernclass));</span>
<span class="lineNum">    3085 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;subtable = SFSubTableFindOrMake(sf, CHR('v','k','r','n'), DEFAULT_SCRIPT, gpos_pair);</span>
<span class="lineNum">    3086 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;firsts = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3087 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;firsts_names = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3088 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;firsts_flags = calloc(1, sizeof(int));</span>
<span class="lineNum">    3089 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;seconds = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3090 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;seconds_names = calloc(1, sizeof(char *));</span>
<span class="lineNum">    3091 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;seconds_flags = calloc(1, sizeof(int));</span>
<span class="lineNum">    3092 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;offsets = calloc(1, sizeof(int16));</span>
<span class="lineNum">    3093 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;offsets_flags = calloc(1, sizeof(int));</span>
<span class="lineNum">    3094 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;first_cnt = 1;</span>
<span class="lineNum">    3095 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;second_cnt = 1;</span>
<span class="lineNum">    3096 </span>            :   }
<span class="lineNum">    3097 </span>            :   // Set starts.
<span class="lineNum">    3098 </span><span class="lineNoCov">          0 :   if (sf-&gt;kerns != NULL) { left_start = sf-&gt;kerns-&gt;first_cnt; right_start = sf-&gt;kerns-&gt;second_cnt; }</span>
<span class="lineNum">    3099 </span><span class="lineNoCov">          0 :   if (sf-&gt;vkerns != NULL) { above_start = sf-&gt;vkerns-&gt;first_cnt; below_start = sf-&gt;vkerns-&gt;second_cnt; }</span>
<span class="lineNum">    3100 </span>            :   // Make space for the new entries.
<span class="lineNum">    3101 </span>            :   // We start by allocating space for the offsets and offsets flags. We then copy the old contents, row-by-row.
<span class="lineNum">    3102 </span><span class="lineNoCov">          0 :   if ((left_count &gt; 0 || right_count &gt; 0) &amp;&amp; ((sf-&gt;kerns-&gt;first_cnt + left_count) * (sf-&gt;kerns-&gt;second_cnt + right_count) &gt; 0)) {</span>
<span class="lineNum">    3103 </span>            :     // Offsets.
<span class="lineNum">    3104 </span><span class="lineNoCov">          0 :     int16 *tmp_offsets = calloc((sf-&gt;kerns-&gt;first_cnt + left_count) * (sf-&gt;kerns-&gt;second_cnt + right_count), sizeof(int16));</span>
<span class="lineNum">    3105 </span><span class="lineNoCov">          0 :     if (sf-&gt;kerns-&gt;offsets) {</span>
<span class="lineNum">    3106 </span>            :       int rowpos;
<span class="lineNum">    3107 </span><span class="lineNoCov">          0 :       for (rowpos = 0; rowpos &lt; sf-&gt;kerns-&gt;first_cnt; rowpos ++) {</span>
<span class="lineNum">    3108 </span><span class="lineNoCov">          0 :         memcpy((void *)tmp_offsets + (rowpos * (sf-&gt;kerns-&gt;second_cnt + right_count)) * sizeof(int16), (void *)(sf-&gt;kerns-&gt;offsets) + (rowpos * sf-&gt;kerns-&gt;second_cnt) * sizeof(int16), sf-&gt;kerns-&gt;second_cnt * sizeof(int16));</span>
<span class="lineNum">    3109 </span>            :       }
<span class="lineNum">    3110 </span><span class="lineNoCov">          0 :       free(sf-&gt;kerns-&gt;offsets);</span>
<span class="lineNum">    3111 </span>            :     }
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;offsets = tmp_offsets;</span>
<span class="lineNum">    3113 </span>            :     // Offset flags.
<span class="lineNum">    3114 </span><span class="lineNoCov">          0 :     int *tmp_offsets_flags = calloc((sf-&gt;kerns-&gt;first_cnt + left_count) * (sf-&gt;kerns-&gt;second_cnt + right_count), sizeof(int));</span>
<span class="lineNum">    3115 </span><span class="lineNoCov">          0 :     if (sf-&gt;kerns-&gt;offsets_flags) {</span>
<span class="lineNum">    3116 </span>            :       int rowpos;
<span class="lineNum">    3117 </span><span class="lineNoCov">          0 :       for (rowpos = 0; rowpos &lt; sf-&gt;kerns-&gt;first_cnt; rowpos ++) {</span>
<span class="lineNum">    3118 </span><span class="lineNoCov">          0 :         memcpy((void *)tmp_offsets_flags + (rowpos * (sf-&gt;kerns-&gt;second_cnt + right_count)) * sizeof(int), (void *)(sf-&gt;kerns-&gt;offsets_flags) + (rowpos * sf-&gt;kerns-&gt;second_cnt) * sizeof(int), sf-&gt;kerns-&gt;second_cnt * sizeof(int));</span>
<span class="lineNum">    3119 </span>            :       }
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :       free(sf-&gt;kerns-&gt;offsets_flags);</span>
<span class="lineNum">    3121 </span>            :     }
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;offsets_flags = tmp_offsets_flags;</span>
<span class="lineNum">    3123 </span>            :     // Adjusts.
<span class="lineNum">    3124 </span><span class="lineNoCov">          0 :     DeviceTable *tmp_adjusts = calloc((sf-&gt;kerns-&gt;first_cnt + left_count) * (sf-&gt;kerns-&gt;second_cnt + right_count), sizeof(DeviceTable));</span>
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :     if (sf-&gt;kerns-&gt;adjusts) {</span>
<span class="lineNum">    3126 </span>            :       int rowpos;
<span class="lineNum">    3127 </span><span class="lineNoCov">          0 :       for (rowpos = 0; rowpos &lt; sf-&gt;kerns-&gt;first_cnt; rowpos ++) {</span>
<span class="lineNum">    3128 </span><span class="lineNoCov">          0 :         memcpy((void *)tmp_adjusts + (rowpos * (sf-&gt;kerns-&gt;second_cnt + right_count)) * sizeof(DeviceTable), (void *)(sf-&gt;kerns-&gt;adjusts) + (rowpos * sf-&gt;kerns-&gt;second_cnt) * sizeof(DeviceTable), sf-&gt;kerns-&gt;second_cnt * sizeof(DeviceTable));</span>
<span class="lineNum">    3129 </span>            :       }
<span class="lineNum">    3130 </span><span class="lineNoCov">          0 :       free(sf-&gt;kerns-&gt;adjusts);</span>
<span class="lineNum">    3131 </span>            :     }
<span class="lineNum">    3132 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;adjusts = tmp_adjusts;</span>
<span class="lineNum">    3133 </span>            :   }
<span class="lineNum">    3134 </span><span class="lineNoCov">          0 :   if ((above_count &gt; 0 || below_count &gt; 0) &amp;&amp; ((sf-&gt;vkerns-&gt;first_cnt + above_count) * (sf-&gt;vkerns-&gt;second_cnt + below_count) &gt; 0)) {</span>
<span class="lineNum">    3135 </span>            :     // Offsets.
<span class="lineNum">    3136 </span><span class="lineNoCov">          0 :     int16 *tmp_offsets = calloc((sf-&gt;vkerns-&gt;first_cnt + above_count) * (sf-&gt;vkerns-&gt;second_cnt + below_count), sizeof(int16));</span>
<span class="lineNum">    3137 </span><span class="lineNoCov">          0 :     if (sf-&gt;vkerns-&gt;offsets) {</span>
<span class="lineNum">    3138 </span>            :       int rowpos;
<span class="lineNum">    3139 </span><span class="lineNoCov">          0 :       for (rowpos = 0; rowpos &lt; sf-&gt;vkerns-&gt;first_cnt; rowpos ++) {</span>
<span class="lineNum">    3140 </span><span class="lineNoCov">          0 :         memcpy((void *)tmp_offsets + (rowpos * (sf-&gt;vkerns-&gt;second_cnt + below_count)) * sizeof(int16), (void *)(sf-&gt;vkerns-&gt;offsets) + (rowpos * sf-&gt;vkerns-&gt;second_cnt) * sizeof(int16), sf-&gt;vkerns-&gt;second_cnt * sizeof(int16));</span>
<span class="lineNum">    3141 </span>            :       }
<span class="lineNum">    3142 </span><span class="lineNoCov">          0 :       free(sf-&gt;vkerns-&gt;offsets);</span>
<span class="lineNum">    3143 </span>            :     }
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;offsets = tmp_offsets;</span>
<span class="lineNum">    3145 </span>            :     // Offset flags.
<span class="lineNum">    3146 </span><span class="lineNoCov">          0 :     int *tmp_offsets_flags = calloc((sf-&gt;vkerns-&gt;first_cnt + above_count) * (sf-&gt;vkerns-&gt;second_cnt + below_count), sizeof(int));</span>
<span class="lineNum">    3147 </span><span class="lineNoCov">          0 :     if (sf-&gt;vkerns-&gt;offsets_flags) {</span>
<span class="lineNum">    3148 </span>            :       int rowpos;
<span class="lineNum">    3149 </span><span class="lineNoCov">          0 :       for (rowpos = 0; rowpos &lt; sf-&gt;vkerns-&gt;first_cnt; rowpos ++) {</span>
<span class="lineNum">    3150 </span><span class="lineNoCov">          0 :         memcpy((void *)tmp_offsets_flags + (rowpos * (sf-&gt;vkerns-&gt;second_cnt + below_count)) * sizeof(int), (void *)(sf-&gt;vkerns-&gt;offsets_flags) + (rowpos * sf-&gt;vkerns-&gt;second_cnt) * sizeof(int), sf-&gt;vkerns-&gt;second_cnt * sizeof(int));</span>
<span class="lineNum">    3151 </span>            :       }
<span class="lineNum">    3152 </span><span class="lineNoCov">          0 :       free(sf-&gt;vkerns-&gt;offsets_flags);</span>
<span class="lineNum">    3153 </span>            :     }
<span class="lineNum">    3154 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;offsets_flags = tmp_offsets_flags;</span>
<span class="lineNum">    3155 </span>            :     // Adjusts.
<span class="lineNum">    3156 </span><span class="lineNoCov">          0 :     DeviceTable *tmp_adjusts = calloc((sf-&gt;vkerns-&gt;first_cnt + above_count) * (sf-&gt;vkerns-&gt;second_cnt + below_count), sizeof(DeviceTable));</span>
<span class="lineNum">    3157 </span><span class="lineNoCov">          0 :     if (sf-&gt;vkerns-&gt;adjusts) {</span>
<span class="lineNum">    3158 </span>            :       int rowpos;
<span class="lineNum">    3159 </span><span class="lineNoCov">          0 :       for (rowpos = 0; rowpos &lt; sf-&gt;vkerns-&gt;first_cnt; rowpos ++) {</span>
<span class="lineNum">    3160 </span><span class="lineNoCov">          0 :         memcpy((void *)tmp_adjusts + (rowpos * (sf-&gt;vkerns-&gt;second_cnt + above_count)) * sizeof(DeviceTable), (void *)(sf-&gt;vkerns-&gt;adjusts) + (rowpos * sf-&gt;vkerns-&gt;second_cnt) * sizeof(DeviceTable), sf-&gt;vkerns-&gt;second_cnt * sizeof(DeviceTable));</span>
<span class="lineNum">    3161 </span>            :       }
<span class="lineNum">    3162 </span><span class="lineNoCov">          0 :       free(sf-&gt;vkerns-&gt;adjusts);</span>
<span class="lineNum">    3163 </span>            :     }
<span class="lineNum">    3164 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;adjusts = tmp_adjusts;</span>
<span class="lineNum">    3165 </span>            :   }
<span class="lineNum">    3166 </span>            :   // Since the linear data need no repositioning, we can just use realloc. But it's important that we zero the new space in case it does not get filled.
<span class="lineNum">    3167 </span><span class="lineNoCov">          0 :   if (left_count &gt; 0) {</span>
<span class="lineNum">    3168 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;firsts = realloc(sf-&gt;kerns-&gt;firsts, sizeof(char *) * (sf-&gt;kerns-&gt;first_cnt + left_count));</span>
<span class="lineNum">    3169 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;kerns-&gt;firsts + sf-&gt;kerns-&gt;first_cnt * sizeof(char *), 0, left_count * sizeof(char *));</span>
<span class="lineNum">    3170 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;firsts_names = realloc(sf-&gt;kerns-&gt;firsts_names, sizeof(char *) * (sf-&gt;kerns-&gt;first_cnt + left_count));</span>
<span class="lineNum">    3171 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;kerns-&gt;firsts_names + sf-&gt;kerns-&gt;first_cnt * sizeof(char *), 0, left_count * sizeof(char *));</span>
<span class="lineNum">    3172 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;firsts_flags = realloc(sf-&gt;kerns-&gt;firsts_flags, sizeof(int) * (sf-&gt;kerns-&gt;first_cnt + left_count));</span>
<span class="lineNum">    3173 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;kerns-&gt;firsts_flags + sf-&gt;kerns-&gt;first_cnt * sizeof(int), 0, left_count * sizeof(int));</span>
<span class="lineNum">    3174 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;first_cnt += left_count;</span>
<span class="lineNum">    3175 </span>            :   }
<span class="lineNum">    3176 </span><span class="lineNoCov">          0 :   if (right_count &gt; 0) {</span>
<span class="lineNum">    3177 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;seconds = realloc(sf-&gt;kerns-&gt;seconds, sizeof(char *) * (sf-&gt;kerns-&gt;second_cnt + right_count));</span>
<span class="lineNum">    3178 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;kerns-&gt;seconds + sf-&gt;kerns-&gt;second_cnt * sizeof(char *), 0, right_count * sizeof(char *));</span>
<span class="lineNum">    3179 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;seconds_names = realloc(sf-&gt;kerns-&gt;seconds_names, sizeof(char *) * (sf-&gt;kerns-&gt;second_cnt + right_count));</span>
<span class="lineNum">    3180 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;kerns-&gt;seconds_names + sf-&gt;kerns-&gt;second_cnt * sizeof(char *), 0, right_count * sizeof(char *));</span>
<span class="lineNum">    3181 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;seconds_flags = realloc(sf-&gt;kerns-&gt;seconds_flags, sizeof(int) * (sf-&gt;kerns-&gt;second_cnt + right_count));</span>
<span class="lineNum">    3182 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;kerns-&gt;seconds_flags + sf-&gt;kerns-&gt;second_cnt * sizeof(int), 0, right_count * sizeof(int));</span>
<span class="lineNum">    3183 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;second_cnt += right_count;</span>
<span class="lineNum">    3184 </span>            :   }
<span class="lineNum">    3185 </span><span class="lineNoCov">          0 :   if (above_count &gt; 0) {</span>
<span class="lineNum">    3186 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;firsts = realloc(sf-&gt;vkerns-&gt;firsts, sizeof(char *) * (sf-&gt;vkerns-&gt;first_cnt + above_count));</span>
<span class="lineNum">    3187 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;vkerns-&gt;firsts + sf-&gt;vkerns-&gt;first_cnt * sizeof(char *), 0, above_count * sizeof(char *));</span>
<span class="lineNum">    3188 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;firsts_names = realloc(sf-&gt;vkerns-&gt;firsts_names, sizeof(char *) * (sf-&gt;vkerns-&gt;first_cnt + above_count));</span>
<span class="lineNum">    3189 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;vkerns-&gt;firsts_names + sf-&gt;vkerns-&gt;first_cnt * sizeof(char *), 0, above_count * sizeof(char *));</span>
<span class="lineNum">    3190 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;firsts_flags = realloc(sf-&gt;vkerns-&gt;firsts_flags, sizeof(int) * (sf-&gt;vkerns-&gt;first_cnt + above_count));</span>
<span class="lineNum">    3191 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;vkerns-&gt;firsts_flags + sf-&gt;vkerns-&gt;first_cnt * sizeof(int), 0, above_count * sizeof(int));</span>
<span class="lineNum">    3192 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;first_cnt += above_count;</span>
<span class="lineNum">    3193 </span>            :   }
<span class="lineNum">    3194 </span><span class="lineNoCov">          0 :   if (below_count &gt; 0) {</span>
<span class="lineNum">    3195 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;seconds = realloc(sf-&gt;vkerns-&gt;seconds, sizeof(char *) * (sf-&gt;vkerns-&gt;second_cnt + below_count));</span>
<span class="lineNum">    3196 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;vkerns-&gt;seconds + sf-&gt;vkerns-&gt;second_cnt * sizeof(char *), 0, below_count * sizeof(char *));</span>
<span class="lineNum">    3197 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;seconds_names = realloc(sf-&gt;vkerns-&gt;seconds_names, sizeof(char *) * (sf-&gt;vkerns-&gt;second_cnt + below_count));</span>
<span class="lineNum">    3198 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;vkerns-&gt;seconds_names + sf-&gt;vkerns-&gt;second_cnt * sizeof(char *), 0, below_count * sizeof(char *));</span>
<span class="lineNum">    3199 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;seconds_flags = realloc(sf-&gt;vkerns-&gt;seconds_flags, sizeof(int) * (sf-&gt;vkerns-&gt;second_cnt + below_count));</span>
<span class="lineNum">    3200 </span><span class="lineNoCov">          0 :     memset((void*)sf-&gt;vkerns-&gt;seconds_flags + sf-&gt;vkerns-&gt;second_cnt * sizeof(char *), 0, below_count * sizeof(int));</span>
<span class="lineNum">    3201 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;second_cnt += below_count;</span>
<span class="lineNum">    3202 </span>            :   }
<span class="lineNum">    3203 </span>            :   // Start copying.
<span class="lineNum">    3204 </span><span class="lineNoCov">          0 :   left_count = 0; right_count = 0; above_count = 0; below_count = 0;</span>
<span class="lineNum">    3205 </span><span class="lineNoCov">          0 :   for (current_group = group_base; current_group != NULL; current_group = current_group-&gt;next) {</span>
<span class="lineNum">    3206 </span><span class="lineNoCov">          0 :     int group_type = GroupNameType(current_group-&gt;classname);</span>
<span class="lineNum">    3207 </span>            :     // This function only gets used in processing groups.plist right now, so it assumes that the groups are native as below.
<span class="lineNum">    3208 </span><span class="lineNoCov">          0 :     if ((group_type != -1) &amp;&amp; (group_type &amp; (GROUP_NAME_KERNING_UFO|GROUP_NAME_KERNING_FEATURE))) {</span>
<span class="lineNum">    3209 </span><span class="lineNoCov">          0 :       if (group_type &amp; GROUP_NAME_VERTICAL) {</span>
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 :         if (group_type &amp; GROUP_NAME_RIGHT) {</span>
<span class="lineNum">    3211 </span><span class="lineNoCov">          0 :           sf-&gt;vkerns-&gt;seconds[below_start + below_count] = copy(current_group-&gt;glyphs);</span>
<span class="lineNum">    3212 </span><span class="lineNoCov">          0 :           sf-&gt;vkerns-&gt;seconds_names[below_start + below_count] = copy(current_group-&gt;classname);</span>
<span class="lineNum">    3213 </span><span class="lineNoCov">          0 :           sf-&gt;vkerns-&gt;seconds_flags[below_start + below_count] = FF_KERNCLASS_FLAG_NATIVE | ((group_type &amp; GROUP_NAME_KERNING_FEATURE) ? FF_KERNCLASS_FLAG_NAMETYPE : 0);</span>
<span class="lineNum">    3214 </span><span class="lineNoCov">          0 :           below_count++;</span>
<span class="lineNum">    3215 </span>            :         } else {
<span class="lineNum">    3216 </span><span class="lineNoCov">          0 :           sf-&gt;vkerns-&gt;firsts[above_start + above_count] = copy(current_group-&gt;glyphs);</span>
<span class="lineNum">    3217 </span><span class="lineNoCov">          0 :           sf-&gt;vkerns-&gt;firsts_names[above_start + above_count] = copy(current_group-&gt;classname);</span>
<span class="lineNum">    3218 </span><span class="lineNoCov">          0 :           sf-&gt;vkerns-&gt;firsts_flags[above_start + above_count] = FF_KERNCLASS_FLAG_NATIVE | ((group_type &amp; GROUP_NAME_KERNING_FEATURE) ? FF_KERNCLASS_FLAG_NAMETYPE : 0);</span>
<span class="lineNum">    3219 </span><span class="lineNoCov">          0 :           above_count++;</span>
<span class="lineNum">    3220 </span>            :         }
<span class="lineNum">    3221 </span>            :       } else {
<span class="lineNum">    3222 </span><span class="lineNoCov">          0 :         if (group_type &amp; GROUP_NAME_RIGHT) {</span>
<span class="lineNum">    3223 </span><span class="lineNoCov">          0 :           sf-&gt;kerns-&gt;seconds[right_start + right_count] = copy(current_group-&gt;glyphs);</span>
<span class="lineNum">    3224 </span><span class="lineNoCov">          0 :           sf-&gt;kerns-&gt;seconds_names[right_start + right_count] = copy(current_group-&gt;classname);</span>
<span class="lineNum">    3225 </span><span class="lineNoCov">          0 :           sf-&gt;kerns-&gt;seconds_flags[right_start + right_count] = FF_KERNCLASS_FLAG_NATIVE | ((group_type &amp; GROUP_NAME_KERNING_FEATURE) ? FF_KERNCLASS_FLAG_NAMETYPE : 0);</span>
<span class="lineNum">    3226 </span><span class="lineNoCov">          0 :           right_count++;</span>
<span class="lineNum">    3227 </span>            :         } else {
<span class="lineNum">    3228 </span><span class="lineNoCov">          0 :           sf-&gt;kerns-&gt;firsts[left_start + left_count] = copy(current_group-&gt;glyphs);</span>
<span class="lineNum">    3229 </span><span class="lineNoCov">          0 :           sf-&gt;kerns-&gt;firsts_names[left_start + left_count] = copy(current_group-&gt;classname);</span>
<span class="lineNum">    3230 </span><span class="lineNoCov">          0 :           sf-&gt;kerns-&gt;firsts_flags[left_start + left_count] = FF_KERNCLASS_FLAG_NATIVE | ((group_type &amp; GROUP_NAME_KERNING_FEATURE) ? FF_KERNCLASS_FLAG_NAMETYPE : 0);</span>
<span class="lineNum">    3231 </span><span class="lineNoCov">          0 :           left_count++;</span>
<span class="lineNum">    3232 </span>            :         }
<span class="lineNum">    3233 </span>            :       }
<span class="lineNum">    3234 </span>            :     }
<span class="lineNum">    3235 </span>            :   }
<span class="lineNum">    3236 </span>            : #ifdef UFO_GUESS_SCRIPTS
<span class="lineNum">    3237 </span>            :   // Check the script in each element of each group (for each polarity) until a character is of a script other than DFLT.
<span class="lineNum">    3238 </span>            :   if (sf-&gt;kerns != NULL) {
<span class="lineNum">    3239 </span>            :     uint32 script = DEFAULT_SCRIPT;
<span class="lineNum">    3240 </span>            :     int class_index;
<span class="lineNum">    3241 </span>            :     class_index = 0;
<span class="lineNum">    3242 </span>            :     while (script == DEFAULT_SCRIPT &amp;&amp; class_index &lt; sf-&gt;kerns-&gt;first_cnt) {
<span class="lineNum">    3243 </span>            :       if (sf-&gt;kerns-&gt;firsts[class_index] != NULL) script = script_from_glyph_list(sf, sf-&gt;kerns-&gt;firsts[class_index]);
<span class="lineNum">    3244 </span>            :       class_index++;
<span class="lineNum">    3245 </span>            :     }
<span class="lineNum">    3246 </span>            :     class_index = 0;
<span class="lineNum">    3247 </span>            :     while (script == DEFAULT_SCRIPT &amp;&amp; class_index &lt; sf-&gt;kerns-&gt;second_cnt) {
<span class="lineNum">    3248 </span>            :       if (sf-&gt;kerns-&gt;seconds[class_index] != NULL) script = script_from_glyph_list(sf, sf-&gt;kerns-&gt;seconds[class_index]);
<span class="lineNum">    3249 </span>            :       class_index++;
<span class="lineNum">    3250 </span>            :     }
<span class="lineNum">    3251 </span>            :     sf-&gt;kerns-&gt;subtable = SFSubTableFindOrMake(sf, CHR('k','e','r','n'), script, gpos_pair);
<span class="lineNum">    3252 </span>            :   }
<span class="lineNum">    3253 </span>            :   if (sf-&gt;vkerns != NULL) {
<span class="lineNum">    3254 </span>            :     uint32 script = DEFAULT_SCRIPT;
<span class="lineNum">    3255 </span>            :     int class_index;
<span class="lineNum">    3256 </span>            :     class_index = 0;
<span class="lineNum">    3257 </span>            :     while (script == DEFAULT_SCRIPT &amp;&amp; class_index &lt; sf-&gt;vkerns-&gt;first_cnt) {
<span class="lineNum">    3258 </span>            :       if (sf-&gt;vkerns-&gt;firsts[class_index] != NULL) script = script_from_glyph_list(sf, sf-&gt;vkerns-&gt;firsts[class_index]);
<span class="lineNum">    3259 </span>            :       class_index++;
<span class="lineNum">    3260 </span>            :     }
<span class="lineNum">    3261 </span>            :     class_index = 0;
<span class="lineNum">    3262 </span>            :     while (script == DEFAULT_SCRIPT &amp;&amp; class_index &lt; sf-&gt;vkerns-&gt;second_cnt) {
<span class="lineNum">    3263 </span>            :       if (sf-&gt;vkerns-&gt;seconds[class_index] != NULL) script = script_from_glyph_list(sf, sf-&gt;vkerns-&gt;seconds[class_index]);
<span class="lineNum">    3264 </span>            :       class_index++;
<span class="lineNum">    3265 </span>            :     }
<span class="lineNum">    3266 </span>            :     sf-&gt;vkerns-&gt;subtable = SFSubTableFindOrMake(sf, CHR('v','k','r','n'), script, gpos_pair);
<span class="lineNum">    3267 </span>            :   }
<span class="lineNum">    3268 </span>            : #else
<span class="lineNum">    3269 </span>            :   // Some test cases have proven that FontForge would do best to avoid classifying these.
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 :   uint32 script = DEFAULT_SCRIPT;</span>
<span class="lineNum">    3271 </span><span class="lineNoCov">          0 :   if (sf-&gt;kerns != NULL) {</span>
<span class="lineNum">    3272 </span><span class="lineNoCov">          0 :     sf-&gt;kerns-&gt;subtable = SFSubTableFindOrMake(sf, CHR('k','e','r','n'), script, gpos_pair);</span>
<span class="lineNum">    3273 </span>            :   }
<span class="lineNum">    3274 </span><span class="lineNoCov">          0 :   if (sf-&gt;vkerns != NULL) {</span>
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :     sf-&gt;vkerns-&gt;subtable = SFSubTableFindOrMake(sf, CHR('v','k','r','n'), script, gpos_pair);</span>
<span class="lineNum">    3276 </span>            :   }
<span class="lineNum">    3277 </span>            : #endif // UFO_GUESS_SCRIPTS
<span class="lineNum">    3278 </span>            : 
<a name="3279"><span class="lineNum">    3279 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3280 </span>            : 
<span class="lineNum">    3281 </span><span class="lineNoCov">          0 : static void UFOHandleGroups(SplineFont *sf, char *basedir) {</span>
<span class="lineNum">    3282 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir, &quot;groups.plist&quot;);</span>
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 :     xmlDocPtr doc=NULL;</span>
<span class="lineNum">    3284 </span>            :     xmlNodePtr plist,dict,keys,value,subkeys;
<span class="lineNum">    3285 </span>            :     char *keyname, *valname;
<span class="lineNum">    3286 </span><span class="lineNoCov">          0 :     struct ff_glyphclasses *current_group = NULL;</span>
<span class="lineNum">    3287 </span>            :     // We want to start at the end of the list of groups already in the SplineFont (probably not any right now).
<span class="lineNum">    3288 </span><span class="lineNoCov">          0 :     for (current_group = sf-&gt;groups; current_group != NULL &amp;&amp; current_group-&gt;next != NULL; current_group = current_group-&gt;next);</span>
<span class="lineNum">    3289 </span>            :     int group_count;
<span class="lineNum">    3290 </span>            : 
<span class="lineNum">    3291 </span><span class="lineNoCov">          0 :     if ( GFileExists(fname))</span>
<span class="lineNum">    3292 </span><span class="lineNoCov">          0 :         doc = xmlParseFile(fname);</span>
<span class="lineNum">    3293 </span><span class="lineNoCov">          0 :     free(fname);</span>
<span class="lineNum">    3294 </span><span class="lineNoCov">          0 :     if ( doc==NULL )</span>
<span class="lineNum">    3295 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3296 </span>            : 
<span class="lineNum">    3297 </span><span class="lineNoCov">          0 :     plist = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    3298 </span><span class="lineNoCov">          0 :     dict = FindNode(plist-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    3299 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(plist-&gt;name,(const xmlChar *) &quot;plist&quot;)!=0 || dict==NULL ) {</span>
<span class="lineNum">    3300 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Expected property list file&quot;));</span>
<span class="lineNum">    3301 </span><span class="lineNoCov">          0 :         xmlFreeDoc(doc);</span>
<span class="lineNum">    3302 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3303 </span>            :     }
<span class="lineNum">    3304 </span><span class="lineNoCov">          0 :     for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    3305 </span><span class="lineNoCov">          0 :         for ( value = keys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    3306 </span><span class="lineNoCov">          0 :                 value = value-&gt;next );</span>
<span class="lineNum">    3307 </span><span class="lineNoCov">          0 :         if ( value==NULL )</span>
<span class="lineNum">    3308 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3309 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    3310 </span><span class="lineNoCov">          0 :             keyname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    3311 </span><span class="lineNoCov">          0 :             SplineChar *sc = SFGetChar(sf,-1,keyname);</span>
<span class="lineNum">    3312 </span><span class="lineNoCov">          0 :             if ( sc!=NULL ) { LogError(_(&quot;Skipping group %s with same name as a glyph.\n&quot;), keyname); free(keyname); keyname = NULL; continue; }</span>
<span class="lineNum">    3313 </span><span class="lineNoCov">          0 :             struct ff_glyphclasses *sfg = SFGetGroup(sf,-1,keyname);</span>
<span class="lineNum">    3314 </span><span class="lineNoCov">          0 :             if ( sfg!=NULL ) { LogError(_(&quot;Skipping duplicate group %s.\n&quot;), keyname); free(keyname); keyname = NULL; continue; }</span>
<span class="lineNum">    3315 </span><span class="lineNoCov">          0 :             sfg = calloc(1, sizeof(struct ff_glyphclasses)); // We allocate space for the new group.</span>
<span class="lineNum">    3316 </span><span class="lineNoCov">          0 :             sfg-&gt;classname = keyname; keyname = NULL; // We name it.</span>
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :             if (current_group == NULL) sf-&gt;groups = sfg;</span>
<span class="lineNum">    3318 </span><span class="lineNoCov">          0 :             else current_group-&gt;next = sfg;</span>
<span class="lineNum">    3319 </span><span class="lineNoCov">          0 :             current_group = sfg; // And we put it at the end of the list.</span>
<span class="lineNum">    3320 </span>            :             // We prepare to populate it. We will match to native glyphs first (in order to validate) and then convert back to strings later.
<span class="lineNum">    3321 </span><span class="lineNoCov">          0 :             RefChar *members_native = NULL;</span>
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :             RefChar *member_native_current = NULL;</span>
<span class="lineNum">    3323 </span><span class="lineNoCov">          0 :             int member_count = 0;</span>
<span class="lineNum">    3324 </span><span class="lineNoCov">          0 :             int member_list_length = 0; // This makes it easy to allocate a string at the end.</span>
<span class="lineNum">    3325 </span>            :             // We fetch the contents now. They are in an array, but we do not verify that.
<span class="lineNum">    3326 </span><span class="lineNoCov">          0 :             keys = value;</span>
<span class="lineNum">    3327 </span><span class="lineNoCov">          0 :             for ( subkeys = keys-&gt;children; subkeys!=NULL; subkeys = subkeys-&gt;next ) {</span>
<span class="lineNum">    3328 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(subkeys-&gt;name,(const xmlChar *) &quot;string&quot;)==0 ) {</span>
<span class="lineNum">    3329 </span><span class="lineNoCov">          0 :                     keyname = (char *) xmlNodeListGetString(doc,subkeys-&gt;children,true); // Get the member name.</span>
<span class="lineNum">    3330 </span><span class="lineNoCov">          0 :                     SplineChar *ssc = SFGetChar(sf,-1,keyname); // Try to match an existing glyph.</span>
<span class="lineNum">    3331 </span><span class="lineNoCov">          0 :                     if ( ssc==NULL ) { LogError(_(&quot;Skipping non-existent glyph %s in group %s.\n&quot;), keyname, current_group-&gt;classname); free(keyname); keyname = NULL; continue; }</span>
<span class="lineNum">    3332 </span><span class="lineNoCov">          0 :                     member_list_length += strlen(keyname) + 1; member_count++; // Make space for its name.</span>
<span class="lineNum">    3333 </span><span class="lineNoCov">          0 :                     free(keyname); // Free the name for now. (We get it directly from the SplineChar later.)</span>
<span class="lineNum">    3334 </span><span class="lineNoCov">          0 :                     RefChar *member_native_temp = calloc(1, sizeof(RefChar)); // Make an entry in the list for the native reference.</span>
<span class="lineNum">    3335 </span><span class="lineNoCov">          0 :                     member_native_temp-&gt;sc = ssc; ssc = NULL;</span>
<span class="lineNum">    3336 </span><span class="lineNoCov">          0 :                     if (member_native_current == NULL) members_native = member_native_temp;</span>
<span class="lineNum">    3337 </span><span class="lineNoCov">          0 :                     else member_native_current-&gt;next = member_native_temp;</span>
<span class="lineNum">    3338 </span><span class="lineNoCov">          0 :                     member_native_current = member_native_temp; // Add it to the end of the list.</span>
<span class="lineNum">    3339 </span>            :                 }
<span class="lineNum">    3340 </span>            :             }
<span class="lineNum">    3341 </span><span class="lineNoCov">          0 :             if (member_list_length == 0) member_list_length++; // We must have space for a zero-terminator even if the list is empty. A non-empty list has space for a space at the end that we can use.</span>
<span class="lineNum">    3342 </span><span class="lineNoCov">          0 :             current_group-&gt;glyphs = malloc(member_list_length); // We allocate space for the list.</span>
<span class="lineNum">    3343 </span><span class="lineNoCov">          0 :             current_group-&gt;glyphs[0] = '\0';</span>
<span class="lineNum">    3344 </span><span class="lineNoCov">          0 :             for (member_native_current = members_native; member_native_current != NULL; member_native_current = member_native_current-&gt;next) {</span>
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :                 if (member_native_current != members_native) strcat(current_group-&gt;glyphs, &quot; &quot;);</span>
<span class="lineNum">    3346 </span><span class="lineNoCov">          0 :                 strcat(current_group-&gt;glyphs, member_native_current-&gt;sc-&gt;name);</span>
<span class="lineNum">    3347 </span>            :             }
<span class="lineNum">    3348 </span><span class="lineNoCov">          0 :             RefCharsFree(members_native); members_native = NULL;</span>
<span class="lineNum">    3349 </span>            :         }
<span class="lineNum">    3350 </span>            :     }
<span class="lineNum">    3351 </span>            :     // The preceding routine was sufficiently complicated that it seemed like a good idea to perform the deduplication in a separate block.
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :     sf-&gt;groups = GlyphGroupDeduplicate(sf-&gt;groups, sf, 1);</span>
<span class="lineNum">    3353 </span>            :     // We now add kerning classes for any groups that are named like kerning classes.
<span class="lineNum">    3354 </span><span class="lineNoCov">          0 :     MakeKerningClasses(sf, sf-&gt;groups);</span>
<span class="lineNum">    3355 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc);</span>
<a name="3356"><span class="lineNum">    3356 </span>            : }</a>
<span class="lineNum">    3357 </span>            : 
<span class="lineNum">    3358 </span><span class="lineNoCov">          0 : static void UFOHandleKern(SplineFont *sf,char *basedir,int isv) {</span>
<span class="lineNum">    3359 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir,isv ? &quot;vkerning.plist&quot; : &quot;kerning.plist&quot;);</span>
<span class="lineNum">    3360 </span><span class="lineNoCov">          0 :     xmlDocPtr doc=NULL;</span>
<span class="lineNum">    3361 </span>            :     xmlNodePtr plist,dict,keys,value,subkeys;
<span class="lineNum">    3362 </span>            :     char *keyname, *valname;
<span class="lineNum">    3363 </span>            :     int offset;
<span class="lineNum">    3364 </span>            :     SplineChar *sc, *ssc;
<span class="lineNum">    3365 </span>            :     KernPair *kp;
<span class="lineNum">    3366 </span>            :     char *end;
<span class="lineNum">    3367 </span>            :     uint32 script;
<span class="lineNum">    3368 </span>            : 
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :     if ( GFileExists(fname))</span>
<span class="lineNum">    3370 </span><span class="lineNoCov">          0 :         doc = xmlParseFile(fname);</span>
<span class="lineNum">    3371 </span><span class="lineNoCov">          0 :     free(fname);</span>
<span class="lineNum">    3372 </span><span class="lineNoCov">          0 :     if ( doc==NULL )</span>
<span class="lineNum">    3373 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3374 </span>            : 
<span class="lineNum">    3375 </span>            :     // If there is native kerning (as we would expect if the function has not returned), set the SplineFont flag to prefer it on output.
<span class="lineNum">    3376 </span><span class="lineNoCov">          0 :     sf-&gt;preferred_kerning = 1;</span>
<span class="lineNum">    3377 </span>            : 
<span class="lineNum">    3378 </span><span class="lineNoCov">          0 :     plist = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    3379 </span><span class="lineNoCov">          0 :     dict = FindNode(plist-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    3380 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(plist-&gt;name,(const xmlChar *) &quot;plist&quot;)!=0 || dict==NULL ) {</span>
<span class="lineNum">    3381 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Expected property list file&quot;));</span>
<span class="lineNum">    3382 </span><span class="lineNoCov">          0 :         xmlFreeDoc(doc);</span>
<span class="lineNum">    3383 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3384 </span>            :     }
<span class="lineNum">    3385 </span><span class="lineNoCov">          0 :     for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    3386 </span><span class="lineNoCov">          0 :         for ( value = keys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    3387 </span><span class="lineNoCov">          0 :                 value = value-&gt;next );</span>
<span class="lineNum">    3388 </span><span class="lineNoCov">          0 :         if ( value==NULL )</span>
<span class="lineNum">    3389 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3390 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 :             keyname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    3392 </span><span class="lineNoCov">          0 :             sc = SFGetChar(sf,-1,keyname);</span>
<span class="lineNum">    3393 </span><span class="lineNoCov">          0 :             free(keyname);</span>
<span class="lineNum">    3394 </span><span class="lineNoCov">          0 :             if ( sc==NULL )</span>
<span class="lineNum">    3395 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    3396 </span><span class="lineNoCov">          0 :             keys = value;</span>
<span class="lineNum">    3397 </span><span class="lineNoCov">          0 :             for ( subkeys = value-&gt;children; subkeys!=NULL; subkeys = subkeys-&gt;next ) {</span>
<span class="lineNum">    3398 </span><span class="lineNoCov">          0 :                 for ( value = subkeys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    3399 </span><span class="lineNoCov">          0 :                         value = value-&gt;next );</span>
<span class="lineNum">    3400 </span><span class="lineNoCov">          0 :                 if ( value==NULL )</span>
<span class="lineNum">    3401 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3402 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(subkeys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    3403 </span><span class="lineNoCov">          0 :                     keyname = (char *) xmlNodeListGetString(doc,subkeys-&gt;children,true);</span>
<span class="lineNum">    3404 </span><span class="lineNoCov">          0 :                     ssc = SFGetChar(sf,-1,keyname);</span>
<span class="lineNum">    3405 </span><span class="lineNoCov">          0 :                     free(keyname);</span>
<span class="lineNum">    3406 </span><span class="lineNoCov">          0 :                     if ( ssc==NULL )</span>
<span class="lineNum">    3407 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    3408 </span><span class="lineNoCov">          0 :                     for ( kp=isv?sc-&gt;vkerns:sc-&gt;kerns; kp!=NULL &amp;&amp; kp-&gt;sc!=ssc; kp=kp-&gt;next );</span>
<span class="lineNum">    3409 </span><span class="lineNoCov">          0 :                     if ( kp!=NULL )</span>
<span class="lineNum">    3410 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    3411 </span><span class="lineNoCov">          0 :                     subkeys = value;</span>
<span class="lineNum">    3412 </span><span class="lineNoCov">          0 :                     valname = (char *) xmlNodeListGetString(doc,value-&gt;children,true);</span>
<span class="lineNum">    3413 </span><span class="lineNoCov">          0 :                     offset = strtol(valname,&amp;end,10);</span>
<span class="lineNum">    3414 </span><span class="lineNoCov">          0 :                     if ( *end=='\0' ) {</span>
<span class="lineNum">    3415 </span><span class="lineNoCov">          0 :                         kp = chunkalloc(sizeof(KernPair));</span>
<span class="lineNum">    3416 </span><span class="lineNoCov">          0 :                         kp-&gt;off = offset;</span>
<span class="lineNum">    3417 </span><span class="lineNoCov">          0 :                         kp-&gt;sc = ssc;</span>
<span class="lineNum">    3418 </span><span class="lineNoCov">          0 :                         if ( isv ) {</span>
<span class="lineNum">    3419 </span><span class="lineNoCov">          0 :                             kp-&gt;next = sc-&gt;vkerns;</span>
<span class="lineNum">    3420 </span><span class="lineNoCov">          0 :                             sc-&gt;vkerns = kp;</span>
<span class="lineNum">    3421 </span>            :                         } else {
<span class="lineNum">    3422 </span><span class="lineNoCov">          0 :                             kp-&gt;next = sc-&gt;kerns;</span>
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :                             sc-&gt;kerns = kp;</span>
<span class="lineNum">    3424 </span>            :                         }
<span class="lineNum">    3425 </span>            : #ifdef UFO_GUESS_SCRIPTS
<span class="lineNum">    3426 </span>            :                         script = SCScriptFromUnicode(sc);
<span class="lineNum">    3427 </span>            :                         if ( script==DEFAULT_SCRIPT )
<span class="lineNum">    3428 </span>            :                             script = SCScriptFromUnicode(ssc);
<span class="lineNum">    3429 </span>            : #else
<span class="lineNum">    3430 </span>            :                         // Some test cases have proven that FontForge would do best to avoid classifying these.
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 :                         script = DEFAULT_SCRIPT;</span>
<span class="lineNum">    3432 </span>            : #endif // UFO_GUESS_SCRIPTS
<span class="lineNum">    3433 </span><span class="lineNoCov">          0 :                         kp-&gt;subtable = SFSubTableFindOrMake(sf,</span>
<span class="lineNum">    3434 </span>            :                                 isv?CHR('v','k','r','n'):CHR('k','e','r','n'),
<span class="lineNum">    3435 </span>            :                                 script, gpos_pair);
<span class="lineNum">    3436 </span>            :                     }
<span class="lineNum">    3437 </span><span class="lineNoCov">          0 :                     free(valname);</span>
<span class="lineNum">    3438 </span>            :                 }
<span class="lineNum">    3439 </span>            :             }
<span class="lineNum">    3440 </span>            :         }
<span class="lineNum">    3441 </span>            :     }
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc);</span>
<a name="3443"><span class="lineNum">    3443 </span>            : }</a>
<span class="lineNum">    3444 </span>            : 
<span class="lineNum">    3445 </span><span class="lineNoCov">          0 : int TryAddRawGroupKern(struct splinefont *sf, int isv, struct glif_name_index *class_name_pair_hash, int *current_groupkern_index_p, struct ff_rawoffsets **current_groupkern_p, const char *left, const char *right, int offset) {</span>
<span class="lineNum">    3446 </span>            :   char *pairtext;
<span class="lineNum">    3447 </span><span class="lineNoCov">          0 :   int success = 0;</span>
<span class="lineNum">    3448 </span><span class="lineNoCov">          0 :   if (left &amp;&amp; right &amp;&amp; asprintf(&amp;pairtext, &quot;%s %s&quot;, left, right) &gt; 0 &amp;&amp; pairtext) {</span>
<span class="lineNum">    3449 </span><span class="lineNoCov">          0 :     if (!glif_name_search_glif_name(class_name_pair_hash, pairtext)) {</span>
<span class="lineNum">    3450 </span><span class="lineNoCov">          0 :       glif_name_track_new(class_name_pair_hash, (*current_groupkern_index_p)++, pairtext);</span>
<span class="lineNum">    3451 </span><span class="lineNoCov">          0 :       struct ff_rawoffsets *tmp_groupkern = calloc(1, sizeof(struct ff_rawoffsets));</span>
<span class="lineNum">    3452 </span><span class="lineNoCov">          0 :       tmp_groupkern-&gt;left = copy(left);</span>
<span class="lineNum">    3453 </span><span class="lineNoCov">          0 :       tmp_groupkern-&gt;right = copy(right);</span>
<span class="lineNum">    3454 </span><span class="lineNoCov">          0 :       tmp_groupkern-&gt;offset = offset;</span>
<span class="lineNum">    3455 </span><span class="lineNoCov">          0 :       if (*current_groupkern_p == NULL) {</span>
<span class="lineNum">    3456 </span><span class="lineNoCov">          0 :         if (isv) sf-&gt;groupvkerns = tmp_groupkern;</span>
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :         else sf-&gt;groupkerns = tmp_groupkern;</span>
<span class="lineNum">    3458 </span><span class="lineNoCov">          0 :       } else (*current_groupkern_p)-&gt;next = tmp_groupkern;</span>
<span class="lineNum">    3459 </span><span class="lineNoCov">          0 :       *current_groupkern_p = tmp_groupkern;</span>
<span class="lineNum">    3460 </span><span class="lineNoCov">          0 :       success = 1;</span>
<span class="lineNum">    3461 </span>            :     }
<span class="lineNum">    3462 </span><span class="lineNoCov">          0 :     free(pairtext); pairtext = NULL;</span>
<span class="lineNum">    3463 </span>            :   }
<span class="lineNum">    3464 </span><span class="lineNoCov">          0 :   return success;</span>
<a name="3465"><span class="lineNum">    3465 </span>            : }</a>
<span class="lineNum">    3466 </span>            : 
<span class="lineNum">    3467 </span><span class="lineNoCov">          0 : static void UFOHandleKern3(SplineFont *sf,char *basedir,int isv) {</span>
<span class="lineNum">    3468 </span><span class="lineNoCov">          0 :     char *fname = buildname(basedir,isv ? &quot;vkerning.plist&quot; : &quot;kerning.plist&quot;);</span>
<span class="lineNum">    3469 </span><span class="lineNoCov">          0 :     xmlDocPtr doc=NULL;</span>
<span class="lineNum">    3470 </span>            :     xmlNodePtr plist,dict,keys,value,subkeys;
<span class="lineNum">    3471 </span>            :     char *keyname, *valname;
<span class="lineNum">    3472 </span>            :     int offset;
<span class="lineNum">    3473 </span>            :     SplineChar *sc, *ssc;
<span class="lineNum">    3474 </span>            :     KernPair *kp;
<span class="lineNum">    3475 </span>            :     char *end;
<span class="lineNum">    3476 </span>            :     uint32 script;
<span class="lineNum">    3477 </span>            : 
<span class="lineNum">    3478 </span><span class="lineNoCov">          0 :     if ( GFileExists(fname))</span>
<span class="lineNum">    3479 </span><span class="lineNoCov">          0 :         doc = xmlParseFile(fname);</span>
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :     free(fname);</span>
<span class="lineNum">    3481 </span><span class="lineNoCov">          0 :     if ( doc==NULL )</span>
<span class="lineNum">    3482 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span>            :     // If there is native kerning (as we would expect if the function has not returned), set the SplineFont flag to prefer it on output.
<span class="lineNum">    3485 </span><span class="lineNoCov">          0 :     sf-&gt;preferred_kerning = 1;</span>
<span class="lineNum">    3486 </span>            : 
<span class="lineNum">    3487 </span><span class="lineNoCov">          0 :     plist = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    3488 </span><span class="lineNoCov">          0 :     dict = FindNode(plist-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    3489 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(plist-&gt;name,(const xmlChar *) &quot;plist&quot;)!=0 || dict==NULL ) {</span>
<span class="lineNum">    3490 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Expected property list file&quot;));</span>
<span class="lineNum">    3491 </span><span class="lineNoCov">          0 :         xmlFreeDoc(doc);</span>
<span class="lineNum">    3492 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3493 </span>            :     }
<span class="lineNum">    3494 </span>            : 
<span class="lineNum">    3495 </span>            :     // We want a hash table of group names for reference.
<span class="lineNum">    3496 </span>            :     struct glif_name_index _group_name_hash;
<span class="lineNum">    3497 </span><span class="lineNoCov">          0 :     struct glif_name_index * group_name_hash = &amp;_group_name_hash; // Open the group hash table.</span>
<span class="lineNum">    3498 </span><span class="lineNoCov">          0 :     memset(group_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    3499 </span><span class="lineNoCov">          0 :     struct ff_glyphclasses *current_group = NULL;</span>
<span class="lineNum">    3500 </span><span class="lineNoCov">          0 :     int current_group_index = 0;</span>
<span class="lineNum">    3501 </span><span class="lineNoCov">          0 :     for (current_group = sf-&gt;groups, current_group_index = 0; current_group != NULL; current_group = current_group-&gt;next, current_group_index++)</span>
<span class="lineNum">    3502 </span><span class="lineNoCov">          0 :       if (current_group-&gt;classname != NULL) glif_name_track_new(group_name_hash, current_group_index, current_group-&gt;classname);</span>
<span class="lineNum">    3503 </span>            :     // We also want a hash table of kerning class names. (We'll probably standardize on one approach or the other later.)
<span class="lineNum">    3504 </span>            :     struct glif_name_index _class_name_hash;
<span class="lineNum">    3505 </span><span class="lineNoCov">          0 :     struct glif_name_index * class_name_hash = &amp;_class_name_hash; // Open the group hash table.</span>
<span class="lineNum">    3506 </span><span class="lineNoCov">          0 :     memset(class_name_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    3507 </span><span class="lineNoCov">          0 :     HashKerningClassNames(sf, class_name_hash);</span>
<span class="lineNum">    3508 </span>            :     // We also want a hash table of the lookup pairs.
<span class="lineNum">    3509 </span>            :     struct glif_name_index _class_name_pair_hash;
<span class="lineNum">    3510 </span><span class="lineNoCov">          0 :     struct glif_name_index * class_name_pair_hash = &amp;_class_name_pair_hash; // Open the group hash table.</span>
<span class="lineNum">    3511 </span><span class="lineNoCov">          0 :     memset(class_name_pair_hash, 0, sizeof(struct glif_name_index));</span>
<span class="lineNum">    3512 </span>            :     // We need to track the head of the group kerns.
<span class="lineNum">    3513 </span><span class="lineNoCov">          0 :     struct ff_rawoffsets *current_groupkern = NULL;</span>
<span class="lineNum">    3514 </span><span class="lineNoCov">          0 :     int current_groupkern_index = 0;</span>
<span class="lineNum">    3515 </span>            :     // We want to start at the end of the list of kerns already in the SplineFont (probably not any right now).
<span class="lineNum">    3516 </span><span class="lineNoCov">          0 :     for (current_groupkern = (isv ? sf-&gt;groupvkerns : sf-&gt;groupkerns); current_groupkern != NULL &amp;&amp; current_groupkern-&gt;next != NULL; current_groupkern = current_groupkern-&gt;next);</span>
<span class="lineNum">    3517 </span>            : 
<span class="lineNum">    3518 </span>            :     // Read the left node. Set sc if it matches a character or isgroup and the associated values if it matches a group.
<span class="lineNum">    3519 </span>            :     // Read the right node. Set ssc if it matches a character or isgroup and the associated values if it matches a group.
<span class="lineNum">    3520 </span>            :     // If sc and ssc, add a kerning pair to sc for ssc.
<span class="lineNum">    3521 </span>            :     // If left_isgroup and right_isgroup, use the processed values in order to offset.
<span class="lineNum">    3522 </span><span class="lineNoCov">          0 :     for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    3523 </span><span class="lineNoCov">          0 :         for ( value = keys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    3524 </span><span class="lineNoCov">          0 :                 value = value-&gt;next );</span>
<span class="lineNum">    3525 </span><span class="lineNoCov">          0 :         if ( value==NULL )</span>
<span class="lineNum">    3526 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    3527 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    3528 </span><span class="lineNoCov">          0 :             keyname = (char *) xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    3529 </span>            :             // Search for a glyph first.
<span class="lineNum">    3530 </span><span class="lineNoCov">          0 :             sc = SFGetChar(sf,-1,keyname);</span>
<span class="lineNum">    3531 </span>            :             // Search for a group.
<span class="lineNum">    3532 </span><span class="lineNoCov">          0 :             struct glif_name *left_class_name_record = glif_name_search_glif_name(class_name_hash, keyname);</span>
<span class="lineNum">    3533 </span><span class="lineNoCov">          0 :             free(keyname);</span>
<span class="lineNum">    3534 </span><span class="lineNoCov">          0 :             if (sc == NULL &amp;&amp; left_class_name_record == NULL) { LogError(_(&quot;kerning.plist references an entity that is neither a glyph nor a group.&quot;)); continue; }</span>
<span class="lineNum">    3535 </span><span class="lineNoCov">          0 :             keys = value; // Set the offset for the next round.</span>
<span class="lineNum">    3536 </span>            :             // This key represents the left/above side of the pair. The child keys represent its right/below complements.
<span class="lineNum">    3537 </span><span class="lineNoCov">          0 :             for ( subkeys = value-&gt;children; subkeys!=NULL; subkeys = subkeys-&gt;next ) {</span>
<span class="lineNum">    3538 </span><span class="lineNoCov">          0 :                 for ( value = subkeys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    3539 </span><span class="lineNoCov">          0 :                         value = value-&gt;next );</span>
<span class="lineNum">    3540 </span><span class="lineNoCov">          0 :                 if ( value==NULL )</span>
<span class="lineNum">    3541 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    3542 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(subkeys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    3543 </span>            :                     // Get the second name of the pair.
<span class="lineNum">    3544 </span><span class="lineNoCov">          0 :                     keyname = (char *) xmlNodeListGetString(doc,subkeys-&gt;children,true);</span>
<span class="lineNum">    3545 </span>            :                     // Get the offset in numeric form.
<span class="lineNum">    3546 </span><span class="lineNoCov">          0 :                     valname = (char *) xmlNodeListGetString(doc,value-&gt;children,true);</span>
<span class="lineNum">    3547 </span><span class="lineNoCov">          0 :                     offset = strtol(valname,&amp;end,10);</span>
<span class="lineNum">    3548 </span><span class="lineNoCov">          0 :                     if (*end != '\0') { LogError(_(&quot;kerning.plist has a non-numeric offset.&quot;)); continue; }</span>
<span class="lineNum">    3549 </span><span class="lineNoCov">          0 :                     free(valname); valname = NULL;</span>
<span class="lineNum">    3550 </span><span class="lineNoCov">          0 :                     subkeys = value; // Set the iterator for the next use.</span>
<span class="lineNum">    3551 </span>            :                     // Search for a character.
<span class="lineNum">    3552 </span><span class="lineNoCov">          0 :                     ssc = SFGetChar(sf,-1,keyname);</span>
<span class="lineNum">    3553 </span>            :                     // Search for a group.
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :                     struct glif_name *right_class_name_record = glif_name_search_glif_name(class_name_hash, keyname);</span>
<span class="lineNum">    3555 </span><span class="lineNoCov">          0 :                     free(keyname);</span>
<span class="lineNum">    3556 </span><span class="lineNoCov">          0 :                     if (ssc == NULL &amp;&amp; right_class_name_record == NULL) { LogError(_(&quot;kerning.plist references an entity that is neither a glyph nor a group.&quot;)); continue; }</span>
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :                   if (sc &amp;&amp; ssc) {</span>
<span class="lineNum">    3559 </span><span class="lineNoCov">          0 :                     KernPair *lastkp = NULL;</span>
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 :                     for ( kp=(isv?sc-&gt;vkerns:sc-&gt;kerns); kp!=NULL &amp;&amp; kp-&gt;sc!=ssc; lastkp = kp, kp=kp-&gt;next );</span>
<span class="lineNum">    3561 </span><span class="lineNoCov">          0 :                     if ( kp!=NULL ) { LogError(_(&quot;kerning.plist defines kerning between two glyphs that are already kerned.&quot;)); continue; }</span>
<span class="lineNum">    3562 </span>            :                     // We do not want to add the virtual entry until we have confirmed the possibility of adding the real entry as precedes this.
<span class="lineNum">    3563 </span><span class="lineNoCov">          0 :                     if (!TryAddRawGroupKern(sf, isv, class_name_pair_hash, &amp;current_groupkern_index, &amp;current_groupkern, sc-&gt;name, ssc-&gt;name, offset)) {</span>
<span class="lineNum">    3564 </span><span class="lineNoCov">          0 :                       LogError(_(&quot;kerning.plist defines kerning between two glyphs that are already partially kerned.&quot;)); continue;</span>
<span class="lineNum">    3565 </span>            :                     }
<span class="lineNum">    3566 </span>            :                     {
<span class="lineNum">    3567 </span><span class="lineNoCov">          0 :                         kp = chunkalloc(sizeof(KernPair));</span>
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :                         kp-&gt;off = offset;</span>
<span class="lineNum">    3569 </span><span class="lineNoCov">          0 :                         kp-&gt;sc = ssc;</span>
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :                         if ( isv ) {</span>
<span class="lineNum">    3571 </span><span class="lineNoCov">          0 :                             if (lastkp != NULL) lastkp-&gt;next = kp;</span>
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 :                             else sc-&gt;vkerns = kp;</span>
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :                             lastkp = kp;</span>
<span class="lineNum">    3574 </span>            :                             // kp-&gt;next = sc-&gt;vkerns;
<span class="lineNum">    3575 </span>            :                             // sc-&gt;vkerns = kp;
<span class="lineNum">    3576 </span>            :                         } else {
<span class="lineNum">    3577 </span><span class="lineNoCov">          0 :                             if (lastkp != NULL) lastkp-&gt;next = kp;</span>
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :                             else sc-&gt;kerns = kp;</span>
<span class="lineNum">    3579 </span><span class="lineNoCov">          0 :                             lastkp = kp;</span>
<span class="lineNum">    3580 </span>            :                             // kp-&gt;next = sc-&gt;kerns;
<span class="lineNum">    3581 </span>            :                             // sc-&gt;kerns = kp;
<span class="lineNum">    3582 </span>            :                         }
<span class="lineNum">    3583 </span>            : #ifdef UFO_GUESS_SCRIPTS
<span class="lineNum">    3584 </span>            :                         script = SCScriptFromUnicode(sc);
<span class="lineNum">    3585 </span>            :                         if ( script==DEFAULT_SCRIPT )
<span class="lineNum">    3586 </span>            :                             script = SCScriptFromUnicode(ssc);
<span class="lineNum">    3587 </span>            : #else
<span class="lineNum">    3588 </span>            :                         // Some test cases have proven that FontForge would do best to avoid classifying these.
<span class="lineNum">    3589 </span><span class="lineNoCov">          0 :                         script = DEFAULT_SCRIPT;</span>
<span class="lineNum">    3590 </span>            : #endif // UFO_GUESS_SCRIPTS
<span class="lineNum">    3591 </span><span class="lineNoCov">          0 :                         kp-&gt;subtable = SFSubTableFindOrMake(sf,</span>
<span class="lineNum">    3592 </span>            :                                 isv?CHR('v','k','r','n'):CHR('k','e','r','n'),
<span class="lineNum">    3593 </span>            :                                 script, gpos_pair);
<span class="lineNum">    3594 </span>            :                     }
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :                   } else if (sc &amp;&amp; right_class_name_record) {</span>
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :                     if (!TryAddRawGroupKern(sf, isv, class_name_pair_hash, &amp;current_groupkern_index, &amp;current_groupkern, sc-&gt;name, right_class_name_record-&gt;glif_name, offset)) {</span>
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :                       LogError(_(&quot;kerning.plist defines kerning between two glyphs that are already partially kerned.&quot;)); continue;</span>
<span class="lineNum">    3598 </span>            :                     }
<span class="lineNum">    3599 </span><span class="lineNoCov">          0 :                   } else if (ssc &amp;&amp; left_class_name_record) {</span>
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :                     if (!TryAddRawGroupKern(sf, isv, class_name_pair_hash, &amp;current_groupkern_index, &amp;current_groupkern, left_class_name_record-&gt;glif_name, ssc-&gt;name, offset)) {</span>
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :                       LogError(_(&quot;kerning.plist defines kerning between two glyphs that are already partially kerned.&quot;)); continue;</span>
<span class="lineNum">    3602 </span>            :                     }
<span class="lineNum">    3603 </span><span class="lineNoCov">          0 :                   } else if (left_class_name_record &amp;&amp; right_class_name_record) {</span>
<span class="lineNum">    3604 </span>            :                     struct kernclass *left_kc, *right_kc;
<span class="lineNum">    3605 </span>            :                     int left_isv, right_isv, left_isr, right_isr, left_offset, right_offset;
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :                     int left_exists = KerningClassSeekByAbsoluteIndex(sf, left_class_name_record-&gt;gid, &amp;left_kc, &amp;left_isv, &amp;left_isr, &amp;left_offset);</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :                     int right_exists = KerningClassSeekByAbsoluteIndex(sf, right_class_name_record-&gt;gid, &amp;right_kc, &amp;right_isv, &amp;right_isr, &amp;right_offset);</span>
<span class="lineNum">    3608 </span><span class="lineNoCov">          0 :                     if ((left_kc == NULL) || (right_kc == NULL)) { LogError(_(&quot;kerning.plist references a missing kerning class.&quot;)); continue; } // I don't know how this would happen, at least as the code is now, but we do need to throw an error.</span>
<span class="lineNum">    3609 </span><span class="lineNoCov">          0 :                     if ((left_kc != right_kc)) { LogError(_(&quot;kerning.plist defines an offset between classes in different lookups.&quot;)); continue; }</span>
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :                     if ((left_offset &gt; left_kc-&gt;first_cnt) || (right_offset &gt; right_kc-&gt;second_cnt)) { LogError(_(&quot;There is a kerning class index error.&quot;)); continue; }</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :                     if (left_kc-&gt;offsets_flags[left_offset*left_kc-&gt;second_cnt+right_offset]) { LogError(_(&quot;kerning.plist attempts to redefine a class kerning offset.&quot;)); continue; }</span>
<span class="lineNum">    3612 </span>            :                     // All checks pass. We add the virtual pair and then the real one.
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 :                     if (!TryAddRawGroupKern(sf, isv, class_name_pair_hash, &amp;current_groupkern_index, &amp;current_groupkern, left_class_name_record-&gt;glif_name, right_class_name_record-&gt;glif_name, offset)) {</span>
<span class="lineNum">    3614 </span><span class="lineNoCov">          0 :                       LogError(_(&quot;kerning.plist defines kerning between two glyphs that are already partially kerned.&quot;)); continue;</span>
<span class="lineNum">    3615 </span>            :                     }
<span class="lineNum">    3616 </span><span class="lineNoCov">          0 :                     left_kc-&gt;offsets[left_offset*left_kc-&gt;second_cnt+right_offset] = offset;</span>
<span class="lineNum">    3617 </span><span class="lineNoCov">          0 :                     left_kc-&gt;offsets_flags[left_offset*left_kc-&gt;second_cnt+right_offset] |= FF_KERNCLASS_FLAG_NATIVE;</span>
<span class="lineNum">    3618 </span>            :                   }
<span class="lineNum">    3619 </span>            :                 }
<span class="lineNum">    3620 </span>            :             }
<span class="lineNum">    3621 </span>            :         }
<span class="lineNum">    3622 </span>            :     }
<span class="lineNum">    3623 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(group_name_hash);</span>
<span class="lineNum">    3624 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(class_name_hash);</span>
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 :     glif_name_hash_destroy(class_name_pair_hash);</span>
<span class="lineNum">    3626 </span><span class="lineNoCov">          0 :     xmlFreeDoc(doc);</span>
<a name="3627"><span class="lineNum">    3627 </span>            : }</a>
<span class="lineNum">    3628 </span>            : 
<span class="lineNum">    3629 </span><span class="lineNoCov">          0 : static void UFOAddName(SplineFont *sf,char *value,int strid) {</span>
<span class="lineNum">    3630 </span>            :     /* We simply assume that the entries in the name table are in English */
<span class="lineNum">    3631 </span>            :     /* The format doesn't say -- which bothers me */
<span class="lineNum">    3632 </span>            :     struct ttflangname *names;
<span class="lineNum">    3633 </span>            : 
<span class="lineNum">    3634 </span><span class="lineNoCov">          0 :     for ( names=sf-&gt;names; names!=NULL &amp;&amp; names-&gt;lang!=0x409; names=names-&gt;next );</span>
<span class="lineNum">    3635 </span><span class="lineNoCov">          0 :     if ( names==NULL ) {</span>
<span class="lineNum">    3636 </span><span class="lineNoCov">          0 :         names = chunkalloc(sizeof(struct ttflangname));</span>
<span class="lineNum">    3637 </span><span class="lineNoCov">          0 :         names-&gt;next = sf-&gt;names;</span>
<span class="lineNum">    3638 </span><span class="lineNoCov">          0 :         names-&gt;lang = 0x409;</span>
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 :         sf-&gt;names = names;</span>
<span class="lineNum">    3640 </span>            :     }
<span class="lineNum">    3641 </span><span class="lineNoCov">          0 :     names-&gt;names[strid] = value;</span>
<a name="3642"><span class="lineNum">    3642 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3643 </span>            : 
<span class="lineNum">    3644 </span><span class="lineNoCov">          0 : static void UFOAddPrivate(SplineFont *sf,char *key,char *value) {</span>
<span class="lineNum">    3645 </span>            :     char *pt;
<span class="lineNum">    3646 </span>            : 
<span class="lineNum">    3647 </span><span class="lineNoCov">          0 :     if ( sf-&gt;private==NULL )</span>
<span class="lineNum">    3648 </span><span class="lineNoCov">          0 :         sf-&gt;private = chunkalloc(sizeof(struct psdict));</span>
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 :     for ( pt=value; *pt!='\0'; ++pt ) { /* Value might contain white space. turn into spaces */</span>
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :         if ( *pt=='\n' || *pt=='\r' || *pt=='\t' )</span>
<span class="lineNum">    3651 </span><span class="lineNoCov">          0 :             *pt = ' ';</span>
<span class="lineNum">    3652 </span>            :     }
<span class="lineNum">    3653 </span><span class="lineNoCov">          0 :     PSDictChangeEntry(sf-&gt;private, key, value);</span>
<a name="3654"><span class="lineNum">    3654 </span><span class="lineNoCov">          0 : }</span></a>
<span class="lineNum">    3655 </span>            : 
<span class="lineNum">    3656 </span><span class="lineNoCov">          0 : static void UFOAddPrivateArray(SplineFont *sf,char *key,xmlDocPtr doc,xmlNodePtr value) {</span>
<span class="lineNum">    3657 </span>            :     char space[400], *pt, *end;
<span class="lineNum">    3658 </span>            :     xmlNodePtr kid;
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;array&quot;)!=0 )</span>
<span class="lineNum">    3661 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3662 </span><span class="lineNoCov">          0 :     pt = space; end = pt+sizeof(space)-10;</span>
<span class="lineNum">    3663 </span><span class="lineNoCov">          0 :     *pt++ = '[';</span>
<span class="lineNum">    3664 </span><span class="lineNoCov">          0 :     for ( kid = value-&gt;children; kid!=NULL; kid=kid-&gt;next ) {</span>
<span class="lineNum">    3665 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(kid-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 ||</span>
<span class="lineNum">    3666 </span><span class="lineNoCov">          0 :                 xmlStrcmp(kid-&gt;name,(const xmlChar *) &quot;real&quot;)==0 ) {</span>
<span class="lineNum">    3667 </span><span class="lineNoCov">          0 :             char *valName = (char *) xmlNodeListGetString(doc,kid-&gt;children,true);</span>
<span class="lineNum">    3668 </span><span class="lineNoCov">          0 :             if ( pt+1+strlen(valName)&lt;end ) {</span>
<span class="lineNum">    3669 </span><span class="lineNoCov">          0 :                 if ( pt!=space+1 )</span>
<span class="lineNum">    3670 </span><span class="lineNoCov">          0 :                     *pt++=' ';</span>
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :                 strcpy(pt,valName);</span>
<span class="lineNum">    3672 </span><span class="lineNoCov">          0 :                 pt += strlen(pt);</span>
<span class="lineNum">    3673 </span>            :             }
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :             free(valName);</span>
<span class="lineNum">    3675 </span>            :         }
<span class="lineNum">    3676 </span>            :     }
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 :     if ( pt!=space+1 ) {</span>
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :         *pt++ = ']';</span>
<span class="lineNum">    3679 </span><span class="lineNoCov">          0 :         *pt++ = '\0';</span>
<span class="lineNum">    3680 </span><span class="lineNoCov">          0 :         UFOAddPrivate(sf,key,space);</span>
<span class="lineNum">    3681 </span>            :     }
<a name="3682"><span class="lineNum">    3682 </span>            : }</a>
<span class="lineNum">    3683 </span>            : 
<span class="lineNum">    3684 </span><span class="lineNoCov">          0 : static void UFOGetByteArray(char *array,int cnt,xmlDocPtr doc,xmlNodePtr value) {</span>
<span class="lineNum">    3685 </span>            :     xmlNodePtr kid;
<span class="lineNum">    3686 </span>            :     int i;
<span class="lineNum">    3687 </span>            : 
<span class="lineNum">    3688 </span><span class="lineNoCov">          0 :     memset(array,0,cnt);</span>
<span class="lineNum">    3689 </span>            : 
<span class="lineNum">    3690 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;array&quot;)!=0 )</span>
<span class="lineNum">    3691 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3692 </span><span class="lineNoCov">          0 :     i=0;</span>
<span class="lineNum">    3693 </span><span class="lineNoCov">          0 :     for ( kid = value-&gt;children; kid!=NULL; kid=kid-&gt;next ) {</span>
<span class="lineNum">    3694 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(kid-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 ) {</span>
<span class="lineNum">    3695 </span><span class="lineNoCov">          0 :             char *valName = (char *) xmlNodeListGetString(doc,kid-&gt;children,true);</span>
<span class="lineNum">    3696 </span><span class="lineNoCov">          0 :             if ( i&lt;cnt )</span>
<span class="lineNum">    3697 </span><span class="lineNoCov">          0 :                 array[i++] = strtol(valName,NULL,10);</span>
<span class="lineNum">    3698 </span><span class="lineNoCov">          0 :             free(valName);</span>
<span class="lineNum">    3699 </span>            :         }
<span class="lineNum">    3700 </span>            :     }
<a name="3701"><span class="lineNum">    3701 </span>            : }</a>
<span class="lineNum">    3702 </span>            : 
<span class="lineNum">    3703 </span><span class="lineNoCov">          0 : static long UFOGetBits(xmlDocPtr doc,xmlNodePtr value) {</span>
<span class="lineNum">    3704 </span>            :     xmlNodePtr kid;
<span class="lineNum">    3705 </span><span class="lineNoCov">          0 :     long mask=0;</span>
<span class="lineNum">    3706 </span>            : 
<span class="lineNum">    3707 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;array&quot;)!=0 )</span>
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 : return( 0 );</span>
<span class="lineNum">    3709 </span><span class="lineNoCov">          0 :     for ( kid = value-&gt;children; kid!=NULL; kid=kid-&gt;next ) {</span>
<span class="lineNum">    3710 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(kid-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 ) {</span>
<span class="lineNum">    3711 </span><span class="lineNoCov">          0 :             char *valName = (char *) xmlNodeListGetString(doc,kid-&gt;children,true);</span>
<span class="lineNum">    3712 </span><span class="lineNoCov">          0 :             mask |= 1&lt;&lt;strtol(valName,NULL,10);</span>
<span class="lineNum">    3713 </span><span class="lineNoCov">          0 :             free(valName);</span>
<span class="lineNum">    3714 </span>            :         }
<span class="lineNum">    3715 </span>            :     }
<span class="lineNum">    3716 </span><span class="lineNoCov">          0 : return( mask );</span>
<a name="3717"><span class="lineNum">    3717 </span>            : }</a>
<span class="lineNum">    3718 </span>            : 
<span class="lineNum">    3719 </span><span class="lineNoCov">          0 : static void UFOGetBitArray(xmlDocPtr doc,xmlNodePtr value,uint32 *res,int len) {</span>
<span class="lineNum">    3720 </span>            :     xmlNodePtr kid;
<span class="lineNum">    3721 </span>            :     int index;
<span class="lineNum">    3722 </span>            : 
<span class="lineNum">    3723 </span><span class="lineNoCov">          0 :     if ( xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;array&quot;)!=0 )</span>
<span class="lineNum">    3724 </span><span class="lineNoCov">          0 : return;</span>
<span class="lineNum">    3725 </span><span class="lineNoCov">          0 :     for ( kid = value-&gt;children; kid!=NULL; kid=kid-&gt;next ) {</span>
<span class="lineNum">    3726 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(kid-&gt;name,(const xmlChar *) &quot;integer&quot;)==0 ) {</span>
<span class="lineNum">    3727 </span><span class="lineNoCov">          0 :             char *valName = (char *) xmlNodeListGetString(doc,kid-&gt;children,true);</span>
<span class="lineNum">    3728 </span><span class="lineNoCov">          0 :             index = strtol(valName,NULL,10);</span>
<span class="lineNum">    3729 </span><span class="lineNoCov">          0 :             if ( index &lt; len&lt;&lt;5 )</span>
<span class="lineNum">    3730 </span><span class="lineNoCov">          0 :                 res[index&gt;&gt;5] |= 1&lt;&lt;(index&amp;31);</span>
<span class="lineNum">    3731 </span><span class="lineNoCov">          0 :             free(valName);</span>
<span class="lineNum">    3732 </span>            :         }
<span class="lineNum">    3733 </span>            :     }
<a name="3734"><span class="lineNum">    3734 </span>            : }</a>
<span class="lineNum">    3735 </span>            : 
<span class="lineNum">    3736 </span><span class="lineNoCov">          0 : SplineFont *SFReadUFO(char *basedir, int flags) {</span>
<span class="lineNum">    3737 </span>            :     xmlNodePtr plist, dict, keys, value;
<span class="lineNum">    3738 </span>            :     xmlDocPtr doc;
<span class="lineNum">    3739 </span>            :     SplineFont *sf;
<span class="lineNum">    3740 </span>            :     xmlChar *keyname, *valname;
<span class="lineNum">    3741 </span><span class="lineNoCov">          0 :     char *stylename=NULL;</span>
<span class="lineNum">    3742 </span>            :     char *temp, *glyphlist, *glyphdir;
<span class="lineNum">    3743 </span>            :     char *end;
<span class="lineNum">    3744 </span><span class="lineNoCov">          0 :     int as = -1, ds= -1, em= -1;</span>
<span class="lineNum">    3745 </span>            : 
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 :     if ( !libxml_init_base()) {</span>
<span class="lineNum">    3747 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Can't find libxml2.&quot;));</span>
<span class="lineNum">    3748 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    3749 </span>            :     }
<span class="lineNum">    3750 </span>            : 
<span class="lineNum">    3751 </span><span class="lineNoCov">          0 :     sf = SplineFontEmpty();</span>
<span class="lineNum">    3752 </span><span class="lineNoCov">          0 :     SFDefaultOS2Info(&amp;sf-&gt;pfminfo, sf, &quot;&quot;); // We set the default pfm values.</span>
<span class="lineNum">    3753 </span><span class="lineNoCov">          0 :     sf-&gt;pfminfo.pfmset = 1; // We flag the pfminfo as present since we expect the U. F. O. to set any desired values.</span>
<span class="lineNum">    3754 </span><span class="lineNoCov">          0 :     int versionMajor = -1; // These are not native SplineFont values.</span>
<span class="lineNum">    3755 </span><span class="lineNoCov">          0 :     int versionMinor = -1; // We store the U. F. O. values and then process them at the end.</span>
<span class="lineNum">    3756 </span><span class="lineNoCov">          0 :     sf-&gt;styleMapFamilyName = &quot;&quot;; // Empty default to disable fallback at export (not user-accessible anyway as of now).</span>
<span class="lineNum">    3757 </span><span class="lineNoCov">          0 :     sf-&gt;pfminfo.stylemap = 0x0;</span>
<span class="lineNum">    3758 </span>            : 
<span class="lineNum">    3759 </span><span class="lineNoCov">          0 :     temp = buildname(basedir,&quot;fontinfo.plist&quot;);</span>
<span class="lineNum">    3760 </span><span class="lineNoCov">          0 :     doc = xmlParseFile(temp);</span>
<span class="lineNum">    3761 </span><span class="lineNoCov">          0 :     free(temp);</span>
<span class="lineNum">    3762 </span>            :     locale_t tmplocale; locale_t oldlocale; // Declare temporary locale storage.
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :     switch_to_c_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the C locale temporarily and cache the old locale.</span>
<span class="lineNum">    3764 </span><span class="lineNoCov">          0 :     if ( doc!=NULL ) {</span>
<span class="lineNum">    3765 </span><span class="lineNoCov">          0 :       plist = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    3766 </span><span class="lineNoCov">          0 :       dict = FindNode(plist-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    3767 </span><span class="lineNoCov">          0 :       if ( xmlStrcmp(plist-&gt;name,(const xmlChar *) &quot;plist&quot;)!=0 || dict==NULL ) {</span>
<span class="lineNum">    3768 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Expected property list file&quot;));</span>
<span class="lineNum">    3769 </span><span class="lineNoCov">          0 :         xmlFreeDoc(doc);</span>
<span class="lineNum">    3770 </span><span class="lineNoCov">          0 :       return( NULL );</span>
<span class="lineNum">    3771 </span>            :       }
<span class="lineNum">    3772 </span><span class="lineNoCov">          0 :       for ( keys=dict-&gt;children; keys!=NULL; keys=keys-&gt;next ) {</span>
<span class="lineNum">    3773 </span><span class="lineNoCov">          0 :         for ( value = keys-&gt;next; value!=NULL &amp;&amp; xmlStrcmp(value-&gt;name,(const xmlChar *) &quot;text&quot;)==0;</span>
<span class="lineNum">    3774 </span><span class="lineNoCov">          0 :                 value = value-&gt;next );</span>
<span class="lineNum">    3775 </span><span class="lineNoCov">          0 :         if ( value==NULL )</span>
<span class="lineNum">    3776 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    3777 </span><span class="lineNoCov">          0 :         if ( xmlStrcmp(keys-&gt;name,(const xmlChar *) &quot;key&quot;)==0 ) {</span>
<span class="lineNum">    3778 </span><span class="lineNoCov">          0 :             keyname = xmlNodeListGetString(doc,keys-&gt;children,true);</span>
<span class="lineNum">    3779 </span><span class="lineNoCov">          0 :             valname = xmlNodeListGetString(doc,value-&gt;children,true);</span>
<span class="lineNum">    3780 </span><span class="lineNoCov">          0 :             keys = value;</span>
<span class="lineNum">    3781 </span><span class="lineNoCov">          0 :             if ( xmlStrcmp(keyname,(xmlChar *) &quot;familyName&quot;)==0 ) {</span>
<span class="lineNum">    3782 </span><span class="lineNoCov">          0 :                 if (sf-&gt;familyname == NULL) sf-&gt;familyname = (char *) valname;</span>
<span class="lineNum">    3783 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3784 </span>            :             }
<span class="lineNum">    3785 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;styleName&quot;)==0 ) {</span>
<span class="lineNum">    3786 </span><span class="lineNoCov">          0 :                 if (stylename == NULL) stylename = (char *) valname;</span>
<span class="lineNum">    3787 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3788 </span>            :             }
<span class="lineNum">    3789 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;styleMapFamilyName&quot;)==0 ) {</span>
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :                 if (sf-&gt;styleMapFamilyName == NULL) sf-&gt;styleMapFamilyName = (char *) valname;</span>
<span class="lineNum">    3791 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3792 </span>            :             }
<span class="lineNum">    3793 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;styleMapStyleName&quot;)==0 ) {</span>
<span class="lineNum">    3794 </span><span class="lineNoCov">          0 :                 if (strcmp((char *) valname, &quot;regular&quot;)==0) sf-&gt;pfminfo.stylemap = 0x40;</span>
<span class="lineNum">    3795 </span><span class="lineNoCov">          0 :         else if (strcmp((char *) valname, &quot;italic&quot;)==0) sf-&gt;pfminfo.stylemap = 0x01;</span>
<span class="lineNum">    3796 </span><span class="lineNoCov">          0 :         else if (strcmp((char *) valname, &quot;bold&quot;)==0) sf-&gt;pfminfo.stylemap = 0x20;</span>
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :         else if (strcmp((char *) valname, &quot;bold italic&quot;)==0) sf-&gt;pfminfo.stylemap = 0x21;</span>
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3799 </span>            :             }
<span class="lineNum">    3800 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;fullName&quot;)==0 ||</span>
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :                     xmlStrcmp(keyname,(xmlChar *) &quot;postscriptFullName&quot;)==0 ) {</span>
<span class="lineNum">    3802 </span><span class="lineNoCov">          0 :                 if (sf-&gt;fullname == NULL) sf-&gt;fullname = (char *) valname;</span>
<span class="lineNum">    3803 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3804 </span>            :             }
<span class="lineNum">    3805 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;fontName&quot;)==0 ||</span>
<span class="lineNum">    3806 </span><span class="lineNoCov">          0 :                     xmlStrcmp(keyname,(xmlChar *) &quot;postscriptFontName&quot;)==0 ) {</span>
<span class="lineNum">    3807 </span><span class="lineNoCov">          0 :                 if (sf-&gt;fontname == NULL) sf-&gt;fontname = (char *) valname;</span>
<span class="lineNum">    3808 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3809 </span>            :             }
<span class="lineNum">    3810 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;weightName&quot;)==0 ||</span>
<span class="lineNum">    3811 </span><span class="lineNoCov">          0 :                     xmlStrcmp(keyname,(xmlChar *) &quot;postscriptWeightName&quot;)==0 ) {</span>
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :                 if (sf-&gt;weight == NULL) sf-&gt;weight = (char *) valname;</span>
<span class="lineNum">    3813 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3814 </span>            :             }
<span class="lineNum">    3815 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;note&quot;)==0 ) {</span>
<span class="lineNum">    3816 </span><span class="lineNoCov">          0 :                 if (sf-&gt;comments == NULL) sf-&gt;comments = (char *) valname;</span>
<span class="lineNum">    3817 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3818 </span>            :             }
<span class="lineNum">    3819 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;copyright&quot;)==0 ) {</span>
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :                 UFOAddName(sf,(char *) valname,ttf_copyright);</span>
<span class="lineNum">    3821 </span>            :         /* sf-&gt;copyright hosts the old ASCII-only PS attribute */
<span class="lineNum">    3822 </span><span class="lineNoCov">          0 :         if (sf-&gt;copyright == NULL) sf-&gt;copyright = normalizeToASCII((char *) valname);</span>
<span class="lineNum">    3823 </span><span class="lineNoCov">          0 :                 else free(valname);</span>
<span class="lineNum">    3824 </span>            :             }
<span class="lineNum">    3825 </span><span class="lineNoCov">          0 :             else if ( xmlStrcmp(keyname,(xmlChar *) &quot;trademark&quot;)==0 )</span>
<span class="lineNum">    3826 </span><span class="lineNoCov">          0 :                 UFOAddName(sf,(char *) valname,ttf_trademark);</span>
<span class="lineNum">    3827 </span><span class="lineNoCov">          0 :             else if ( strncmp((char *) keyname,&quot;openTypeName&quot;,12)==0 ) {</span>
<span class="lineNum">    3828 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;Designer&quot;)==0 )</span>
<span class="lineNum">    3829 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_designer);</span>
<span class="lineNum">    3830 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;DesignerURL&quot;)==0 )</span>
<span class="lineNum">    3831 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_designerurl);</span>
<span class="lineNum">    3832 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;Manufacturer&quot;)==0 )</span>
<span class="lineNum">    3833 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_manufacturer);</span>
<span class="lineNum">    3834 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;ManufacturerURL&quot;)==0 )</span>
<span class="lineNum">    3835 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_venderurl);</span>
<span class="lineNum">    3836 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;License&quot;)==0 )</span>
<span class="lineNum">    3837 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_license);</span>
<span class="lineNum">    3838 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;LicenseURL&quot;)==0 )</span>
<span class="lineNum">    3839 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_licenseurl);</span>
<span class="lineNum">    3840 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;Version&quot;)==0 )</span>
<span class="lineNum">    3841 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_version);</span>
<span class="lineNum">    3842 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;UniqueID&quot;)==0 )</span>
<span class="lineNum">    3843 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_uniqueid);</span>
<span class="lineNum">    3844 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;Description&quot;)==0 )</span>
<span class="lineNum">    3845 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_descriptor);</span>
<span class="lineNum">    3846 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;PreferredFamilyName&quot;)==0 )</span>
<span class="lineNum">    3847 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_preffamilyname);</span>
<span class="lineNum">    3848 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;PreferredSubfamilyName&quot;)==0 )</span>
<span class="lineNum">    3849 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_prefmodifiers);</span>
<span class="lineNum">    3850 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;CompatibleFullName&quot;)==0 )</span>
<span class="lineNum">    3851 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_compatfull);</span>
<span class="lineNum">    3852 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;SampleText&quot;)==0 )</span>
<span class="lineNum">    3853 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_sampletext);</span>
<span class="lineNum">    3854 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;WWSFamilyName&quot;)==0 )</span>
<span class="lineNum">    3855 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_wwsfamily);</span>
<span class="lineNum">    3856 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;WWSSubfamilyName&quot;)==0 )</span>
<span class="lineNum">    3857 </span><span class="lineNoCov">          0 :                     UFOAddName(sf,(char *) valname,ttf_wwssubfamily);</span>
<span class="lineNum">    3858 </span>            :                 else
<span class="lineNum">    3859 </span><span class="lineNoCov">          0 :                     free(valname);</span>
<span class="lineNum">    3860 </span><span class="lineNoCov">          0 :             } else if ( strncmp((char *) keyname, &quot;openTypeHhea&quot;,12)==0 ) {</span>
<span class="lineNum">    3861 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;Ascender&quot;)==0 ) {</span>
<span class="lineNum">    3862 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.hhead_ascent = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3863 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.hheadascent_add = false;</span>
<span class="lineNum">    3864 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;Descender&quot;)==0 ) {</span>
<span class="lineNum">    3865 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.hhead_descent = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3866 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.hheaddescent_add = false;</span>
<span class="lineNum">    3867 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;LineGap&quot;)==0 )</span>
<span class="lineNum">    3868 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.linegap = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3869 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3870 </span><span class="lineNoCov">          0 :                 sf-&gt;pfminfo.hheadset = true;</span>
<span class="lineNum">    3871 </span><span class="lineNoCov">          0 :             } else if ( strncmp((char *) keyname,&quot;openTypeVhea&quot;,12)==0 ) {</span>
<span class="lineNum">    3872 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keyname+12,(xmlChar *) &quot;LineGap&quot;)==0 )</span>
<span class="lineNum">    3873 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.vlinegap = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3874 </span><span class="lineNoCov">          0 :                 sf-&gt;pfminfo.vheadset = true;</span>
<span class="lineNum">    3875 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3876 </span><span class="lineNoCov">          0 :             } else if ( strncmp((char *) keyname,&quot;openTypeOS2&quot;,11)==0 ) {</span>
<span class="lineNum">    3877 </span><span class="lineNoCov">          0 :                 sf-&gt;pfminfo.pfmset = true;</span>
<span class="lineNum">    3878 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;Panose&quot;)==0 ) {</span>
<span class="lineNum">    3879 </span><span class="lineNoCov">          0 :                     UFOGetByteArray(sf-&gt;pfminfo.panose,sizeof(sf-&gt;pfminfo.panose),doc,value);</span>
<span class="lineNum">    3880 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.panose_set = true;</span>
<span class="lineNum">    3881 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;Type&quot;)==0 ) {</span>
<span class="lineNum">    3882 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.fstype = UFOGetBits(doc,value);</span>
<span class="lineNum">    3883 </span><span class="lineNoCov">          0 :                     if ( sf-&gt;pfminfo.fstype&lt;0 ) {</span>
<span class="lineNum">    3884 </span>            :                         /* all bits are set, but this is wrong, OpenType spec says */
<span class="lineNum">    3885 </span>            :                         /* bits 0, 4-7 and 10-15 must be unset, go see             */
<span class="lineNum">    3886 </span>            :                         /* http://www.microsoft.com/typography/otspec/os2.htm#fst  */
<span class="lineNum">    3887 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;Bad openTypeOS2type key: all bits are set. It will be ignored&quot;));</span>
<span class="lineNum">    3888 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.fstype = 0;</span>
<span class="lineNum">    3889 </span>            :                     }
<span class="lineNum">    3890 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;FamilyClass&quot;)==0 ) {</span>
<span class="lineNum">    3891 </span>            :                     char fc[2];
<span class="lineNum">    3892 </span><span class="lineNoCov">          0 :                     UFOGetByteArray(fc,sizeof(fc),doc,value);</span>
<span class="lineNum">    3893 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.os2_family_class = (fc[0]&lt;&lt;8)|fc[1];</span>
<span class="lineNum">    3894 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;WidthClass&quot;)==0 )</span>
<span class="lineNum">    3895 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.width = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3896 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;WeightClass&quot;)==0 )</span>
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.weight = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3898 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;VendorID&quot;)==0 )</span>
<span class="lineNum">    3899 </span>            :                 {
<span class="lineNum">    3900 </span><span class="lineNoCov">          0 :                     const int os2_vendor_sz = sizeof(sf-&gt;pfminfo.os2_vendor);</span>
<span class="lineNum">    3901 </span><span class="lineNoCov">          0 :                     const int valname_len = c_strlen(valname);</span>
<span class="lineNum">    3902 </span>            : 
<span class="lineNum">    3903 </span><span class="lineNoCov">          0 :                     if( valname &amp;&amp; valname_len &lt;= os2_vendor_sz )</span>
<span class="lineNum">    3904 </span><span class="lineNoCov">          0 :                         strncpy(sf-&gt;pfminfo.os2_vendor,valname,valname_len);</span>
<span class="lineNum">    3905 </span>            : 
<span class="lineNum">    3906 </span><span class="lineNoCov">          0 :                     char *temp = sf-&gt;pfminfo.os2_vendor + os2_vendor_sz - 1;</span>
<span class="lineNum">    3907 </span><span class="lineNoCov">          0 :                     while ( *temp == 0 &amp;&amp; temp &gt;= sf-&gt;pfminfo.os2_vendor )</span>
<span class="lineNum">    3908 </span><span class="lineNoCov">          0 :                         *temp-- = ' ';</span>
<span class="lineNum">    3909 </span>            :                 }
<span class="lineNum">    3910 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;TypoAscender&quot;)==0 ) {</span>
<span class="lineNum">    3911 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.typoascent_add = false;</span>
<span class="lineNum">    3912 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.os2_typoascent = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3913 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;TypoDescender&quot;)==0 ) {</span>
<span class="lineNum">    3914 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.typodescent_add = false;</span>
<span class="lineNum">    3915 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.os2_typodescent = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;TypoLineGap&quot;)==0 )</span>
<span class="lineNum">    3917 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.os2_typolinegap = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3918 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;WinAscent&quot;)==0 ) {</span>
<span class="lineNum">    3919 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.winascent_add = false;</span>
<span class="lineNum">    3920 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.os2_winascent = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3921 </span><span class="lineNoCov">          0 :                 } else if ( xmlStrcmp(keyname+11,(xmlChar *) &quot;WinDescent&quot;)==0 ) {</span>
<span class="lineNum">    3922 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.windescent_add = false;</span>
<span class="lineNum">    3923 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.os2_windescent = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3924 </span><span class="lineNoCov">          0 :                 } else if ( strncmp((char *) keyname+11,&quot;Subscript&quot;,9)==0 ) {</span>
<span class="lineNum">    3925 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.subsuper_set = true;</span>
<span class="lineNum">    3926 </span><span class="lineNoCov">          0 :                     if ( xmlStrcmp(keyname+20,(xmlChar *) &quot;XSize&quot;)==0 )</span>
<span class="lineNum">    3927 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_subxsize = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3928 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+20,(xmlChar *) &quot;YSize&quot;)==0 )</span>
<span class="lineNum">    3929 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_subysize = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3930 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+20,(xmlChar *) &quot;XOffset&quot;)==0 )</span>
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_subxoff = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3932 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+20,(xmlChar *) &quot;YOffset&quot;)==0 )</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_subyoff = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3934 </span><span class="lineNoCov">          0 :                 } else if ( strncmp((char *) keyname+11, &quot;Superscript&quot;,11)==0 ) {</span>
<span class="lineNum">    3935 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.subsuper_set = true;</span>
<span class="lineNum">    3936 </span><span class="lineNoCov">          0 :                     if ( xmlStrcmp(keyname+22,(xmlChar *) &quot;XSize&quot;)==0 )</span>
<span class="lineNum">    3937 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_supxsize = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3938 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+22,(xmlChar *) &quot;YSize&quot;)==0 )</span>
<span class="lineNum">    3939 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_supysize = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3940 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+22,(xmlChar *) &quot;XOffset&quot;)==0 )</span>
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_supxoff = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3942 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+22,(xmlChar *) &quot;YOffset&quot;)==0 )</span>
<span class="lineNum">    3943 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_supyoff = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3944 </span><span class="lineNoCov">          0 :                 } else if ( strncmp((char *) keyname+11, &quot;Strikeout&quot;,9)==0 ) {</span>
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.subsuper_set = true;</span>
<span class="lineNum">    3946 </span><span class="lineNoCov">          0 :                     if ( xmlStrcmp(keyname+20,(xmlChar *) &quot;Size&quot;)==0 )</span>
<span class="lineNum">    3947 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_strikeysize = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3948 </span><span class="lineNoCov">          0 :                     else if ( xmlStrcmp(keyname+20,(xmlChar *) &quot;Position&quot;)==0 )</span>
<span class="lineNum">    3949 </span><span class="lineNoCov">          0 :                         sf-&gt;pfminfo.os2_strikeypos = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 :                 } else if ( strncmp((char *) keyname+11, &quot;CodePageRanges&quot;,14)==0 ) {</span>
<span class="lineNum">    3951 </span><span class="lineNoCov">          0 :                     UFOGetBitArray(doc,value,sf-&gt;pfminfo.codepages,2);</span>
<span class="lineNum">    3952 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.hascodepages = true;</span>
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :                 } else if ( strncmp((char *) keyname+11, &quot;UnicodeRanges&quot;,13)==0 ) {</span>
<span class="lineNum">    3954 </span><span class="lineNoCov">          0 :                     UFOGetBitArray(doc,value,sf-&gt;pfminfo.unicoderanges,4);</span>
<span class="lineNum">    3955 </span><span class="lineNoCov">          0 :                     sf-&gt;pfminfo.hasunicoderanges = true;</span>
<span class="lineNum">    3956 </span>            :                 }
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3958 </span><span class="lineNoCov">          0 :             } else if ( strncmp((char *) keyname, &quot;postscript&quot;,10)==0 ) {</span>
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;UnderlineThickness&quot;)==0 )</span>
<span class="lineNum">    3960 </span><span class="lineNoCov">          0 :                     sf-&gt;uwidth = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3961 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;UnderlinePosition&quot;)==0 )</span>
<span class="lineNum">    3962 </span><span class="lineNoCov">          0 :                     sf-&gt;upos = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;BlueFuzz&quot;)==0 )</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :                     UFOAddPrivate(sf,&quot;BlueFuzz&quot;,(char *) valname);</span>
<span class="lineNum">    3965 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;BlueScale&quot;)==0 )</span>
<span class="lineNum">    3966 </span><span class="lineNoCov">          0 :                     UFOAddPrivate(sf,&quot;BlueScale&quot;,(char *) valname);</span>
<span class="lineNum">    3967 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;BlueShift&quot;)==0 )</span>
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :                     UFOAddPrivate(sf,&quot;BlueShift&quot;,(char *) valname);</span>
<span class="lineNum">    3969 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;BlueValues&quot;)==0 )</span>
<span class="lineNum">    3970 </span><span class="lineNoCov">          0 :                     UFOAddPrivateArray(sf,&quot;BlueValues&quot;,doc,value);</span>
<span class="lineNum">    3971 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;OtherBlues&quot;)==0 )</span>
<span class="lineNum">    3972 </span><span class="lineNoCov">          0 :                     UFOAddPrivateArray(sf,&quot;OtherBlues&quot;,doc,value);</span>
<span class="lineNum">    3973 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;FamilyBlues&quot;)==0 )</span>
<span class="lineNum">    3974 </span><span class="lineNoCov">          0 :                     UFOAddPrivateArray(sf,&quot;FamilyBlues&quot;,doc,value);</span>
<span class="lineNum">    3975 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;FamilyOtherBlues&quot;)==0 )</span>
<span class="lineNum">    3976 </span><span class="lineNoCov">          0 :                     UFOAddPrivateArray(sf,&quot;FamilyOtherBlues&quot;,doc,value);</span>
<span class="lineNum">    3977 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;StemSnapH&quot;)==0 )</span>
<span class="lineNum">    3978 </span><span class="lineNoCov">          0 :                     UFOAddPrivateArray(sf,&quot;StemSnapH&quot;,doc,value);</span>
<span class="lineNum">    3979 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;StemSnapV&quot;)==0 )</span>
<span class="lineNum">    3980 </span><span class="lineNoCov">          0 :                     UFOAddPrivateArray(sf,&quot;StemSnapV&quot;,doc,value);</span>
<span class="lineNum">    3981 </span><span class="lineNoCov">          0 :                 else if ( xmlStrcmp(keyname+10,(xmlChar *) &quot;ForceBold&quot;)==0 )</span>
<span class="lineNum">    3982 </span><span class="lineNoCov">          0 :                     UFOAddPrivate(sf,&quot;ForceBold&quot;,(char *) value-&gt;name);</span>
<span class="lineNum">    3983 </span>            :                         /* value-&gt;name is either true or false */
<span class="lineNum">    3984 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3985 </span><span class="lineNoCov">          0 :             } else if ( strncmp((char *)keyname,&quot;macintosh&quot;,9)==0 ) {</span>
<span class="lineNum">    3986 </span><span class="lineNoCov">          0 :                 if ( xmlStrcmp(keyname+9,(xmlChar *) &quot;FONDName&quot;)==0 )</span>
<span class="lineNum">    3987 </span><span class="lineNoCov">          0 :                     sf-&gt;fondname = (char *) valname;</span>
<span class="lineNum">    3988 </span>            :                 else
<span class="lineNum">    3989 </span><span class="lineNoCov">          0 :                     free(valname);</span>
<span class="lineNum">    3990 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;unitsPerEm&quot;)==0 ) {</span>
<span class="lineNum">    3991 </span><span class="lineNoCov">          0 :                 em = strtol((char *) valname,&amp;end,10);</span>
<span class="lineNum">    3992 </span><span class="lineNoCov">          0 :                 if ( *end!='\0' || em &lt; 0 ) em = -1;</span>
<span class="lineNum">    3993 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3994 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;ascender&quot;)==0 ) {</span>
<span class="lineNum">    3995 </span><span class="lineNoCov">          0 :                 as = strtod((char *) valname,&amp;end);</span>
<span class="lineNum">    3996 </span><span class="lineNoCov">          0 :                 if ( *end!='\0' ) as = -1;</span>
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 :                 else sf-&gt;ufo_ascent = as;</span>
<span class="lineNum">    3998 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    3999 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;descender&quot;)==0 ) {</span>
<span class="lineNum">    4000 </span><span class="lineNoCov">          0 :                 ds = -strtod((char *) valname,&amp;end);</span>
<span class="lineNum">    4001 </span><span class="lineNoCov">          0 :                 if ( *end!='\0' ) ds = -1;</span>
<span class="lineNum">    4002 </span><span class="lineNoCov">          0 :                 else sf-&gt;ufo_descent = -ds;</span>
<span class="lineNum">    4003 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    4004 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;xHeight&quot;)==0 ) {</span>
<span class="lineNum">    4005 </span><span class="lineNoCov">          0 :                 sf-&gt;pfminfo.os2_xheight = strtol((char *) valname,&amp;end,10); free(valname);</span>
<span class="lineNum">    4006 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;capHeight&quot;)==0 ) {</span>
<span class="lineNum">    4007 </span><span class="lineNoCov">          0 :                 sf-&gt;pfminfo.os2_capheight = strtol((char *) valname,&amp;end,10); free(valname);</span>
<span class="lineNum">    4008 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;italicAngle&quot;)==0 ||</span>
<span class="lineNum">    4009 </span><span class="lineNoCov">          0 :                     xmlStrcmp(keyname,(xmlChar *) &quot;postscriptSlantAngle&quot;)==0 ) {</span>
<span class="lineNum">    4010 </span><span class="lineNoCov">          0 :                 sf-&gt;italicangle = strtod((char *) valname,&amp;end);</span>
<span class="lineNum">    4011 </span><span class="lineNoCov">          0 :                 if ( *end!='\0' ) sf-&gt;italicangle = 0;</span>
<span class="lineNum">    4012 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    4013 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;versionMajor&quot;)==0 ) {</span>
<span class="lineNum">    4014 </span><span class="lineNoCov">          0 :                 versionMajor = strtol((char *) valname,&amp;end, 10);</span>
<span class="lineNum">    4015 </span><span class="lineNoCov">          0 :                 if ( *end!='\0' ) versionMajor = -1;</span>
<span class="lineNum">    4016 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    4017 </span><span class="lineNoCov">          0 :             } else if ( xmlStrcmp(keyname,(xmlChar *) &quot;versionMinor&quot;)==0 ) {</span>
<span class="lineNum">    4018 </span><span class="lineNoCov">          0 :                 versionMinor = strtol((char *) valname,&amp;end, 10);</span>
<span class="lineNum">    4019 </span><span class="lineNoCov">          0 :                 if ( *end!='\0' ) versionMinor = -1;</span>
<span class="lineNum">    4020 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    4021 </span>            :             } else
<span class="lineNum">    4022 </span><span class="lineNoCov">          0 :                 free(valname);</span>
<span class="lineNum">    4023 </span><span class="lineNoCov">          0 :             free(keyname);</span>
<span class="lineNum">    4024 </span>            :         }
<span class="lineNum">    4025 </span>            :       }
<span class="lineNum">    4026 </span><span class="lineNoCov">          0 :       xmlFreeDoc(doc);</span>
<span class="lineNum">    4027 </span>            :     }
<span class="lineNum">    4028 </span><span class="lineNoCov">          0 :     if ( em==-1 &amp;&amp; as&gt;=0 &amp;&amp; ds&gt;=0 )</span>
<span class="lineNum">    4029 </span><span class="lineNoCov">          0 :         em = as + ds;</span>
<span class="lineNum">    4030 </span><span class="lineNoCov">          0 :     if ( em==as+ds ) {</span>
<span class="lineNum">    4031 </span>            :         /* Yay! They follow my conventions */;
<span class="lineNum">    4032 </span><span class="lineNoCov">          0 :     } else if ( em!=-1 ) {</span>
<span class="lineNum">    4033 </span><span class="lineNoCov">          0 :         as = 800*em/1000;</span>
<span class="lineNum">    4034 </span><span class="lineNoCov">          0 :         ds = em-as;</span>
<span class="lineNum">    4035 </span><span class="lineNoCov">          0 :         sf-&gt;invalidem = 1;</span>
<span class="lineNum">    4036 </span>            :     }
<span class="lineNum">    4037 </span><span class="lineNoCov">          0 :     if ( em==-1 ) {</span>
<span class="lineNum">    4038 </span><span class="lineNoCov">          0 :         LogError(_(&quot;This font does not specify unitsPerEm, so we guess 1000.&quot;));</span>
<span class="lineNum">    4039 </span><span class="lineNoCov">          0 :         em = 1000;</span>
<span class="lineNum">    4040 </span>            :     }
<span class="lineNum">    4041 </span><span class="lineNoCov">          0 :     sf-&gt;ascent = as; sf-&gt;descent = ds;</span>
<span class="lineNum">    4042 </span><span class="lineNoCov">          0 :     if ( sf-&gt;fontname==NULL ) {</span>
<span class="lineNum">    4043 </span><span class="lineNoCov">          0 :         if ( stylename!=NULL &amp;&amp; sf-&gt;familyname!=NULL )</span>
<span class="lineNum">    4044 </span><span class="lineNoCov">          0 :             sf-&gt;fontname = strconcat3(sf-&gt;familyname,&quot;-&quot;,stylename);</span>
<span class="lineNum">    4045 </span>            :         else
<span class="lineNum">    4046 </span><span class="lineNoCov">          0 :             sf-&gt;fontname = copy(&quot;Untitled&quot;);</span>
<span class="lineNum">    4047 </span>            :     }
<span class="lineNum">    4048 </span><span class="lineNoCov">          0 :     if ( sf-&gt;fullname==NULL ) {</span>
<span class="lineNum">    4049 </span><span class="lineNoCov">          0 :         if ( stylename!=NULL &amp;&amp; sf-&gt;familyname!=NULL )</span>
<span class="lineNum">    4050 </span><span class="lineNoCov">          0 :             sf-&gt;fullname = strconcat3(sf-&gt;familyname,&quot; &quot;,stylename);</span>
<span class="lineNum">    4051 </span>            :         else
<span class="lineNum">    4052 </span><span class="lineNoCov">          0 :             sf-&gt;fullname = copy(sf-&gt;fontname);</span>
<span class="lineNum">    4053 </span>            :     }
<span class="lineNum">    4054 </span><span class="lineNoCov">          0 :     if ( sf-&gt;familyname==NULL )</span>
<span class="lineNum">    4055 </span><span class="lineNoCov">          0 :         sf-&gt;familyname = copy(sf-&gt;fontname);</span>
<span class="lineNum">    4056 </span><span class="lineNoCov">          0 :     free(stylename); stylename = NULL;</span>
<span class="lineNum">    4057 </span><span class="lineNoCov">          0 :     if ( sf-&gt;weight==NULL )</span>
<span class="lineNum">    4058 </span><span class="lineNoCov">          0 :         sf-&gt;weight = copy(&quot;Regular&quot;);</span>
<span class="lineNum">    4059 </span>            :     // We first try to set the SplineFont version by using the native numeric U. F. O. values.
<span class="lineNum">    4060 </span><span class="lineNoCov">          0 :     if ( sf-&gt;version==NULL &amp;&amp; versionMajor != -1 )</span>
<span class="lineNum">    4061 </span><span class="lineNoCov">          0 :       injectNumericVersion(&amp;sf-&gt;version, versionMajor, versionMinor);</span>
<span class="lineNum">    4062 </span>            :     // If that fails, we attempt to use the TrueType values.
<span class="lineNum">    4063 </span><span class="lineNoCov">          0 :     if ( sf-&gt;version==NULL &amp;&amp; sf-&gt;names!=NULL &amp;&amp;</span>
<span class="lineNum">    4064 </span><span class="lineNoCov">          0 :             sf-&gt;names-&gt;names[ttf_version]!=NULL &amp;&amp;</span>
<span class="lineNum">    4065 </span><span class="lineNoCov">          0 :             strncmp(sf-&gt;names-&gt;names[ttf_version],&quot;Version &quot;,8)==0 )</span>
<span class="lineNum">    4066 </span><span class="lineNoCov">          0 :         sf-&gt;version = copy(sf-&gt;names-&gt;names[ttf_version]+8);</span>
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span><span class="lineNoCov">          0 :         char * layercontentsname = buildname(basedir,&quot;layercontents.plist&quot;);</span>
<span class="lineNum">    4069 </span><span class="lineNoCov">          0 :         char ** layernames = NULL;</span>
<span class="lineNum">    4070 </span><span class="lineNoCov">          0 :         if (layercontentsname == NULL) {</span>
<span class="lineNum">    4071 </span><span class="lineNoCov">          0 :                 switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.</span>
<span class="lineNum">    4072 </span><span class="lineNoCov">          0 :                 return( NULL );</span>
<span class="lineNum">    4073 </span><span class="lineNoCov">          0 :         } else if ( GFileExists(layercontentsname)) {</span>
<span class="lineNum">    4074 </span><span class="lineNoCov">          0 :                 xmlDocPtr layercontentsdoc = NULL;</span>
<span class="lineNum">    4075 </span><span class="lineNoCov">          0 :                 xmlNodePtr layercontentsplist = NULL;</span>
<span class="lineNum">    4076 </span><span class="lineNoCov">          0 :                 xmlNodePtr layercontentsdict = NULL;</span>
<span class="lineNum">    4077 </span><span class="lineNoCov">          0 :                 xmlNodePtr layercontentslayer = NULL;</span>
<span class="lineNum">    4078 </span><span class="lineNoCov">          0 :                 xmlNodePtr layercontentsvalue = NULL;</span>
<span class="lineNum">    4079 </span><span class="lineNoCov">          0 :                 int layercontentslayercount = 0;</span>
<span class="lineNum">    4080 </span><span class="lineNoCov">          0 :                 int layernamesbuffersize = 0;</span>
<span class="lineNum">    4081 </span><span class="lineNoCov">          0 :                 int layercontentsvaluecount = 0;</span>
<span class="lineNum">    4082 </span><span class="lineNoCov">          0 :                 if ( (layercontentsdoc = xmlParseFile(layercontentsname)) ) {</span>
<span class="lineNum">    4083 </span>            :                         // The layercontents plist contains an array of double-element arrays. There is no top-level dict. Note that the indices in the layercontents array may not match those in the Fontforge layers array due to reserved spaces.
<span class="lineNum">    4084 </span><span class="lineNoCov">          0 :                         if ( ( layercontentsplist = xmlDocGetRootElement(layercontentsdoc) ) &amp;&amp; ( layercontentsdict = FindNode(layercontentsplist-&gt;children,&quot;array&quot;) ) ) {</span>
<span class="lineNum">    4085 </span><span class="lineNoCov">          0 :                                 layercontentslayercount = 0;</span>
<span class="lineNum">    4086 </span><span class="lineNoCov">          0 :                                 layernamesbuffersize = 2;</span>
<span class="lineNum">    4087 </span><span class="lineNoCov">          0 :                                 layernames = malloc(2*sizeof(char*)*layernamesbuffersize);</span>
<span class="lineNum">    4088 </span>            :                                 // Look through the children of the top-level array. Stop if one of them is not an array. (Ignore text objects since these probably just have whitespace.)
<span class="lineNum">    4089 </span><span class="lineNoCov">          0 :                                 for ( layercontentslayer = layercontentsdict-&gt;children ;</span>
<span class="lineNum">    4090 </span><span class="lineNoCov">          0 :                                 ( layercontentslayer != NULL ) &amp;&amp; ( ( xmlStrcmp(layercontentslayer-&gt;name,(const xmlChar *) &quot;array&quot;)==0 ) || ( xmlStrcmp(layercontentslayer-&gt;name,(const xmlChar *) &quot;text&quot;)==0 ) ) ;</span>
<span class="lineNum">    4091 </span><span class="lineNoCov">          0 :                                 layercontentslayer = layercontentslayer-&gt;next ) {</span>
<span class="lineNum">    4092 </span><span class="lineNoCov">          0 :                                         if ( xmlStrcmp(layercontentslayer-&gt;name,(const xmlChar *) &quot;array&quot;)==0 ) {</span>
<span class="lineNum">    4093 </span><span class="lineNoCov">          0 :                                                 xmlChar * layerlabel = NULL;</span>
<span class="lineNum">    4094 </span><span class="lineNoCov">          0 :                                                 xmlChar * layerglyphdirname = NULL;</span>
<span class="lineNum">    4095 </span><span class="lineNoCov">          0 :                                                 layercontentsvaluecount = 0;</span>
<span class="lineNum">    4096 </span>            :                                                 // Look through the children (effectively columns) of the layer array (the row). Reject non-string values.
<span class="lineNum">    4097 </span><span class="lineNoCov">          0 :                                                 for ( layercontentsvalue = layercontentslayer-&gt;children ;</span>
<span class="lineNum">    4098 </span><span class="lineNoCov">          0 :                                                 ( layercontentsvalue != NULL ) &amp;&amp; ( ( xmlStrcmp(layercontentsvalue-&gt;name,(const xmlChar *) &quot;string&quot;)==0 ) || ( xmlStrcmp(layercontentsvalue-&gt;name,(const xmlChar *) &quot;text&quot;)==0 ) ) ;</span>
<span class="lineNum">    4099 </span><span class="lineNoCov">          0 :                                                 layercontentsvalue = layercontentsvalue-&gt;next ) {</span>
<span class="lineNum">    4100 </span><span class="lineNoCov">          0 :                                                         if ( xmlStrcmp(layercontentsvalue-&gt;name,(const xmlChar *) &quot;string&quot;)==0 ) {</span>
<span class="lineNum">    4101 </span><span class="lineNoCov">          0 :                                                                 if (layercontentsvaluecount == 0) layerlabel = xmlNodeListGetString(layercontentsdoc, layercontentsvalue-&gt;xmlChildrenNode, true);</span>
<span class="lineNum">    4102 </span><span class="lineNoCov">          0 :                                                                 if (layercontentsvaluecount == 1) layerglyphdirname = xmlNodeListGetString(layercontentsdoc, layercontentsvalue-&gt;xmlChildrenNode, true);</span>
<span class="lineNum">    4103 </span><span class="lineNoCov">          0 :                                                                 layercontentsvaluecount++;</span>
<span class="lineNum">    4104 </span>            :                                                                 }
<span class="lineNum">    4105 </span>            :                                                 }
<span class="lineNum">    4106 </span>            :                                                 // We need two values (as noted above) per layer entry and ignore any layer lacking those.
<span class="lineNum">    4107 </span><span class="lineNoCov">          0 :                                                 if ((layercontentsvaluecount &gt; 1) &amp;&amp; (layernamesbuffersize &lt; INT_MAX/2)) {</span>
<span class="lineNum">    4108 </span>            :                                                         // Resize the layer names array as necessary.
<span class="lineNum">    4109 </span><span class="lineNoCov">          0 :                                                         if (layercontentslayercount &gt;= layernamesbuffersize) {</span>
<span class="lineNum">    4110 </span><span class="lineNoCov">          0 :                                                                 layernamesbuffersize *= 2;</span>
<span class="lineNum">    4111 </span><span class="lineNoCov">          0 :                                                                 layernames = realloc(layernames, 2*sizeof(char*)*layernamesbuffersize);</span>
<span class="lineNum">    4112 </span>            :                                                         }
<span class="lineNum">    4113 </span>            :                                                         // Fail silently on allocation failure; it's highly unlikely.
<span class="lineNum">    4114 </span><span class="lineNoCov">          0 :                                                         if (layernames != NULL) {</span>
<span class="lineNum">    4115 </span><span class="lineNoCov">          0 :                                                                 layernames[2*layercontentslayercount] = copy((char*)(layerlabel));</span>
<span class="lineNum">    4116 </span><span class="lineNoCov">          0 :                                                                 if (layernames[2*layercontentslayercount]) {</span>
<span class="lineNum">    4117 </span><span class="lineNoCov">          0 :                                                                         layernames[(2*layercontentslayercount)+1] = copy((char*)(layerglyphdirname));</span>
<span class="lineNum">    4118 </span><span class="lineNoCov">          0 :                                                                         if (layernames[(2*layercontentslayercount)+1])</span>
<span class="lineNum">    4119 </span><span class="lineNoCov">          0 :                                                                                 layercontentslayercount++; // We increment only if both pointers are valid so as to avoid read problems later.</span>
<span class="lineNum">    4120 </span>            :                                                                         else
<span class="lineNum">    4121 </span><span class="lineNoCov">          0 :                                                                                 free(layernames[2*layercontentslayercount]);</span>
<span class="lineNum">    4122 </span>            :                                                                 }
<span class="lineNum">    4123 </span>            :                                                         }
<span class="lineNum">    4124 </span>            :                                                 }
<span class="lineNum">    4125 </span><span class="lineNoCov">          0 :                                                 if (layerlabel != NULL) { xmlFree(layerlabel); layerlabel = NULL; }</span>
<span class="lineNum">    4126 </span><span class="lineNoCov">          0 :                                                 if (layerglyphdirname != NULL) { xmlFree(layerglyphdirname); layerglyphdirname = NULL; }</span>
<span class="lineNum">    4127 </span>            :                                         }
<span class="lineNum">    4128 </span>            :                                 }
<span class="lineNum">    4129 </span>            :                                 {
<span class="lineNum">    4130 </span>            :                                         // Some typefaces (from very reputable shops) identify as following version 2 of the U. F. O. specification
<span class="lineNum">    4131 </span>            :                                         // but have multiple layers and a layercontents.plist and omit the foreground layer from layercontents.plist.
<span class="lineNum">    4132 </span>            :                                         // So, if the layercontents.plist includes no foreground layer and makes no other use of the directory glyphs
<span class="lineNum">    4133 </span>            :                                         // and if that directory exists within the typeface, we map it to the foreground.
<span class="lineNum">    4134 </span>            :                                         // Note that FontForge cannot round-trip this anomaly at present and shall include the foreground in
<span class="lineNum">    4135 </span>            :                                         // layercontents.plist in any exported U. F. O..
<span class="lineNum">    4136 </span><span class="lineNoCov">          0 :                                         int tmply = 0; // Temporary layer index.</span>
<span class="lineNum">    4137 </span><span class="lineNoCov">          0 :                                         while (tmply &lt; layercontentslayercount &amp;&amp; strcmp(layernames[2*tmply], &quot;public.default&quot;) &amp;&amp;</span>
<span class="lineNum">    4138 </span><span class="lineNoCov">          0 :                                           strcmp(layernames[2*tmply+1], &quot;glyphs&quot;)) tmply ++;</span>
<span class="lineNum">    4139 </span>            :                                         // If tmply == layercontentslayercount then we know that no layer was named public.default and that no layer
<span class="lineNum">    4140 </span>            :                                         // used the glyphs directory.
<span class="lineNum">    4141 </span><span class="lineNoCov">          0 :                                         char * layerpath = buildname(basedir, &quot;glyphs&quot;);</span>
<span class="lineNum">    4142 </span><span class="lineNoCov">          0 :                                         if (tmply == layercontentslayercount &amp;&amp; layerpath != NULL &amp;&amp; GFileExists(layerpath)) {</span>
<span class="lineNum">    4143 </span><span class="lineNoCov">          0 :                                                 layercontentsvaluecount = 2;</span>
<span class="lineNum">    4144 </span>            :                                                 // Note the copying here.
<span class="lineNum">    4145 </span><span class="lineNoCov">          0 :                                                 xmlChar * layerlabel = (xmlChar*)&quot;public.default&quot;;</span>
<span class="lineNum">    4146 </span><span class="lineNoCov">          0 :                                                 xmlChar * layerglyphdirname = (xmlChar*)&quot;glyphs&quot;;</span>
<span class="lineNum">    4147 </span>            :                                                 // We need two values (as noted above) per layer entry and ignore any layer lacking those.
<span class="lineNum">    4148 </span><span class="lineNoCov">          0 :                                                 if ((layercontentsvaluecount &gt; 1) &amp;&amp; (layernamesbuffersize &lt; INT_MAX/2)) {</span>
<span class="lineNum">    4149 </span>            :                                                         // Resize the layer names array as necessary.
<span class="lineNum">    4150 </span><span class="lineNoCov">          0 :                                                         if (layercontentslayercount &gt;= layernamesbuffersize) {</span>
<span class="lineNum">    4151 </span><span class="lineNoCov">          0 :                                                                 layernamesbuffersize *= 2;</span>
<span class="lineNum">    4152 </span><span class="lineNoCov">          0 :                                                                 layernames = realloc(layernames, 2*sizeof(char*)*layernamesbuffersize);</span>
<span class="lineNum">    4153 </span>            :                                                         }
<span class="lineNum">    4154 </span>            :                                                         // Fail silently on allocation failure; it's highly unlikely.
<span class="lineNum">    4155 </span><span class="lineNoCov">          0 :                                                         if (layernames != NULL) {</span>
<span class="lineNum">    4156 </span><span class="lineNoCov">          0 :                                                                 layernames[2*layercontentslayercount] = copy((char*)(layerlabel));</span>
<span class="lineNum">    4157 </span><span class="lineNoCov">          0 :                                                                 if (layernames[2*layercontentslayercount]) {</span>
<span class="lineNum">    4158 </span><span class="lineNoCov">          0 :                                                                         layernames[(2*layercontentslayercount)+1] = copy((char*)(layerglyphdirname));</span>
<span class="lineNum">    4159 </span><span class="lineNoCov">          0 :                                                                         if (layernames[(2*layercontentslayercount)+1])</span>
<span class="lineNum">    4160 </span><span class="lineNoCov">          0 :                                                                                 layercontentslayercount++; // We increment only if both pointers are valid so as to avoid read problems later.</span>
<span class="lineNum">    4161 </span>            :                                                                         else
<span class="lineNum">    4162 </span><span class="lineNoCov">          0 :                                                                                 free(layernames[2*layercontentslayercount]);</span>
<span class="lineNum">    4163 </span>            :                                                                 }
<span class="lineNum">    4164 </span>            :                                                         }
<span class="lineNum">    4165 </span>            :                                                 }
<span class="lineNum">    4166 </span>            :                                         }
<span class="lineNum">    4167 </span><span class="lineNoCov">          0 :                                         if (layerpath != NULL) { free(layerpath); layerpath = NULL; }</span>
<span class="lineNum">    4168 </span>            :                                 }
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span><span class="lineNoCov">          0 :                                 if (layernames != NULL) {</span>
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 :                                         int lcount = 0;</span>
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :                                         int auxpos = 2;</span>
<span class="lineNum">    4173 </span><span class="lineNoCov">          0 :                                         int layerdest = 0;</span>
<span class="lineNum">    4174 </span><span class="lineNoCov">          0 :                                         int bg = 1;</span>
<span class="lineNum">    4175 </span><span class="lineNoCov">          0 :                                         if (layercontentslayercount &gt; 0) {</span>
<span class="lineNum">    4176 </span>            :                                                 // Start reading layers.
<span class="lineNum">    4177 </span><span class="lineNoCov">          0 :                                                 for (lcount = 0; lcount &lt; layercontentslayercount; lcount++) {</span>
<span class="lineNum">    4178 </span>            :                                                         // We refuse to load a layer with an incorrect prefix.
<span class="lineNum">    4179 </span><span class="lineNoCov">          0 :                                                         if (</span>
<span class="lineNum">    4180 </span><span class="lineNoCov">          0 :                                                         (((strcmp(layernames[2*lcount],&quot;public.default&quot;)==0) &amp;&amp;</span>
<span class="lineNum">    4181 </span><span class="lineNoCov">          0 :                                                         (strcmp(layernames[2*lcount+1],&quot;glyphs&quot;) == 0)) ||</span>
<span class="lineNum">    4182 </span><span class="lineNoCov">          0 :                                                         (strstr(layernames[2*lcount+1],&quot;glyphs.&quot;) == layernames[2*lcount+1])) &amp;&amp;</span>
<span class="lineNum">    4183 </span><span class="lineNoCov">          0 :                                                         (glyphdir = buildname(basedir,layernames[2*lcount+1]))) {</span>
<span class="lineNum">    4184 </span><span class="lineNoCov">          0 :                                                                 if ((glyphlist = buildname(glyphdir,&quot;contents.plist&quot;))) {</span>
<span class="lineNum">    4185 </span><span class="lineNoCov">          0 :                                                                         if ( !GFileExists(glyphlist)) {</span>
<span class="lineNum">    4186 </span><span class="lineNoCov">          0 :                                                                                 LogError(_(&quot;No glyphs directory or no contents file&quot;));</span>
<span class="lineNum">    4187 </span>            :                                                                         } else {
<span class="lineNum">    4188 </span>            :                                                                                 // Only public.default gets mapped as a foreground layer.
<span class="lineNum">    4189 </span><span class="lineNoCov">          0 :                                                                                 bg = 1;</span>
<span class="lineNum">    4190 </span>            :                                                                                 // public.default and public.background have fixed mappings. Other layers start at 2.
<span class="lineNum">    4191 </span><span class="lineNoCov">          0 :                                                                                 if (strcmp(layernames[2*lcount],&quot;public.default&quot;)==0) {</span>
<span class="lineNum">    4192 </span><span class="lineNoCov">          0 :                                                                                         layerdest = ly_fore;</span>
<span class="lineNum">    4193 </span><span class="lineNoCov">          0 :                                                                                         bg = 0;</span>
<span class="lineNum">    4194 </span><span class="lineNoCov">          0 :                                                                                 } else if (strcmp(layernames[2*lcount],&quot;public.background&quot;)==0) {</span>
<span class="lineNum">    4195 </span><span class="lineNoCov">          0 :                                                                                         layerdest = ly_back;</span>
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :                                                                                         sf-&gt;multilayer |= 1;</span>
<span class="lineNum">    4197 </span>            :                                                                                 } else {
<span class="lineNum">    4198 </span><span class="lineNoCov">          0 :                                                                                         layerdest = auxpos++;</span>
<span class="lineNum">    4199 </span><span class="lineNoCov">          0 :                                                                                         sf-&gt;multilayer |= 1;</span>
<span class="lineNum">    4200 </span>            :                                                                                 }
<span class="lineNum">    4201 </span>            : 
<span class="lineNum">    4202 </span>            :                                                                                 // We ensure that the splinefont layer list has sufficient space.
<span class="lineNum">    4203 </span><span class="lineNoCov">          0 :                                                                                 if ( layerdest+1&gt;sf-&gt;layer_cnt ) {</span>
<span class="lineNum">    4204 </span><span class="lineNoCov">          0 :                                                                                     sf-&gt;layers = realloc(sf-&gt;layers,(layerdest+1)*sizeof(LayerInfo));</span>
<span class="lineNum">    4205 </span><span class="lineNoCov">          0 :                                                                                     memset(sf-&gt;layers+sf-&gt;layer_cnt,0,((layerdest+1)-sf-&gt;layer_cnt)*sizeof(LayerInfo));</span>
<span class="lineNum">    4206 </span><span class="lineNoCov">          0 :                                                                                     sf-&gt;layer_cnt = layerdest+1;</span>
<span class="lineNum">    4207 </span>            :                                                                                 }
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span>            :                                                                                 // The check is redundant, but it allows us to copy from sfd.c.
<span class="lineNum">    4210 </span><span class="lineNoCov">          0 :                                                                                 if (( layerdest&lt;sf-&gt;layer_cnt ) &amp;&amp; sf-&gt;layers) {</span>
<span class="lineNum">    4211 </span><span class="lineNoCov">          0 :                                                                                         if (sf-&gt;layers[layerdest].name)</span>
<span class="lineNum">    4212 </span><span class="lineNoCov">          0 :                                                                                                 free(sf-&gt;layers[layerdest].name);</span>
<span class="lineNum">    4213 </span><span class="lineNoCov">          0 :                                                                                         sf-&gt;layers[layerdest].name = strdup(layernames[2*lcount]);</span>
<span class="lineNum">    4214 </span><span class="lineNoCov">          0 :                                                                                         if (sf-&gt;layers[layerdest].ufo_path)</span>
<span class="lineNum">    4215 </span><span class="lineNoCov">          0 :                                                                                                 free(sf-&gt;layers[layerdest].ufo_path);</span>
<span class="lineNum">    4216 </span><span class="lineNoCov">          0 :                                                                                         sf-&gt;layers[layerdest].ufo_path = strdup(layernames[2*lcount+1]);</span>
<span class="lineNum">    4217 </span><span class="lineNoCov">          0 :                                                                                         sf-&gt;layers[layerdest].background = bg;</span>
<span class="lineNum">    4218 </span>            :                                                                                         // Fetch glyphs.
<span class="lineNum">    4219 </span><span class="lineNoCov">          0 :                                                                                         UFOLoadGlyphs(sf,glyphdir,layerdest);</span>
<span class="lineNum">    4220 </span>            :                                                                                         // Determine layer spline order.
<span class="lineNum">    4221 </span><span class="lineNoCov">          0 :                                                                                         sf-&gt;layers[layerdest].order2 = SFLFindOrder(sf,layerdest);</span>
<span class="lineNum">    4222 </span>            :                                                                                         // Conform layer spline order (reworking control points if necessary).
<span class="lineNum">    4223 </span><span class="lineNoCov">          0 :                                                                                         SFLSetOrder(sf,layerdest,sf-&gt;layers[layerdest].order2);</span>
<span class="lineNum">    4224 </span>            :                                                                                         // Set the grid order to the foreground order if appropriate.
<span class="lineNum">    4225 </span><span class="lineNoCov">          0 :                                                                                         if (layerdest == ly_fore) sf-&gt;grid.order2 = sf-&gt;layers[layerdest].order2;</span>
<span class="lineNum">    4226 </span>            :                                                                                 }
<span class="lineNum">    4227 </span>            :                                                                         }
<span class="lineNum">    4228 </span><span class="lineNoCov">          0 :                                                                         free(glyphlist);</span>
<span class="lineNum">    4229 </span>            :                                                                 }
<span class="lineNum">    4230 </span><span class="lineNoCov">          0 :                                                                 free(glyphdir);</span>
<span class="lineNum">    4231 </span>            :                                                         }
<span class="lineNum">    4232 </span>            :                                                 }
<span class="lineNum">    4233 </span>            :                                         } else {
<span class="lineNum">    4234 </span><span class="lineNoCov">          0 :                                                 LogError(_(&quot;layercontents.plist lists no valid layers.&quot;));</span>
<span class="lineNum">    4235 </span>            :                                         }
<span class="lineNum">    4236 </span>            :                                         // Free layer names.
<span class="lineNum">    4237 </span><span class="lineNoCov">          0 :                                         for (lcount = 0; lcount &lt; layercontentslayercount; lcount++) {</span>
<span class="lineNum">    4238 </span><span class="lineNoCov">          0 :                                                 if (layernames[2*lcount]) free(layernames[2*lcount]);</span>
<span class="lineNum">    4239 </span><span class="lineNoCov">          0 :                                                 if (layernames[2*lcount+1]) free(layernames[2*lcount+1]);</span>
<span class="lineNum">    4240 </span>            :                                         }
<span class="lineNum">    4241 </span><span class="lineNoCov">          0 :                                         free(layernames);</span>
<span class="lineNum">    4242 </span>            :                                 }
<span class="lineNum">    4243 </span>            :                         }
<span class="lineNum">    4244 </span><span class="lineNoCov">          0 :                         xmlFreeDoc(layercontentsdoc);</span>
<span class="lineNum">    4245 </span>            :                 }
<span class="lineNum">    4246 </span>            :         } else {
<span class="lineNum">    4247 </span><span class="lineNoCov">          0 :                 glyphdir = buildname(basedir,&quot;glyphs&quot;);</span>
<span class="lineNum">    4248 </span><span class="lineNoCov">          0 :         glyphlist = buildname(glyphdir,&quot;contents.plist&quot;);</span>
<span class="lineNum">    4249 </span><span class="lineNoCov">          0 :         if ( !GFileExists(glyphlist)) {</span>
<span class="lineNum">    4250 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;No glyphs directory or no contents file&quot;));</span>
<span class="lineNum">    4251 </span>            :         } else {
<span class="lineNum">    4252 </span><span class="lineNoCov">          0 :                         UFOLoadGlyphs(sf,glyphdir,ly_fore);</span>
<span class="lineNum">    4253 </span><span class="lineNoCov">          0 :                         sf-&gt;layers[ly_fore].order2 = sf-&gt;layers[ly_back].order2 = sf-&gt;grid.order2 =</span>
<span class="lineNum">    4254 </span><span class="lineNoCov">          0 :                     SFFindOrder(sf);</span>
<span class="lineNum">    4255 </span><span class="lineNoCov">          0 :                 SFSetOrder(sf,sf-&gt;layers[ly_fore].order2);</span>
<span class="lineNum">    4256 </span>            :                 }
<span class="lineNum">    4257 </span><span class="lineNoCov">          0 :             free(glyphlist);</span>
<span class="lineNum">    4258 </span><span class="lineNoCov">          0 :                 free(glyphdir);</span>
<span class="lineNum">    4259 </span>            :         }
<span class="lineNum">    4260 </span><span class="lineNoCov">          0 :         free(layercontentsname);</span>
<span class="lineNum">    4261 </span>            : 
<span class="lineNum">    4262 </span><span class="lineNoCov">          0 :     sf-&gt;map = EncMap1to1(sf-&gt;glyphcnt);</span>
<span class="lineNum">    4263 </span>            : 
<span class="lineNum">    4264 </span><span class="lineNoCov">          0 :     UFOHandleGroups(sf, basedir);</span>
<span class="lineNum">    4265 </span>            : 
<span class="lineNum">    4266 </span><span class="lineNoCov">          0 :     UFOHandleKern3(sf,basedir,0);</span>
<span class="lineNum">    4267 </span><span class="lineNoCov">          0 :     UFOHandleKern3(sf,basedir,1);</span>
<span class="lineNum">    4268 </span>            : 
<span class="lineNum">    4269 </span>            :     /* Might as well check for feature files even if version 1 */
<span class="lineNum">    4270 </span><span class="lineNoCov">          0 :     temp = buildname(basedir,&quot;features.fea&quot;);</span>
<span class="lineNum">    4271 </span><span class="lineNoCov">          0 :     if ( GFileExists(temp))</span>
<span class="lineNum">    4272 </span><span class="lineNoCov">          0 :         SFApplyFeatureFilename(sf,temp);</span>
<span class="lineNum">    4273 </span><span class="lineNoCov">          0 :     free(temp);</span>
<span class="lineNum">    4274 </span>            : 
<span class="lineNum">    4275 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :     temp = buildname(basedir,&quot;lib.plist&quot;);</span>
<span class="lineNum">    4277 </span><span class="lineNoCov">          0 :     doc = NULL;</span>
<span class="lineNum">    4278 </span><span class="lineNoCov">          0 :     if ( GFileExists(temp))</span>
<span class="lineNum">    4279 </span><span class="lineNoCov">          0 :         doc = xmlParseFile(temp);</span>
<span class="lineNum">    4280 </span><span class="lineNoCov">          0 :     free(temp);</span>
<span class="lineNum">    4281 </span><span class="lineNoCov">          0 :     if ( doc!=NULL ) {</span>
<span class="lineNum">    4282 </span><span class="lineNoCov">          0 :                 plist = xmlDocGetRootElement(doc);</span>
<span class="lineNum">    4283 </span><span class="lineNoCov">          0 :                 dict = NULL;</span>
<span class="lineNum">    4284 </span><span class="lineNoCov">          0 :                 if ( plist!=NULL )</span>
<span class="lineNum">    4285 </span><span class="lineNoCov">          0 :                         dict = FindNode(plist-&gt;children,&quot;dict&quot;);</span>
<span class="lineNum">    4286 </span><span class="lineNoCov">          0 :                 if ( plist==NULL ||</span>
<span class="lineNum">    4287 </span><span class="lineNoCov">          0 :                         xmlStrcmp(plist-&gt;name,(const xmlChar *) &quot;plist&quot;)!=0 ||</span>
<span class="lineNum">    4288 </span>            :                         dict==NULL ) {
<span class="lineNum">    4289 </span><span class="lineNoCov">          0 :                         LogError(_(&quot;Expected property list file&quot;));</span>
<span class="lineNum">    4290 </span>            :                 } else {
<span class="lineNum">    4291 </span><span class="lineNoCov">          0 :                         sf-&gt;python_persistent = LibToPython(doc,dict,1);</span>
<span class="lineNum">    4292 </span><span class="lineNoCov">          0 :                         sf-&gt;python_persistent_has_lists = 1;</span>
<span class="lineNum">    4293 </span>            :                 }
<span class="lineNum">    4294 </span><span class="lineNoCov">          0 :                 xmlFreeDoc(doc);</span>
<span class="lineNum">    4295 </span>            :     }
<span class="lineNum">    4296 </span>            : #endif
<span class="lineNum">    4297 </span><span class="lineNoCov">          0 :     switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.</span>
<span class="lineNum">    4298 </span><span class="lineNoCov">          0 : return( sf );</span>
<a name="4299"><span class="lineNum">    4299 </span>            : }</a>
<span class="lineNum">    4300 </span>            : 
<span class="lineNum">    4301 </span><span class="lineNoCov">          0 : SplineSet *SplinePointListInterpretGlif(SplineFont *sf,char *filename,char *memory, int memlen,</span>
<span class="lineNum">    4302 </span>            :         int em_size,int ascent,int is_stroked) {
<span class="lineNum">    4303 </span>            :     xmlDocPtr doc;
<span class="lineNum">    4304 </span>            :     SplineChar *sc;
<span class="lineNum">    4305 </span>            :     SplineSet *ss;
<span class="lineNum">    4306 </span>            : 
<span class="lineNum">    4307 </span><span class="lineNoCov">          0 :     if ( !libxml_init_base()) {</span>
<span class="lineNum">    4308 </span><span class="lineNoCov">          0 :         LogError(_(&quot;Can't find libxml2.&quot;));</span>
<span class="lineNum">    4309 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    4310 </span>            :     }
<span class="lineNum">    4311 </span><span class="lineNoCov">          0 :     if ( filename!=NULL )</span>
<span class="lineNum">    4312 </span><span class="lineNoCov">          0 :         doc = xmlParseFile(filename);</span>
<span class="lineNum">    4313 </span>            :     else
<span class="lineNum">    4314 </span><span class="lineNoCov">          0 :         doc = xmlParseMemory(memory,memlen);</span>
<span class="lineNum">    4315 </span><span class="lineNoCov">          0 :     if ( doc==NULL )</span>
<span class="lineNum">    4316 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    4317 </span>            : 
<span class="lineNum">    4318 </span>            :     locale_t tmplocale; locale_t oldlocale; // Declare temporary locale storage.
<span class="lineNum">    4319 </span><span class="lineNoCov">          0 :     switch_to_c_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the C locale temporarily and cache the old locale.</span>
<span class="lineNum">    4320 </span><span class="lineNoCov">          0 :     setlocale(LC_NUMERIC,&quot;C&quot;);</span>
<span class="lineNum">    4321 </span><span class="lineNoCov">          0 :     sc = _UFOLoadGlyph(sf,doc,filename,NULL,NULL,ly_fore);</span>
<span class="lineNum">    4322 </span><span class="lineNoCov">          0 :     switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.</span>
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span><span class="lineNoCov">          0 :     if ( sc==NULL )</span>
<span class="lineNum">    4325 </span><span class="lineNoCov">          0 : return( NULL );</span>
<span class="lineNum">    4326 </span>            : 
<span class="lineNum">    4327 </span><span class="lineNoCov">          0 :     ss = sc-&gt;layers[ly_fore].splines;</span>
<span class="lineNum">    4328 </span><span class="lineNoCov">          0 :     sc-&gt;layers[ly_fore].splines = NULL;</span>
<span class="lineNum">    4329 </span><span class="lineNoCov">          0 :     SplineCharFree(sc);</span>
<span class="lineNum">    4330 </span><span class="lineNoCov">          0 : return( ss );</span>
<a name="4331"><span class="lineNum">    4331 </span>            : }</a>
<span class="lineNum">    4332 </span>            : 
<span class="lineNum">    4333 </span><span class="lineNoCov">          0 : int HasUFO(void) {</span>
<span class="lineNum">    4334 </span><span class="lineNoCov">          0 : return( libxml_init_base());</span>
<span class="lineNum">    4335 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
