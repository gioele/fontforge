<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd) - fontforge/splinefont.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">fontforge</a> - splinefont.h<span style="font-size: 80%;"> (source / <a href="splinefont.h.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">FontForge coverage report 2017-08-04 01:21:11+02:00 (commit d35f7e4107a9e1db65cce47c468fcc914cecb8fd)</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntryLo">52.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-08-04</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">40.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Copyright (C) 2000-2012 by George Williams */</a>
<span class="lineNum">       2 </span>            : /*
<span class="lineNum">       3 </span>            :  * Redistribution and use in source and binary forms, with or without
<span class="lineNum">       4 </span>            :  * modification, are permitted provided that the following conditions are met:
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            :  * Redistributions of source code must retain the above copyright notice, this
<span class="lineNum">       7 </span>            :  * list of conditions and the following disclaimer.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            :  * Redistributions in binary form must reproduce the above copyright notice,
<span class="lineNum">      10 </span>            :  * this list of conditions and the following disclaimer in the documentation
<span class="lineNum">      11 </span>            :  * and/or other materials provided with the distribution.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            :  * The name of the author may not be used to endorse or promote products
<span class="lineNum">      14 </span>            :  * derived from this software without specific prior written permission.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
<span class="lineNum">      17 </span>            :  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
<span class="lineNum">      18 </span>            :  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
<span class="lineNum">      19 </span>            :  * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      20 </span>            :  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      21 </span>            :  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
<span class="lineNum">      22 </span>            :  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
<span class="lineNum">      23 </span>            :  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
<span class="lineNum">      24 </span>            :  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
<span class="lineNum">      25 </span>            :  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      26 </span>            :  */
<span class="lineNum">      27 </span>            : #ifndef _SPLINEFONT_H
<span class="lineNum">      28 </span>            : #define _SPLINEFONT_H
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;basics.h&gt;
<span class="lineNum">      31 </span>            : #include &lt;dlist.h&gt;
<span class="lineNum">      32 </span>            : #include &quot;configure-fontforge.h&quot;
<span class="lineNum">      33 </span>            : #ifdef HAVE_ICONV
<span class="lineNum">      34 </span>            : # include &lt;iconv.h&gt;
<span class="lineNum">      35 </span>            : #else
<span class="lineNum">      36 </span>            : # include &lt;gwwiconv.h&gt;
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : #include &quot;locale.h&quot;
<span class="lineNum">      39 </span>            : #include &lt;gnetwork.h&gt;
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : #ifdef FONTFORGE_CONFIG_USE_DOUBLE
<span class="lineNum">      42 </span>            : # define real           double
<span class="lineNum">      43 </span>            : # define bigreal        double
<span class="lineNum">      44 </span>            : #else
<span class="lineNum">      45 </span>            : # define real           float
<span class="lineNum">      46 </span>            : # define bigreal        double
<span class="lineNum">      47 </span>            : #endif
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : #define extended        double
<span class="lineNum">      50 </span>            :         /* Solaris wants to define extended to be unsigned [3] unless we do this*/
<span class="lineNum">      51 </span>            : #define _EXTENDED
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : #define CHR(ch1,ch2,ch3,ch4) (((ch1)&lt;&lt;24)|((ch2)&lt;&lt;16)|((ch3)&lt;&lt;8)|(ch4))
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            : #define MmMax           16      /* PS says at most this many instances for type1/2 mm fonts */
<span class="lineNum">      56 </span>            : #define AppleMmMax      26      /* Apple sort of has a limit of 4095, but we only support this many */
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* The maximum number of layers allowed in a normal font (this includes the */
<span class="lineNum">      60 </span>            : /*  default foreground and background layers) -- this does not limit type3  */
<span class="lineNum">      61 </span>            : /*  fonts */
<span class="lineNum">      62 </span>            : #define BACK_LAYER_MAX 256
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : typedef struct ipoint {
<span class="lineNum">      66 </span>            :     int x;
<span class="lineNum">      67 </span>            :     int y;
<span class="lineNum">      68 </span>            : } IPoint;
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            : #define IPOINT_EMPTY { 0, 0 }
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : typedef struct basepoint {
<span class="lineNum">      74 </span>            :     real x;
<span class="lineNum">      75 </span>            :     real y;
<span class="lineNum">      76 </span>            : } BasePoint;
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : #define BASEPOINT_EMPTY { (real)0.0, (real)0.0 }
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : typedef struct dbasepoint {
<span class="lineNum">      82 </span>            :     bigreal x;
<span class="lineNum">      83 </span>            :     bigreal y;
<span class="lineNum">      84 </span>            : } DBasePoint;
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : #define DBASEPOINT_EMPTY { (bigreal)0.0, (bigreal)0.0 }
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : typedef struct tpoint {
<span class="lineNum">      90 </span>            :     real x;
<span class="lineNum">      91 </span>            :     real y;
<span class="lineNum">      92 </span>            :     real t;
<span class="lineNum">      93 </span>            : } TPoint;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : #define TPOINT_EMPTY { (real)0.0, (real)0.0, (real)0.0 }
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : typedef struct dbounds {
<span class="lineNum">      99 </span>            :     real minx, maxx;
<span class="lineNum">     100 </span>            :     real miny, maxy;
<span class="lineNum">     101 </span>            : } DBounds;
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : #define DBOUNDS_EMPTY { (real)0.0, (real)0.0, (real)0.0, (real)0.0 }
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : typedef struct ibounds {
<span class="lineNum">     107 </span>            :     int minx, maxx;
<span class="lineNum">     108 </span>            :     int miny, maxy;
<span class="lineNum">     109 </span>            : } IBounds;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : #define IBOUNDS_EMPTY { 0, 0, 0, 0 }
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : enum val_type { v_int, v_real, v_str, v_unicode, v_lval, v_arr, v_arrfree,
<span class="lineNum">     115 </span>            :                 v_int32pt, v_int16pt, v_int8pt, v_void };
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            : typedef struct val {
<span class="lineNum">     118 </span>            :     enum val_type type;
<span class="lineNum">     119 </span>            :     union {
<span class="lineNum">     120 </span>            :         int ival;
<span class="lineNum">     121 </span>            :         real fval;
<span class="lineNum">     122 </span>            :         char *sval;
<span class="lineNum">     123 </span>            :         struct val *lval;
<span class="lineNum">     124 </span>            :         struct array *aval;
<span class="lineNum">     125 </span>            :         uint32 *u32ptval;
<span class="lineNum">     126 </span>            :         uint16 *u16ptval;
<span class="lineNum">     127 </span>            :         uint8  *u8ptval;
<span class="lineNum">     128 </span>            :     } u;
<span class="lineNum">     129 </span>            : } Val;          /* Used by scripting */
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : struct psdict {
<span class="lineNum">     132 </span>            :     int cnt;            /* *key[0..cnt] and *values[0..cnt] currently available */
<span class="lineNum">     133 </span>            :     int next;           /* **key[0..next] and **values[0..next] currently used  */
<span class="lineNum">     134 </span>            :     char **keys;
<span class="lineNum">     135 </span>            :     char **values;
<span class="lineNum">     136 </span>            : };
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : struct pschars {
<span class="lineNum">     139 </span>            :     int cnt, next;
<span class="lineNum">     140 </span>            :     char **keys;
<span class="lineNum">     141 </span>            :     uint8 **values;
<span class="lineNum">     142 </span>            :     int *lens;
<span class="lineNum">     143 </span>            :     int bias;           /* for type2 strings */
<span class="lineNum">     144 </span>            : };
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : enum linejoin {
<span class="lineNum">     147 </span>            :     lj_miter,           /* Extend lines until they meet */
<span class="lineNum">     148 </span>            :     lj_round,           /* circle centered at the join of expand radius */
<span class="lineNum">     149 </span>            :     lj_bevel,           /* Straight line between the ends of next and prev */
<span class="lineNum">     150 </span>            :     lj_inherited
<span class="lineNum">     151 </span>            : };
<span class="lineNum">     152 </span>            : enum linecap {
<span class="lineNum">     153 </span>            :     lc_butt,            /* equiv to lj_bevel, straight line extends from one side to other */
<span class="lineNum">     154 </span>            :     lc_round,           /* semi-circle */
<span class="lineNum">     155 </span>            :     lc_square,          /* Extend lines by radius, then join them */
<span class="lineNum">     156 </span>            :     lc_inherited
<span class="lineNum">     157 </span>            : };
<span class="lineNum">     158 </span>            : enum spreadMethod {
<span class="lineNum">     159 </span>            :     sm_pad, sm_reflect, sm_repeat
<span class="lineNum">     160 </span>            : };
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            : #define COLOR_INHERITED 0xfffffffe
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : struct grad_stops {
<span class="lineNum">     165 </span>            :     real offset;
<span class="lineNum">     166 </span>            :     uint32 col;
<span class="lineNum">     167 </span>            :     real opacity;
<span class="lineNum">     168 </span>            : };
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            : struct gradient {
<span class="lineNum">     171 </span>            :     BasePoint start;    /* focal of a radial gradient, start of a linear */
<span class="lineNum">     172 </span>            :     BasePoint stop;     /* center of a radial gradient, end of a linear */
<span class="lineNum">     173 </span>            :     real radius;        /* 0=&gt;linear gradient, else radius of a radial gradient */
<span class="lineNum">     174 </span>            :     enum spreadMethod sm;
<span class="lineNum">     175 </span>            :     int stop_cnt;
<span class="lineNum">     176 </span>            :     struct grad_stops *grad_stops;
<span class="lineNum">     177 </span>            : };
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : struct pattern {
<span class="lineNum">     180 </span>            :     char *pattern;
<span class="lineNum">     181 </span>            :     real width, height;         /* Pattern is scaled to be repeated every width/height (in user coordinates) */
<span class="lineNum">     182 </span>            :     real transform[6];
<span class="lineNum">     183 </span>            :     /* Used during rasterization process */
<span class="lineNum">     184 </span>            :     struct bdfchar *pat;
<span class="lineNum">     185 </span>            :     real invtrans[6];
<span class="lineNum">     186 </span>            :     int bminx, bminy, bwidth, bheight;  /* of the pattern at bdfchar scale */
<span class="lineNum">     187 </span>            : };
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : struct brush {
<span class="lineNum">     190 </span>            :     uint32 col;
<span class="lineNum">     191 </span>            :     float opacity;              /* number between [0,1], only for svg/pdf */
<span class="lineNum">     192 </span>            :     struct pattern *pattern;    /* A pattern to be tiled */
<span class="lineNum">     193 </span>            :     struct gradient *gradient;  /* A gradient fill */
<span class="lineNum">     194 </span>            : };
<span class="lineNum">     195 </span>            : #define WIDTH_INHERITED (-1)
<span class="lineNum">     196 </span>            : #define DASH_INHERITED  255     /* if the dashes[0]==0 &amp;&amp; dashes[1]==DASH_INHERITED */
<span class="lineNum">     197 </span>            : #define DASH_MAX        8
<span class="lineNum">     198 </span>            : typedef unsigned char DashType;
<span class="lineNum">     199 </span>            : struct pen {
<span class="lineNum">     200 </span>            :     struct brush brush;
<span class="lineNum">     201 </span>            :     uint8 linejoin;
<span class="lineNum">     202 </span>            :     uint8 linecap;
<span class="lineNum">     203 </span>            :     float width;
<span class="lineNum">     204 </span>            :     real trans[4];
<span class="lineNum">     205 </span>            :     DashType dashes[DASH_MAX];
<span class="lineNum">     206 </span>            : };
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            : struct spline;
<span class="lineNum">     209 </span>            : enum si_type { si_std, si_caligraphic, si_poly, si_centerline };
<span class="lineNum">     210 </span>            : /* If you change this structure you may need to update MakeStrokeDlg */
<span class="lineNum">     211 </span>            : /*  and cvpalettes.c both contain statically initialized StrokeInfos */
<span class="lineNum">     212 </span>            : typedef struct strokeinfo {
<span class="lineNum">     213 </span>            :     real radius;                        /* or major axis of pen */
<span class="lineNum">     214 </span>            :     enum linejoin join;
<span class="lineNum">     215 </span>            :     enum linecap cap;
<span class="lineNum">     216 </span>            :     enum si_type stroke_type;
<span class="lineNum">     217 </span>            :     unsigned int removeinternal: 1;
<span class="lineNum">     218 </span>            :     unsigned int removeexternal: 1;
<span class="lineNum">     219 </span>            :     unsigned int leave_users_center: 1;                 /* Don't move the pen so its center is at the origin */
<span class="lineNum">     220 </span>            :     real penangle;
<span class="lineNum">     221 </span>            :     real minorradius;
<span class="lineNum">     222 </span>            :     struct splinepointlist *poly;
<span class="lineNum">     223 </span>            :     real resolution;
<span class="lineNum">     224 </span>            : /* For freehand tool */
<span class="lineNum">     225 </span>            :     real radius2;
<span class="lineNum">     226 </span>            :     int pressure1, pressure2;
<span class="lineNum">     227 </span>            : /* End freehand tool */
<span class="lineNum">     228 </span>            :     void *data;
<span class="lineNum">     229 </span>            :     bigreal (*factor)(void *data,struct spline *spline,real t);
<span class="lineNum">     230 </span>            : } StrokeInfo;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            : enum overlap_type { over_remove, over_rmselected, over_intersect, over_intersel,
<span class="lineNum">     233 </span>            :         over_exclude, over_findinter, over_fisel };
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : enum simpify_flags { sf_cleanup=-1, sf_normal=0, sf_ignoreslopes=1,
<span class="lineNum">     236 </span>            :         sf_ignoreextremum=2, sf_smoothcurves=4, sf_choosehv=8,
<span class="lineNum">     237 </span>            :         sf_forcelines=0x10, sf_nearlyhvlines=0x20,
<span class="lineNum">     238 </span>            :         sf_mergelines=0x40, sf_setstart2extremum=0x80,
<span class="lineNum">     239 </span>            :         sf_rmsingletonpoints=0x100 };
<span class="lineNum">     240 </span>            : struct simplifyinfo {
<span class="lineNum">     241 </span>            :     int flags;
<span class="lineNum">     242 </span>            :     bigreal err;
<span class="lineNum">     243 </span>            :     bigreal tan_bounds;
<span class="lineNum">     244 </span>            :     bigreal linefixup;
<span class="lineNum">     245 </span>            :     bigreal linelenmax;         /* Don't simplify any straight lines longer than this */
<span class="lineNum">     246 </span>            :     int set_as_default;
<span class="lineNum">     247 </span>            :     int check_selected_contours;
<span class="lineNum">     248 </span>            : };
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : struct hsquash { double lsb_percent, stem_percent, counter_percent, rsb_percent; };
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : enum serif_type { srf_flat, srf_simpleslant, srf_complexslant };
<span class="lineNum">     253 </span>            : /* |    | (flat)    |   | (simple)     |    | (complex) */
<span class="lineNum">     254 </span>            : /* |    |           |  /               |   /            */
<span class="lineNum">     255 </span>            : /* |    |           | /                |  /             */
<span class="lineNum">     256 </span>            : /* +----+           |/                 \ /              */
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            : typedef struct italicinfo {
<span class="lineNum">     259 </span>            :     double italic_angle;
<span class="lineNum">     260 </span>            :     double xheight_percent;
<span class="lineNum">     261 </span>            :     struct hsquash lc, uc, neither;
<span class="lineNum">     262 </span>            :     enum serif_type secondary_serif;
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :     unsigned int transform_bottom_serifs: 1;
<span class="lineNum">     265 </span>            :     unsigned int transform_top_xh_serifs: 1;    /* Those at x-height */
<span class="lineNum">     266 </span>            :     unsigned int transform_top_as_serifs: 1;    /* Those at ascender-height */
<span class="lineNum">     267 </span>            :     unsigned int transform_diagon_serifs: 1;    /* Those at baseline/xheight */
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :     unsigned int a_from_d: 1;           /* replace the &quot;a&quot; glyph with the variant which looks like a &quot;d&quot; without an ascender */
<span class="lineNum">     270 </span>            :   /* When I say &quot;f&quot; I also mean &quot;f_f&quot; ligature, &quot;longs&quot;, cyrillic phi and other things shaped like &quot;f&quot; */
<span class="lineNum">     271 </span>            :     unsigned int f_long_tail: 1;        /* Some Italic fonts have the &quot;f&quot; grow an extension of the main stem below the baseline */
<span class="lineNum">     272 </span>            :     unsigned int f_rotate_top: 1;       /* Most Italic fonts take the top curve of the &quot;f&quot;, rotate it 180 and attach to the bottom */
<span class="lineNum">     273 </span>            :     unsigned int pq_deserif: 1;         /* Remove a serif from the descender of p or q and replace with a secondary serif as above */
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :   /* Unsupported */
<span class="lineNum">     276 </span>            :     /* e becomes rounder, cross bar slightly slanted */
<span class="lineNum">     277 </span>            :     /* g closed counter at bottom */
<span class="lineNum">     278 </span>            :     /* k closed counter at top */
<span class="lineNum">     279 </span>            :     /* v-z diagonal stems become more curvatious */
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :     unsigned int cyrl_phi: 1;           /* Gains an &quot;f&quot; like top, bottom treated like &quot;f&quot; */
<span class="lineNum">     282 </span>            :     unsigned int cyrl_i: 1;             /* Turns into a latin u */
<span class="lineNum">     283 </span>            :     unsigned int cyrl_pi: 1;            /* Turns into a latin n */
<span class="lineNum">     284 </span>            :     unsigned int cyrl_te: 1;            /* Turns into a latin m */
<span class="lineNum">     285 </span>            :     unsigned int cyrl_sha: 1;           /* Turns into a latin m rotated 180 */
<span class="lineNum">     286 </span>            :     unsigned int cyrl_dje: 1;           /* Turns into a latin smallcaps T */
<span class="lineNum">     287 </span>            :     unsigned int cyrl_dzhe: 1;          /* Turns into a latin u */
<span class="lineNum">     288 </span>            :                     /* Is there a difference between dzhe and i? both look like u to me */
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            :   /* Unsupported */
<span class="lineNum">     291 </span>            :     /* u432 curved B */
<span class="lineNum">     292 </span>            :     /* u433 strange gamma */
<span class="lineNum">     293 </span>            :     /* u434 normal delta */
<span class="lineNum">     294 </span>            :     /* u436 */
<span class="lineNum">     295 </span>            :     /* u43b lambda ? */
<span class="lineNum">     296 </span>            :     /* u43c */
<span class="lineNum">     297 </span>            :     /* u446 */
<span class="lineNum">     298 </span>            :     /* u449 */
<span class="lineNum">     299 </span>            :     /* u449 */
<span class="lineNum">     300 </span>            :     /* u44a */
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : /* This half of the structure gets filled in later - see ITALICINFO_REMAINDER */
<span class="lineNum">     303 </span>            :     double tan_ia;
<span class="lineNum">     304 </span>            :     double x_height;
<span class="lineNum">     305 </span>            :     double pq_depth;
<span class="lineNum">     306 </span>            :     double ascender_height;
<span class="lineNum">     307 </span>            :     double emsize;
<span class="lineNum">     308 </span>            :     int order2;
<span class="lineNum">     309 </span>            :     struct splinefont *sf;
<span class="lineNum">     310 </span>            :     int layer;
<span class="lineNum">     311 </span>            :     double serif_extent, serif_height;
<span class="lineNum">     312 </span>            :     struct splinepoint *f_start, *f_end;                /* start has next pointing into the f head and up */
<span class="lineNum">     313 </span>            :     struct splinepoint *ff_start1, *ff_end1, *ff_start2, *ff_end2;
<span class="lineNum">     314 </span>            :     double f_height, ff_height;
<span class="lineNum">     315 </span>            : } ItalicInfo;
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : #define ITALICINFO_REMAINDER 0, 0, 0, 0, 0, 0, NULL, 0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            : typedef struct bluedata {
<span class="lineNum">     321 </span>            :     real xheight, xheighttop;           /* height of &quot;x&quot; and &quot;o&quot; (u,v,w,x,y,z) */
<span class="lineNum">     322 </span>            :     real caph, caphtop;                 /* height of &quot;I&quot; and &quot;O&quot; */
<span class="lineNum">     323 </span>            :     real base, basebelow;               /* bottom of &quot;I&quot; and &quot;O&quot; */
<span class="lineNum">     324 </span>            :     real ascent;                        /* height of &quot;l&quot; */
<span class="lineNum">     325 </span>            :     real descent;                       /* depth of &quot;p&quot; */
<span class="lineNum">     326 </span>            :     real numh, numhtop;                 /* height of &quot;7&quot; and &quot;8&quot; */ /* numbers with ascenders */
<span class="lineNum">     327 </span>            :     int bluecnt;                        /* If the private dica contains bluevalues... */
<span class="lineNum">     328 </span>            :     real blues[12][2];                  /* 7 pairs from bluevalues, 5 from otherblues */
<span class="lineNum">     329 </span>            : } BlueData;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : #define BLUEDATA_EMPTY { \
<span class="lineNum">     332 </span>            :     0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, \
<span class="lineNum">     333 </span>            :     { { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, \
<span class="lineNum">     334 </span>            :       { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }, { 0.0, 0.0 }  \
<span class="lineNum">     335 </span>            :     } \
<span class="lineNum">     336 </span>            : }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : typedef struct bdffloat {
<span class="lineNum">     340 </span>            :     int16 xmin,xmax,ymin,ymax;
<span class="lineNum">     341 </span>            :     int16 bytes_per_line;
<span class="lineNum">     342 </span>            :     unsigned int byte_data:1;
<span class="lineNum">     343 </span>            :     uint8 depth;
<span class="lineNum">     344 </span>            :     uint8 *bitmap;
<span class="lineNum">     345 </span>            : } BDFFloat;
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : /* OpenType does not document 'dflt' as a language, but we'll use it anyway. */
<span class="lineNum">     348 </span>            : /* (Adobe uses it too) we'll turn it into a default entry when we output it. */
<span class="lineNum">     349 </span>            : #define DEFAULT_LANG            CHR('d','f','l','t')
<span class="lineNum">     350 </span>            : /* The OpenType spec says in one place that the default script is 'dflt' and */
<span class="lineNum">     351 </span>            : /*  in another that it is 'DFLT'. 'DFLT' is correct */
<span class="lineNum">     352 </span>            : #define DEFAULT_SCRIPT          CHR('D','F','L','T')
<span class="lineNum">     353 </span>            : #define REQUIRED_FEATURE        CHR(' ','R','Q','D')
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : enum otlookup_type {
<span class="lineNum">     356 </span>            :     ot_undef = 0,                       /* Not a lookup type */
<span class="lineNum">     357 </span>            :     gsub_start         = 0x000,         /* Not a lookup type */
<span class="lineNum">     358 </span>            :     gsub_single        = 0x001,
<span class="lineNum">     359 </span>            :     gsub_multiple      = 0x002,
<span class="lineNum">     360 </span>            :     gsub_alternate     = 0x003,
<span class="lineNum">     361 </span>            :     gsub_ligature      = 0x004,
<span class="lineNum">     362 </span>            :     gsub_context       = 0x005,
<span class="lineNum">     363 </span>            :     gsub_contextchain  = 0x006,
<span class="lineNum">     364 </span>            :      /* GSUB extension 7 */
<span class="lineNum">     365 </span>            :     gsub_reversecchain = 0x008,
<span class="lineNum">     366 </span>            :     /* mac state machines */
<span class="lineNum">     367 </span>            :     morx_indic         = 0x0fd,
<span class="lineNum">     368 </span>            :     morx_context       = 0x0fe,
<span class="lineNum">     369 </span>            :     morx_insert        = 0x0ff,
<span class="lineNum">     370 </span>            :     /* ********************* */
<span class="lineNum">     371 </span>            :     gpos_start         = 0x100,         /* Not a lookup type */
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            :     gpos_single        = 0x101,
<span class="lineNum">     374 </span>            :     gpos_pair          = 0x102,
<span class="lineNum">     375 </span>            :     gpos_cursive       = 0x103,
<span class="lineNum">     376 </span>            :     gpos_mark2base     = 0x104,
<span class="lineNum">     377 </span>            :     gpos_mark2ligature = 0x105,
<span class="lineNum">     378 </span>            :     gpos_mark2mark     = 0x106,
<span class="lineNum">     379 </span>            :     gpos_context       = 0x107,
<span class="lineNum">     380 </span>            :     gpos_contextchain  = 0x108,
<span class="lineNum">     381 </span>            :     /* GPOS extension 9 */
<span class="lineNum">     382 </span>            :     kern_statemachine  = 0x1ff
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :     /* otlookup&amp;0xff == lookup type for the appropriate table */
<span class="lineNum">     385 </span>            :     /* otlookup&gt;&gt;8:     0=&gt;GSUB, 1=&gt;GPOS */
<span class="lineNum">     386 </span>            : };
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : enum otlookup_typemasks {
<span class="lineNum">     389 </span>            :     gsub_single_mask        = 0x00001,
<span class="lineNum">     390 </span>            :     gsub_multiple_mask      = 0x00002,
<span class="lineNum">     391 </span>            :     gsub_alternate_mask     = 0x00004,
<span class="lineNum">     392 </span>            :     gsub_ligature_mask      = 0x00008,
<span class="lineNum">     393 </span>            :     gsub_context_mask       = 0x00010,
<span class="lineNum">     394 </span>            :     gsub_contextchain_mask  = 0x00020,
<span class="lineNum">     395 </span>            :     gsub_reversecchain_mask = 0x00040,
<span class="lineNum">     396 </span>            :     morx_indic_mask         = 0x00080,
<span class="lineNum">     397 </span>            :     morx_context_mask       = 0x00100,
<span class="lineNum">     398 </span>            :     morx_insert_mask        = 0x00200,
<span class="lineNum">     399 </span>            :     /* ********************* */
<span class="lineNum">     400 </span>            :     gpos_single_mask        = 0x00400,
<span class="lineNum">     401 </span>            :     gpos_pair_mask          = 0x00800,
<span class="lineNum">     402 </span>            :     gpos_cursive_mask       = 0x01000,
<span class="lineNum">     403 </span>            :     gpos_mark2base_mask     = 0x02000,
<span class="lineNum">     404 </span>            :     gpos_mark2ligature_mask = 0x04000,
<span class="lineNum">     405 </span>            :     gpos_mark2mark_mask     = 0x08000,
<span class="lineNum">     406 </span>            :     gpos_context_mask       = 0x10000,
<span class="lineNum">     407 </span>            :     gpos_contextchain_mask  = 0x20000,
<span class="lineNum">     408 </span>            :     kern_statemachine_mask  = 0x40000
<span class="lineNum">     409 </span>            : };
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : #define MAX_LANG                4       /* If more than this we allocate more_langs in chunks of MAX_LANG */
<span class="lineNum">     412 </span>            : struct scriptlanglist {
<span class="lineNum">     413 </span>            :     uint32 script;
<span class="lineNum">     414 </span>            :     uint32 langs[MAX_LANG];
<span class="lineNum">     415 </span>            :     uint32 *morelangs;
<span class="lineNum">     416 </span>            :     int lang_cnt;
<span class="lineNum">     417 </span>            :     struct scriptlanglist *next;
<span class="lineNum">     418 </span>            : };
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : extern struct opentype_feature_friendlynames {
<span class="lineNum">     421 </span>            :     uint32 tag;
<span class="lineNum">     422 </span>            :     char *tagstr;
<span class="lineNum">     423 </span>            :     char *friendlyname;
<span class="lineNum">     424 </span>            :     int masks;
<span class="lineNum">     425 </span>            : } friendlies[];
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            : #define OPENTYPE_FEATURE_FRIENDLYNAMES_EMPTY { 0, NULL, NULL, 0 }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : typedef struct featurescriptlanglist {
<span class="lineNum">     431 </span>            :     uint32 featuretag;
<span class="lineNum">     432 </span>            :     struct scriptlanglist *scripts;
<span class="lineNum">     433 </span>            :     struct featurescriptlanglist *next;
<span class="lineNum">     434 </span>            :     unsigned int ismac: 1;      /* treat the featuretag as a mac feature/setting */
<span class="lineNum">     435 </span>            : } FeatureScriptLangList;
<span class="lineNum">     436 </span>            : 
<span class="lineNum">     437 </span>            : enum pst_flags { pst_r2l=1, pst_ignorebaseglyphs=2, pst_ignoreligatures=4,
<span class="lineNum">     438 </span>            :         pst_ignorecombiningmarks=8, pst_usemarkfilteringset=0x10,
<span class="lineNum">     439 </span>            :         pst_markclass=0xff00, pst_markset=0xffff0000 };
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span>            : struct lookup_subtable {
<span class="lineNum">     442 </span>            :     char *subtable_name;
<span class="lineNum">     443 </span>            :     char *suffix;                       /* for gsub_single, used to find a default replacement */
<span class="lineNum">     444 </span>            :     int16 separation, minkern;  /* for gpos_pair, used to guess default kerning values */
<span class="lineNum">     445 </span>            :     struct otlookup *lookup;
<span class="lineNum">     446 </span>            :     unsigned int unused: 1;
<span class="lineNum">     447 </span>            :     unsigned int per_glyph_pst_or_kern: 1;
<span class="lineNum">     448 </span>            :     unsigned int anchor_classes: 1;
<span class="lineNum">     449 </span>            :     unsigned int vertical_kerning: 1;
<span class="lineNum">     450 </span>            :     unsigned int ticked: 1;
<span class="lineNum">     451 </span>            :     unsigned int kerning_by_touch: 1;   /* for gpos_pair, calculate kerning so that glyphs will touch */
<span class="lineNum">     452 </span>            :     unsigned int onlyCloser: 1;         /* for kerning classes */
<span class="lineNum">     453 </span>            :     unsigned int dontautokern: 1;               /* for kerning classes */
<span class="lineNum">     454 </span>            :     struct kernclass *kc;
<span class="lineNum">     455 </span>            :     struct generic_fpst *fpst;
<span class="lineNum">     456 </span>            :     struct generic_asm  *sm;
<span class="lineNum">     457 </span>            :     /* Each time an item is added to a lookup we must place it into a */
<span class="lineNum">     458 </span>            :     /*  subtable. If it's a kerning class, fpst or state machine it has */
<span class="lineNum">     459 </span>            :     /*  a subtable all to itself. If it's an anchor class it can share */
<span class="lineNum">     460 </span>            :     /*  a subtable with other anchor classes (merge with). If it's a glyph */
<span class="lineNum">     461 </span>            :     /*  PST it may share a subtable with other PSTs */
<span class="lineNum">     462 </span>            :     /* Note items may only be placed in lookups in which they fit. Can't */
<span class="lineNum">     463 </span>            :     /*  put kerning data in a gpos_single lookup, etc. */
<span class="lineNum">     464 </span>            :     struct lookup_subtable *next;
<span class="lineNum">     465 </span>            :     int32 subtable_offset;
<span class="lineNum">     466 </span>            :     int32 *extra_subtables;
<span class="lineNum">     467 </span>            :     /* If a kerning subtable has too much stuff in it, we are prepared to */
<span class="lineNum">     468 </span>            :     /*  break it up into several smaller subtables, each of which has */
<span class="lineNum">     469 </span>            :     /*  an offset in this list (extra-subtables[0]==subtable_offset) */
<span class="lineNum">     470 </span>            :     /*  the list is terminated by an entry of -1 */
<span class="lineNum">     471 </span>            : };
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span>            : typedef struct otlookup {
<span class="lineNum">     474 </span>            :     struct otlookup *next;
<span class="lineNum">     475 </span>            :     enum otlookup_type lookup_type;
<span class="lineNum">     476 </span>            :     uint32 lookup_flags;                /* Low order: traditional flags, High order: markset index, only meaningful if pst_usemarkfilteringset set */
<span class="lineNum">     477 </span>            :     char *lookup_name;
<span class="lineNum">     478 </span>            :     FeatureScriptLangList *features;
<span class="lineNum">     479 </span>            :     struct lookup_subtable *subtables;
<span class="lineNum">     480 </span>            :     unsigned int unused: 1;     /* No subtable is used (call SFFindUnusedLookups before examining) */
<span class="lineNum">     481 </span>            :     unsigned int empty: 1;      /* No subtable is used, and no anchor classes are used */
<span class="lineNum">     482 </span>            :     unsigned int store_in_afm: 1;       /* Used for ligatures, some get stored */
<span class="lineNum">     483 </span>            :                                         /*  'liga' generally does, but 'frac' doesn't */
<span class="lineNum">     484 </span>            :     unsigned int needs_extension: 1;    /* Used during opentype generation */
<span class="lineNum">     485 </span>            :     unsigned int temporary_kern: 1;     /* Used when decomposing kerning classes into kern pairs for older formats */
<span class="lineNum">     486 </span>            :     unsigned int def_lang_checked: 1;
<span class="lineNum">     487 </span>            :     unsigned int def_lang_found: 1;
<span class="lineNum">     488 </span>            :     unsigned int ticked: 1;
<span class="lineNum">     489 </span>            :     unsigned int in_gpos: 1;
<span class="lineNum">     490 </span>            :     unsigned int in_jstf: 1;
<span class="lineNum">     491 </span>            :     unsigned int only_jstf: 1;
<span class="lineNum">     492 </span>            :     int16 subcnt;               /* Actual number of subtables we will output */
<span class="lineNum">     493 </span>            :                                 /* Some of our subtables may contain no data */
<span class="lineNum">     494 </span>            :                                 /* Some may be too big and need to be broken up.*/
<span class="lineNum">     495 </span>            :                                 /* So this field may be different than just counting the subtables */
<span class="lineNum">     496 </span>            :     int lookup_index;           /* used during opentype generation */
<span class="lineNum">     497 </span>            :     uint32 lookup_offset;
<span class="lineNum">     498 </span>            :     uint32 lookup_length;
<span class="lineNum">     499 </span>            :     char *tempname;
<span class="lineNum">     500 </span>            : } OTLookup;
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            : #define LOOKUP_SUBTABLE_EMPTY { NULL, NULL, 0, 0, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, NULL, NULL, 0, NULL }
<span class="lineNum">     503 </span>            : #define OTLOOKUP_EMPTY { NULL, 0, 0, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL }
<span class="lineNum">     504 </span>            : 
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : typedef struct devicetab {
<span class="lineNum">     507 </span>            :     uint16 first_pixel_size, last_pixel_size;           /* A range of point sizes to which this table applies */
<span class="lineNum">     508 </span>            :     int8 *corrections;                                  /* a set of pixel corrections, one for each point size */
<span class="lineNum">     509 </span>            : } DeviceTable;
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : typedef struct valdev {         /* Value records can have four associated device tables */
<span class="lineNum">     512 </span>            :     DeviceTable xadjust;
<span class="lineNum">     513 </span>            :     DeviceTable yadjust;
<span class="lineNum">     514 </span>            :     DeviceTable xadv;
<span class="lineNum">     515 </span>            :     DeviceTable yadv;
<span class="lineNum">     516 </span>            : } ValDevTab;
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : enum anchorclass_type { act_mark, act_mkmk, act_curs, act_mklg, act_unknown };
<span class="lineNum">     519 </span>            : typedef struct anchorclass {
<span class="lineNum">     520 </span>            :     char *name;                 /* in utf8 */
<span class="lineNum">     521 </span>            :     struct lookup_subtable *subtable;
<span class="lineNum">     522 </span>            :     uint8 type;         /* anchorclass_type */
<span class="lineNum">     523 </span>            :     uint8 has_base;
<span class="lineNum">     524 </span>            :     uint8 processed, has_mark, matches, ac_num;
<span class="lineNum">     525 </span>            :     uint8 ticked;
<span class="lineNum">     526 </span>            :     struct anchorclass *next;
<span class="lineNum">     527 </span>            : } AnchorClass;
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            : enum anchor_type { at_mark, at_basechar, at_baselig, at_basemark, at_centry, at_cexit, at_max };
<span class="lineNum">     530 </span>            : typedef struct anchorpoint {
<span class="lineNum">     531 </span>            :     AnchorClass *anchor;
<span class="lineNum">     532 </span>            :     BasePoint me;
<span class="lineNum">     533 </span>            :     DeviceTable xadjust, yadjust;
<span class="lineNum">     534 </span>            :     unsigned int type: 4;
<span class="lineNum">     535 </span>            :     unsigned int selected: 1;
<span class="lineNum">     536 </span>            :     unsigned int ticked: 1;
<span class="lineNum">     537 </span>            :     unsigned int has_ttf_pt: 1;
<span class="lineNum">     538 </span>            :     uint16 ttf_pt_index;
<span class="lineNum">     539 </span>            :     int16  lig_index;
<span class="lineNum">     540 </span>            :     struct anchorpoint *next;
<span class="lineNum">     541 </span>            : } AnchorPoint;
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            : typedef struct kernpair {
<span class="lineNum">     544 </span>            :     // Note that the left character in the pair has the reference to the kerning pair, which in turn references the right character.
<span class="lineNum">     545 </span>            :     struct lookup_subtable *subtable;
<span class="lineNum">     546 </span>            :     struct splinechar *sc;
<span class="lineNum">     547 </span>            :     int16 off;
<span class="lineNum">     548 </span>            :     uint16 kcid;                        /* temporary value */
<span class="lineNum">     549 </span>            :     DeviceTable *adjust;                /* Only adjustment in one dimen, if more needed use pst */
<span class="lineNum">     550 </span>            :     struct kernpair *next;
<span class="lineNum">     551 </span>            : } KernPair;
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            : #define FF_KERNCLASS_FLAG_NATIVE 2 // If set, the class goes into groups.plist or kerning.plist.
<span class="lineNum">     554 </span>            : #define FF_KERNCLASS_FLAG_FEATURE 4 // If set, the class or rule goes into the feature file. In the present configuration, this ought to be zero always.
<span class="lineNum">     555 </span>            : #define FF_KERNCLASS_FLAG_NAMETYPE 8 // If unset (default), the class has a standard name, which translates to a U. F. O. name starting in public.kern, which may be illegal in the feature file. If set, it has a name like @MMK_.
<span class="lineNum">     556 </span>            : #define FF_KERNCLASS_FLAG_NAMELEGACY 16 // If set, the class has a U. F. O. name starting in @kc as FontForge liked to do in the past.
<span class="lineNum">     557 </span>            : #define FF_KERNCLASS_FLAG_VIRTUAL 32 // If unset (default), the class is a real character class and does not conflict with same-sided classes. If set, FontForge mostly ignores the class except for U. F. O. input/output.
<span class="lineNum">     558 </span>            : #define FF_KERNCLASS_FLAG_FLATTEN 64 // If unset (default), the class gets exported as a class. If set, it gets exported as its first member (in order to support class-character kerns).
<span class="lineNum">     559 </span>            : #define FF_KERNCLASS_FLAG_SINGLECHAR (FF_KERNCLASS_FLAG_VIRTUAL | FF_KERNCLASS_FLAG_FLATTEN) // We expect to see these used together.
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : typedef struct kernclass {
<span class="lineNum">     562 </span>            :     int first_cnt, second_cnt;          /* Count of classes for first and second chars */
<span class="lineNum">     563 </span>            :     char **firsts;                      /* list of a space separated list of char names */
<span class="lineNum">     564 </span>            :     char **seconds;                     /*  one entry for each class. Entry 0 is null */
<span class="lineNum">     565 </span>            :                                         /*  and means everything not specified elsewhere */
<span class="lineNum">     566 </span>            :     char **firsts_names; // We need to track the names of the classes in order to round-trip U. F. O. data.
<span class="lineNum">     567 </span>            :     char **seconds_names;
<span class="lineNum">     568 </span>            :     int *firsts_flags; // This tracks the storage format of the class in U. F. O. (groups.plist or features.fea) and whether it's a single-character class.
<span class="lineNum">     569 </span>            :     int *seconds_flags; // We also track the name format (@MMK or public.kern).
<span class="lineNum">     570 </span>            :     struct lookup_subtable *subtable;
<span class="lineNum">     571 </span>            :     uint16 kcid;                        /* Temporary value, used for many things briefly */
<span class="lineNum">     572 </span>            :     int16 *offsets;                     /* array of first_cnt*second_cnt entries with 0 representing no data */
<span class="lineNum">     573 </span>            :     int *offsets_flags;
<span class="lineNum">     574 </span>            :     DeviceTable *adjusts;               /* array of first_cnt*second_cnt entries representing resolution-specific adjustments */
<span class="lineNum">     575 </span>            :     struct kernclass *next;             // Note that, in most cases, a typeface needs only one struct kernclass since it can contain all classes.
<span class="lineNum">     576 </span>            :     int feature; // This indicates whether the kerning class came from a feature file. This is important during export.
<span class="lineNum">     577 </span>            : } KernClass;
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            : enum possub_type { pst_null, pst_position, pst_pair,
<span class="lineNum">     580 </span>            :         pst_substitution, pst_alternate,
<span class="lineNum">     581 </span>            :         pst_multiple, pst_ligature,
<span class="lineNum">     582 </span>            :         pst_lcaret /* must be pst_max-1, see charinfo.c*/,
<span class="lineNum">     583 </span>            :         pst_max,
<span class="lineNum">     584 </span>            :         /* These are not psts but are related so it's handly to have values for them */
<span class="lineNum">     585 </span>            :         pst_kerning = pst_max, pst_vkerning, pst_anchors,
<span class="lineNum">     586 </span>            :         /* And these are fpsts */
<span class="lineNum">     587 </span>            :         pst_contextpos, pst_contextsub, pst_chainpos, pst_chainsub,
<span class="lineNum">     588 </span>            :         pst_reversesub, fpst_max,
<span class="lineNum">     589 </span>            :         /* And these are used to specify a kerning pair where the current */
<span class="lineNum">     590 </span>            :         /*  char is the final glyph rather than the initial one */
<span class="lineNum">     591 </span>            :         /* A kludge used when cutting and pasting features */
<span class="lineNum">     592 </span>            :         pst_kernback, pst_vkernback
<span class="lineNum">     593 </span>            :         };
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : struct vr {
<span class="lineNum">     596 </span>            :     int16 xoff, yoff, h_adv_off, v_adv_off;
<span class="lineNum">     597 </span>            :     ValDevTab *adjust;
<span class="lineNum">     598 </span>            : };
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span>            : typedef struct generic_pst {
<span class="lineNum">     601 </span>            :     unsigned int ticked: 1;
<span class="lineNum">     602 </span>            :     unsigned int temporary: 1;          /* Used in afm ligature closure */
<span class="lineNum">     603 </span>            :     /* enum possub_type*/ uint8 type;
<span class="lineNum">     604 </span>            :     struct lookup_subtable *subtable;
<span class="lineNum">     605 </span>            :     struct generic_pst *next;
<span class="lineNum">     606 </span>            :     union {
<span class="lineNum">     607 </span>            :         struct vr pos;
<span class="lineNum">     608 </span>            :         struct { char *paired; struct vr *vr; } pair;
<span class="lineNum">     609 </span>            :         struct { char *variant; } subs;
<span class="lineNum">     610 </span>            :         struct { char *components; } mult, alt;
<span class="lineNum">     611 </span>            :         struct { char *components; struct splinechar *lig; } lig;
<span class="lineNum">     612 </span>            :         struct { int16 *carets; int cnt; } lcaret;      /* Ligature caret positions */
<span class="lineNum">     613 </span>            :     } u;
<span class="lineNum">     614 </span>            : } PST;
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            : typedef struct liglist {
<span class="lineNum">     617 </span>            :     PST *lig;
<span class="lineNum">     618 </span>            :     struct splinechar *first;           /* First component */
<span class="lineNum">     619 </span>            :     struct splinecharlist *components;  /* Other than the first */
<span class="lineNum">     620 </span>            :     struct liglist *next;
<span class="lineNum">     621 </span>            :     int ccnt;                           /* Component count. (includes first component) */
<span class="lineNum">     622 </span>            : } LigList;
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            : enum fpossub_format { pst_glyphs, pst_class, pst_coverage,
<span class="lineNum">     625 </span>            :                     pst_reversecoverage, pst_formatmax };
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : struct seqlookup {
<span class="lineNum">     628 </span>            :     int seq;
<span class="lineNum">     629 </span>            :     struct otlookup *lookup;
<span class="lineNum">     630 </span>            : };
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : struct fpg { char *names, *back, *fore; };
<span class="lineNum">     633 </span>            : struct fpc { int ncnt, bcnt, fcnt; uint16 *nclasses, *bclasses, *fclasses, *allclasses; };
<span class="lineNum">     634 </span>            : struct fpv { int ncnt, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; };
<span class="lineNum">     635 </span>            : struct fpr { int always1, bcnt, fcnt; char **ncovers, **bcovers, **fcovers; char *replacements; };
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            : struct fpst_rule {
<span class="lineNum">     638 </span>            :     union {
<span class="lineNum">     639 </span>            :         /* Note: Items in backtrack area are in reverse order because that's how the OT wants them */
<span class="lineNum">     640 </span>            :         /*  they need to be reversed again to be displayed to the user */
<span class="lineNum">     641 </span>            :         struct fpg glyph;
<span class="lineNum">     642 </span>            :         struct fpc class;
<span class="lineNum">     643 </span>            :         struct fpv coverage;
<span class="lineNum">     644 </span>            :         struct fpr rcoverage;
<span class="lineNum">     645 </span>            :     } u;
<span class="lineNum">     646 </span>            :     int lookup_cnt;
<span class="lineNum">     647 </span>            :     struct seqlookup *lookups;
<span class="lineNum">     648 </span>            : };
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span>            : typedef struct generic_fpst {
<span class="lineNum">     651 </span>            :     uint16 /*enum possub_type*/ type;
<span class="lineNum">     652 </span>            :     uint16 /*enum fpossub_format*/ format;
<span class="lineNum">     653 </span>            :     struct lookup_subtable *subtable;
<span class="lineNum">     654 </span>            :     struct generic_fpst *next;
<span class="lineNum">     655 </span>            :     uint16 nccnt, bccnt, fccnt;
<span class="lineNum">     656 </span>            :     uint16 rule_cnt;
<span class="lineNum">     657 </span>            :     char **nclass, **bclass, **fclass;
<span class="lineNum">     658 </span>            :     struct fpst_rule *rules;
<span class="lineNum">     659 </span>            :     uint8 ticked;
<span class="lineNum">     660 </span>            :     uint8 effectively_by_glyphs;
<span class="lineNum">     661 </span>            :     char **nclassnames, **bclassnames, **fclassnames;
<span class="lineNum">     662 </span>            : } FPST;
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : enum asm_type { asm_indic, asm_context, asm_lig, asm_simple=4, asm_insert,
<span class="lineNum">     665 </span>            :         asm_kern=0x11 };
<span class="lineNum">     666 </span>            : enum asm_flags { asm_vert=0x8000, asm_descending=0x4000, asm_always=0x2000 };
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : struct asm_state {
<span class="lineNum">     669 </span>            :     uint16 next_state;
<span class="lineNum">     670 </span>            :     uint16 flags;
<span class="lineNum">     671 </span>            :     union {
<span class="lineNum">     672 </span>            :         struct {
<span class="lineNum">     673 </span>            :             struct otlookup *mark_lookup;       /* for contextual glyph subs (tag of a nested lookup) */
<span class="lineNum">     674 </span>            :             struct otlookup *cur_lookup;        /* for contextual glyph subs */
<span class="lineNum">     675 </span>            :         } context;
<span class="lineNum">     676 </span>            :         struct {
<span class="lineNum">     677 </span>            :             char *mark_ins;
<span class="lineNum">     678 </span>            :             char *cur_ins;
<span class="lineNum">     679 </span>            :         } insert;
<span class="lineNum">     680 </span>            :         struct {
<span class="lineNum">     681 </span>            :             int16 *kerns;
<span class="lineNum">     682 </span>            :             int kcnt;
<span class="lineNum">     683 </span>            :         } kern;
<span class="lineNum">     684 </span>            :     } u;
<span class="lineNum">     685 </span>            : };
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : typedef struct generic_asm {            /* Apple State Machine */
<span class="lineNum">     688 </span>            :     struct generic_asm *next;
<span class="lineNum">     689 </span>            :     uint16 /*enum asm_type*/ type;
<span class="lineNum">     690 </span>            :     struct lookup_subtable *subtable;   /* Lookup contains feature setting info */
<span class="lineNum">     691 </span>            :     uint16 flags;       /* 0x8000=&gt;vert, 0x4000=&gt;r2l, 0x2000=&gt;hor&amp;vert */
<span class="lineNum">     692 </span>            :     uint8 ticked;
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            :     uint16 class_cnt, state_cnt;
<span class="lineNum">     695 </span>            :     char **classes;
<span class="lineNum">     696 </span>            :     struct asm_state *state;
<span class="lineNum">     697 </span>            : } ASM;
<span class="lineNum">     698 </span>            : /* State Flags:
<span class="lineNum">     699 </span>            :  Indic:
<span class="lineNum">     700 </span>            :         0x8000  mark current glyph as first in rearrangement
<span class="lineNum">     701 </span>            :         0x4000  don't advance to next glyph
<span class="lineNum">     702 </span>            :         0x2000  mark current glyph as last
<span class="lineNum">     703 </span>            :         0x000f  verb
<span class="lineNum">     704 </span>            :                 0 = no change           8 = AxCD =&gt; CDxA
<span class="lineNum">     705 </span>            :                 1 = Ax =&gt; xA         9 = AxCD =&gt; DCxA
<span class="lineNum">     706 </span>            :                 2 = xD =&gt; Dx         a = ABxD =&gt; DxAB
<span class="lineNum">     707 </span>            :                 3 = AxD =&gt; DxA               b = ABxD =&gt; DxBA
<span class="lineNum">     708 </span>            :                 4 = ABx =&gt; xAB               c = ABxCD =&gt; CDxAB
<span class="lineNum">     709 </span>            :                 5 = ABx =&gt; xBA               d = ABxCD =&gt; CDxBA
<span class="lineNum">     710 </span>            :                 6 = xCD =&gt; CDx               e = ABxCD =&gt; DCxAB
<span class="lineNum">     711 </span>            :                 7 = xCD =&gt; DCx               f = ABxCD =&gt; DCxBA
<span class="lineNum">     712 </span>            :  Contextual:
<span class="lineNum">     713 </span>            :         0x8000  mark current glyph
<span class="lineNum">     714 </span>            :         0x4000  don't advance to next glyph
<span class="lineNum">     715 </span>            :  Insert:
<span class="lineNum">     716 </span>            :         0x8000  mark current glyph
<span class="lineNum">     717 </span>            :         0x4000  don't advance to next glyph
<span class="lineNum">     718 </span>            :         0x2000  current is Kashida like
<span class="lineNum">     719 </span>            :         0x1000  mark is Kashida like
<span class="lineNum">     720 </span>            :         0x0800  current insert before
<span class="lineNum">     721 </span>            :         0x0400  mark insert before
<span class="lineNum">     722 </span>            :         0x03e0  count of chars to be inserted at current (31 max)
<span class="lineNum">     723 </span>            :         0x001f  count of chars to be inserted at mark (31 max)
<span class="lineNum">     724 </span>            :  Kern:
<span class="lineNum">     725 </span>            :         0x8000  add current glyph to kerning stack
<span class="lineNum">     726 </span>            :         0x4000  don't advance to next glyph
<span class="lineNum">     727 </span>            :         0x3fff  value offset
<span class="lineNum">     728 </span>            : */
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            : struct jstf_prio {
<span class="lineNum">     731 </span>            :     OTLookup **enableShrink;    /* Points to an array of lookups (GSUB or GPOS)*/
<span class="lineNum">     732 </span>            :     OTLookup **disableShrink;   /* NULL terminated */
<span class="lineNum">     733 </span>            :     OTLookup **maxShrink;       /* Array of GPOS like lookups */
<span class="lineNum">     734 </span>            :     OTLookup **enableExtend;
<span class="lineNum">     735 </span>            :     OTLookup **disableExtend;
<span class="lineNum">     736 </span>            :     OTLookup **maxExtend;
<span class="lineNum">     737 </span>            : };
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : struct jstf_lang {
<span class="lineNum">     740 </span>            :     uint32 lang;
<span class="lineNum">     741 </span>            :     struct jstf_lang *next;
<span class="lineNum">     742 </span>            :     int cnt;
<span class="lineNum">     743 </span>            :     struct jstf_prio *prios;
<span class="lineNum">     744 </span>            : };
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            : typedef struct jstf_script {
<span class="lineNum">     747 </span>            :     uint32 script;
<span class="lineNum">     748 </span>            :     struct jstf_script *next;
<span class="lineNum">     749 </span>            :     char *extenders;            /* list of glyph names */
<span class="lineNum">     750 </span>            :     struct jstf_lang *langs;
<span class="lineNum">     751 </span>            : } Justify;
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            : struct opentype_str {
<span class="lineNum">     754 </span>            :     struct splinechar *sc;
<span class="lineNum">     755 </span>            :     struct vr vr;               /* Scaled and rounded gpos modifications (device table info included in xoff, etc. not in adjusts) */
<span class="lineNum">     756 </span>            :     struct kernpair *kp;
<span class="lineNum">     757 </span>            :     struct kernclass *kc;
<span class="lineNum">     758 </span>            :     unsigned int prev_kc0: 1;
<span class="lineNum">     759 </span>            :     unsigned int next_kc0: 1;
<span class="lineNum">     760 </span>            :     int16 advance_width;        /* Basic advance, modifications in vr, scaled and rounded */
<span class="lineNum">     761 </span>            :         /* Er... not actually set by ApplyLookups, but somewhere the caller */
<span class="lineNum">     762 </span>            :         /*  can stash info. (Extract width from hinted bdf if possible, tt */
<span class="lineNum">     763 </span>            :         /*  instructions can change it from the expected value) */
<span class="lineNum">     764 </span>            :     int16 kc_index;
<span class="lineNum">     765 </span>            :     int16 lig_pos;              /* when skipping marks to form a ligature keep track of what ligature element a mark was attached to */
<span class="lineNum">     766 </span>            :     int16 context_pos;          /* When doing a contextual match remember which glyphs are used, and where in the match they occur. Skipped glyphs have -1 */
<span class="lineNum">     767 </span>            :     int32 orig_index;
<span class="lineNum">     768 </span>            :     void *fl;
<span class="lineNum">     769 </span>            :     unsigned int line_break_after: 1;
<span class="lineNum">     770 </span>            :     unsigned int r2l: 1;
<span class="lineNum">     771 </span>            :     int16 bsln_off;
<span class="lineNum">     772 </span>            : };
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : struct macname {
<span class="lineNum">     775 </span>            :     struct macname *next;
<span class="lineNum">     776 </span>            :     uint16 enc;         /* Platform specific encoding. 0=&gt;mac roman, 1=&gt;sjis, 7=&gt;russian */
<span class="lineNum">     777 </span>            :     uint16 lang;        /* Mac languages 0=&gt;english, 1=&gt;french, 2=&gt;german */
<span class="lineNum">     778 </span>            :     char *name;         /* Not a unicode string, uninterpreted mac encoded string */
<span class="lineNum">     779 </span>            : };
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : /* Wow, the GPOS 'size' feature stores a string in the name table just as mac */
<span class="lineNum">     782 </span>            : /*  features do */
<span class="lineNum">     783 </span>            : /* And now (OTF 1.6) GSUB 'ss01'-'ss20' do too */
<span class="lineNum">     784 </span>            : struct otfname {
<span class="lineNum">     785 </span>            :     struct otfname *next;
<span class="lineNum">     786 </span>            :     uint16 lang;        /* windows language code */
<span class="lineNum">     787 </span>            :     char *name;         /* utf8 */
<span class="lineNum">     788 </span>            : };
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : struct otffeatname {
<span class="lineNum">     791 </span>            :     uint32 tag;                 /* Feature tag */
<span class="lineNum">     792 </span>            :     struct otfname *names;
<span class="lineNum">     793 </span>            :     struct otffeatname *next;
<span class="lineNum">     794 </span>            :     uint16 nid;                 /* temporary value */
<span class="lineNum">     795 </span>            : };
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : struct macsetting {
<span class="lineNum">     798 </span>            :     struct macsetting *next;
<span class="lineNum">     799 </span>            :     uint16 setting;
<span class="lineNum">     800 </span>            :     uint16 strid;
<span class="lineNum">     801 </span>            :     struct macname *setname;
<span class="lineNum">     802 </span>            :     unsigned int initially_enabled: 1;
<span class="lineNum">     803 </span>            : };
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span>            : typedef struct macfeat {
<span class="lineNum">     806 </span>            :     struct macfeat *next;
<span class="lineNum">     807 </span>            :     uint16 feature;
<span class="lineNum">     808 </span>            :     uint8 ismutex;
<span class="lineNum">     809 </span>            :     uint8 default_setting;              /* Apple's docs say both that this is a byte and a short. It's a byte */
<span class="lineNum">     810 </span>            :     uint16 strid;                       /* Temporary value, used when reading in */
<span class="lineNum">     811 </span>            :     struct macname *featname;
<span class="lineNum">     812 </span>            :     struct macsetting *settings;
<span class="lineNum">     813 </span>            : } MacFeat;
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span>            : typedef struct refbdfc {
<span class="lineNum">     816 </span>            :     unsigned int checked: 1;
<span class="lineNum">     817 </span>            :     unsigned int selected: 1;
<span class="lineNum">     818 </span>            :     int8 xoff;
<span class="lineNum">     819 </span>            :     int8 yoff;
<span class="lineNum">     820 </span>            :     uint16 gid;
<span class="lineNum">     821 </span>            :     struct refbdfc *next;
<span class="lineNum">     822 </span>            :     struct bdfchar *bdfc;
<span class="lineNum">     823 </span>            : } BDFRefChar;
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : struct bdfcharlist {
<span class="lineNum">     826 </span>            :     struct bdfchar *bc;
<span class="lineNum">     827 </span>            :     struct bdfcharlist *next;
<span class="lineNum">     828 </span>            : };
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span>            : typedef struct bdfchar {
<span class="lineNum">     831 </span>            :     struct splinechar *sc;
<span class="lineNum">     832 </span>            :     int16 xmin,xmax,ymin,ymax;
<span class="lineNum">     833 </span>            :     int16 width;
<span class="lineNum">     834 </span>            :     int16 bytes_per_line;
<span class="lineNum">     835 </span>            :     uint8 *bitmap;
<span class="lineNum">     836 </span>            :     struct refbdfc *refs;
<span class="lineNum">     837 </span>            :     int orig_pos;
<span class="lineNum">     838 </span>            :     int16 pixelsize;                    /* for undoes */
<span class="lineNum">     839 </span>            :     struct bitmapview *views;
<span class="lineNum">     840 </span>            :     struct undoes *undoes;
<span class="lineNum">     841 </span>            :     struct undoes *redoes;
<span class="lineNum">     842 </span>            :     unsigned int changed: 1;
<span class="lineNum">     843 </span>            :     unsigned int byte_data: 1;  /* for anti-aliased chars entries are grey-scale bytes not bw bits */
<span class="lineNum">     844 </span>            :     unsigned int widthgroup: 1; /* for ttf bitmap output */
<span class="lineNum">     845 </span>            :     unsigned int isreference: 1;        /* for ttf bitmap input, */
<span class="lineNum">     846 </span>            :     unsigned int ticked: 1;
<span class="lineNum">     847 </span>            :     uint8 depth;                        /* for ttf bitmap output */
<span class="lineNum">     848 </span>            :     uint16 vwidth;
<span class="lineNum">     849 </span>            :     BDFFloat *selection;
<span class="lineNum">     850 </span>            :     BDFFloat *backup;
<span class="lineNum">     851 </span>            :     struct bdfcharlist *dependents;
<span class="lineNum">     852 </span>            : } BDFChar;
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : enum undotype { ut_none=0, ut_state, ut_tstate, ut_statehint, ut_statename,
<span class="lineNum">     855 </span>            :                 ut_statelookup,
<span class="lineNum">     856 </span>            :                 ut_anchors,
<span class="lineNum">     857 </span>            :                 ut_width, ut_vwidth, ut_lbearing, ut_rbearing, ut_possub,
<span class="lineNum">     858 </span>            :                 ut_hints, ut_bitmap, ut_bitmapsel, ut_composit, ut_multiple, ut_layers,
<span class="lineNum">     859 </span>            :                 ut_noop };
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : #define UNDO_LAYER_UNKNOWN -1
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span>            : typedef struct undoes {
<span class="lineNum">     864 </span>            :     struct undoes *next;
<span class="lineNum">     865 </span>            :     enum undotype undotype;
<span class="lineNum">     866 </span>            :     unsigned int was_modified: 1;
<span class="lineNum">     867 </span>            :     unsigned int was_order2: 1;
<span class="lineNum">     868 </span>            :     int layer; /* the layer the undo is assoicated with or -1 if unknown */
<span class="lineNum">     869 </span>            :     union {
<span class="lineNum">     870 </span>            :         struct {
<span class="lineNum">     871 </span>            :             int16 width, vwidth;
<span class="lineNum">     872 </span>            :             int16 lbearingchange;
<span class="lineNum">     873 </span>            :             int unicodeenc;                     /* only for ut_statename */
<span class="lineNum">     874 </span>            :             char *charname;                     /* only for ut_statename */
<span class="lineNum">     875 </span>            :             char *comment;                      /* in utf8 */
<span class="lineNum">     876 </span>            :             PST *possub;                        /* only for ut_statename */
<span class="lineNum">     877 </span>            :             struct splinepointlist *splines;
<span class="lineNum">     878 </span>            :             struct refchar *refs;
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span>            :             struct imagelist *images;
<span class="lineNum">     881 </span>            :             void *hints;                        /* ut_statehint, ut_statename */
<span class="lineNum">     882 </span>            :             uint8 *instrs;
<span class="lineNum">     883 </span>            :             int instrs_len;
<span class="lineNum">     884 </span>            :             AnchorPoint *anchor;
<span class="lineNum">     885 </span>            :             struct brush fill_brush;
<span class="lineNum">     886 </span>            :             struct pen stroke_pen;
<span class="lineNum">     887 </span>            :             unsigned int dofill: 1;
<span class="lineNum">     888 </span>            :             unsigned int dostroke: 1;
<span class="lineNum">     889 </span>            :             unsigned int fillfirst: 1;
<span class="lineNum">     890 </span>            :         } state;
<span class="lineNum">     891 </span>            :         int width;      /* used by both ut_width and ut_vwidth */
<span class="lineNum">     892 </span>            :         int lbearing;   /* used by ut_lbearing */
<span class="lineNum">     893 </span>            :         int rbearing;   /* used by ut_rbearing */
<span class="lineNum">     894 </span>            :         BDFChar bmpstate;
<span class="lineNum">     895 </span>            :         struct {                /* copy contains an outline state and a set of bitmap states */
<span class="lineNum">     896 </span>            :             struct undoes *state;
<span class="lineNum">     897 </span>            :             struct undoes *bitmaps;
<span class="lineNum">     898 </span>            :         } composit;
<span class="lineNum">     899 </span>            :         struct {
<span class="lineNum">     900 </span>            :             struct undoes *mult; /* copy contains several sub copies (composits, or states or widths or...) */
<span class="lineNum">     901 </span>            :                 /* Also used for ut_layers, each sub copy is a state (first is ly_fore, next ly_fore+1...) */
<span class="lineNum">     902 </span>            :         } multiple;
<span class="lineNum">     903 </span>            :         struct {
<span class="lineNum">     904 </span>            :             enum possub_type pst;
<span class="lineNum">     905 </span>            :             char **data;                /* First 4 bytes is tag, then space then data */
<span class="lineNum">     906 </span>            :             struct undoes *more_pst;
<span class="lineNum">     907 </span>            :             short cnt,max;              /* Not always set */
<span class="lineNum">     908 </span>            :         } possub;
<span class="lineNum">     909 </span>            :         uint8 *bitmap;
<span class="lineNum">     910 </span>            :     } u;
<span class="lineNum">     911 </span>            :     struct splinefont *copied_from;
<span class="lineNum">     912 </span>            : } Undoes;
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span>            : enum sfundotype
<span class="lineNum">     915 </span>            : {
<span class="lineNum">     916 </span>            :     sfut_none=0,
<span class="lineNum">     917 </span>            :     sfut_lookups,
<span class="lineNum">     918 </span>            :     sfut_lookups_kerns,
<span class="lineNum">     919 </span>            :     sfut_fontinfo,
<span class="lineNum">     920 </span>            :     sfut_noop
<span class="lineNum">     921 </span>            : };
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span>            : /**
<span class="lineNum">     924 </span>            :  * A spline font level undo stack. undoes are doubly linked using the
<span class="lineNum">     925 </span>            :  * 'ln' member and carry some user presentable description of what the
<span class="lineNum">     926 </span>            :  * undo relates to in 'msg'.
<span class="lineNum">     927 </span>            :  *
<span class="lineNum">     928 </span>            :  * The sfdchunk is a pointer to an SFD fragment which will apply the
<span class="lineNum">     929 </span>            :  * undo to the current state. For example, it might contain
<span class="lineNum">     930 </span>            :  * information about the old value of kerning pairs which can be used
<span class="lineNum">     931 </span>            :  * to restore state to how it was. Note that the sfdchunk might only
<span class="lineNum">     932 </span>            :  * be partial, containing only enough information to restore the state
<span class="lineNum">     933 </span>            :  * which changed when the undo was created.
<span class="lineNum">     934 </span>            :  */
<span class="lineNum">     935 </span>            : typedef struct sfundoes {
<span class="lineNum">     936 </span>            :     struct dlistnode ln;
<span class="lineNum">     937 </span>            :     char* msg;
<span class="lineNum">     938 </span>            :     enum sfundotype type;
<span class="lineNum">     939 </span>            :     union {
<span class="lineNum">     940 </span>            :         int dummy;
<span class="lineNum">     941 </span>            :     } u;
<span class="lineNum">     942 </span>            :     char* sfdchunk;
<span class="lineNum">     943 </span>            : } SFUndoes;
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : typedef struct enc {
<span class="lineNum">     947 </span>            :     char *enc_name;
<span class="lineNum">     948 </span>            :     int char_cnt;       /* Size of the next two arrays */
<span class="lineNum">     949 </span>            :     int32 *unicode;     /* unicode value for each encoding point */
<span class="lineNum">     950 </span>            :     char **psnames;     /* optional postscript name for each encoding point */
<span class="lineNum">     951 </span>            :     struct enc *next;
<span class="lineNum">     952 </span>            :     unsigned int builtin: 1;
<span class="lineNum">     953 </span>            :     unsigned int hidden: 1;
<span class="lineNum">     954 </span>            :     unsigned int only_1byte: 1;
<span class="lineNum">     955 </span>            :     unsigned int has_1byte: 1;
<span class="lineNum">     956 </span>            :     unsigned int has_2byte: 1;
<span class="lineNum">     957 </span>            :     unsigned int is_unicodebmp: 1;
<span class="lineNum">     958 </span>            :     unsigned int is_unicodefull: 1;
<span class="lineNum">     959 </span>            :     unsigned int is_custom: 1;
<span class="lineNum">     960 </span>            :     unsigned int is_original: 1;
<span class="lineNum">     961 </span>            :     unsigned int is_compact: 1;
<span class="lineNum">     962 </span>            :     unsigned int is_japanese: 1;
<span class="lineNum">     963 </span>            :     unsigned int is_korean: 1;
<span class="lineNum">     964 </span>            :     unsigned int is_tradchinese: 1;
<span class="lineNum">     965 </span>            :     unsigned int is_simplechinese: 1;
<span class="lineNum">     966 </span>            :     char iso_2022_escape[8];
<span class="lineNum">     967 </span>            :     int iso_2022_escape_len;
<span class="lineNum">     968 </span>            :     int low_page, high_page;
<span class="lineNum">     969 </span>            :     char *iconv_name;   /* For compatibility to old versions we might use a different name from that used by iconv. */
<span class="lineNum">     970 </span>            :     iconv_t *tounicode;
<span class="lineNum">     971 </span>            :     iconv_t *fromunicode;
<span class="lineNum">     972 </span>            :     int (*tounicode_func)(int);
<span class="lineNum">     973 </span>            :     int (*fromunicode_func)(int);
<span class="lineNum">     974 </span>            :     unsigned int is_temporary: 1;       /* freed when the map gets freed */
<span class="lineNum">     975 </span>            :     int char_max;                       /* Used by temporary encodings */
<span class="lineNum">     976 </span>            : } Encoding;
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : struct renames { char *from; char *to; };
<span class="lineNum">     979 </span>            : 
<span class="lineNum">     980 </span>            : typedef struct namelist {
<span class="lineNum">     981 </span>            :     struct namelist *basedon;
<span class="lineNum">     982 </span>            :     char *title;
<span class="lineNum">     983 </span>            :     const char ***unicode[17];
<span class="lineNum">     984 </span>            :     struct namelist *next;
<span class="lineNum">     985 </span>            :     struct renames *renames;
<span class="lineNum">     986 </span>            :     int uses_unicode;
<span class="lineNum">     987 </span>            :     char *a_utf8_name;
<span class="lineNum">     988 </span>            : } NameList;
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            : enum uni_interp { ui_unset= -1, ui_none, ui_adobe, ui_greek, ui_japanese,
<span class="lineNum">     991 </span>            :         ui_trad_chinese, ui_simp_chinese, ui_korean, ui_ams };
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span>            : struct remap { uint32 firstenc, lastenc; int32 infont; };
<span class="lineNum">     994 </span>            : 
<span class="lineNum">     995 </span>            : typedef struct encmap {         /* A per-font map of encoding to glyph id */
<span class="lineNum">     996 </span>            :     int32 *map;                 /* Map from encoding to glyphid */
<span class="lineNum">     997 </span>            :     int32 *backmap;             /* Map from glyphid to encoding */
<span class="lineNum">     998 </span>            :     int enccount;               /* used size of the map array */
<span class="lineNum">     999 </span>            :                                 /*  strictly speaking this might include */
<span class="lineNum">    1000 </span>            :                                 /*  glyphs that are not encoded, but which */
<span class="lineNum">    1001 </span>            :                                 /*  are displayed after the proper encoding */
<span class="lineNum">    1002 </span>            :     int encmax;                 /* allocated size of the map array */
<span class="lineNum">    1003 </span>            :     int backmax;                /* allocated size of the backmap array */
<span class="lineNum">    1004 </span>            :     struct remap *remap;
<span class="lineNum">    1005 </span>            :     Encoding *enc;
<span class="lineNum">    1006 </span>            :     unsigned int ticked: 1;
<span class="lineNum">    1007 </span>            : } EncMap;
<span class="lineNum">    1008 </span>            : 
<span class="lineNum">    1009 </span>            : enum property_type { prt_string, prt_atom, prt_int, prt_uint, prt_property=0x10 };
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : typedef struct bdfprops {
<span class="lineNum">    1012 </span>            :     char *name;         /* These include both properties (like SLANT) and non-properties (like FONT) */
<span class="lineNum">    1013 </span>            :     int type;
<span class="lineNum">    1014 </span>            :     union {
<span class="lineNum">    1015 </span>            :         char *str;
<span class="lineNum">    1016 </span>            :         char *atom;
<span class="lineNum">    1017 </span>            :         int val;
<span class="lineNum">    1018 </span>            :     } u;
<span class="lineNum">    1019 </span>            : } BDFProperties;
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            : typedef struct bdffont {
<span class="lineNum">    1022 </span>            :     struct splinefont *sf;
<span class="lineNum">    1023 </span>            :     int glyphcnt, glyphmax;     /* used &amp; allocated sizes of glyphs array */
<span class="lineNum">    1024 </span>            :     BDFChar **glyphs;           /* an array of charcnt entries */
<span class="lineNum">    1025 </span>            :     int16 pixelsize;
<span class="lineNum">    1026 </span>            :     int16 ascent, descent;
<span class="lineNum">    1027 </span>            :     int16 layer;                /* for piecemeal fonts */
<span class="lineNum">    1028 </span>            :     unsigned int piecemeal: 1;
<span class="lineNum">    1029 </span>            :     unsigned int bbsized: 1;
<span class="lineNum">    1030 </span>            :     unsigned int ticked: 1;
<span class="lineNum">    1031 </span>            :     unsigned int unhinted_freetype: 1;
<span class="lineNum">    1032 </span>            :     unsigned int recontext_freetype: 1;
<span class="lineNum">    1033 </span>            :     struct bdffont *next;
<span class="lineNum">    1034 </span>            :     struct clut *clut;
<span class="lineNum">    1035 </span>            :     char *foundry;
<span class="lineNum">    1036 </span>            :     int res;
<span class="lineNum">    1037 </span>            :     void *freetype_context;
<span class="lineNum">    1038 </span>            :     uint16 truesize;            /* for bbsized fonts */
<span class="lineNum">    1039 </span>            :     int16 prop_cnt;
<span class="lineNum">    1040 </span>            :     int16 prop_max;             /* only used within bdfinfo dlg */
<span class="lineNum">    1041 </span>            :     BDFProperties *props;
<span class="lineNum">    1042 </span>            :     uint16 ptsize, dpi;         /* for piecemeal fonts */
<span class="lineNum">    1043 </span>            : } BDFFont;
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            : #define HntMax  96              /* PS says at most 96 hints */
<span class="lineNum">    1046 </span>            : typedef uint8 HintMask[HntMax/8];
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : enum pointtype { pt_curve, pt_corner, pt_tangent, pt_hvcurve };
<span class="lineNum">    1049 </span>            : typedef struct splinepoint {
<span class="lineNum">    1050 </span>            :     BasePoint me;
<span class="lineNum">    1051 </span>            :     BasePoint nextcp;           /* control point */
<span class="lineNum">    1052 </span>            :     BasePoint prevcp;           /* control point */
<span class="lineNum">    1053 </span>            :     unsigned int nonextcp:1;
<span class="lineNum">    1054 </span>            :     unsigned int noprevcp:1;
<span class="lineNum">    1055 </span>            :     unsigned int nextcpdef:1;
<span class="lineNum">    1056 </span>            :     unsigned int prevcpdef:1;
<span class="lineNum">    1057 </span>            :     unsigned int selected:1;    /* for UI */
<span class="lineNum">    1058 </span>            :     unsigned int nextcpselected: 2; /* Is the next BCP selected */
<span class="lineNum">    1059 </span>            :     unsigned int prevcpselected: 2; /* Is the prev BCP selected */
<span class="lineNum">    1060 </span>            :     unsigned int pointtype:2;
<span class="lineNum">    1061 </span>            :     unsigned int isintersection: 1;
<span class="lineNum">    1062 </span>            :     unsigned int flexy: 1;      /* When &quot;freetype_markup&quot; is on in charview.c:DrawPoint */
<span class="lineNum">    1063 </span>            :     unsigned int flexx: 1;      /* flexy means select nextcp, and flexx means draw circle around nextcp */
<span class="lineNum">    1064 </span>            :     unsigned int roundx: 1;     /* For true type hinting */
<span class="lineNum">    1065 </span>            :     unsigned int roundy: 1;     /* For true type hinting */
<span class="lineNum">    1066 </span>            :     unsigned int dontinterpolate: 1;    /* in ttf, don't imply point by interpolating between cps */
<span class="lineNum">    1067 </span>            :     unsigned int ticked: 1;
<span class="lineNum">    1068 </span>            :     unsigned int watched: 1;
<span class="lineNum">    1069 </span>            :         /* 1 bits left... */
<span class="lineNum">    1070 </span>            :     uint16 ptindex;             /* Temporary value used by metafont routine */
<span class="lineNum">    1071 </span>            :     uint16 ttfindex;            /* Truetype point index */
<span class="lineNum">    1072 </span>            :         /* Special values 0xffff =&gt; point implied by averaging control points */
<span class="lineNum">    1073 </span>            :         /*                0xfffe =&gt; point created with no real number yet */
<span class="lineNum">    1074 </span>            :         /* (or perhaps point in context where no number is possible as in a glyph with points &amp; refs) */
<span class="lineNum">    1075 </span>            :     uint16 nextcpindex;         /* Truetype point index */
<span class="lineNum">    1076 </span>            :     struct spline *next;
<span class="lineNum">    1077 </span>            :     struct spline *prev;
<span class="lineNum">    1078 </span>            :     HintMask *hintmask;
<span class="lineNum">    1079 </span>            :         char* name;
<span class="lineNum">    1080 </span>            : } SplinePoint;
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            : enum linelist_flags { cvli_onscreen=0x1, cvli_clipped=0x2 };
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : typedef struct linelist {
<span class="lineNum">    1085 </span>            :     IPoint here;
<span class="lineNum">    1086 </span>            :     struct linelist *next;
<span class="lineNum">    1087 </span>            :     /* The first two fields are constant for the linelist, the next ones */
<span class="lineNum">    1088 </span>            :     /*  refer to a particular screen. If some portion of the line from */
<span class="lineNum">    1089 </span>            :     /*  this point to the next one is on the screen then set cvli_onscreen */
<span class="lineNum">    1090 </span>            :     /*  if this point needs to be clipped then set cvli_clipped */
<span class="lineNum">    1091 </span>            :     /*  asend and asstart are the actual screen locations where this point */
<span class="lineNum">    1092 </span>            :     /*  intersects the clip edge. */
<span class="lineNum">    1093 </span>            :     enum linelist_flags flags;
<span class="lineNum">    1094 </span>            :     IPoint asend, asstart;
<span class="lineNum">    1095 </span>            : } LineList;
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            : typedef struct linearapprox {
<span class="lineNum">    1098 </span>            :     real scale;
<span class="lineNum">    1099 </span>            :     unsigned int oneline: 1;
<span class="lineNum">    1100 </span>            :     unsigned int onepoint: 1;
<span class="lineNum">    1101 </span>            :     unsigned int any: 1;                /* refers to a particular screen */
<span class="lineNum">    1102 </span>            :     struct linelist *lines;
<span class="lineNum">    1103 </span>            :     struct linearapprox *next;
<span class="lineNum">    1104 </span>            : } LinearApprox;
<span class="lineNum">    1105 </span>            : 
<span class="lineNum">    1106 </span>            : typedef struct spline1d {
<span class="lineNum">    1107 </span>            :     real a, b, c, d;
<span class="lineNum">    1108 </span>            : } Spline1D;
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span>            : /**
<span class="lineNum">    1111 </span>            :  *
<span class="lineNum">    1112 </span>            :  * 2013Note: If you are altering from-&gt;me.x and y then you will
<span class="lineNum">    1113 </span>            :  *           probably have to modify splines[] to match your change.
<span class="lineNum">    1114 </span>            :  *           eg, moving both ends of a spline up/down by changing their
<span class="lineNum">    1115 </span>            :  *           to/from will also probably need an update to splines[ 0 | 1 ].d to
<span class="lineNum">    1116 </span>            :  *           match.
<span class="lineNum">    1117 </span>            :  */
<span class="lineNum">    1118 </span>            : typedef struct spline {
<span class="lineNum">    1119 </span>            :     unsigned int islinear: 1;           /* No control points */
<span class="lineNum">    1120 </span>            :     unsigned int isquadratic: 1;        /* probably read in from ttf */
<span class="lineNum">    1121 </span>            :     unsigned int isticked: 1;
<span class="lineNum">    1122 </span>            :     unsigned int isneeded: 1;           /* Used in remove overlap */
<span class="lineNum">    1123 </span>            :     unsigned int isunneeded: 1;         /* Used in remove overlap */
<span class="lineNum">    1124 </span>            :     unsigned int exclude: 1;            /* Used in remove overlap varient: exclude */
<span class="lineNum">    1125 </span>            :     unsigned int ishorvert: 1;
<span class="lineNum">    1126 </span>            :     unsigned int knowncurved: 1;        /* We know that it curves */
<span class="lineNum">    1127 </span>            :     unsigned int knownlinear: 1;        /* it might have control points, but still traces out a line */
<span class="lineNum">    1128 </span>            :         /* If neither knownlinear nor curved then we haven't checked */
<span class="lineNum">    1129 </span>            :     unsigned int order2: 1;             /* It's a bezier curve with only one cp */
<span class="lineNum">    1130 </span>            :     unsigned int touched: 1;
<span class="lineNum">    1131 </span>            :     unsigned int leftedge: 1;
<span class="lineNum">    1132 </span>            :     unsigned int rightedge: 1;
<span class="lineNum">    1133 </span>            :     unsigned int acceptableextrema: 1;  /* This spline has extrema, but we don't care */
<span class="lineNum">    1134 </span>            :     SplinePoint *from;
<span class="lineNum">    1135 </span>            :     SplinePoint *to;
<span class="lineNum">    1136 </span>            :     Spline1D splines[2];                /* splines[0] is the x spline, splines[1] is y */
<span class="lineNum">    1137 </span>            :     struct linearapprox *approx;
<span class="lineNum">    1138 </span>            :     /* Posible optimizations:
<span class="lineNum">    1139 </span>            :         Precalculate bounding box
<span class="lineNum">    1140 </span>            :         Precalculate min/max/ points of inflection
<span class="lineNum">    1141 </span>            :     */
<span class="lineNum">    1142 </span>            : } Spline;
<span class="lineNum">    1143 </span>            : 
<span class="lineNum">    1144 </span>            : #ifndef _NO_LIBSPIRO
<span class="lineNum">    1145 </span>            : # include &quot;spiroentrypoints.h&quot;
<span class="lineNum">    1146 </span>            : #else
<span class="lineNum">    1147 </span>            : # define SPIRO_OPEN_CONTOUR     '{'
<span class="lineNum">    1148 </span>            : # define SPIRO_CORNER           'v'
<span class="lineNum">    1149 </span>            : # define SPIRO_G4               'o'
<span class="lineNum">    1150 </span>            : # define SPIRO_G2               'c'
<span class="lineNum">    1151 </span>            : # define SPIRO_LEFT             '['
<span class="lineNum">    1152 </span>            : # define SPIRO_RIGHT            ']'
<span class="lineNum">    1153 </span>            : # define SPIRO_END              'z'
<span class="lineNum">    1154 </span>            : typedef struct {                        /* Taken from spiro.h because I want */
<span class="lineNum">    1155 </span>            :     double x;                           /*  to be able to compile for spiro */
<span class="lineNum">    1156 </span>            :     double y;                           /*  even on a system without it */
<span class="lineNum">    1157 </span>            :     char ty;
<span class="lineNum">    1158 </span>            : } spiro_cp;
<span class="lineNum">    1159 </span>            : #endif
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            : typedef struct splinepointlist {
<span class="lineNum">    1162 </span>            :     SplinePoint *first, *last;
<span class="lineNum">    1163 </span>            :     struct splinepointlist *next;
<span class="lineNum">    1164 </span>            :     spiro_cp *spiros;
<span class="lineNum">    1165 </span>            :     uint16 spiro_cnt, spiro_max;
<span class="lineNum">    1166 </span>            :         /* These could be bit fields, but bytes are easier to access and we */
<span class="lineNum">    1167 </span>            :         /*  don't need the space (yet) */
<span class="lineNum">    1168 </span>            :     uint8 ticked;
<span class="lineNum">    1169 </span>            :     uint8 beziers_need_optimizer;       /* If the spiros have changed in spiro mode, then reverting to bezier mode might, someday, run a simplifier */
<span class="lineNum">    1170 </span>            :     uint8 is_clip_path;                 /* In type3/svg fonts */
<span class="lineNum">    1171 </span>            :     int start_offset; // This indicates which point is the canonical first for purposes of outputting to U. F. O..
<span class="lineNum">    1172 </span>            :     char *contour_name;
<span class="lineNum">    1173 </span>            : } SplinePointList, SplineSet;
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span>            : typedef struct imagelist {
<span class="lineNum">    1176 </span>            :     struct gimage *image;
<span class="lineNum">    1177 </span>            :     real xoff, yoff;            /* position in character space of upper left corner of image */
<span class="lineNum">    1178 </span>            :     real xscale, yscale;        /* scale to convert one pixel of image to one unit of character space */
<span class="lineNum">    1179 </span>            :     DBounds bb;
<span class="lineNum">    1180 </span>            :     struct imagelist *next;
<span class="lineNum">    1181 </span>            :     unsigned int selected: 1;
<span class="lineNum">    1182 </span>            : } ImageList;
<span class="lineNum">    1183 </span>            : 
<span class="lineNum">    1184 </span>            : struct reflayer {
<span class="lineNum">    1185 </span>            :     unsigned int background: 1;
<span class="lineNum">    1186 </span>            :     unsigned int order2: 1;
<span class="lineNum">    1187 </span>            :     unsigned int anyflexes: 1;
<span class="lineNum">    1188 </span>            :     unsigned int dofill: 1;
<span class="lineNum">    1189 </span>            :     unsigned int dostroke: 1;
<span class="lineNum">    1190 </span>            :     unsigned int fillfirst: 1;
<span class="lineNum">    1191 </span>            :     struct brush fill_brush;
<span class="lineNum">    1192 </span>            :     struct pen stroke_pen;
<span class="lineNum">    1193 </span>            :     SplinePointList *splines;
<span class="lineNum">    1194 </span>            :     ImageList *images;                  /* Only in background or type3 layer(s) */
<span class="lineNum">    1195 </span>            : };
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            : typedef struct refchar {
<span class="lineNum">    1198 </span>            :     unsigned int checked: 1;
<span class="lineNum">    1199 </span>            :     unsigned int selected: 1;
<span class="lineNum">    1200 </span>            :     unsigned int point_match: 1;        /* match_pt* are point indexes */
<span class="lineNum">    1201 </span>            :                                         /*  and need to be converted to a */
<span class="lineNum">    1202 </span>            :                                         /*  translation after truetype readin */
<span class="lineNum">    1203 </span>            :     unsigned int encoded: 1;            /* orig_pos is actually an encoded value, used for old sfd files */
<span class="lineNum">    1204 </span>            :     unsigned int justtranslated: 1;     /* The transformation matrix specifies a translation (or is identity) */
<span class="lineNum">    1205 </span>            :     unsigned int use_my_metrics: 1;     /* Retain the ttf &quot;use_my_metrics&quot; info. */
<span class="lineNum">    1206 </span>            :         /* important for glyphs with instructions which change the width used */
<span class="lineNum">    1207 </span>            :         /* inside composites */
<span class="lineNum">    1208 </span>            :     unsigned int round_translation_to_grid: 1;  /* Retain the ttf &quot;round_to_grid&quot; info. */
<span class="lineNum">    1209 </span>            :     unsigned int point_match_out_of_date: 1;    /* Someone has edited a base glyph */
<span class="lineNum">    1210 </span>            :     int16 adobe_enc;
<span class="lineNum">    1211 </span>            :     int orig_pos;
<span class="lineNum">    1212 </span>            :     int unicode_enc;            /* used by paste */
<span class="lineNum">    1213 </span>            :     real transform[6];          /* transformation matrix (first 2 rows of a 3x3 matrix, missing row is 0,0,1) */
<span class="lineNum">    1214 </span>            :     struct reflayer *layers;
<span class="lineNum">    1215 </span>            :     int layer_cnt;
<span class="lineNum">    1216 </span>            :     struct refchar *next;
<span class="lineNum">    1217 </span>            :     DBounds bb;
<span class="lineNum">    1218 </span>            :     struct splinechar *sc;
<span class="lineNum">    1219 </span>            :     BasePoint top;
<span class="lineNum">    1220 </span>            :     uint16 match_pt_base, match_pt_ref;
<span class="lineNum">    1221 </span>            : } RefChar;
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span>            : /* Some stems may appear, disappear, reapear several times */
<span class="lineNum">    1224 </span>            : /* Serif stems on I which appear at 0, disappear, reappear at top */
<span class="lineNum">    1225 </span>            : /* Or the major vertical stems on H which disappear at the cross bar */
<span class="lineNum">    1226 </span>            : typedef struct hintinstance {
<span class="lineNum">    1227 </span>            :     real begin;                 /* location in the non-major direction*/
<span class="lineNum">    1228 </span>            :     real end;                           /* width/height in non-major direction*/
<span class="lineNum">    1229 </span>            :     unsigned int closed: 1;
<span class="lineNum">    1230 </span>            :     short int counternumber;
<span class="lineNum">    1231 </span>            :     struct hintinstance *next;
<span class="lineNum">    1232 </span>            : } HintInstance;
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span>            : enum hinttypes { ht_unspecified=0, ht_h, ht_v, ht_d };
<span class="lineNum">    1235 </span>            : typedef real _MMArray[2][MmMax];
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span>            : typedef struct steminfo {
<span class="lineNum">    1238 </span>            :     struct steminfo *next;
<span class="lineNum">    1239 </span>            :     unsigned int hinttype: 2;   /* Only used by undoes */
<span class="lineNum">    1240 </span>            :     unsigned int ghost: 1;      /* this is a ghost stem hint. As such truetype should ignore it, type2 output should negate it, and type1 should use as is */
<span class="lineNum">    1241 </span>            :                     /* stored width will be either 20 or 21 */
<span class="lineNum">    1242 </span>            :                     /* Type2 says: -20 is &quot;width&quot; of top edge, -21 is &quot;width&quot; of bottom edge, type1 accepts either */
<span class="lineNum">    1243 </span>            :     unsigned int haspointleft:1;
<span class="lineNum">    1244 </span>            :     unsigned int haspointright:1;
<span class="lineNum">    1245 </span>            :     unsigned int hasconflicts:1;/* Does this stem have conflicts within its cluster? */
<span class="lineNum">    1246 </span>            :     unsigned int used: 1;       /* Temporary for counter hints or hint substitution */
<span class="lineNum">    1247 </span>            :     unsigned int tobeused: 1;   /* Temporary for counter hints or hint substitution */
<span class="lineNum">    1248 </span>            :     unsigned int active: 1;     /* Currently active hint in Review Hints dlg */
<span class="lineNum">    1249 </span>            :                                 /*  displayed differently in char display */
<span class="lineNum">    1250 </span>            :     unsigned int enddone: 1;    /* Used by ttf instructing, indicates a prev */
<span class="lineNum">    1251 </span>            :                                 /*  hint had the same end as this one (so */
<span class="lineNum">    1252 </span>            :                                 /*  the points on the end line have been */
<span class="lineNum">    1253 </span>            :                                 /*  instructed already */
<span class="lineNum">    1254 </span>            :     unsigned int startdone: 1;  /* Used by ttf instructing */
<span class="lineNum">    1255 </span>            :     /*unsigned int backwards: 1;*/      /* If we think this hint is better done with a negative width */
<span class="lineNum">    1256 </span>            :     unsigned int reordered: 1;  /* In AutoHinting. Means we changed the start of the hint, need to test for out of order */
<span class="lineNum">    1257 </span>            :     unsigned int pendingpt: 1;  /* A pending stem creation, not a true stem */
<span class="lineNum">    1258 </span>            :     unsigned int linearedges: 1;/* If we have a nice rectangle then we aren't */
<span class="lineNum">    1259 </span>            :                                 /*  interested in the orientation which is */
<span class="lineNum">    1260 </span>            :                                 /*  wider than long */
<span class="lineNum">    1261 </span>            :     int16 hintnumber;           /* when dumping out hintmasks we need to know */
<span class="lineNum">    1262 </span>            :                                 /*  what bit to set for this hint */
<span class="lineNum">    1263 </span>            :     union {
<span class="lineNum">    1264 </span>            :         int mask;               /* Mask of all references that use this hint */
<span class="lineNum">    1265 </span>            :                                 /*  in type2 output */
<span class="lineNum">    1266 </span>            :         _MMArray *unblended /*[2][MmMax]*/;     /* Used when reading in type1 mm hints */
<span class="lineNum">    1267 </span>            :     } u;
<span class="lineNum">    1268 </span>            :     real start;                 /* location at which the stem starts */
<span class="lineNum">    1269 </span>            :     real width;                 /* or height */
<span class="lineNum">    1270 </span>            :     HintInstance *where;        /* location(s) in the other coord */
<span class="lineNum">    1271 </span>            : } StemInfo;
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            : typedef struct dsteminfo {
<span class="lineNum">    1274 </span>            :     struct dsteminfo *next;     /* First two fields match those in steminfo */
<span class="lineNum">    1275 </span>            :     unsigned int hinttype: 2;   /* Only used by undoes */
<span class="lineNum">    1276 </span>            :     unsigned int used: 1;       /* used only by tottf.c:gendinstrs, metafont.c to mark a hint that has been dealt with */
<span class="lineNum">    1277 </span>            :     BasePoint left, right, unit;
<span class="lineNum">    1278 </span>            :     HintInstance *where;        /* location(s) along the unit vector */
<span class="lineNum">    1279 </span>            : } DStemInfo;
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            : typedef struct minimumdistance {
<span class="lineNum">    1282 </span>            :     /* If either point is NULL it will be assumed to mean either the origin */
<span class="lineNum">    1283 </span>            :     /*  or the width point (depending on which is closer). This allows user */
<span class="lineNum">    1284 </span>            :     /*  to control metrics... */
<span class="lineNum">    1285 </span>            :     SplinePoint *sp1, *sp2;
<span class="lineNum">    1286 </span>            :     unsigned int x: 1;
<span class="lineNum">    1287 </span>            :     unsigned int done: 1;
<span class="lineNum">    1288 </span>            :     struct minimumdistance *next;
<span class="lineNum">    1289 </span>            : } MinimumDistance;
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            : typedef struct layer /* : reflayer */{
<span class="lineNum">    1292 </span>            :     unsigned int background: 1;
<span class="lineNum">    1293 </span>            :     unsigned int order2: 1;
<span class="lineNum">    1294 </span>            :     unsigned int anyflexes: 1;
<span class="lineNum">    1295 </span>            :     unsigned int dofill: 1;
<span class="lineNum">    1296 </span>            :     unsigned int dostroke: 1;
<span class="lineNum">    1297 </span>            :     unsigned int fillfirst: 1;
<span class="lineNum">    1298 </span>            :     struct brush fill_brush;
<span class="lineNum">    1299 </span>            :     struct pen stroke_pen;
<span class="lineNum">    1300 </span>            :     SplinePointList *splines;
<span class="lineNum">    1301 </span>            :     ImageList *images;                  /* Only in background or type3 layer(s) */
<span class="lineNum">    1302 </span>            :     RefChar *refs;                      /* Only in foreground layer(s) */
<span class="lineNum">    1303 </span>            :     Undoes *undoes;
<span class="lineNum">    1304 </span>            :     Undoes *redoes;
<span class="lineNum">    1305 </span>            :     uint32 validation_state;
<span class="lineNum">    1306 </span>            :     uint32 old_vs;
<span class="lineNum">    1307 </span>            :     void *python_persistent;            /* If python this will hold a python object, if not python this will hold a string containing a pickled object. We do nothing with it (if not python) except save it back out unchanged */
<span class="lineNum">    1308 </span>            :     int python_persistent_has_lists;
<span class="lineNum">    1309 </span>            : } Layer;
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span>            : enum layer_type { ly_all=-2, ly_grid= -1, ly_back=0, ly_fore=1,
<span class="lineNum">    1312 </span>            :     /* Possibly other foreground layers for type3 things */
<span class="lineNum">    1313 </span>            :     /* Possibly other background layers for normal fonts */
<span class="lineNum">    1314 </span>            :         ly_none = -3
<span class="lineNum">    1315 </span>            :     };
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span>            : struct gv_part {
<span class="lineNum">    1318 </span>            :     char *component;
<span class="lineNum">    1319 </span>            :     unsigned int is_extender: 1;        /* This component may be skipped or repeated */
<span class="lineNum">    1320 </span>            :     uint16 startConnectorLength;
<span class="lineNum">    1321 </span>            :     uint16 endConnectorLength;
<span class="lineNum">    1322 </span>            :     uint16 fullAdvance;
<span class="lineNum">    1323 </span>            : };
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : /* For the 'MATH' table (and for TeX) */
<span class="lineNum">    1326 </span>            : struct glyphvariants {
<span class="lineNum">    1327 </span>            :     char *variants;     /* Space separated list of glyph names */
<span class="lineNum">    1328 </span>            : /* Glyph assembly */
<span class="lineNum">    1329 </span>            :     int16 italic_correction;    /* Of the composed glyph */
<span class="lineNum">    1330 </span>            :     DeviceTable *italic_adjusts;
<span class="lineNum">    1331 </span>            :     int part_cnt;
<span class="lineNum">    1332 </span>            :     struct gv_part *parts;
<span class="lineNum">    1333 </span>            : };
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            : struct mathkerndata {
<span class="lineNum">    1336 </span>            :     int16 height,kern;
<span class="lineNum">    1337 </span>            :     DeviceTable *height_adjusts;
<span class="lineNum">    1338 </span>            :     DeviceTable *kern_adjusts;
<span class="lineNum">    1339 </span>            : };
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : /* For the 'MATH' table */
<span class="lineNum">    1342 </span>            : struct mathkernvertex {
<span class="lineNum">    1343 </span>            :     int cnt;            /* There is one more kern entry than height entry */
<span class="lineNum">    1344 </span>            :             /* So the last mkd should have its height ignored */
<span class="lineNum">    1345 </span>            :             /* The MATH table stores the height count, I think the kern count */
<span class="lineNum">    1346 </span>            :             /*  is more useful (and that's what I use here). They differ by 1 */
<span class="lineNum">    1347 </span>            :     struct mathkerndata *mkd;
<span class="lineNum">    1348 </span>            : };
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            : struct mathkern {
<span class="lineNum">    1351 </span>            :     struct mathkernvertex top_right;
<span class="lineNum">    1352 </span>            :     struct mathkernvertex top_left;
<span class="lineNum">    1353 </span>            :     struct mathkernvertex bottom_right;
<span class="lineNum">    1354 </span>            :     struct mathkernvertex bottom_left;
<span class="lineNum">    1355 </span>            : };
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : enum privatedict_state {
<span class="lineNum">    1358 </span>            :     pds_odd        = 0x1,       /* Odd number of entries */
<span class="lineNum">    1359 </span>            :     pds_outoforder = 0x2,       /* Bluevalues should be listed in order */
<span class="lineNum">    1360 </span>            :     pds_toomany    = 0x4,       /* arrays are of limited sizes */
<span class="lineNum">    1361 </span>            :     pds_tooclose   = 0x8,       /* adjacent zones must not be within 2*bluefuzz+1 (or 3, if bluefuzz omitted) */
<span class="lineNum">    1362 </span>            :     pds_notintegral= 0x10,      /* Must be integers */
<span class="lineNum">    1363 </span>            :     pds_toobig     = 0x20,      /* within pair difference have some relation to BlueScale but the docs make no sense to me */
<span class="lineNum">    1364 </span>            :     pds_shift      = 8,         /* BlueValues/OtherBlues, unshifted, FamilyBlues/FamilyOtherBlues shifted once */
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span>            :     pds_missingblue  = 0x010000,
<span class="lineNum">    1367 </span>            :     pds_badbluefuzz  = 0x020000,
<span class="lineNum">    1368 </span>            :     pds_badbluescale = 0x040000,
<span class="lineNum">    1369 </span>            :     pds_badstdhw     = 0x080000,
<span class="lineNum">    1370 </span>            :     pds_badstdvw     = 0x100000,
<span class="lineNum">    1371 </span>            :     pds_badstemsnaph = 0x200000,
<span class="lineNum">    1372 </span>            :     pds_badstemsnapv = 0x400000,
<span class="lineNum">    1373 </span>            :     pds_stemsnapnostdh = 0x0800000,
<span class="lineNum">    1374 </span>            :     pds_stemsnapnostdv = 0x1000000,
<span class="lineNum">    1375 </span>            :     pds_badblueshift   = 0x2000000
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            : };
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            : enum validation_state { vs_unknown = 0,
<span class="lineNum">    1380 </span>            :         vs_known=0x01,                          /* It has been validated */
<span class="lineNum">    1381 </span>            :         vs_opencontour=0x02,
<span class="lineNum">    1382 </span>            :         vs_selfintersects=0x04,
<span class="lineNum">    1383 </span>            :         vs_wrongdirection=0x08,
<span class="lineNum">    1384 </span>            :         vs_flippedreferences=0x10,              /* special case of wrong direction */
<span class="lineNum">    1385 </span>            :         vs_missingextrema=0x20,
<span class="lineNum">    1386 </span>            :         vs_missingglyphnameingsub=0x40,
<span class="lineNum">    1387 </span>            :             /* Next few are postscript only */
<span class="lineNum">    1388 </span>            :         vs_toomanypoints=0x80,
<span class="lineNum">    1389 </span>            :         vs_toomanyhints=0x100,
<span class="lineNum">    1390 </span>            :         vs_badglyphname=0x200,
<span class="lineNum">    1391 </span>            :             /* Next few are only for fontlint */
<span class="lineNum">    1392 </span>            :             /* These are relative to maxp values which ff would fix on generating a font */
<span class="lineNum">    1393 </span>            :         vs_maxp_toomanypoints    =0x400,
<span class="lineNum">    1394 </span>            :         vs_maxp_toomanypaths     =0x800,
<span class="lineNum">    1395 </span>            :         vs_maxp_toomanycomppoints=0x1000,
<span class="lineNum">    1396 </span>            :         vs_maxp_toomanycomppaths =0x2000,
<span class="lineNum">    1397 </span>            :         vs_maxp_instrtoolong     =0x4000,
<span class="lineNum">    1398 </span>            :         vs_maxp_toomanyrefs      =0x8000,
<span class="lineNum">    1399 </span>            :         vs_maxp_refstoodeep      =0x10000,
<span class="lineNum">    1400 </span>            :         /* vs_maxp_prepfpgmtoolong=0x20000, */  /* I think I was wrong about this &quot;error&quot; */
<span class="lineNum">    1401 </span>            :             /* Oops, we need another one, two, for the glyphs */
<span class="lineNum">    1402 </span>            :         vs_pointstoofarapart    = 0x40000,
<span class="lineNum">    1403 </span>            :         vs_nonintegral          = 0x80000,      /* This will never be interesting in a real font, but might be in an sfd file */
<span class="lineNum">    1404 </span>            :         vs_missinganchor        = 0x100000,
<span class="lineNum">    1405 </span>            :         vs_dupname              = 0x200000,
<span class="lineNum">    1406 </span>            :         vs_dupunicode           = 0x400000,
<span class="lineNum">    1407 </span>            :         vs_overlappedhints      = 0x800000,
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span>            :         vs_last = vs_overlappedhints,
<span class="lineNum">    1410 </span>            :         vs_maskps = 0x3fe | vs_pointstoofarapart | vs_missinganchor | vs_dupname | vs_dupunicode | vs_overlappedhints,
<span class="lineNum">    1411 </span>            :         vs_maskcid = 0x1fe | vs_pointstoofarapart | vs_missinganchor | vs_dupname | vs_overlappedhints,
<span class="lineNum">    1412 </span>            :         vs_maskttf = 0x7e | vs_pointstoofarapart | vs_nonintegral | vs_missinganchor | vs_dupunicode,
<span class="lineNum">    1413 </span>            :         vs_maskfindproblems = 0x1be | vs_pointstoofarapart | vs_nonintegral | vs_missinganchor | vs_overlappedhints
<span class="lineNum">    1414 </span>            :         };
<span class="lineNum">    1415 </span>            : 
<span class="lineNum">    1416 </span>            : struct splinecharlist { struct splinechar *sc; struct splinecharlist *next;};
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : struct altuni { struct altuni *next; int32 unienc, vs; uint32 fid; };
<span class="lineNum">    1419 </span>            :         /* vs is the &quot;variation selector&quot; a unicode codepoint which modifieds */
<span class="lineNum">    1420 </span>            :         /*  the code point before it. If vs is -1 then unienc is just an */
<span class="lineNum">    1421 </span>            :         /*  alternate encoding (greek Alpha and latin A), but if vs is one */
<span class="lineNum">    1422 </span>            :         /*  of unicode's variation selectors then this glyph is somehow a */
<span class="lineNum">    1423 </span>            :         /*  variant shape. The specifics depend on the selector and script */
<span class="lineNum">    1424 </span>            :         /*  fid is currently unused, but may, someday, be used to do ttcs */
<span class="lineNum">    1425 </span>            :         /* NOTE: GlyphInfo displays vs==-1 as vs==0, and fixes things up */
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            : typedef struct splinechar {
<span class="lineNum">    1428 </span>            :     char *name;
<span class="lineNum">    1429 </span>            :     int unicodeenc;
<span class="lineNum">    1430 </span>            :     int orig_pos;               /* Original position in the glyph list */
<span class="lineNum">    1431 </span>            :     int16 width, vwidth;
<span class="lineNum">    1432 </span>            :     int16 lsidebearing;         /* only used when reading in a type1 font */
<span class="lineNum">    1433 </span>            :                                 /*  Or an otf font where it is the subr number of a refered character */
<span class="lineNum">    1434 </span>            :                                 /*  or a ttf font without bit 1 of head.flags set */
<span class="lineNum">    1435 </span>            :                                 /*  or (once upon a time, but no longer) a ttf font with vert metrics where it is the ymax value when we had a font-wide vertical offset */
<span class="lineNum">    1436 </span>            :                                 /*  or when generating morx where it is the mask of tables in which the glyph occurs */
<span class="lineNum">    1437 </span>            :                                 /* Always a temporary value */
<span class="lineNum">    1438 </span>            :     int ttf_glyph;              /* only used when writing out a ttf or otf font */
<span class="lineNum">    1439 </span>            :     Layer *layers;              /* layer[0] is background, layer[1] foreground */
<span class="lineNum">    1440 </span>            :         /* In type3 fonts 2-n are also foreground, otherwise also background */
<span class="lineNum">    1441 </span>            :     int layer_cnt;
<span class="lineNum">    1442 </span>            :     StemInfo *hstem;            /* hstem hints have a vertical offset but run horizontally */
<span class="lineNum">    1443 </span>            :     StemInfo *vstem;            /* vstem hints have a horizontal offset but run vertically */
<span class="lineNum">    1444 </span>            :     DStemInfo *dstem;           /* diagonal hints for ttf */
<span class="lineNum">    1445 </span>            :     MinimumDistance *md;
<span class="lineNum">    1446 </span>            :     struct charviewbase *views;
<span class="lineNum">    1447 </span>            :     struct charinfo *charinfo;
<span class="lineNum">    1448 </span>            :     struct splinefont *parent;
<span class="lineNum">    1449 </span>            :     unsigned int changed: 1;
<span class="lineNum">    1450 </span>            :     unsigned int changedsincelasthinted: 1;
<span class="lineNum">    1451 </span>            :     unsigned int manualhints: 1;
<span class="lineNum">    1452 </span>            :     unsigned int ticked: 1;     /* For reference character processing */
<span class="lineNum">    1453 </span>            :                                 /* And fontview processing */
<span class="lineNum">    1454 </span>            :     unsigned int changed_since_autosave: 1;
<span class="lineNum">    1455 </span>            :     unsigned int widthset: 1;   /* needed so an emspace char doesn't disappear */
<span class="lineNum">    1456 </span>            :     unsigned int vconflicts: 1; /* Any hint overlaps in the vstem list? */
<span class="lineNum">    1457 </span>            :     unsigned int hconflicts: 1; /* Any hint overlaps in the hstem list? */
<span class="lineNum">    1458 </span>            :     unsigned int searcherdummy: 1;
<span class="lineNum">    1459 </span>            :     unsigned int changed_since_search: 1;
<span class="lineNum">    1460 </span>            :     unsigned int wasopen: 1;
<span class="lineNum">    1461 </span>            :     unsigned int namechanged: 1;
<span class="lineNum">    1462 </span>            :     unsigned int blended: 1;    /* An MM blended character */
<span class="lineNum">    1463 </span>            :     unsigned int ticked2: 1;
<span class="lineNum">    1464 </span>            :     unsigned int glyph_class: 3; /* 0=&gt; fontforge determines class automagically, else one more than the class value in gdef so 2+1=&gt;lig, 3+1=&gt;mark */
<span class="lineNum">    1465 </span>            :     unsigned int numberpointsbackards: 1;
<span class="lineNum">    1466 </span>            :     unsigned int instructions_out_of_date: 1;
<span class="lineNum">    1467 </span>            :     unsigned int complained_about_ptnums: 1;
<span class="lineNum">    1468 </span>            :     unsigned int vs_open: 1;
<span class="lineNum">    1469 </span>            :     unsigned int unlink_rm_ovrlp_save_undo: 1;
<span class="lineNum">    1470 </span>            :     unsigned int inspiro: 1;
<span class="lineNum">    1471 </span>            :     unsigned int lig_caret_cnt_fixed: 1;
<span class="lineNum">    1472 </span>            :     unsigned int suspendMetricsViewEventPropagation: 1; /* rect tool might do this while drawing */
<span class="lineNum">    1473 </span>            :     /* 5 bits left (one more if we ignore compositionunit below) */
<span class="lineNum">    1474 </span>            : #if HANYANG
<span class="lineNum">    1475 </span>            :     unsigned int compositionunit: 1;
<span class="lineNum">    1476 </span>            :     int16 jamo, varient;
<span class="lineNum">    1477 </span>            : #endif
<span class="lineNum">    1478 </span>            :     struct splinecharlist *dependents;
<span class="lineNum">    1479 </span>            :             /* The dependents list is a list of all characters which refenence*/
<span class="lineNum">    1480 </span>            :             /*  the current character directly */
<span class="lineNum">    1481 </span>            :     KernPair *kerns; // Note that the left character in the pair has the reference to the kerning pair, which in turn references the right character.
<span class="lineNum">    1482 </span>            :     KernPair *vkerns;
<span class="lineNum">    1483 </span>            :     PST *possub;                /* If we are a ligature then this tells us what */
<span class="lineNum">    1484 </span>            :                                 /*  It may also contain a bunch of other stuff now */
<span class="lineNum">    1485 </span>            :     LigList *ligofme;           /* If this is the first character of a ligature then this gives us the list of possible ones */
<span class="lineNum">    1486 </span>            :                                 /*  this field must be regenerated before the font is saved */
<span class="lineNum">    1487 </span>            :     char *comment;                      /* in utf8 */
<span class="lineNum">    1488 </span>            :     uint32 /*Color*/ color;
<span class="lineNum">    1489 </span>            :     AnchorPoint *anchor;
<span class="lineNum">    1490 </span>            :     uint8 *ttf_instrs;
<span class="lineNum">    1491 </span>            :     int16 ttf_instrs_len;
<span class="lineNum">    1492 </span>            :     int16 countermask_cnt;
<span class="lineNum">    1493 </span>            :     HintMask *countermasks;
<span class="lineNum">    1494 </span>            :     struct altuni *altuni;
<span class="lineNum">    1495 </span>            : /* for TeX */
<span class="lineNum">    1496 </span>            :     int16 tex_height, tex_depth;
<span class="lineNum">    1497 </span>            : /* TeX also uses italic_correction and glyph variants below */
<span class="lineNum">    1498 </span>            : /* For the 'MATH' table (and for TeX) */
<span class="lineNum">    1499 </span>            :     unsigned int is_extended_shape: 1;
<span class="lineNum">    1500 </span>            :     int16 italic_correction;
<span class="lineNum">    1501 </span>            :     int16 top_accent_horiz;             /* MATH table allows you to specific a*/
<span class="lineNum">    1502 </span>            :                 /* horizontal anchor for accent attachments, vertical */
<span class="lineNum">    1503 </span>            :                 /* positioning is done elsewhere */
<span class="lineNum">    1504 </span>            :     DeviceTable *italic_adjusts;
<span class="lineNum">    1505 </span>            :     DeviceTable *top_accent_adjusts;
<span class="lineNum">    1506 </span>            :     struct glyphvariants *vert_variants;
<span class="lineNum">    1507 </span>            :     struct glyphvariants *horiz_variants;
<span class="lineNum">    1508 </span>            :     struct mathkern *mathkern;
<span class="lineNum">    1509 </span>            : /* End of MATH/TeX fields */
<span class="lineNum">    1510 </span>            : #ifndef _NO_PYTHON
<span class="lineNum">    1511 </span>            :     void *python_sc_object;
<span class="lineNum">    1512 </span>            :     void *python_temporary;
<span class="lineNum">    1513 </span>            : #endif
<span class="lineNum">    1514 </span>            : #if 0
<span class="lineNum">    1515 </span>            :     // Python persistent data is now in the layers.
<span class="lineNum">    1516 </span>            :     void *python_persistent;            /* If python this will hold a python object, if not python this will hold a string containing a pickled object. We do nothing with it (if not python) except save it back out unchanged */
<span class="lineNum">    1517 </span>            :     int python_persistent_has_lists;
<span class="lineNum">    1518 </span>            : #endif // 0
<span class="lineNum">    1519 </span>            :         /* If the glyph is used as a tile pattern, then the next two values */
<span class="lineNum">    1520 </span>            :         /*  determine the amount of white space around the tile. If extra is*/
<span class="lineNum">    1521 </span>            :         /*  non-zero then we add it to the max components of the bbox and   */
<span class="lineNum">    1522 </span>            :         /*  subtract it from the min components. If extra is 0 then tile_bounds*/
<span class="lineNum">    1523 </span>            :         /*  will be used. If tile_bounds is all zeros then the glyph's bbox */
<span class="lineNum">    1524 </span>            :         /*  will be used. */
<span class="lineNum">    1525 </span>            :     real tile_margin;                   /* If the glyph is used as a tile */
<span class="lineNum">    1526 </span>            :     DBounds tile_bounds;
<span class="lineNum">    1527 </span>            :     char * glif_name; // This stores the base name of the glyph when saved to U. F. O..
<span class="lineNum">    1528 </span>            : } SplineChar;
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            : #define TEX_UNDEF 0x7fff
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            : enum ttfnames { ttf_copyright=0, ttf_family, ttf_subfamily, ttf_uniqueid,
<span class="lineNum">    1533 </span>            :     ttf_fullname, ttf_version, ttf_postscriptname, ttf_trademark,
<span class="lineNum">    1534 </span>            :     ttf_manufacturer, ttf_designer, ttf_descriptor, ttf_venderurl,
<span class="lineNum">    1535 </span>            :     ttf_designerurl, ttf_license, ttf_licenseurl, ttf_idontknow/*reserved*/,
<span class="lineNum">    1536 </span>            :     ttf_preffamilyname, ttf_prefmodifiers, ttf_compatfull, ttf_sampletext,
<span class="lineNum">    1537 </span>            :     ttf_cidfindfontname, ttf_wwsfamily, ttf_wwssubfamily, ttf_namemax };
<span class="lineNum">    1538 </span>            : struct ttflangname {
<span class="lineNum">    1539 </span>            :     int lang;
<span class="lineNum">    1540 </span>            :     char *names[ttf_namemax];                   /* in utf8 */
<span class="lineNum">    1541 </span>            :     int frommac[(ttf_namemax+31)/32];           /* Used when parsing the 'name' table */
<span class="lineNum">    1542 </span>            :     struct ttflangname *next;
<span class="lineNum">    1543 </span>            : };
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span>            : struct MATH {
<span class="lineNum">    1546 </span>            : /* From the MATH Constants subtable (constants for positioning glyphs. Not PI)*/
<span class="lineNum">    1547 </span>            :     int16 ScriptPercentScaleDown;
<span class="lineNum">    1548 </span>            :     int16 ScriptScriptPercentScaleDown;
<span class="lineNum">    1549 </span>            :     uint16 DelimitedSubFormulaMinHeight;
<span class="lineNum">    1550 </span>            :     uint16 DisplayOperatorMinHeight;
<span class="lineNum">    1551 </span>            :     int16 MathLeading;
<span class="lineNum">    1552 </span>            :     DeviceTable *MathLeading_adjust;
<span class="lineNum">    1553 </span>            :     int16 AxisHeight;
<span class="lineNum">    1554 </span>            :     DeviceTable *AxisHeight_adjust;
<span class="lineNum">    1555 </span>            :     int16 AccentBaseHeight;
<span class="lineNum">    1556 </span>            :     DeviceTable *AccentBaseHeight_adjust;
<span class="lineNum">    1557 </span>            :     int16 FlattenedAccentBaseHeight;
<span class="lineNum">    1558 </span>            :     DeviceTable *FlattenedAccentBaseHeight_adjust;
<span class="lineNum">    1559 </span>            :     int16 SubscriptShiftDown;
<span class="lineNum">    1560 </span>            :     DeviceTable *SubscriptShiftDown_adjust;
<span class="lineNum">    1561 </span>            :     int16 SubscriptTopMax;
<span class="lineNum">    1562 </span>            :     DeviceTable *SubscriptTopMax_adjust;
<span class="lineNum">    1563 </span>            :     int16 SubscriptBaselineDropMin;
<span class="lineNum">    1564 </span>            :     DeviceTable *SubscriptBaselineDropMin_adjust;
<span class="lineNum">    1565 </span>            :     int16 SuperscriptShiftUp;
<span class="lineNum">    1566 </span>            :     DeviceTable *SuperscriptShiftUp_adjust;
<span class="lineNum">    1567 </span>            :     int16 SuperscriptShiftUpCramped;
<span class="lineNum">    1568 </span>            :     DeviceTable *SuperscriptShiftUpCramped_adjust;
<span class="lineNum">    1569 </span>            :     int16 SuperscriptBottomMin;
<span class="lineNum">    1570 </span>            :     DeviceTable *SuperscriptBottomMin_adjust;
<span class="lineNum">    1571 </span>            :     int16 SuperscriptBaselineDropMax;
<span class="lineNum">    1572 </span>            :     DeviceTable *SuperscriptBaselineDropMax_adjust;
<span class="lineNum">    1573 </span>            :     int16 SubSuperscriptGapMin;
<span class="lineNum">    1574 </span>            :     DeviceTable *SubSuperscriptGapMin_adjust;
<span class="lineNum">    1575 </span>            :     int16 SuperscriptBottomMaxWithSubscript;
<span class="lineNum">    1576 </span>            :     DeviceTable *SuperscriptBottomMaxWithSubscript_adjust;
<span class="lineNum">    1577 </span>            :     int16 SpaceAfterScript;
<span class="lineNum">    1578 </span>            :     DeviceTable *SpaceAfterScript_adjust;
<span class="lineNum">    1579 </span>            :     int16 UpperLimitGapMin;
<span class="lineNum">    1580 </span>            :     DeviceTable *UpperLimitGapMin_adjust;
<span class="lineNum">    1581 </span>            :     int16 UpperLimitBaselineRiseMin;
<span class="lineNum">    1582 </span>            :     DeviceTable *UpperLimitBaselineRiseMin_adjust;
<span class="lineNum">    1583 </span>            :     int16 LowerLimitGapMin;
<span class="lineNum">    1584 </span>            :     DeviceTable *LowerLimitGapMin_adjust;
<span class="lineNum">    1585 </span>            :     int16 LowerLimitBaselineDropMin;
<span class="lineNum">    1586 </span>            :     DeviceTable *LowerLimitBaselineDropMin_adjust;
<span class="lineNum">    1587 </span>            :     int16 StackTopShiftUp;
<span class="lineNum">    1588 </span>            :     DeviceTable *StackTopShiftUp_adjust;
<span class="lineNum">    1589 </span>            :     int16 StackTopDisplayStyleShiftUp;
<span class="lineNum">    1590 </span>            :     DeviceTable *StackTopDisplayStyleShiftUp_adjust;
<span class="lineNum">    1591 </span>            :     int16 StackBottomShiftDown;
<span class="lineNum">    1592 </span>            :     DeviceTable *StackBottomShiftDown_adjust;
<span class="lineNum">    1593 </span>            :     int16 StackBottomDisplayStyleShiftDown;
<span class="lineNum">    1594 </span>            :     DeviceTable *StackBottomDisplayStyleShiftDown_adjust;
<span class="lineNum">    1595 </span>            :     int16 StackGapMin;
<span class="lineNum">    1596 </span>            :     DeviceTable *StackGapMin_adjust;
<span class="lineNum">    1597 </span>            :     int16 StackDisplayStyleGapMin;
<span class="lineNum">    1598 </span>            :     DeviceTable *StackDisplayStyleGapMin_adjust;
<span class="lineNum">    1599 </span>            :     int16 StretchStackTopShiftUp;
<span class="lineNum">    1600 </span>            :     DeviceTable *StretchStackTopShiftUp_adjust;
<span class="lineNum">    1601 </span>            :     int16 StretchStackBottomShiftDown;
<span class="lineNum">    1602 </span>            :     DeviceTable *StretchStackBottomShiftDown_adjust;
<span class="lineNum">    1603 </span>            :     int16 StretchStackGapAboveMin;
<span class="lineNum">    1604 </span>            :     DeviceTable *StretchStackGapAboveMin_adjust;
<span class="lineNum">    1605 </span>            :     int16 StretchStackGapBelowMin;
<span class="lineNum">    1606 </span>            :     DeviceTable *StretchStackGapBelowMin_adjust;
<span class="lineNum">    1607 </span>            :     int16 FractionNumeratorShiftUp;
<span class="lineNum">    1608 </span>            :     DeviceTable *FractionNumeratorShiftUp_adjust;
<span class="lineNum">    1609 </span>            :     int16 FractionNumeratorDisplayStyleShiftUp;
<span class="lineNum">    1610 </span>            :     DeviceTable *FractionNumeratorDisplayStyleShiftUp_adjust;
<span class="lineNum">    1611 </span>            :     int16 FractionDenominatorShiftDown;
<span class="lineNum">    1612 </span>            :     DeviceTable *FractionDenominatorShiftDown_adjust;
<span class="lineNum">    1613 </span>            :     int16 FractionDenominatorDisplayStyleShiftDown;
<span class="lineNum">    1614 </span>            :     DeviceTable *FractionDenominatorDisplayStyleShiftDown_adjust;
<span class="lineNum">    1615 </span>            :     int16 FractionNumeratorGapMin;
<span class="lineNum">    1616 </span>            :     DeviceTable *FractionNumeratorGapMin_adjust;
<span class="lineNum">    1617 </span>            :     int16 FractionNumeratorDisplayStyleGapMin;
<span class="lineNum">    1618 </span>            :     DeviceTable *FractionNumeratorDisplayStyleGapMin_adjust;
<span class="lineNum">    1619 </span>            :     int16 FractionRuleThickness;
<span class="lineNum">    1620 </span>            :     DeviceTable *FractionRuleThickness_adjust;
<span class="lineNum">    1621 </span>            :     int16 FractionDenominatorGapMin;
<span class="lineNum">    1622 </span>            :     DeviceTable *FractionDenominatorGapMin_adjust;
<span class="lineNum">    1623 </span>            :     int16 FractionDenominatorDisplayStyleGapMin;
<span class="lineNum">    1624 </span>            :     DeviceTable *FractionDenominatorDisplayStyleGapMin_adjust;
<span class="lineNum">    1625 </span>            :     int16 SkewedFractionHorizontalGap;
<span class="lineNum">    1626 </span>            :     DeviceTable *SkewedFractionHorizontalGap_adjust;
<span class="lineNum">    1627 </span>            :     int16 SkewedFractionVerticalGap;
<span class="lineNum">    1628 </span>            :     DeviceTable *SkewedFractionVerticalGap_adjust;
<span class="lineNum">    1629 </span>            :     int16 OverbarVerticalGap;
<span class="lineNum">    1630 </span>            :     DeviceTable *OverbarVerticalGap_adjust;
<span class="lineNum">    1631 </span>            :     int16 OverbarRuleThickness;
<span class="lineNum">    1632 </span>            :     DeviceTable *OverbarRuleThickness_adjust;
<span class="lineNum">    1633 </span>            :     int16 OverbarExtraAscender;
<span class="lineNum">    1634 </span>            :     DeviceTable *OverbarExtraAscender_adjust;
<span class="lineNum">    1635 </span>            :     int16 UnderbarVerticalGap;
<span class="lineNum">    1636 </span>            :     DeviceTable *UnderbarVerticalGap_adjust;
<span class="lineNum">    1637 </span>            :     int16 UnderbarRuleThickness;
<span class="lineNum">    1638 </span>            :     DeviceTable *UnderbarRuleThickness_adjust;
<span class="lineNum">    1639 </span>            :     int16 UnderbarExtraDescender;
<span class="lineNum">    1640 </span>            :     DeviceTable *UnderbarExtraDescender_adjust;
<span class="lineNum">    1641 </span>            :     int16 RadicalVerticalGap;
<span class="lineNum">    1642 </span>            :     DeviceTable *RadicalVerticalGap_adjust;
<span class="lineNum">    1643 </span>            :     int16 RadicalDisplayStyleVerticalGap;
<span class="lineNum">    1644 </span>            :     DeviceTable *RadicalDisplayStyleVerticalGap_adjust;
<span class="lineNum">    1645 </span>            :     int16 RadicalRuleThickness;
<span class="lineNum">    1646 </span>            :     DeviceTable *RadicalRuleThickness_adjust;
<span class="lineNum">    1647 </span>            :     int16 RadicalExtraAscender;
<span class="lineNum">    1648 </span>            :     DeviceTable *RadicalExtraAscender_adjust;
<span class="lineNum">    1649 </span>            :     int16 RadicalKernBeforeDegree;
<span class="lineNum">    1650 </span>            :     DeviceTable *RadicalKernBeforeDegree_adjust;
<span class="lineNum">    1651 </span>            :     int16 RadicalKernAfterDegree;
<span class="lineNum">    1652 </span>            :     DeviceTable *RadicalKernAfterDegree_adjust;
<span class="lineNum">    1653 </span>            :     uint16 RadicalDegreeBottomRaisePercent;
<span class="lineNum">    1654 </span>            : /* Global constants from other subtables */
<span class="lineNum">    1655 </span>            :     uint16 MinConnectorOverlap;                 /* in the math variants sub-table */
<span class="lineNum">    1656 </span>            : };
<span class="lineNum">    1657 </span>            : 
<span class="lineNum">    1658 </span>            : enum backedup_state { bs_dontknow=0, bs_not=1, bs_backedup=2 };
<span class="lineNum">    1659 </span>            : enum loadvalidation_state {
<span class="lineNum">    1660 </span>            :         lvs_bad_ps_fontname    = 0x001,
<span class="lineNum">    1661 </span>            :         lvs_bad_glyph_table    = 0x002,
<span class="lineNum">    1662 </span>            :         lvs_bad_cff_table      = 0x004,
<span class="lineNum">    1663 </span>            :         lvs_bad_metrics_table  = 0x008,
<span class="lineNum">    1664 </span>            :         lvs_bad_cmap_table     = 0x010,
<span class="lineNum">    1665 </span>            :         lvs_bad_bitmaps_table  = 0x020,
<span class="lineNum">    1666 </span>            :         lvs_bad_gx_table       = 0x040,
<span class="lineNum">    1667 </span>            :         lvs_bad_ot_table       = 0x080,
<span class="lineNum">    1668 </span>            :         lvs_bad_os2_version    = 0x100,
<span class="lineNum">    1669 </span>            :         lvs_bad_sfnt_header    = 0x200
<span class="lineNum">    1670 </span>            :     };
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span>            : typedef struct layerinfo {
<span class="lineNum">    1673 </span>            :     char *name;
<span class="lineNum">    1674 </span>            :     unsigned int background: 1;                 /* Layer is to be treated as background: No width, images, not worth outputting */
<span class="lineNum">    1675 </span>            :     unsigned int order2: 1;                     /* Layer's data are order 2 bezier splines (truetype) rather than order 3 (postscript) */
<span class="lineNum">    1676 </span>            :                                                 /* In all glyphs in the font */
<span class="lineNum">    1677 </span>            :     unsigned int ticked: 1;
<span class="lineNum">    1678 </span>            :     char * ufo_path;
<span class="lineNum">    1679 </span>            : } LayerInfo;
<span class="lineNum">    1680 </span>            : 
<span class="lineNum">    1681 </span>            : /* Baseline data from the 'BASE' table */
<span class="lineNum">    1682 </span>            : struct baselangextent {
<span class="lineNum">    1683 </span>            :     uint32 lang;                /* also used for feature tag */
<span class="lineNum">    1684 </span>            :     struct baselangextent *next;
<span class="lineNum">    1685 </span>            :     int16 ascent, descent;
<span class="lineNum">    1686 </span>            :     struct baselangextent *features;
<span class="lineNum">    1687 </span>            : };
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span>            : struct basescript {
<span class="lineNum">    1690 </span>            :     uint32 script;
<span class="lineNum">    1691 </span>            :     struct basescript *next;
<span class="lineNum">    1692 </span>            :     int    def_baseline;        /* index [0-baseline_cnt) */
<span class="lineNum">    1693 </span>            :     int16 *baseline_pos;        /* baseline_cnt of these */
<span class="lineNum">    1694 </span>            :     struct baselangextent *langs;       /* Language specific extents (may be NULL) */
<span class="lineNum">    1695 </span>            :                                 /* The default one has the tag DEFAULT_LANG */
<span class="lineNum">    1696 </span>            : };
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span>            : struct Base {
<span class="lineNum">    1699 </span>            :     int baseline_cnt;
<span class="lineNum">    1700 </span>            :     uint32 *baseline_tags;
<span class="lineNum">    1701 </span>            :     /* A font does not need to provide info on all baselines, but if one script */
<span class="lineNum">    1702 </span>            :     /*  talks about a baseline, then all must. So the set of baselines is global*/
<span class="lineNum">    1703 </span>            :     struct basescript *scripts;
<span class="lineNum">    1704 </span>            : };
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span>            : struct pfminfo {                /* A misnomer now. OS/2 info would be more accurate, but that's stuff in here from all over ttf files */
<span class="lineNum">    1707 </span>            :     unsigned int pfmset: 1;
<span class="lineNum">    1708 </span>            :     unsigned int winascent_add: 1;
<span class="lineNum">    1709 </span>            :     unsigned int windescent_add: 1;
<span class="lineNum">    1710 </span>            :     unsigned int hheadascent_add: 1;
<span class="lineNum">    1711 </span>            :     unsigned int hheaddescent_add: 1;
<span class="lineNum">    1712 </span>            :     unsigned int typoascent_add: 1;
<span class="lineNum">    1713 </span>            :     unsigned int typodescent_add: 1;
<span class="lineNum">    1714 </span>            :     unsigned int subsuper_set: 1;
<span class="lineNum">    1715 </span>            :     unsigned int panose_set: 1;
<span class="lineNum">    1716 </span>            :     unsigned int hheadset: 1;
<span class="lineNum">    1717 </span>            :     unsigned int vheadset: 1;
<span class="lineNum">    1718 </span>            :     unsigned int hascodepages: 1;
<span class="lineNum">    1719 </span>            :     unsigned int hasunicoderanges: 1;
<span class="lineNum">    1720 </span>            :     unsigned char pfmfamily;
<span class="lineNum">    1721 </span>            :     int16 weight;
<span class="lineNum">    1722 </span>            :     int16 width;
<span class="lineNum">    1723 </span>            :     char panose[10];
<span class="lineNum">    1724 </span>            :     /* A subset of OS/2 fsSelection, used for style mapping. */
<span class="lineNum">    1725 </span>            :     /* Must agree with macStyle per otspec, takes precedence. */
<span class="lineNum">    1726 </span>            :     /* Can't use macStyle because it doesn't have a &quot;regular&quot; bit unlike the OS/2 component. */
<span class="lineNum">    1727 </span>            :     int16 stylemap;
<span class="lineNum">    1728 </span>            :     int16 fstype;
<span class="lineNum">    1729 </span>            :     int16 linegap;              /* from hhea */
<span class="lineNum">    1730 </span>            :     int16 vlinegap;             /* from vhea */
<span class="lineNum">    1731 </span>            :     int16 hhead_ascent, hhead_descent;
<span class="lineNum">    1732 </span>            :     int16 os2_typoascent, os2_typodescent, os2_typolinegap;
<span class="lineNum">    1733 </span>            :     int16 os2_winascent, os2_windescent;
<span class="lineNum">    1734 </span>            :     int16 os2_subxsize, os2_subysize, os2_subxoff, os2_subyoff;
<span class="lineNum">    1735 </span>            :     int16 os2_supxsize, os2_supysize, os2_supxoff, os2_supyoff;
<span class="lineNum">    1736 </span>            :     int16 os2_strikeysize, os2_strikeypos;
<span class="lineNum">    1737 </span>            :     int16 os2_capheight, os2_xheight;
<span class="lineNum">    1738 </span>            :     char os2_vendor[4];
<span class="lineNum">    1739 </span>            :     int16 os2_family_class;
<span class="lineNum">    1740 </span>            :     uint32 codepages[2];
<span class="lineNum">    1741 </span>            :     uint32 unicoderanges[4];
<span class="lineNum">    1742 </span>            : };
<span class="lineNum">    1743 </span>            : 
<span class="lineNum">    1744 </span>            : struct ttf_table {
<span class="lineNum">    1745 </span>            :     uint32 tag;
<span class="lineNum">    1746 </span>            :     uint32 len, maxlen;
<span class="lineNum">    1747 </span>            :     uint8 *data;
<span class="lineNum">    1748 </span>            :     struct ttf_table *next;
<span class="lineNum">    1749 </span>            :     FILE *temp; /* Temporary storage used during generation */
<span class="lineNum">    1750 </span>            : };
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span>            : enum texdata_type { tex_unset, tex_text, tex_math, tex_mathext };
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            : struct texdata {
<span class="lineNum">    1755 </span>            :     enum texdata_type type;
<span class="lineNum">    1756 </span>            :     int32 params[22];           /* param[6] has different meanings in normal and math fonts */
<span class="lineNum">    1757 </span>            : };
<span class="lineNum">    1758 </span>            : 
<span class="lineNum">    1759 </span>            : struct gasp {
<span class="lineNum">    1760 </span>            :     uint16 ppem;
<span class="lineNum">    1761 </span>            :     uint16 flags;
<span class="lineNum">    1762 </span>            : };
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span>            : struct ff_glyphclasses {
<span class="lineNum">    1765 </span>            :     // This matches struct glyphclasses from featurefile.c for now. We may make the references numeric in the future.
<span class="lineNum">    1766 </span>            :     // There may be a matching entry as a class elsewhere. For now, the output driver is responsible for eliminating duplicates.
<span class="lineNum">    1767 </span>            :     // In the interest of preserving orderings, we shall output from here, checking for value overrides from kerning classes on each kerning group entry.
<span class="lineNum">    1768 </span>            :     char *classname, *glyphs;
<span class="lineNum">    1769 </span>            :     struct ff_glyphclasses *next;
<span class="lineNum">    1770 </span>            : };
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span>            : struct ff_rawoffsets {
<span class="lineNum">    1773 </span>            :     // This stores raw offsets as read from kerning.plist.
<span class="lineNum">    1774 </span>            :     // FontForge shall output these after native data and shall output only those for which it has not emitted native data.
<span class="lineNum">    1775 </span>            :     char *left;
<span class="lineNum">    1776 </span>            :     char *right;
<span class="lineNum">    1777 </span>            :     int offset;
<span class="lineNum">    1778 </span>            :     struct ff_rawoffsets *next;
<span class="lineNum">    1779 </span>            : };
<span class="lineNum">    1780 </span>            : 
<span class="lineNum">    1781 </span>            : typedef struct splinefont {
<span class="lineNum">    1782 </span>            :     char *fontname, *fullname, *familyname, *weight;
<span class="lineNum">    1783 </span>            :     char *familyname_with_timestamp;
<span class="lineNum">    1784 </span>            :     char *copyright;
<span class="lineNum">    1785 </span>            :     char *filename;                             /* sfd name. NULL if we open a font, that's origname */
<span class="lineNum">    1786 </span>            :     char *defbasefilename;
<span class="lineNum">    1787 </span>            :     char *version;
<span class="lineNum">    1788 </span>            :     real italicangle, upos, uwidth;             /* In font info */
<span class="lineNum">    1789 </span>            :     int ascent, descent, invalidem; // If invalidem, then we use the format-specific ascent and descent on export.
<span class="lineNum">    1790 </span>            :     int uniqueid;                               /* Not copied when reading in!!!! */
<span class="lineNum">    1791 </span>            :     int glyphcnt, glyphmax;                     /* allocated size of glyphs array */
<span class="lineNum">    1792 </span>            :     SplineChar **glyphs;
<span class="lineNum">    1793 </span>            :     unsigned int changed: 1;
<span class="lineNum">    1794 </span>            :     unsigned int changed_since_autosave: 1;
<span class="lineNum">    1795 </span>            :     unsigned int changed_since_xuidchanged: 1;
<span class="lineNum">    1796 </span>            :     unsigned int display_antialias: 1;
<span class="lineNum">    1797 </span>            :     unsigned int display_bbsized: 1;
<span class="lineNum">    1798 </span>            :     unsigned int dotlesswarn: 1;                /* User warned that font doesn't have a dotless i character */
<span class="lineNum">    1799 </span>            :     unsigned int onlybitmaps: 1;                /* it's a bdf editor, not a postscript editor */
<span class="lineNum">    1800 </span>            :     unsigned int serifcheck: 1;                 /* Have we checked to see if we have serifs? */
<span class="lineNum">    1801 </span>            :     unsigned int issans: 1;                     /* We have no serifs */
<span class="lineNum">    1802 </span>            :     unsigned int isserif: 1;                    /* We have serifs. If neither set then we don't know. */
<span class="lineNum">    1803 </span>            :     unsigned int hasvmetrics: 1;                /* We've got vertical metric data and should output vhea/vmtx/VORG tables */
<span class="lineNum">    1804 </span>            :     unsigned int loading_cid_map: 1;
<span class="lineNum">    1805 </span>            :     unsigned int dupnamewarn: 1;                /* Warn about duplicate names when loading bdf font */
<span class="lineNum">    1806 </span>            :     unsigned int encodingchanged: 1;            /* Font's encoding has changed since it was loaded */
<span class="lineNum">    1807 </span>            :     unsigned int multilayer: 1;                 /* only applies if TYPE3 is set, means this font can contain strokes &amp; fills */
<span class="lineNum">    1808 </span>            :                                                 /*  I leave it in so as to avoid cluttering up code with #ifdefs */
<span class="lineNum">    1809 </span>            :     unsigned int strokedfont: 1;
<span class="lineNum">    1810 </span>            :     unsigned int new: 1;                        /* A new and unsaved font */
<span class="lineNum">    1811 </span>            :     unsigned int compacted: 1;                  /* only used when opening a font */
<span class="lineNum">    1812 </span>            :     unsigned int backedup: 2;                   /* 0=&gt;don't know, 1=&gt;no, 2=&gt;yes */
<span class="lineNum">    1813 </span>            :     unsigned int use_typo_metrics: 1;           /* The standard says to. But MS */
<span class="lineNum">    1814 </span>            :                                                 /* seems to feel that isn't good */
<span class="lineNum">    1815 </span>            :                                                 /* enough and has created a bit */
<span class="lineNum">    1816 </span>            :                                                 /* to mean &quot;really use them&quot; */
<span class="lineNum">    1817 </span>            :     unsigned int weight_width_slope_only: 1;    /* This bit seems stupid to me */
<span class="lineNum">    1818 </span>            :     unsigned int save_to_dir: 1;                /* Loaded from an sfdir collection rather than a simple sfd file */
<span class="lineNum">    1819 </span>            :     unsigned int head_optimized_for_cleartype: 1;/* Bit in the 'head' flags field, if unset &quot;East Asian fonts in the Windows Presentation Framework (Avalon) will not be hinted&quot; */
<span class="lineNum">    1820 </span>            :     unsigned int ticked: 1;
<span class="lineNum">    1821 </span>            :     unsigned int internal_temp: 1;              /* Internal temporary font to be passed to freetype for rasterizing. Don't complain about oddities. Don't generate GPOS/GSUB tables, etc. */
<span class="lineNum">    1822 </span>            :     unsigned int complained_about_spiros: 1;
<span class="lineNum">    1823 </span>            :     unsigned int use_xuid: 1;                   /* Adobe has deprecated these two */
<span class="lineNum">    1824 </span>            :     unsigned int use_uniqueid: 1;               /* fields. Mostly we don't want to use them */
<span class="lineNum">    1825 </span>            :         /* 2 bits left */
<span class="lineNum">    1826 </span>            :     struct fontviewbase *fv;
<span class="lineNum">    1827 </span>            :     struct metricsview *metrics;
<span class="lineNum">    1828 </span>            :     enum uni_interp uni_interp;
<span class="lineNum">    1829 </span>            :     NameList *for_new_glyphs;
<span class="lineNum">    1830 </span>            :     EncMap *map;                /* only used when opening a font to provide original default encoding */
<span class="lineNum">    1831 </span>            :     Layer grid;
<span class="lineNum">    1832 </span>            :     BDFFont *bitmaps;
<span class="lineNum">    1833 </span>            :     char *origname;             /* filename of font file (ie. if not an sfd) */
<span class="lineNum">    1834 </span>            :     char *autosavename;
<span class="lineNum">    1835 </span>            :     int display_size;           /* a val &lt;0 =&gt; Generate our own images from splines, a value &gt;0 =&gt; find a bdf font of that size */
<span class="lineNum">    1836 </span>            :     struct psdict *private;     /* read in from type1 file or provided by user */
<span class="lineNum">    1837 </span>            :     char *xuid;
<span class="lineNum">    1838 </span>            :     struct pfminfo pfminfo;
<span class="lineNum">    1839 </span>            :     struct ttflangname *names;
<span class="lineNum">    1840 </span>            :     char *cidregistry, *ordering;
<span class="lineNum">    1841 </span>            :     int supplement;
<span class="lineNum">    1842 </span>            :     int subfontcnt;
<span class="lineNum">    1843 </span>            :     struct splinefont **subfonts;
<span class="lineNum">    1844 </span>            :     struct splinefont *cidmaster;               /* Top level cid font */
<span class="lineNum">    1845 </span>            :     float cidversion;
<span class="lineNum">    1846 </span>            : #if HANYANG
<span class="lineNum">    1847 </span>            :     struct compositionrules *rules;
<span class="lineNum">    1848 </span>            : #endif
<span class="lineNum">    1849 </span>            :     char *comments;     /* Used to be restricted to ASCII, now utf8 */
<span class="lineNum">    1850 </span>            :     char *fontlog;
<span class="lineNum">    1851 </span>            :     int tempuniqueid;
<span class="lineNum">    1852 </span>            :     int top_enc;
<span class="lineNum">    1853 </span>            :     uint16 desired_row_cnt, desired_col_cnt;
<span class="lineNum">    1854 </span>            :     struct glyphnamehash *glyphnames;
<span class="lineNum">    1855 </span>            :     struct ttf_table *ttf_tables, *ttf_tab_saved;
<span class="lineNum">    1856 </span>            :         /* We copy: fpgm, prep, cvt, maxp (into ttf_tables) user can ask for others, into saved*/
<span class="lineNum">    1857 </span>            :     char **cvt_names;
<span class="lineNum">    1858 </span>            :     /* The end of this array is marked by a special entry: */
<span class="lineNum">    1859 </span>            : #define END_CVT_NAMES ((char *) (~(intpt) 0))
<span class="lineNum">    1860 </span>            :     struct instrdata *instr_dlgs;       /* Pointer to all table and character instruction dlgs in this font */
<span class="lineNum">    1861 </span>            :     struct shortview *cvt_dlg;
<span class="lineNum">    1862 </span>            :     struct kernclasslistdlg *kcld, *vkcld;
<span class="lineNum">    1863 </span>            :     struct kernclassdlg *kcd;
<span class="lineNum">    1864 </span>            :     struct texdata texdata;
<span class="lineNum">    1865 </span>            :     OTLookup *gsub_lookups, *gpos_lookups;
<span class="lineNum">    1866 </span>            :     /* Apple morx subtables become gsub, and kern subtables become gpos */
<span class="lineNum">    1867 </span>            :     AnchorClass *anchor;
<span class="lineNum">    1868 </span>            :     KernClass *kerns, *vkerns;
<span class="lineNum">    1869 </span>            :     FPST *possub;
<span class="lineNum">    1870 </span>            :     ASM *sm;                            /* asm is a keyword */
<span class="lineNum">    1871 </span>            :     MacFeat *features;
<span class="lineNum">    1872 </span>            :     char *chosenname;                   /* Set for files with multiple fonts in them */
<span class="lineNum">    1873 </span>            :     struct mmset *mm;                   /* If part of a multiple master set */
<span class="lineNum">    1874 </span>            :     int16 macstyle;
<span class="lineNum">    1875 </span>            :     char *fondname;                     /* For use in generating mac families */
<span class="lineNum">    1876 </span>            :     /* from the GPOS 'size' feature. design_size, etc. are measured in tenths of a point */
<span class="lineNum">    1877 </span>            :     /*  bottom is exclusive, top is inclusive */
<span class="lineNum">    1878 </span>            :     /*  if any field is 0, it is undefined. All may be undefined, All may be */
<span class="lineNum">    1879 </span>            :     /*  defined, or design_size may be defined without any of the others */
<span class="lineNum">    1880 </span>            :     /*  but we can't define the range without defining the other junk */
<span class="lineNum">    1881 </span>            :     /*  Name must contain an English language name, may contain others */
<span class="lineNum">    1882 </span>            :     uint16 design_size;
<span class="lineNum">    1883 </span>            :     uint16 fontstyle_id;
<span class="lineNum">    1884 </span>            :     struct otfname *fontstyle_name;
<span class="lineNum">    1885 </span>            :     uint16 design_range_bottom, design_range_top;
<span class="lineNum">    1886 </span>            :     struct otffeatname *feat_names;
<span class="lineNum">    1887 </span>            :     real strokewidth;
<span class="lineNum">    1888 </span>            : /* For GDEF Mark Attachment Class -- used in lookup flags */
<span class="lineNum">    1889 </span>            : /* As usual, class 0 is unused */
<span class="lineNum">    1890 </span>            :     int mark_class_cnt;
<span class="lineNum">    1891 </span>            :     char **mark_classes;                /* glyph name list */
<span class="lineNum">    1892 </span>            :     char **mark_class_names;            /* used within ff, utf8 (the name we've given to this class of marks) */
<span class="lineNum">    1893 </span>            : /* For GDEF Mark Attachment Sets -- used in lookup flags */
<span class="lineNum">    1894 </span>            : /* but here, set 0 is meaningful, since pst_usemarkfilteringset tells us */
<span class="lineNum">    1895 </span>            :     int mark_set_cnt;
<span class="lineNum">    1896 </span>            :     char **mark_sets;                   /* glyph name list */
<span class="lineNum">    1897 </span>            :     char **mark_set_names;              /* used within ff, utf8 (the name we've given to this class of marks) */
<span class="lineNum">    1898 </span>            :     struct ff_glyphclasses *groups; // This stores arbitrary named character lists for use in kerning or in the feature file.
<span class="lineNum">    1899 </span>            :     struct ff_rawoffsets *groupkerns;
<span class="lineNum">    1900 </span>            :     struct ff_rawoffsets *groupvkerns;
<span class="lineNum">    1901 </span>            :     long long creationtime;             /* seconds since 1970 */
<span class="lineNum">    1902 </span>            :     long long modificationtime;
<span class="lineNum">    1903 </span>            :     short os2_version;                  /* 0 means default rather than the real version 0 */
<span class="lineNum">    1904 </span>            :     short compression;                  /* If we opened a compressed sfd file, then save it out compressed too */
<span class="lineNum">    1905 </span>            :     short gasp_version;                 /* 0/1 currently */
<span class="lineNum">    1906 </span>            :     short gasp_cnt;
<span class="lineNum">    1907 </span>            :     struct gasp *gasp;
<span class="lineNum">    1908 </span>            :     struct MATH *MATH;
<span class="lineNum">    1909 </span>            :     float sfd_version;                  /* Used only when reading in an sfd file */
<span class="lineNum">    1910 </span>            :     struct gfi_data *fontinfo;
<span class="lineNum">    1911 </span>            :     struct val_data *valwin;
<span class="lineNum">    1912 </span>            : #if !defined(_NO_PYTHON)
<span class="lineNum">    1913 </span>            :     void *python_temporary;
<span class="lineNum">    1914 </span>            : #endif
<span class="lineNum">    1915 </span>            :     void *python_persistent;            /* If python this will hold a python object, if not python this will hold a string containing a pickled object. We do nothing with it (if not python) except save it back out unchanged */
<span class="lineNum">    1916 </span>            :     int python_persistent_has_lists; // This affects whether arrays exist as tuples or as lists (thus allowing us to use tuples for foreign data).
<span class="lineNum">    1917 </span>            :     enum loadvalidation_state loadvalidation_state;
<span class="lineNum">    1918 </span>            :     LayerInfo *layers;
<span class="lineNum">    1919 </span>            :     int layer_cnt;
<span class="lineNum">    1920 </span>            :     int display_layer;
<span class="lineNum">    1921 </span>            :     struct Base *horiz_base, *vert_base;
<span class="lineNum">    1922 </span>            :     Justify *justify;
<span class="lineNum">    1923 </span>            :     int extrema_bound;                  /* Splines do not count for extrema complaints when the distance between the endpoints is less than or equal to this */
<span class="lineNum">    1924 </span>            :     int width_separation;
<span class="lineNum">    1925 </span>            :     int sfntRevision;
<span class="lineNum">    1926 </span>            : #define sfntRevisionUnset       0x44445555
<span class="lineNum">    1927 </span>            :     int woffMajor;
<span class="lineNum">    1928 </span>            : #define woffUnset               0x4455
<span class="lineNum">    1929 </span>            :     int woffMinor;
<span class="lineNum">    1930 </span>            :     char *woffMetadata;
<span class="lineNum">    1931 </span>            :     real ufo_ascent, ufo_descent;       /* I don't know what these mean, they don't seem to correspond to any other ascent/descent pair, but retain them so round-trip ufo input/output leaves them unchanged */
<span class="lineNum">    1932 </span>            :             /* ufo_descent is negative */
<span class="lineNum">    1933 </span>            :     char *styleMapFamilyName;
<span class="lineNum">    1934 </span>            :     struct sfundoes *undoes;
<span class="lineNum">    1935 </span>            :     char collab_uuid[ FF_UUID_STRING_SIZE ];
<span class="lineNum">    1936 </span>            :     int preferred_kerning; // 1 for U. F. O. native, 2 for feature file, 0 undefined. Input functions shall flag 2, I think. This is now in S. F. D. in order to round-trip U. F. O. consistently.
<span class="lineNum">    1937 </span>            : } SplineFont;
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span>            : struct axismap {
<span class="lineNum">    1940 </span>            :     int points; /* size of the next two arrays */
<span class="lineNum">    1941 </span>            :     real *blends;       /* between [0,1] ordered so that blend[0]&lt;blend[1]&lt;... */
<span class="lineNum">    1942 </span>            :     real *designs;      /* between the design ranges for this axis, typically [1,999] or [6,72] */
<span class="lineNum">    1943 </span>            :     real min, def, max;         /* For mac */
<span class="lineNum">    1944 </span>            :     struct macname *axisnames;  /* For mac */
<span class="lineNum">    1945 </span>            : };
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span>            : struct named_instance { /* For mac */
<span class="lineNum">    1948 </span>            :     real *coords;       /* array[axis], these are in user units */
<span class="lineNum">    1949 </span>            :     struct macname *names;
<span class="lineNum">    1950 </span>            : };
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span>            : /* I am going to simplify my life and not encourage intermediate designs */
<span class="lineNum">    1953 </span>            : /*  this means I can easily calculate ConvertDesignVector, and don't have */
<span class="lineNum">    1954 </span>            : /*  to bother the user with specifying it. */
<span class="lineNum">    1955 </span>            : /* (NormalizeDesignVector is fairly basic and shouldn't need user help ever) */
<span class="lineNum">    1956 </span>            : /*  (As long as they want piecewise linear) */
<span class="lineNum">    1957 </span>            : /* I'm not going to support intermediate designs at all for apple var tables */
<span class="lineNum">    1958 </span>            : typedef struct mmset {
<span class="lineNum">    1959 </span>            :     int axis_count;
<span class="lineNum">    1960 </span>            :     char *axes[4];
<span class="lineNum">    1961 </span>            :     int instance_count;
<span class="lineNum">    1962 </span>            :     SplineFont **instances;
<span class="lineNum">    1963 </span>            :     SplineFont *normal;
<span class="lineNum">    1964 </span>            :     real *positions;    /* array[instance][axis] saying where each instance lies on each axis */
<span class="lineNum">    1965 </span>            :     real *defweights;   /* array[instance] saying how much of each instance makes the normal font */
<span class="lineNum">    1966 </span>            :                         /* for adobe */
<span class="lineNum">    1967 </span>            :     struct axismap *axismaps;   /* array[axis] */
<span class="lineNum">    1968 </span>            :     char *cdv, *ndv;    /* for adobe */
<span class="lineNum">    1969 </span>            :     int named_instance_count;
<span class="lineNum">    1970 </span>            :     struct named_instance *named_instances;
<span class="lineNum">    1971 </span>            :     unsigned int changed: 1;
<span class="lineNum">    1972 </span>            :     unsigned int apple: 1;
<span class="lineNum">    1973 </span>            : } MMSet;
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            : /* mac styles. Useful idea we'll just steal it */
<span class="lineNum">    1976 </span>            : enum style_flags { sf_bold = 1, sf_italic = 2, sf_underline = 4, sf_outline = 8,
<span class="lineNum">    1977 </span>            :         sf_shadow = 0x10, sf_condense = 0x20, sf_extend = 0x40 };
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span>            : struct sflist {
<span class="lineNum">    1980 </span>            :     SplineFont *sf;
<span class="lineNum">    1981 </span>            :     int32 *sizes;
<span class="lineNum">    1982 </span>            :     FILE *tempttf;              /* For ttf */
<span class="lineNum">    1983 </span>            :     int id;                     /* For ttf */
<span class="lineNum">    1984 </span>            :     int* ids;                   /* One for each size */
<span class="lineNum">    1985 </span>            :     BDFFont **bdfs;             /* Ditto */
<span class="lineNum">    1986 </span>            :     EncMap *map;
<span class="lineNum">    1987 </span>            :     struct sflist *next;
<span class="lineNum">    1988 </span>            :     char **former_names;
<span class="lineNum">    1989 </span>            :     int len;
<span class="lineNum">    1990 </span>            : };
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            :     /* Used for drawing text with mark to base anchors */
<span class="lineNum">    1993 </span>            : typedef struct anchorpos {
<span class="lineNum">    1994 </span>            :     SplineChar *sc;             /* This is the mark being positioned */
<span class="lineNum">    1995 </span>            :     int x,y;                    /* Its origin should be shifted this much relative to that of the original base char */
<span class="lineNum">    1996 </span>            :     AnchorPoint *apm;           /* The anchor point in sc used to position it */
<span class="lineNum">    1997 </span>            :     AnchorPoint *apb;           /* The anchor point in the base character against which we are positioned */
<span class="lineNum">    1998 </span>            :     int base_index;             /* Index in this array to the base character (-1=&gt; original base char) */
<span class="lineNum">    1999 </span>            :     unsigned int ticked: 1;     /* Used as a mark to mark */
<span class="lineNum">    2000 </span>            : } AnchorPos;
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span>            : enum ttf_flags { ttf_flag_shortps = 1, ttf_flag_nohints = 2,
<span class="lineNum">    2003 </span>            :                     ttf_flag_applemode=4,
<span class="lineNum">    2004 </span>            :                     ttf_flag_pfed_comments=8, ttf_flag_pfed_colors=0x10,
<span class="lineNum">    2005 </span>            :                     ttf_flag_otmode=0x20,
<span class="lineNum">    2006 </span>            :                     ttf_flag_glyphmap=0x40,
<span class="lineNum">    2007 </span>            :                     ttf_flag_TeXtable=0x80,
<span class="lineNum">    2008 </span>            :                     ttf_flag_ofm=0x100,
<span class="lineNum">    2009 </span>            :                     ttf_flag_oldkern=0x200,     /* never set in conjunction with applemode */
<span class="lineNum">    2010 </span>            :                     ttf_flag_pfed_lookupnames=0x800,
<span class="lineNum">    2011 </span>            :                     ttf_flag_pfed_guides=0x1000,
<span class="lineNum">    2012 </span>            :                     ttf_flag_pfed_layers=0x2000,
<span class="lineNum">    2013 </span>            :                     ttf_flag_symbol=0x4000,
<span class="lineNum">    2014 </span>            :                     ttf_flag_dummyDSIG=0x8000,
<span class="lineNum">    2015 </span>            :                     ttf_native_kern=0x10000, // This applies mostly to U. F. O. right now.
<span class="lineNum">    2016 </span>            :                     ttf_flag_oldkernmappedonly=0x20000000 // Allow only mapped glyphs in the old-style &quot;kern&quot; table, required for Windows compatibility
<span class="lineNum">    2017 </span>            :                 };
<span class="lineNum">    2018 </span>            : enum ttc_flags { ttc_flag_trymerge=0x1, ttc_flag_cff=0x2 };
<span class="lineNum">    2019 </span>            : enum openflags { of_fstypepermitted=1, of_askcmap=2, of_all_glyphs_in_ttc=4,
<span class="lineNum">    2020 </span>            :         of_fontlint=8, of_hidewindow=0x10, of_all_tables=0x20 };
<span class="lineNum">    2021 </span>            : enum ps_flags { ps_flag_nohintsubs = 0x10000, ps_flag_noflex=0x20000,
<span class="lineNum">    2022 </span>            :                     ps_flag_nohints = 0x40000, ps_flag_restrict256=0x80000,
<span class="lineNum">    2023 </span>            :                     ps_flag_afm = 0x100000, ps_flag_pfm = 0x200000,
<span class="lineNum">    2024 </span>            :                     ps_flag_tfm = 0x400000,
<span class="lineNum">    2025 </span>            :                     ps_flag_round = 0x800000,
<span class="lineNum">    2026 </span>            : /* CFF fonts are wrapped up in some postscript sugar -- unless they are to */
<span class="lineNum">    2027 </span>            : /*  go into a pdf file or an otf font */
<span class="lineNum">    2028 </span>            :                     ps_flag_nocffsugar = 0x1000000,
<span class="lineNum">    2029 </span>            : /* in type42 cid fonts we sometimes want an identity map from gid to cid */
<span class="lineNum">    2030 </span>            :                     ps_flag_identitycidmap = 0x2000000,
<span class="lineNum">    2031 </span>            :                     ps_flag_afmwithmarks = 0x4000000,
<span class="lineNum">    2032 </span>            :                     ps_flag_noseac = 0x8000000,
<span class="lineNum">    2033 </span>            :                     ps_flag_outputfontlog = 0x10000000,
<span class="lineNum">    2034 </span>            :                     ps_flag_mask = (ps_flag_nohintsubs|ps_flag_noflex|
<span class="lineNum">    2035 </span>            :                         ps_flag_afm|ps_flag_pfm|ps_flag_tfm|ps_flag_round)
<span class="lineNum">    2036 </span>            :                 };
<span class="lineNum">    2037 </span>            : 
<span class="lineNum">    2038 </span>            : struct compressors { char *ext, *decomp, *recomp; };
<span class="lineNum">    2039 </span>            : #define COMPRESSORS_EMPTY { NULL, NULL, NULL }
<span class="lineNum">    2040 </span>            : extern struct compressors compressors[];
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span>            : enum archive_list_style { ars_tar, ars_zip };
<span class="lineNum">    2043 </span>            : 
<span class="lineNum">    2044 </span>            : struct archivers {
<span class="lineNum">    2045 </span>            :     char *ext, *unarchive, *archive, *listargs, *extractargs, *appendargs;
<span class="lineNum">    2046 </span>            :     enum archive_list_style ars;
<span class="lineNum">    2047 </span>            : };
<span class="lineNum">    2048 </span>            : #define ARCHIVERS_EMPTY { NULL, NULL, NULL, NULL, NULL, NULL, 0 }
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span>            : struct fontdict;
<span class="lineNum">    2051 </span>            : struct pschars;
<span class="lineNum">    2052 </span>            : struct findsel;
<span class="lineNum">    2053 </span>            : struct charprocs;
<span class="lineNum">    2054 </span>            : struct enc;
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            : #define chunkalloc(size)        calloc(1,size)
<span class="lineNum">    2057 </span>            : #define chunkfree(item,size)    free(item)
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span>            : extern char *strconcat(const char *str, const char *str2);
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            : extern void SFApplyFeatureFile(SplineFont *sf,FILE *file,char *filename);
<span class="lineNum">    2062 </span>            : enum fontformat { ff_pfa, ff_pfb, ff_pfbmacbin, ff_multiple, ff_mma, ff_mmb,
<span class="lineNum">    2063 </span>            :         ff_ptype3, ff_ptype0, ff_cid, ff_cff, ff_cffcid,
<span class="lineNum">    2064 </span>            :         ff_type42, ff_type42cid,
<span class="lineNum">    2065 </span>            :         ff_ttf, ff_ttfsym, ff_ttfmacbin, ff_ttc, ff_ttfdfont, ff_otf, ff_otfdfont,
<span class="lineNum">    2066 </span>            :         ff_otfcid, ff_otfciddfont, ff_svg, ff_ufo, ff_woff, ff_none };
<span class="lineNum">    2067 </span>            : extern struct pschars *SplineFont2ChrsSubrs(SplineFont *sf, int iscjk,
<span class="lineNum">    2068 </span>            :         struct pschars *subrs,int flags,enum fontformat format,int layer);
<span class="lineNum">    2069 </span>            : struct cidbytes;
<span class="lineNum">    2070 </span>            : struct fd2data;
<span class="lineNum">    2071 </span>            : struct ttfinfo;
<span class="lineNum">    2072 </span>            : struct alltabs;
<span class="lineNum">    2073 </span>            : 
<span class="lineNum">    2074 </span>            : typedef struct growbuf {
<span class="lineNum">    2075 </span>            :     unsigned char *pt;
<span class="lineNum">    2076 </span>            :     unsigned char *base;
<span class="lineNum">    2077 </span>            :     unsigned char *end;
<span class="lineNum">    2078 </span>            : } GrowBuf;
<span class="lineNum">    2079 </span>            : extern void GrowBuffer(GrowBuf *gb);
<span class="lineNum">    2080 </span>            : 
<span class="lineNum">    2081 </span>            : struct glyphdata;
<span class="lineNum">    2082 </span>            : extern struct pschars *CID2ChrsSubrs(SplineFont *cidmaster,struct cidbytes *cidbytes,int flags,int layer);
<span class="lineNum">    2083 </span>            : enum bitmapformat { bf_bdf, bf_ttf, bf_sfnt_dfont, bf_sfnt_ms, bf_otb,
<span class="lineNum">    2084 </span>            :         bf_nfntmacbin, /*bf_nfntdfont, */bf_fon, bf_fnt, bf_palm,
<span class="lineNum">    2085 </span>            :         bf_ptype3,
<span class="lineNum">    2086 </span>            :         bf_none };
<span class="lineNum">    2087 </span>            : extern const char *GetAuthor(void);
<span class="lineNum">    2088 </span>            : extern int WriteUFOFont(const char *fontname, SplineFont *sf, enum fontformat format,int flags, const EncMap *enc,int layer);
<span class="lineNum">    2089 </span>            : extern int SLIContainsR2L(SplineFont *sf,int sli);
<span class="lineNum">    2090 </span>            : extern void SFFindNearTop(SplineFont *);
<span class="lineNum">    2091 </span>            : extern void SFRestoreNearTop(SplineFont *);
<span class="lineNum">    2092 </span>            : extern const char *_GetModifiers(const char *fontname, const char *familyname, const char *weight);
<span class="lineNum">    2093 </span>            : extern const char *SFGetModifiers(const SplineFont *sf);
<span class="lineNum">    2094 </span>            : extern const unichar_t *_uGetModifiers(const unichar_t *fontname, const unichar_t *familyname,
<span class="lineNum">    2095 </span>            :         const unichar_t *weight);
<span class="lineNum">    2096 </span>            : extern void ttfdumpbitmap(SplineFont *sf,struct alltabs *at,int32 *sizes);
<span class="lineNum">    2097 </span>            : extern void SplineFontSetUnChanged(SplineFont *sf);
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span>            : extern int RealNear(real a,real b);
<span class="lineNum">    2100 </span>            : 
<span class="lineNum">    2101 </span>            : 
<span class="lineNum">    2102 </span>            : extern void UndoesFree(Undoes *undo);
<span class="lineNum">    2103 </span>            : extern void StemInfosFree(StemInfo *h);
<span class="lineNum">    2104 </span>            : extern void StemInfoFree(StemInfo *h);
<span class="lineNum">    2105 </span>            : extern void SCOrderAP(SplineChar *sc);
<span class="lineNum">    2106 </span>            : extern int AnchorClassesNextMerge(AnchorClass *ac);
<span class="lineNum">    2107 </span>            : extern void AnchorClassMerge(SplineFont *sf,AnchorClass *into,AnchorClass *from);
<span class="lineNum">    2108 </span>            : extern void SCInsertPST(SplineChar *sc,PST *new_);
<span class="lineNum">    2109 </span>            : extern void PSTFree(PST *lig);
<span class="lineNum">    2110 </span>            : extern uint16 PSTDefaultFlags(enum possub_type type,SplineChar *sc );
<span class="lineNum">    2111 </span>            : extern StemInfo *StemInfoCopy(StemInfo *h);
<span class="lineNum">    2112 </span>            : extern void SPChangePointType(SplinePoint *sp, int pointtype);
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span>            : struct lookup_cvt { OTLookup *from, *to; int old;};
<span class="lineNum">    2115 </span>            : struct sub_cvt { struct lookup_subtable *from, *to; int old;};
<span class="lineNum">    2116 </span>            : struct ac_cvt { AnchorClass *from, *to; int old;};
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span>            : struct sfmergecontext {
<span class="lineNum">    2119 </span>            :     SplineFont *sf_from, *sf_to;
<span class="lineNum">    2120 </span>            :     int lcnt;
<span class="lineNum">    2121 </span>            :     struct lookup_cvt *lks;
<span class="lineNum">    2122 </span>            :     int scnt;
<span class="lineNum">    2123 </span>            :     struct sub_cvt *subs;
<span class="lineNum">    2124 </span>            :     int acnt;
<span class="lineNum">    2125 </span>            :     struct ac_cvt *acs;
<span class="lineNum">    2126 </span>            :     char *prefix;
<span class="lineNum">    2127 </span>            :     int preserveCrossFontKerning;
<span class="lineNum">    2128 </span>            :     int lmax;
<span class="lineNum">    2129 </span>            : };
<span class="lineNum">    2130 </span>            : extern void AltUniRemove(SplineChar *sc,int uni);
<span class="lineNum">    2131 </span>            : extern void AltUniAdd(SplineChar *sc,int uni);
<span class="lineNum">    2132 </span>            : extern void AltUniAdd_DontCheckDups(SplineChar *sc,int uni);
<span class="lineNum">    2133 </span>            : extern SplineChar *SplineCharCreate(int layer_cnt);
<span class="lineNum">    2134 </span>            : extern void SCAddRef(SplineChar *sc,SplineChar *rsc,int layer, real xoff, real yoff);
<span class="lineNum">    2135 </span>            : extern void SplineCharFree(SplineChar *sc);
<span class="lineNum">    2136 </span>            : extern void ScriptLangListFree(struct scriptlanglist *sl);
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span>            : #if 1
<span class="lineNum">    2139 </span>            : // These relate to experimental support for U. F. O. groups.
<span class="lineNum">    2140 </span>            : #define GROUP_NAME_KERNING_UFO 1
<span class="lineNum">    2141 </span>            : #define GROUP_NAME_KERNING_FEATURE 2
<span class="lineNum">    2142 </span>            : #define GROUP_NAME_VERTICAL 4 // Otherwise horizontal.
<span class="lineNum">    2143 </span>            : #define GROUP_NAME_RIGHT 8 // Otherwise left (or above).
<span class="lineNum">    2144 </span>            : #endif // 1
<span class="lineNum">    2145 </span>            : extern void MMSetFree(MMSet *mm);
<span class="lineNum">    2146 </span>            : extern void SFRemoveUndoes(SplineFont *sf,uint8 *selected,EncMap *map);
<span class="lineNum">    2147 </span>            : extern void SplineRefigure(Spline *spline);
<span class="lineNum">    2148 </span>            : extern void SPLCategorizePoints(SplinePointList *spl);
<span class="lineNum">    2149 </span>            : extern SplinePointList *SplinePointListCopy(const SplinePointList *base);
<span class="lineNum">    2150 </span>            : /* The order of the enum elements below doesn't make much sense, but it's done*/
<span class="lineNum">    2151 </span>            : /*  this way to preserve binary compatibility */
<span class="lineNum">    2152 </span>            : enum transformPointType { tpt_OnlySelected, tpt_AllPoints, tpt_OnlySelectedInterpCPs };
<span class="lineNum">    2153 </span>            : /*
<span class="lineNum">    2154 </span>            :  * As SplinePointListTransform() does a few things, this is a mask to selectively be
<span class="lineNum">    2155 </span>            :  * able to disable some of them.
<span class="lineNum">    2156 </span>            :  */
<span class="lineNum">    2157 </span>            : enum transformPointMask {
<span class="lineNum">    2158 </span>            :     tpmask_dontFixControlPoints = 1 &lt;&lt; 1,
<span class="lineNum">    2159 </span>            :     tpmask_operateOnSelectedBCP = 1 &lt;&lt; 2
<span class="lineNum">    2160 </span>            : };
<span class="lineNum">    2161 </span>            : extern SplinePointList *SplinePointListTransform(SplinePointList *base, real transform[6], enum transformPointType allpoints );
<span class="lineNum">    2162 </span>            : extern void SCReinstanciateRef(SplineChar *sc,SplineChar *rsc,int layer);
<span class="lineNum">    2163 </span>            : extern SplineChar *MakeDupRef(SplineChar *base, int local_enc, int uni_enc);
<span class="lineNum">    2164 </span>            : extern void BDFClut(BDFFont *bdf, int linear_scale);
<span class="lineNum">    2165 </span>            : struct xlfd_components {
<span class="lineNum">    2166 </span>            :     char foundry[80];
<span class="lineNum">    2167 </span>            :     char family[100];
<span class="lineNum">    2168 </span>            :     char weight[80];
<span class="lineNum">    2169 </span>            :     char slant[40];
<span class="lineNum">    2170 </span>            :     char setwidth[50];
<span class="lineNum">    2171 </span>            :     char add_style[50];
<span class="lineNum">    2172 </span>            :     int pixel_size;
<span class="lineNum">    2173 </span>            :     int point_size;
<span class="lineNum">    2174 </span>            :     int res_x;
<span class="lineNum">    2175 </span>            :     int res_y;
<span class="lineNum">    2176 </span>            :     char spacing[40];
<span class="lineNum">    2177 </span>            :     int avg_width;
<span class="lineNum">    2178 </span>            :     char cs_reg[80];            /* encoding */
<span class="lineNum">    2179 </span>            :     char cs_enc[80];            /* encoding version? */
<span class="lineNum">    2180 </span>            :     int char_cnt;
<span class="lineNum">    2181 </span>            : };
<span class="lineNum">    2182 </span>            : struct std_bdf_props {
<span class="lineNum">    2183 </span>            :     const char *name;
<span class="lineNum">    2184 </span>            :     int type;
<span class="lineNum">    2185 </span>            :     int defaultable;
<span class="lineNum">    2186 </span>            : };
<span class="lineNum">    2187 </span>            : #define STD_BDF_PROPS_EMPTY { NULL, 0, 0 }
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span>            : extern int CubicSolve(const Spline1D *sp,bigreal sought,extended ts[3]);
<span class="lineNum">    2190 </span>            : /* Uses an algebraic solution */
<span class="lineNum">    2191 </span>            : extern extended SplineSolve(const Spline1D *sp, real tmin, real tmax, extended sought_y);
<span class="lineNum">    2192 </span>            : /* Tries to fixup rounding errors that crept in to the solution */
<span class="lineNum">    2193 </span>            : extern extended SplineSolveFixup(const Spline1D *sp, real tmin, real tmax, extended sought_y);
<span class="lineNum">    2194 </span>            : /* Uses an iterative approximation */
<span class="lineNum">    2195 </span>            : /* Uses an iterative approximation and then tries to fix things up */
<span class="lineNum">    2196 </span>            : 
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span>            : #define CURVATURE_ERROR -1e9
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span>            : extern Spline *ApproximateSplineFromPoints(SplinePoint *from, SplinePoint *to,
<span class="lineNum">    2201 </span>            :         TPoint *mid, int cnt,int order2);
<span class="lineNum">    2202 </span>            : extern bigreal SplineLength(Spline *spline);
<span class="lineNum">    2203 </span>            : extern int SplineIsLinear(Spline *spline);
<span class="lineNum">    2204 </span>            : extern void SFOrderBitmapList(SplineFont *sf);
<span class="lineNum">    2205 </span>            : 
<span class="lineNum">    2206 </span>            : extern Spline *SplineMake(SplinePoint *from, SplinePoint *to, int order2);
<span class="lineNum">    2207 </span>            : extern Spline *SFSplineMake(SplineFont *sf,SplinePoint *from, SplinePoint *to);
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span>            : 
<span class="lineNum">    2210 </span>            : extern double BlueScaleFigure(struct psdict *private_,real bluevalues[], real otherblues[]);
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span>            : typedef struct bluezone {
<span class="lineNum">    2213 </span>            :     real base;
<span class="lineNum">    2214 </span>            :     int cvtindex;
<span class="lineNum">    2215 </span>            :     real family_base;      /* NaN if none */
<span class="lineNum">    2216 </span>            :     int family_cvtindex;
<span class="lineNum">    2217 </span>            :     real overshoot;        /* relative to baseline, NOT to base */
<span class="lineNum">    2218 </span>            :     int highest;           /* used in autoinstructing for HStem positioning */
<span class="lineNum">    2219 </span>            :     int lowest;            /* as above */
<span class="lineNum">    2220 </span>            : } BlueZone;
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            : typedef struct stdstem {
<span class="lineNum">    2223 </span>            :     real width;            /* -1 if none */
<span class="lineNum">    2224 </span>            :     int cvtindex;
<span class="lineNum">    2225 </span>            :     struct stdstem *snapto;/* NULL means stem isn't snapped to any other */
<span class="lineNum">    2226 </span>            :     int stopat;            /* at which ppem stop snapping to snapto */
<span class="lineNum">    2227 </span>            : } StdStem;
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            : typedef struct globalinstrct {
<span class="lineNum">    2230 </span>            :     SplineFont *sf;
<span class="lineNum">    2231 </span>            :     int layer;
<span class="lineNum">    2232 </span>            :     BlueData *bd;
<span class="lineNum">    2233 </span>            :     double fudge;
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span>            :     /* Did we initialize the tables needed? 'maxp' is skipped because */
<span class="lineNum">    2236 </span>            :     /* its initialization always succeeds. */
<span class="lineNum">    2237 </span>            :     int cvt_done;
<span class="lineNum">    2238 </span>            :     int fpgm_done;
<span class="lineNum">    2239 </span>            :     int prep_done;
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span>            :     /* PS private data with truetype-specific information added */
<span class="lineNum">    2242 </span>            :     BlueZone blues[12];    /* like in BlueData */
<span class="lineNum">    2243 </span>            :     int      bluecnt;
<span class="lineNum">    2244 </span>            :     StdStem  stdhw;
<span class="lineNum">    2245 </span>            :     StdStem  *stemsnaph;   /* StdHW excluded */
<span class="lineNum">    2246 </span>            :     int      stemsnaphcnt;
<span class="lineNum">    2247 </span>            :     StdStem  stdvw;
<span class="lineNum">    2248 </span>            :     StdStem  *stemsnapv;   /* StdVW excluded */
<span class="lineNum">    2249 </span>            :     int      stemsnapvcnt;
<span class="lineNum">    2250 </span>            : } GlobalInstrCt;
<span class="lineNum">    2251 </span>            : 
<span class="lineNum">    2252 </span>            : extern void InitGlobalInstrCt( GlobalInstrCt *gic,SplineFont *sf,int layer,
<span class="lineNum">    2253 </span>            :         BlueData *bd );
<span class="lineNum">    2254 </span>            : extern void FreeGlobalInstrCt( GlobalInstrCt *gic );
<span class="lineNum">    2255 </span>            : extern void NowakowskiSCAutoInstr( GlobalInstrCt *gic,SplineChar *sc );
<span class="lineNum">    2256 </span>            : extern void CVT_ImportPrivate(SplineFont *sf);
<span class="lineNum">    2257 </span>            : 
<span class="lineNum">    2258 </span>            : extern void SplineFontAutoHint( SplineFont *sf, int layer);
<span class="lineNum">    2259 </span>            : extern int SCDrawsSomething(SplineChar *sc);
<span class="lineNum">    2260 </span>            : extern int SCSetMetaData(SplineChar *sc,const char *name,int unienc,
<span class="lineNum">    2261 </span>            :         const char *comment);
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span>            : extern char* DumpSplineFontMetadata( SplineFont *sf );
<span class="lineNum">    2264 </span>            : 
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span>            : enum ttfflags { ttf_onlystrikes=1, ttf_onlyonestrike=2, ttf_onlykerns=4, ttf_onlynames=8 };
<span class="lineNum">    2267 </span>            : extern SplineFont *SFReadUFO(char *filename,int flags);
<span class="lineNum">    2268 </span>            : extern SplineFont *LoadSplineFont(const char *filename,enum openflags);
<span class="lineNum">    2269 </span>            : extern SplineFont *_ReadSplineFont(FILE *file, const char *filename, enum openflags openflags);
<span class="lineNum">    2270 </span>            : extern SplineFont *ReadSplineFont(const char *filename,enum openflags); /* Don't use this, use LoadSF instead */
<span class="lineNum">    2271 </span>            : extern void ArchiveCleanup(char *archivedir);
<span class="lineNum">    2272 </span>            : extern char *Unarchive(char *name, char **_archivedir);
<span class="lineNum">    2273 </span>            : extern char *Decompress(char *name, int compression);
<span class="lineNum">    2274 </span>            : extern uint16 MacStyleCode( SplineFont *sf, uint16 *psstyle );
<span class="lineNum">    2275 </span>            : extern char **NamesReadUFO(char *filename);
<span class="lineNum">    2276 </span>            : 
<span class="lineNum">    2277 </span>            : 
<span class="lineNum">    2278 </span>            : extern const char *UnicodeRange(int unienc);
<span class="lineNum">    2279 </span>            : extern SplineChar *SCBuildDummy(SplineChar *dummy,SplineFont *sf,EncMap *map,int i);
<span class="lineNum">    2280 </span>            : extern SplineChar *SFMakeChar(SplineFont *sf,EncMap *map,int i);
<span class="lineNum">    2281 </span>            : extern char *AdobeLigatureFormat(char *name);
<span class="lineNum">    2282 </span>            : extern uint32 LigTagFromUnicode(int uni);
<span class="lineNum">    2283 </span>            : extern void SCLigCaretheck(SplineChar *sc,int clean);
<span class="lineNum">    2284 </span>            : 
<span class="lineNum">    2285 </span>            : extern void SCUndoSetLBearingChange(SplineChar *sc,int lb);
<span class="lineNum">    2286 </span>            : 
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span>            : extern SplineSet *SplinePointListInterpretGlif(SplineFont *sf,char *filename,char *memory, int memlen, int em_size, int ascent,int stroked);
<span class="lineNum">    2290 </span>            : #define UNDEFINED_WIDTH -999999
<span class="lineNum">    2291 </span>            : struct pscontext {
<span class="lineNum">    2292 </span>            :     int is_type2;
<span class="lineNum">    2293 </span>            :     int painttype;
<span class="lineNum">    2294 </span>            :     int instance_count;
<span class="lineNum">    2295 </span>            :     real blend_values[17];
<span class="lineNum">    2296 </span>            :     int blend_warn;
<span class="lineNum">    2297 </span>            : };
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span>            : extern int NameToEncoding(SplineFont *sf,EncMap *map,const char *uname);
<span class="lineNum">    2300 </span>            : extern SplineChar *SFGetOrMakeChar(SplineFont *sf, int unienc, const char *name );
<span class="lineNum">    2301 </span>            : extern SplineChar *SFGetOrMakeCharFromUnicode( SplineFont *sf, EncMap *map, int ch );
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span>            : extern int DoAutoRecovery(int);
<span class="lineNum">    2304 </span>            : typedef void (*DoAutoRecoveryPostRecoverFunc)(SplineFont *sf);
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            : extern int SFPrivateGuess(SplineFont *sf,int layer, struct psdict *private,
<span class="lineNum">    2307 </span>            :         char *name, int onlyone);
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span>            : extern void SFRemoveLayer(SplineFont *sf,int l);
<span class="lineNum">    2310 </span>            : extern void SFAddLayer(SplineFont *sf,char *name,int order2, int background);
<span class="lineNum">    2311 </span>            : extern void SFLayerSetBackground(SplineFont *sf,int layer,int is_back);
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            : extern void SplineSetsRound2Int(SplineSet *spl,real factor,int inspiro,int onlysel);
<span class="lineNum">    2314 </span>            : extern void SCRound2Int(SplineChar *sc,int layer, real factor);
<span class="lineNum">    2315 </span>            : 
<span class="lineNum">    2316 </span>            : extern void SFFlatten(SplineFont *cidmaster);
<span class="lineNum">    2317 </span>            : 
<span class="lineNum">    2318 </span>            : extern void SCCopyLayerToLayer(SplineChar *sc, int from, int to,int doclear);
<span class="lineNum">    2319 </span>            : 
<span class="lineNum">    2320 </span>            : extern int hasFreeType(void);
<span class="lineNum">    2321 </span>            : extern int hasFreeTypeDebugger(void);
<span class="lineNum">    2322 </span>            : extern int hasFreeTypeByteCode(void);
<span class="lineNum">    2323 </span>            : extern int FreeTypeAtLeast(int major, int minor, int patch);
<span class="lineNum">    2324 </span>            : extern char *FreeTypeStringVersion(void);
<span class="lineNum">    2325 </span>            : extern void doneFreeType(void);
<span class="lineNum">    2326 </span>            : extern void *_FreeTypeFontContext(SplineFont *sf,SplineChar *sc,struct fontviewbase *fv,
<span class="lineNum">    2327 </span>            :         int layer, enum fontformat ff,int flags,void *shared_ftc);
<span class="lineNum">    2328 </span>            : extern void *FreeTypeFontContext(SplineFont *sf,SplineChar *sc,struct fontviewbase *fv,int layer);
<span class="lineNum">    2329 </span>            : extern BDFFont *SplineFontFreeTypeRasterize(void *freetypecontext,int pixelsize,int depth);
<span class="lineNum">    2330 </span>            : extern BDFChar *SplineCharFreeTypeRasterize(void *freetypecontext,int gid,
<span class="lineNum">    2331 </span>            :         int ptsize, int dpi,int depth);
<span class="lineNum">    2332 </span>            : extern void FreeTypeFreeContext(void *freetypecontext);
<span class="lineNum">    2333 </span>            : extern SplineSet *FreeType_GridFitChar(void *single_glyph_context,
<span class="lineNum">    2334 </span>            :         int enc, real ptsizey, real ptsizex, int dpi, uint16 *width,
<span class="lineNum">    2335 </span>            :         SplineChar *sc, int depth, int scaled);
<span class="lineNum">    2336 </span>            : extern struct freetype_raster *FreeType_GetRaster(void *single_glyph_context,
<span class="lineNum">    2337 </span>            :         int enc, real ptsizey, real ptsizex, int dpi,int depth);
<span class="lineNum">    2338 </span>            : extern BDFChar *SplineCharFreeTypeRasterizeNoHints(SplineChar *sc,int layer,
<span class="lineNum">    2339 </span>            :         int ptsize, int dpi,int depth);
<span class="lineNum">    2340 </span>            : extern BDFFont *SplineFontFreeTypeRasterizeNoHints(SplineFont *sf,int layer,
<span class="lineNum">    2341 </span>            :         int pixelsize,int depth);
<span class="lineNum">    2342 </span>            : extern void FreeType_FreeRaster(struct freetype_raster *raster);
<span class="lineNum">    2343 </span>            : struct TT_ExecContextRec_;
<span class="lineNum">    2344 </span>            : extern struct freetype_raster *DebuggerCurrentRaster(struct  TT_ExecContextRec_ *exc,int depth);
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span>            : extern AnchorPos *AnchorPositioning(SplineChar *sc,unichar_t *ustr,SplineChar **sstr );
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            : extern int  SF_CloseAllInstrs(SplineFont *sf);
<span class="lineNum">    2350 </span>            : extern int  SSTtfNumberPoints(SplineSet *ss);
<span class="lineNum">    2351 </span>            : extern int  SCNumberPoints(SplineChar *sc,int layer);
<span class="lineNum">    2352 </span>            : extern int  SCPointsNumberedProperly(SplineChar *sc,int layer);
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            : extern int SFRenameTheseFeatureTags(SplineFont *sf, uint32 tag, int sli, int flags,
<span class="lineNum">    2355 </span>            :         uint32 totag, int tosli, int toflags, int ismac);
<span class="lineNum">    2356 </span>            : extern int SFRemoveUnusedNestedFeatures(SplineFont *sf);
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span>            : extern struct macsetting *FindMacSetting(SplineFont *sf, int feat, int set,struct macsetting **secondary);
<span class="lineNum">    2361 </span>            : 
<span class="lineNum">    2362 </span>            : 
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span>            : extern int BpColinear(BasePoint *first, BasePoint *mid, BasePoint *last);
<span class="lineNum">    2365 </span>            : extern int BpWithin(BasePoint *first, BasePoint *mid, BasePoint *last);
<span class="lineNum">    2366 </span>            :     /* Colinear &amp; between */
<span class="lineNum">    2367 </span>            : 
<span class="lineNum">    2368 </span>            : enum psstrokeflags { /* sf_removeoverlap=2,*/ sf_handle_eraser=4,
<span class="lineNum">    2369 </span>            :         sf_correctdir=8, sf_clearbeforeinput=16 };
<span class="lineNum">    2370 </span>            : 
<span class="lineNum">    2371 </span>            : 
<span class="lineNum">    2372 </span>            : extern char *ToAbsolute(char *filename);
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span>            : # if HANYANG
<span class="lineNum">    2375 </span>            : extern void SFDDumpCompositionRules(FILE *sfd,struct compositionrules *rules);
<span class="lineNum">    2376 </span>            : extern struct compositionrules *SFDReadCompositionRules(FILE *sfd);
<span class="lineNum">    2377 </span>            : extern void SFModifyComposition(SplineFont *sf);
<span class="lineNum">    2378 </span>            : extern void SFBuildSyllables(SplineFont *sf);
<span class="lineNum">    2379 </span>            : # endif
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span>            : 
<span class="lineNum">    2383 </span>            : extern void SFSetModTime(SplineFont *sf);
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span>            : 
<span class="lineNum">    2387 </span>            : extern struct lookup_subtable *SFFindLookupSubtable(SplineFont *sf,char *name);
<span class="lineNum">    2388 </span>            : extern int FeatureTagInFeatureScriptList(uint32 tag, FeatureScriptLangList *fl);
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span>            : extern void SplinePointRound(SplinePoint *,real);
<span class="lineNum">    2391 </span>            : 
<span class="lineNum">    2392 </span>            : extern KernClass *SFFindKernClass(SplineFont *sf,SplineChar *first,SplineChar *last,
<span class="lineNum">    2393 </span>            :         int *index,int allow_zero);
<span class="lineNum">    2394 </span>            : extern KernClass *SFFindVKernClass(SplineFont *sf,SplineChar *first,SplineChar *last,
<span class="lineNum">    2395 </span>            :         int *index,int allow_zero);
<span class="lineNum">    2396 </span>            : 
<span class="lineNum">    2397 </span>            : extern void SCClearRounds(SplineChar *sc,int layer);
<span class="lineNum">    2398 </span>            : extern void MDReplace(MinimumDistance *md,SplineSet *old,SplineSet *rpl);
<span class="lineNum">    2399 </span>            : extern void SCSynchronizeWidth(SplineChar *sc,real newwidth, real oldwidth,struct fontviewbase *fv);
<span class="lineNum">    2400 </span>            : extern RefChar *HasUseMyMetrics(SplineChar *sc,int layer);
<span class="lineNum">    2401 </span>            : extern void SCSynchronizeLBearing(SplineChar *sc,real off,int layer);
<span class="lineNum">    2402 </span>            : extern void RevertedGlyphReferenceFixup(SplineChar *sc, SplineFont *sf);
<span class="lineNum">    2403 </span>            : 
<span class="lineNum">    2404 </span>            : extern void SFUntickAll(SplineFont *sf);
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span>            : extern int HasUFO(void);
<span class="lineNum">    2408 </span>            : extern void SCImportPS(SplineChar *sc,int layer,char *path,int doclear, int flags);
<span class="lineNum">    2409 </span>            : extern void SCImportPDF(SplineChar *sc,int layer,char *path,int doclear, int flags);
<span class="lineNum">    2410 </span>            : 
<span class="lineNum">    2411 </span>            : extern int _ExportGlif(FILE *glif,SplineChar *sc,int layer);
<span class="lineNum">    2412 </span>            : 
<span class="lineNum">    2413 </span>            : extern void SCCopyWidth(SplineChar *sc,enum undotype);
<span class="lineNum">    2414 </span>            : extern void SCClearBackground(SplineChar *sc);
<span class="lineNum">    2415 </span>            : extern void BackgroundImageTransform(SplineChar *sc, ImageList *img,real transform[6]);
<span class="lineNum">    2416 </span>            : extern int SFIsDuplicatable(SplineFont *sf, SplineChar *sc);
<span class="lineNum">    2417 </span>            : 
<span class="lineNum">    2418 </span>            : extern void SCClearLayer(SplineChar *sc,int layer);
<span class="lineNum">    2419 </span>            : extern void SCClearContents(SplineChar *sc,int layer);
<span class="lineNum">    2420 </span>            : extern void SCClearAll(SplineChar *sc,int layer);
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span>            : #if !defined(_NO_PYTHON)
<span class="lineNum">    2423 </span>            : extern void FontForge_InitializeEmbeddedPython(void);
<span class="lineNum">    2424 </span>            : extern void FontForge_FinalizeEmbeddedPython(void);
<span class="lineNum">    2425 </span>            : extern void PyFF_ErrorString(const char *msg,const char *str);
<span class="lineNum">    2426 </span>            : extern void PyFF_ErrorF3(const char *frmt, const char *str, int size, int depth);
<span class="lineNum">    2427 </span>            : extern void PyFF_Stdin(void);
<span class="lineNum">    2428 </span>            : extern void PyFF_Main(int argc,char **argv,int start);
<span class="lineNum">    2429 </span>            : extern void PyFF_ScriptFile(struct fontviewbase *fv,SplineChar *sc,char *filename);
<span class="lineNum">    2430 </span>            : extern void PyFF_ScriptString(struct fontviewbase *fv,SplineChar *sc,int layer,char *str);
<span class="lineNum">    2431 </span>            : extern void PyFF_FreeFV(struct fontviewbase *fv);
<span class="lineNum">    2432 </span>            : extern void PyFF_FreeSC(SplineChar *sc);
<span class="lineNum">    2433 </span>            : void PyFF_FreeSCLayer(SplineChar *sc, int layer);
<span class="lineNum">    2434 </span>            : extern void PyFF_FreeSF(SplineFont *sf);
<span class="lineNum">    2435 </span>            : extern void PyFF_FreePythonPersistent(void *python_persistent);
<span class="lineNum">    2436 </span>            : extern void PyFF_ProcessInitFiles(void);
<span class="lineNum">    2437 </span>            : extern char *PyFF_PickleMeToString(void *pydata);
<span class="lineNum">    2438 </span>            : extern void *PyFF_UnPickleMeToObjects(char *str);
<span class="lineNum">    2439 </span>            : struct _object;         /* Python Object */
<span class="lineNum">    2440 </span>            : extern void PyFF_CallDictFunc(struct _object *dict,const char *key,const char *argtypes, ... );
<span class="lineNum">    2441 </span>            : #endif
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span>            : 
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span>            : extern struct math_constants_descriptor {
<span class="lineNum">    2447 </span>            :     char *ui_name;
<span class="lineNum">    2448 </span>            :     char *script_name;
<span class="lineNum">    2449 </span>            :     int offset;
<span class="lineNum">    2450 </span>            :     int devtab_offset;
<span class="lineNum">    2451 </span>            :     char *message;
<span class="lineNum">    2452 </span>            :     int new_page;
<span class="lineNum">    2453 </span>            : } math_constants_descriptor[];
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span>            : #define MATH_CONSTANTS_DESCRIPTOR_EMPTY { NULL, NULL, 0, 0, NULL, 0 }
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span>            : extern const char *knownweights[], *realweights[], **noticeweights[];
<span class="lineNum">    2458 </span>            : 
<span class="lineNum">    2459 </span>            : extern int BPTooFar(BasePoint *bp1, BasePoint *bp2);
<span class="lineNum">    2460 </span>            : extern StemInfo *SCHintOverlapInMask(SplineChar *sc,HintMask *hm);
<span class="lineNum">    2461 </span>            : extern char *VSErrorsFromMask(int mask,int private_mask);
<span class="lineNum">    2462 </span>            : extern int SCValidate(SplineChar *sc, int layer, int force);
<span class="lineNum">    2463 </span>            : extern AnchorClass *SCValidateAnchors(SplineChar *sc);
<span class="lineNum">    2464 </span>            : extern void SCTickValidationState(SplineChar *sc,int layer);
<span class="lineNum">    2465 </span>            : extern int ValidatePrivate(SplineFont *sf);
<span class="lineNum">    2466 </span>            : extern int SFValidate(SplineFont *sf, int layer, int force);
<span class="lineNum">    2467 </span>            : extern int VSMaskFromFormat(SplineFont *sf, int layer, enum fontformat format);
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span>            : extern char *RandomParaFromScript(uint32 script, uint32 *lang, SplineFont *sf);
<span class="lineNum">    2470 </span>            : 
<span class="lineNum">    2471 </span>            : extern void PatternSCBounds(SplineChar *sc,DBounds *b);
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span>            : extern char *SFDefaultImage(SplineFont *sf,char *filename);
<span class="lineNum">    2474 </span>            : extern void SCClearInstrsOrMark(SplineChar *sc, int layer, int complain);
<span class="lineNum">    2475 </span>            : extern void instrcheck(SplineChar *sc,int layer);
<span class="lineNum">    2476 </span>            : extern void TTFPointMatches(SplineChar *sc,int layer,int top);
<span class="lineNum">    2477 </span>            : 
<span class="lineNum">    2478 </span>            : extern bigreal SFCapHeight(SplineFont *sf, int layer, int return_error);
<span class="lineNum">    2479 </span>            : extern bigreal SFXHeight(SplineFont *sf, int layer, int return_error);
<span class="lineNum">    2480 </span>            : extern bigreal SFAscender(SplineFont *sf, int layer, int return_error);
<span class="lineNum">    2481 </span>            : extern bigreal SFDescender(SplineFont *sf, int layer, int return_error);
<span class="lineNum">    2482 </span>            : 
<span class="lineNum">    2483 </span>            : extern void SCRemoveKern(SplineChar* sc);
<span class="lineNum">    2484 </span>            : extern void SCRemoveVKern(SplineChar* sc);
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span>            : /**
<span class="lineNum">    2487 </span>            :  * Return falise if the container does not contain &quot;sought&quot;
<span class="lineNum">    2488 </span>            :  * Return true if sought is in the container.
<span class="lineNum">    2489 </span>            :  */
<span class="lineNum">    2490 </span>            : extern int SplinePointListContains( SplinePointList* container, SplinePointList* sought );
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            : /**
<span class="lineNum">    2493 </span>            :  * Return falise if the container does not contain the single splint point &quot;sp&quot;,
<span class="lineNum">    2494 </span>            :  * Return true if &quot;sp&quot; is in the container.
<span class="lineNum">    2495 </span>            :  */
<span class="lineNum">    2496 </span>            : extern int SplinePointListContainsPoint( SplinePointList* container, SplinePoint* sp );
<span class="lineNum">    2497 </span>            : 
<span class="lineNum">    2498 </span>            : /**
<span class="lineNum">    2499 </span>            :  * Visitor for SPLFirstVisitSplines()
<span class="lineNum">    2500 </span>            :  */
<span class="lineNum">    2501 </span>            : typedef void (*SPLFirstVisitSplinesVisitor)( SplinePoint* splfirst, Spline* s, void* udata );
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span>            : /**
<span class="lineNum">    2504 </span>            :  * Visitor Function: print debug information about each spline
<span class="lineNum">    2505 </span>            :  *
<span class="lineNum">    2506 </span>            :  * Visitor for SPLFirstVisit()
<span class="lineNum">    2507 </span>            :  */
<span class="lineNum">    2508 </span>            : extern void SPLFirstVisitorDebug(SplinePoint* splfirst, Spline* spline, void* udata );
<span class="lineNum">    2509 </span>            : 
<span class="lineNum">    2510 </span>            : /**
<span class="lineNum">    2511 </span>            :  * Visitor Function: print debug information about the current
<span class="lineNum">    2512 </span>            :  * selection state including the secondary BCP selection for each
<span class="lineNum">    2513 </span>            :  * spline
<span class="lineNum">    2514 </span>            :  *
<span class="lineNum">    2515 </span>            :  * Visitor for SPLFirstVisit()
<span class="lineNum">    2516 </span>            :  */
<span class="lineNum">    2517 </span>            : extern void SPLFirstVisitorDebugSelectionState(SplinePoint* splfirst, Spline* spline, void* udata );
<span class="lineNum">    2518 </span>            : 
<span class="lineNum">    2519 </span>            : /**
<span class="lineNum">    2520 </span>            :  * Given a SplinePointList* that you want to visit each spline in the
<span class="lineNum">    2521 </span>            :  * iteration is not as simple as it could be, so you can call this
<span class="lineNum">    2522 </span>            :  * function passing spl-&gt;first as 'splfirst' and a visitor function
<span class="lineNum">    2523 </span>            :  * which will see each spline in the splfirst colleciton.
<span class="lineNum">    2524 </span>            :  *
<span class="lineNum">    2525 </span>            :  * For debug, you can pass SPLFirstVisitorDebug which will print
<span class="lineNum">    2526 </span>            :  * information for each item in the splfirst collection.
<span class="lineNum">    2527 </span>            :  *
<span class="lineNum">    2528 </span>            :  * You can pass any arbitrary data in as udata and SPLFirstVisit()
<span class="lineNum">    2529 </span>            :  * will pass that udata to your visitor function without change. If
<span class="lineNum">    2530 </span>            :  * you want a return value from your visitor, pass a pointer to a
<span class="lineNum">    2531 </span>            :  * struct as udata. eg:
<span class="lineNum">    2532 </span>            :  *
<span class="lineNum">    2533 </span>            :  * typedef struct SPLFirstVisitorFoundSoughtDataS
<span class="lineNum">    2534 </span>            :  * {
<span class="lineNum">    2535 </span>            :  *    SplinePoint* sought;
<span class="lineNum">    2536 </span>            :  *    int found;
<span class="lineNum">    2537 </span>            :  * } SPLFirstVisitorFoundSoughtData;
<span class="lineNum">    2538 </span>            :  *
<span class="lineNum">    2539 </span>            :  * // ...
<span class="lineNum">    2540 </span>            :  *
<span class="lineNum">    2541 </span>            :  *      SPLFirstVisitorFoundSoughtData d;
<span class="lineNum">    2542 </span>            :  *      d.sought = sought;
<span class="lineNum">    2543 </span>            :  *      d.found  = 0;
<span class="lineNum">    2544 </span>            :  *      SPLFirstVisit( spl-&gt;first, SPLFirstVisitorFoundSought, &amp;d );
<span class="lineNum">    2545 </span>            :  *      if( d.found )
<span class="lineNum">    2546 </span>            :  *           return 1;
<span class="lineNum">    2547 </span>            :  *
<span class="lineNum">    2548 </span>            :  */
<span class="lineNum">    2549 </span>            : extern void SPLFirstVisitSplines( SplinePoint* splfirst, SPLFirstVisitSplinesVisitor f, void* udata );
<span class="lineNum">    2550 </span>            : 
<span class="lineNum">    2551 </span>            : /**
<span class="lineNum">    2552 </span>            :  * Visitor for SPLFirstVisitPoints()
<span class="lineNum">    2553 </span>            :  */
<span class="lineNum">    2554 </span>            : typedef void (*SPLFirstVisitPointsVisitor)( SplinePoint* splfirst, Spline* s, SplinePoint* sp, void* udata );
<span class="lineNum">    2555 </span>            : 
<span class="lineNum">    2556 </span>            : /**
<span class="lineNum">    2557 </span>            :  * Visit all the SplinePoints on the spline starting at splfirst.
<span class="lineNum">    2558 </span>            :  */
<span class="lineNum">    2559 </span>            : extern void SPLFirstVisitPoints( SplinePoint* splfirst, SPLFirstVisitPointsVisitor f, void* udata );
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span>            : 
<span class="lineNum">    2562 </span>            : 
<span class="lineNum">    2563 </span>            : /**
<span class="lineNum">    2564 </span>            :  * Applies a visitor to the container and returns false if no point in the SPL
<span class="lineNum">    2565 </span>            :  * has an x coordinate of 'x'.
<span class="lineNum">    2566 </span>            :  */
<span class="lineNum">    2567 </span>            : extern SplinePoint* SplinePointListContainsPointAtX( SplinePointList* container, real x );
<span class="lineNum">    2568 </span>            : extern SplinePoint* SplinePointListContainsPointAtY( SplinePointList* container, real y );
<span class="lineNum">    2569 </span>            : extern SplinePoint* SplinePointListContainsPointAtXY( SplinePointList* container, real x, real y );
<span class="lineNum">    2570 </span>            : 
<span class="lineNum">    2571 </span>            : 
<span class="lineNum">    2572 </span>            : /**
<span class="lineNum">    2573 </span>            :  * True if the spline with from/to is part of the guide splines.
<span class="lineNum">    2574 </span>            :  *
<span class="lineNum">    2575 </span>            :  * Handy for telling if the user has just clicked on a guide for example,
<span class="lineNum">    2576 </span>            :  * you might want to also check the active layer first with cv-&gt;b.drawmode == dm_grid
<span class="lineNum">    2577 </span>            :  */
<span class="lineNum">    2578 </span>            : extern bool isSplinePointPartOfGuide( SplineFont *sf, SplinePoint *sp );
<span class="lineNum">    2579 </span>            : 
<span class="lineNum">    2580 </span>            : 
<span class="lineNum">    2581 </span>            : extern void debug_printHint( StemInfo *h, char* msg );
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span>            : #include &quot;ustring.h&quot;
<span class="lineNum">    2584 </span>            : 
<span class="lineNum">    2585 </span>            : #ifdef _WIN32
<span class="lineNum">    2586 </span>            : #define BAD_LOCALE_HACK
<span class="lineNum">    2587 </span>            : typedef char* locale_t;
<span class="lineNum">    2588 </span>            : #define LC_GLOBAL_LOCALE ((locale_t)-1)
<span class="lineNum">    2589 </span>            : #define LC_ALL_MASK LC_ALL
<span class="lineNum">    2590 </span>            : #define LC_COLLATE_MASK LC_COLLATE
<span class="lineNum">    2591 </span>            : #define LC_CTYPE_MASK LC_CTYPE
<span class="lineNum">    2592 </span>            : #define LC_MONETARY_MASK LC_MONETARY
<span class="lineNum">    2593 </span>            : #define LC_NUMERIC_MASK LC_NUMERIC
<span class="lineNum">    2594 </span>            : #define LC_TIME_MASK LC_TIME
<a name="2595"><span class="lineNum">    2595 </span>            : #endif</a>
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span><span class="lineCov">        590 : static inline void switch_to_c_locale(locale_t * tmplocale_p, locale_t * oldlocale_p) {</span>
<span class="lineNum">    2598 </span>            : #ifndef BAD_LOCALE_HACK
<span class="lineNum">    2599 </span><span class="lineCov">        590 :   *tmplocale_p = newlocale(LC_NUMERIC_MASK, &quot;C&quot;, NULL);</span>
<span class="lineNum">    2600 </span><span class="lineCov">        590 :   if (*tmplocale_p == NULL) fprintf(stderr, &quot;Failed to create temporary locale.\n&quot;);</span>
<span class="lineNum">    2601 </span><span class="lineCov">        590 :   else if ((*oldlocale_p = uselocale(*tmplocale_p)) == NULL) {</span>
<span class="lineNum">    2602 </span><span class="lineNoCov">          0 :     fprintf(stderr, &quot;Failed to change locale.\n&quot;);</span>
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :     freelocale(*tmplocale_p); *tmplocale_p = NULL;</span>
<span class="lineNum">    2604 </span>            :   }
<span class="lineNum">    2605 </span>            : #else
<span class="lineNum">    2606 </span>            :   // Yes, it is dirty. But so is an operating system that doesn't support threaded locales.
<span class="lineNum">    2607 </span>            :   *oldlocale_p = (locale_t)copy(setlocale(LC_NUMERIC_MASK, &quot;C&quot;));
<span class="lineNum">    2608 </span>            :   if (*oldlocale_p == NULL) fprintf(stderr, &quot;Failed to change locale.\n&quot;);
<span class="lineNum">    2609 </span>            : #endif
<a name="2610"><span class="lineNum">    2610 </span><span class="lineCov">        590 : }</span></a>
<span class="lineNum">    2611 </span>            : 
<span class="lineNum">    2612 </span><span class="lineCov">        590 : static inline void switch_to_old_locale(locale_t * tmplocale_p, locale_t * oldlocale_p) {</span>
<span class="lineNum">    2613 </span>            : #ifndef BAD_LOCALE_HACK
<span class="lineNum">    2614 </span><span class="lineCov">        590 :   if (*oldlocale_p != NULL) { uselocale(*oldlocale_p); } else { uselocale(LC_GLOBAL_LOCALE); }</span>
<span class="lineNum">    2615 </span><span class="lineCov">        590 :   *oldlocale_p = NULL; // This ends the lifecycle of the temporary old locale storage.</span>
<span class="lineNum">    2616 </span><span class="lineCov">        590 :   if (*tmplocale_p != NULL) { freelocale(*tmplocale_p); *tmplocale_p = NULL; }</span>
<span class="lineNum">    2617 </span>            : #else
<span class="lineNum">    2618 </span>            :   if (*oldlocale_p != NULL) {
<span class="lineNum">    2619 </span>            :     setlocale(LC_NUMERIC_MASK, (char*)(*oldlocale_p));
<span class="lineNum">    2620 </span>            :     free((char*)(*oldlocale_p));
<span class="lineNum">    2621 </span>            :     *oldlocale_p = NULL;
<span class="lineNum">    2622 </span>            :   }
<span class="lineNum">    2623 </span>            : #endif
<a name="2624"><span class="lineNum">    2624 </span><span class="lineCov">        590 : }</span></a>
<span class="lineNum">    2625 </span>            : 
<span class="lineNum">    2626 </span><span class="lineNoCov">          0 : static inline locale_t newlocale_hack(int category_mask, const char *locale, locale_t base) {</span>
<span class="lineNum">    2627 </span>            :   // Note that, in the interest of minimizing the hack, we drop the category mask on Wingdows.
<span class="lineNum">    2628 </span>            : #ifndef BAD_LOCALE_HACK
<span class="lineNum">    2629 </span><span class="lineNoCov">          0 :   return newlocale(category_mask, locale, base);</span>
<span class="lineNum">    2630 </span>            : #else
<span class="lineNum">    2631 </span>            :   return (locale_t)copy(locale);
<span class="lineNum">    2632 </span>            : #endif
<a name="2633"><span class="lineNum">    2633 </span>            : }</a>
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span><span class="lineNoCov">          0 : static inline locale_t uselocale_hack(locale_t dataset) {</span>
<span class="lineNum">    2636 </span>            : #ifndef BAD_LOCALE_HACK
<span class="lineNum">    2637 </span><span class="lineNoCov">          0 :   return uselocale(dataset);</span>
<span class="lineNum">    2638 </span>            : #else
<span class="lineNum">    2639 </span>            :   return (locale_t)copy(setlocale(LC_ALL_MASK, (char*)dataset));
<span class="lineNum">    2640 </span>            : #endif
<a name="2641"><span class="lineNum">    2641 </span>            : }</a>
<span class="lineNum">    2642 </span>            : 
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 : static inline void freelocale_hack(locale_t dataset) {</span>
<span class="lineNum">    2644 </span>            : #ifndef BAD_LOCALE_HACK
<span class="lineNum">    2645 </span><span class="lineNoCov">          0 :   freelocale(dataset);</span>
<span class="lineNum">    2646 </span>            : #else
<span class="lineNum">    2647 </span>            :   if (dataset != NULL) { free(dataset); }
<span class="lineNum">    2648 </span>            : #endif
<span class="lineNum">    2649 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span>            : #if 0
<span class="lineNum">    2652 </span>            : #define DECLARE_TEMP_LOCALE() char oldloc[25];
<span class="lineNum">    2653 </span>            : #define SWITCH_TO_C_LOCALE() strncpy( oldloc,setlocale(LC_NUMERIC,NULL),24 ); oldloc[24]='\0'; setlocale(LC_NUMERIC,&quot;C&quot;);
<span class="lineNum">    2654 </span>            : #define SWITCH_TO_OLD_LOCALE() setlocale(LC_NUMERIC,oldloc);
<span class="lineNum">    2655 </span>            : #else
<span class="lineNum">    2656 </span>            : #define DECLARE_TEMP_LOCALE() locale_t tmplocale; locale_t oldlocale; // Declare temporary locale storage.
<span class="lineNum">    2657 </span>            : #define SWITCH_TO_C_LOCALE() switch_to_c_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the C locale temporarily and cache the old locale.
<span class="lineNum">    2658 </span>            : #define SWITCH_TO_OLD_LOCALE() switch_to_old_locale(&amp;tmplocale, &amp;oldlocale); // Switch to the cached locale.
<span class="lineNum">    2659 </span>            : #endif
<span class="lineNum">    2660 </span>            : 
<span class="lineNum">    2661 </span>            : 
<span class="lineNum">    2662 </span>            : 
<span class="lineNum">    2663 </span>            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>
